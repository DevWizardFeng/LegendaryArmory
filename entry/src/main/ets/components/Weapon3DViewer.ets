/**
 * ç¥å…µå›¾å½• - 3Dæ­¦å™¨æŸ¥çœ‹å™¨ç»„ä»¶
 * ä½¿ç”¨ HarmonyOS ArkGraphics 3D å¼•æ“
 * æ”¯æŒè§¦æ§æ—‹è½¬ã€åŒæŒ‡ç¼©æ”¾ã€è‡ªåŠ¨æ—‹è½¬
 * æ³¨æ„ï¼šä»…æ”¯æŒçœŸæœºï¼Œæ¨¡æ‹Ÿå™¨ä¸æ”¯æŒ3Dæ¸²æŸ“
 */

import {
  Scene, Camera, Light, LightType,
  SceneResourceFactory
} from '@kit.ArkGraphics3D'
import { deviceInfo } from '@kit.BasicServicesKit'
import { ThemeColors, FontSizes, Spacing } from '../common/Theme'
import { LegendaryWeapon } from '../model/LegendaryWeapon'

// SceneOptionså’ŒModelTypeéœ€è¦é€šè¿‡ç±»å‹å®šä¹‰
interface SceneOptions {
  scene: Scene
  modelType?: number  // 0=TEXTURE, 1=SURFACE
}

@Component
export struct Weapon3DViewer {
  @Prop weaponId: string = ''
  @Prop weapon: LegendaryWeapon | null = null
  @State sceneOpt: SceneOptions | null = null
  @State isLoading: boolean = true
  @State loadError: string = ''
  @State autoRotate: boolean = true
  @State isEmulator: boolean = false  // æ˜¯å¦æ˜¯æ¨¡æ‹Ÿå™¨

  private scene: Scene | null = null
  private camera: Camera | null = null
  private autoRotateTimer: number = -1

  // ç›¸æœºæ§åˆ¶å‚æ•°
  private rotationY: number = 0           // æ°´å¹³æ—‹è½¬è§’åº¦
  private rotationX: number = 0           // å‚ç›´æ—‹è½¬è§’åº¦
  private cameraDistance: number = 3      // ç›¸æœºè·ç¦»
  private lastTouchX: number = 0
  private lastTouchY: number = 0
  private lastPinchDistance: number = 0

  async aboutToAppear(): Promise<void> {
    try {
      // é¦–å…ˆæ£€æµ‹æ˜¯å¦æ˜¯æ¨¡æ‹Ÿå™¨
      if (this.checkIsEmulator()) {
        console.warn('[Weapon3DViewer] æ£€æµ‹åˆ°æ¨¡æ‹Ÿå™¨ç¯å¢ƒï¼Œ3DåŠŸèƒ½ä¸å¯ç”¨')
        this.isEmulator = true
        this.loadError = '3Dé¢„è§ˆä»…æ”¯æŒçœŸæœºè®¾å¤‡ï¼Œæ¨¡æ‹Ÿå™¨æš‚ä¸æ”¯æŒ'
        this.isLoading = false
        return
      }

      console.info(`[Weapon3DViewer] å¼€å§‹åŠ è½½3Dæ¨¡å‹: ${this.weaponId}`)
      await this.load3DModel()
      if (this.autoRotate) {
        this.startAutoRotate()
      }
      console.info(`[Weapon3DViewer] 3Dæ¨¡å‹åŠ è½½æˆåŠŸ: ${this.weaponId}`)
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error)
      console.error(`[Weapon3DViewer] åˆå§‹åŒ–å¤±è´¥: ${errorMsg}`, error)
      this.loadError = `3Dæ¨¡å‹åŠ è½½å¤±è´¥: ${errorMsg}`
      this.isLoading = false
    }
  }

  /**
   * æ£€æµ‹æ˜¯å¦æ˜¯æ¨¡æ‹Ÿå™¨ç¯å¢ƒ
   * é€šè¿‡è®¾å¤‡ä¿¡æ¯åˆ¤æ–­
   */
  private checkIsEmulator(): boolean {
    try {
      // æ£€æŸ¥è®¾å¤‡ç±»å‹å’Œå“ç‰Œ
      const brand = deviceInfo.brand || ''
      const manufacturer = deviceInfo.manufacture || ''
      const productModel = deviceInfo.productModel || ''
      const marketName = deviceInfo.marketName || ''

      console.info(`[Weapon3DViewer] è®¾å¤‡ä¿¡æ¯: brand=${brand}, manufacturer=${manufacturer}, model=${productModel}, marketName=${marketName}`)

      // æ¨¡æ‹Ÿå™¨çš„ç‰¹å¾ï¼šbrand/manufacturer é€šå¸¸ä¸ºç©ºæˆ–åŒ…å« emulator/default ç­‰å…³é”®è¯
      const emulatorKeywords = ['emulator', 'simulator', 'default', 'generic', 'unknown']

      const brandLower = brand.toLowerCase()
      const manufacturerLower = manufacturer.toLowerCase()
      const modelLower = productModel.toLowerCase()

      for (const keyword of emulatorKeywords) {
        if (brandLower.includes(keyword) ||
            manufacturerLower.includes(keyword) ||
            modelLower.includes(keyword)) {
          return true
        }
      }

      // å¦‚æœbrandå’Œmanufactureréƒ½ä¸ºç©ºï¼Œä¹Ÿå¯èƒ½æ˜¯æ¨¡æ‹Ÿå™¨
      if (!brand && !manufacturer) {
        console.warn('[Weapon3DViewer] è®¾å¤‡å“ç‰Œå’Œå‚å•†ä¿¡æ¯ä¸ºç©ºï¼Œå¯èƒ½æ˜¯æ¨¡æ‹Ÿå™¨')
        return true
      }

      return false
    } catch (error) {
      console.error('[Weapon3DViewer] è®¾å¤‡æ£€æµ‹å¤±è´¥:', error)
      // æ£€æµ‹å¤±è´¥æ—¶é»˜è®¤å‡è®¾æ˜¯çœŸæœº
      return false
    }
  }

  aboutToDisappear(): void {
    this.stopAutoRotate()
    if (this.scene) {
      // æ¸…ç†èµ„æº
      this.scene = null
    }
  }

  /**
   * åŠ è½½3Dæ¨¡å‹
   */
  async load3DModel(): Promise<void> {
    try {
      this.isLoading = true

      // 1. åŠ è½½GLBæ¨¡å‹
      const modelPath = `models/${this.weaponId}.glb`
      console.info(`[Weapon3DViewer] åŠ è½½æ¨¡å‹è·¯å¾„: ${modelPath}`)

      try {
        this.scene = await Scene.load($rawfile(modelPath))
      } catch (sceneError) {
        console.error(`[Weapon3DViewer] Scene.loadå¤±è´¥:`, sceneError)
        this.loadError = `æ— æ³•åŠ è½½æ¨¡å‹æ–‡ä»¶: ${modelPath}`
        this.isLoading = false
        return
      }

      if (!this.scene) {
        console.error('[Weapon3DViewer] åœºæ™¯åŠ è½½å¤±è´¥ï¼šsceneä¸ºnull')
        this.loadError = 'åœºæ™¯åŠ è½½å¤±è´¥'
        this.isLoading = false
        return
      }

      console.info(`[Weapon3DViewer] åœºæ™¯åŠ è½½æˆåŠŸ`)

      // 2. è·å–èµ„æºå·¥å‚
      const rf: SceneResourceFactory = this.scene.getResourceFactory()
      if (!rf) {
        console.error('[Weapon3DViewer] æ— æ³•è·å–èµ„æºå·¥å‚')
        this.loadError = 'æ— æ³•è·å–èµ„æºå·¥å‚'
        this.isLoading = false
        return
      }

      // 3. é…ç½®ç›¸æœº
      try {
        await this.setupCamera(rf)
        console.info(`[Weapon3DViewer] ç›¸æœºé…ç½®æˆåŠŸ`)
      } catch (cameraError) {
        console.error(`[Weapon3DViewer] ç›¸æœºé…ç½®å¤±è´¥:`, cameraError)
        this.loadError = 'ç›¸æœºé…ç½®å¤±è´¥'
        this.isLoading = false
        return
      }

      // 4. é…ç½®å…‰ç…§
      try {
        await this.setupLighting(rf)
        console.info(`[Weapon3DViewer] å…‰ç…§é…ç½®æˆåŠŸ`)
      } catch (lightError) {
        console.error(`[Weapon3DViewer] å…‰ç…§é…ç½®å¤±è´¥:`, lightError)
        // å…‰ç…§é…ç½®å¤±è´¥ä¸æ˜¯è‡´å‘½é”™è¯¯ï¼Œç»§ç»­
        console.warn(`[Weapon3DViewer] å…‰ç…§é…ç½®å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤å…‰ç…§`)
      }

      // 5. å¢å¼ºæè´¨(å¦‚æœéœ€è¦)
      try {
        await this.setupMaterials(rf)
        console.info(`[Weapon3DViewer] æè´¨é…ç½®æˆåŠŸ`)
      } catch (materialError) {
        console.error(`[Weapon3DViewer] æè´¨é…ç½®å¤±è´¥:`, materialError)
        // æè´¨é…ç½®å¤±è´¥ä¸æ˜¯è‡´å‘½é”™è¯¯ï¼Œç»§ç»­
        console.warn(`[Weapon3DViewer] æè´¨é…ç½®å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤æè´¨`)
      }

      // 6. æ’­æ”¾å¾…æœºåŠ¨ç”»(å¦‚æœæœ‰)
      try {
        this.playIdleAnimation()
      } catch (animError) {
        console.error(`[Weapon3DViewer] åŠ¨ç”»æ’­æ”¾å¤±è´¥:`, animError)
        // åŠ¨ç”»å¤±è´¥ä¸æ˜¯è‡´å‘½é”™è¯¯ï¼Œç»§ç»­
      }

      // 7. é…ç½®åœºæ™¯é€‰é¡¹
      this.sceneOpt = {
        scene: this.scene,
        modelType: 1  // 1 = SURFACE (ä¸“æœ‰ç¡¬ä»¶åˆæˆ)
      }

      this.isLoading = false
      console.info(`[Weapon3DViewer] æ¨¡å‹åŠ è½½å®Œæˆ: ${this.weaponId}`)

    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error)
      console.error(`[Weapon3DViewer] æ¨¡å‹åŠ è½½å¤±è´¥ ${this.weaponId}: ${errorMsg}`, error)
      this.loadError = `æ— æ³•åŠ è½½${this.weaponId}çš„3Dæ¨¡å‹: ${errorMsg}`
      this.isLoading = false
      // ä¸å†æŠ›å‡ºé”™è¯¯ï¼Œè€Œæ˜¯è®¾ç½®é”™è¯¯çŠ¶æ€è®©UIæ˜¾ç¤º
    }
  }

  /**
   * é…ç½®ç›¸æœº
   */
  async setupCamera(rf: SceneResourceFactory): Promise<void> {
    this.camera = await rf.createCamera({ name: "MainCamera" })

    if (!this.camera) {
      throw new Error('ç›¸æœºåˆ›å»ºå¤±è´¥')
    }

    // è®¾ç½®ç›¸æœºåˆå§‹ä½ç½®
    this.camera.enabled = true
    this.camera.position.z = this.cameraDistance
    this.camera.position.y = 1

    // è®¾ç½®ç›¸æœºè§†è§’å‚æ•°
    this.camera.fov = 60 * Math.PI / 180  // 60åº¦è§†è§’è½¬å¼§åº¦
  }

  /**
   * é…ç½®ä¸‰ç‚¹å¼å…‰ç…§ç³»ç»Ÿ
   */
  async setupLighting(rf: SceneResourceFactory): Promise<void> {
    // ä¸»å…‰(Key Light) - æš–è‰²è°ƒå¹³è¡Œå…‰
    const keyLight: Light = await rf.createLight(
      { name: "KeyLight" },
      LightType.DIRECTIONAL
    )
    keyLight.color = { r: 1.0, g: 0.95, b: 0.9, a: 1.0 }
    keyLight.intensity = 1.2
    keyLight.position = { x: 5, y: 10, z: 5 }
    keyLight.enabled = true

    // è¡¥å…‰(Fill Light) - å†·è‰²è°ƒæŸ”å’Œå…‰
    const fillLight: Light = await rf.createLight(
      { name: "FillLight" },
      LightType.DIRECTIONAL
    )
    fillLight.color = { r: 0.8, g: 0.85, b: 1.0, a: 1.0 }
    fillLight.intensity = 0.5
    fillLight.position = { x: -5, y: 5, z: 5 }
    fillLight.enabled = true

    // è½®å»“å…‰(Rim Light) - ç™½è‰²è¾¹ç¼˜å…‰
    const rimLight: Light = await rf.createLight(
      { name: "RimLight" },
      LightType.DIRECTIONAL
    )
    rimLight.color = { r: 1.0, g: 1.0, b: 1.0, a: 1.0 }
    rimLight.intensity = 0.8
    rimLight.position = { x: 0, y: 5, z: -10 }
    rimLight.enabled = true
  }

  /**
   * é…ç½®æè´¨å¢å¼º
   * æ³¨æ„ï¼šå½“å‰HarmonyOS APIä¸æ”¯æŒåŠ¨æ€æè´¨ä¿®æ”¹ï¼Œæ­¤åŠŸèƒ½æš‚æ—¶ç®€åŒ–
   */
  async setupMaterials(rf: SceneResourceFactory): Promise<void> {
    // æè´¨å¢å¼ºåŠŸèƒ½ä¾èµ–é«˜çº§APIï¼Œå½“å‰ç‰ˆæœ¬æš‚ä¸æ”¯æŒ
    // ä¿ç•™æ–¹æ³•ä»¥ä¾¿futureå‡çº§
    console.info('[Weapon3DViewer] æè´¨é…ç½®å·²ç®€åŒ–')
  }

  /**
   * åˆ¤æ–­æ­¦å™¨æ˜¯å¦éœ€è¦å‘å…‰æ•ˆæœ
   */
  weaponHasGlow(): boolean {
    if (!this.weapon) return false
    return this.weapon.rarity === 'artifact' || this.weapon.rarity === 'legendary'
  }

  /**
   * æ’­æ”¾å¾…æœºåŠ¨ç”»
   */
  playIdleAnimation(): void {
    if (!this.scene || !this.scene.animations || this.scene.animations.length === 0) {
      return
    }

    // æ’­æ”¾ç¬¬ä¸€ä¸ªåŠ¨ç”»(é€šå¸¸æ˜¯å¾…æœºåŠ¨ç”»)
    const idleAnim = this.scene.animations[0]
    idleAnim.speed = 1.0
    idleAnim.start()

    idleAnim.onFinished(() => {
      // å¾ªç¯æ’­æ”¾
      idleAnim.restart()
    })
  }

  /**
   * å¼€å§‹è‡ªåŠ¨æ—‹è½¬
   */
  startAutoRotate(): void {
    this.stopAutoRotate()

    this.autoRotateTimer = setInterval(() => {
      this.rotationY += 0.01  // æ¯å¸§æ—‹è½¬0.01å¼§åº¦
      this.updateCameraPosition()
    }, 16)  // çº¦60fps
  }

  /**
   * åœæ­¢è‡ªåŠ¨æ—‹è½¬
   */
  stopAutoRotate(): void {
    if (this.autoRotateTimer !== -1) {
      clearInterval(this.autoRotateTimer)
      this.autoRotateTimer = -1
    }
  }

  /**
   * æ›´æ–°ç›¸æœºä½ç½®
   */
  updateCameraPosition(): void {
    if (!this.camera) return

    const x = Math.sin(this.rotationY) * Math.cos(this.rotationX) * this.cameraDistance
    const y = Math.sin(this.rotationX) * this.cameraDistance
    const z = Math.cos(this.rotationY) * Math.cos(this.rotationX) * this.cameraDistance

    this.camera.position.x = x
    this.camera.position.y = y
    this.camera.position.z = z
  }

  /**
   * é‡ç½®ç›¸æœºè§†è§’
   */
  resetCamera(): void {
    this.rotationY = 0
    this.rotationX = 0
    this.cameraDistance = 3
    this.updateCameraPosition()

    if (!this.autoRotate) {
      this.autoRotate = true
      this.startAutoRotate()
    }
  }

  /**
   * å¤„ç†è§¦æ§äº‹ä»¶
   */
  handleTouch(event: TouchEvent): void {
    if (event.type === TouchType.Down) {
      this.stopAutoRotate()
      this.autoRotate = false

      if (event.touches.length === 1) {
        this.lastTouchX = event.touches[0].x
        this.lastTouchY = event.touches[0].y
      } else if (event.touches.length === 2) {
        this.lastPinchDistance = this.getTouchDistance(event.touches)
      }
    } else if (event.type === TouchType.Move) {
      if (event.touches.length === 1) {
        // å•æŒ‡æ‹–åŠ¨ = æ—‹è½¬
        const deltaX = event.touches[0].x - this.lastTouchX
        const deltaY = event.touches[0].y - this.lastTouchY

        this.rotationY += deltaX * 0.01
        this.rotationX += deltaY * 0.01

        // é™åˆ¶å‚ç›´æ—‹è½¬è§’åº¦(-80Â° to 80Â°)
        this.rotationX = Math.max(-1.4, Math.min(1.4, this.rotationX))

        this.updateCameraPosition()

        this.lastTouchX = event.touches[0].x
        this.lastTouchY = event.touches[0].y

      } else if (event.touches.length === 2) {
        // åŒæŒ‡æåˆ = ç¼©æ”¾
        const distance = this.getTouchDistance(event.touches)
        const scale = distance / this.lastPinchDistance

        this.cameraDistance *= (1 / scale)

        // é™åˆ¶ç¼©æ”¾èŒƒå›´(1.5 to 10)
        this.cameraDistance = Math.max(1.5, Math.min(10, this.cameraDistance))

        this.updateCameraPosition()

        this.lastPinchDistance = distance
      }
    }
  }

  /**
   * è®¡ç®—ä¸¤ä¸ªè§¦ç‚¹ä¹‹é—´çš„è·ç¦»
   */
  getTouchDistance(touches: TouchObject[]): number {
    if (touches.length < 2) return 0

    const dx = touches[0].x - touches[1].x
    const dy = touches[0].y - touches[1].y

    return Math.sqrt(dx * dx + dy * dy)
  }

  build() {
    Stack() {
      if (this.isLoading) {
        // åŠ è½½çŠ¶æ€
        this.LoadingView()
      } else if (this.loadError) {
        // é”™è¯¯çŠ¶æ€
        this.ErrorView()
      } else if (this.sceneOpt) {
        // 3Dè§†å›¾
        Component3D(this.sceneOpt)
          .width('100%')
          .height('100%')
          .onTouch((event: TouchEvent) => this.handleTouch(event))

        // æ§åˆ¶UIæµ®å±‚
        this.ControlOverlay()
      }
    }
    .width('100%')
    .height('100%')
    .backgroundColor(ThemeColors.BASE_0)
  }

  /**
   * åŠ è½½è§†å›¾
   */
  @Builder
  LoadingView() {
    Column() {
      LoadingProgress()
        .width(48)
        .height(48)
        .color(ThemeColors.GOLD_PRIMARY)

      Text('æ­£åœ¨åŠ è½½3Dæ¨¡å‹...')
        .fontSize(FontSizes.BODY)
        .fontColor(ThemeColors.TEXT_SECONDARY)
        .margin({ top: Spacing.MEDIUM })
    }
    .width('100%')
    .height('100%')
    .justifyContent(FlexAlign.Center)
  }

  /**
   * é”™è¯¯è§†å›¾
   */
  @Builder
  ErrorView() {
    Column() {
      Image($r('app.media.icon_close'))
        .width(48)
        .height(48)
        .fillColor(ThemeColors.ERROR)

      Text(this.loadError)
        .fontSize(FontSizes.BODY)
        .fontColor(ThemeColors.TEXT_SECONDARY)
        .margin({ top: Spacing.MEDIUM })

      Text('ç‚¹å‡»è¿”å›2Dè§†å›¾')
        .fontSize(FontSizes.BODY_SMALL)
        .fontColor(ThemeColors.TEXT_TERTIARY)
        .margin({ top: Spacing.SMALL })
    }
    .width('100%')
    .height('100%')
    .justifyContent(FlexAlign.Center)
  }

  /**
   * æ§åˆ¶UIæµ®å±‚
   */
  @Builder
  ControlOverlay() {
    Column() {
      // é¡¶éƒ¨å·¥å…·æ 
      Row() {
        // è‡ªåŠ¨æ—‹è½¬å¼€å…³
        Row() {
          Image(this.autoRotate ? $r('app.media.icon_pause') : $r('app.media.icon_play'))
            .width(20)
            .height(20)
            .fillColor(ThemeColors.TEXT_PRIMARY)
        }
        .width(40)
        .height(40)
        .justifyContent(FlexAlign.Center)
        .backgroundColor('rgba(26,34,51,0.8)')
        .backdropBlur(10)
        .borderRadius(20)
        .onClick(() => {
          this.autoRotate = !this.autoRotate
          if (this.autoRotate) {
            this.startAutoRotate()
          } else {
            this.stopAutoRotate()
          }
        })

        Blank()

        // é‡ç½®è§†è§’
        Row() {
          Image($r('app.media.icon_back'))  // ä¸´æ—¶ä½¿ç”¨backå›¾æ ‡ä»£æ›¿reset
            .width(20)
            .height(20)
            .fillColor(ThemeColors.TEXT_PRIMARY)
        }
        .width(40)
        .height(40)
        .justifyContent(FlexAlign.Center)
        .backgroundColor('rgba(26,34,51,0.8)')
        .backdropBlur(10)
        .borderRadius(20)
        .onClick(() => this.resetCamera())
      }
      .width('100%')
      .padding(Spacing.LARGE)

      Blank()

      // åº•éƒ¨æç¤ºä¿¡æ¯
      Column() {
        if (this.weapon) {
          Text(this.weapon.name.cn)
            .fontSize(FontSizes.SUBTITLE)
            .fontWeight(FontWeight.Bold)
            .fontColor(ThemeColors.TEXT_TITLE)
        }

        Text('ğŸ‘† æ‹–åŠ¨æ—‹è½¬  ğŸ‘Œ åŒæŒ‡ç¼©æ”¾')
          .fontSize(FontSizes.CAPTION)
          .fontColor(ThemeColors.TEXT_TERTIARY)
          .margin({ top: Spacing.TINY })
      }
      .width('100%')
      .padding(Spacing.LARGE)
      .backgroundColor('rgba(26,34,51,0.8)')
      .backdropBlur(20)
      .borderRadius({ topLeft: Spacing.LARGE, topRight: Spacing.LARGE })
    }
    .width('100%')
    .height('100%')
    .justifyContent(FlexAlign.SpaceBetween)
  }
}
