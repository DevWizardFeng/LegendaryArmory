<h1 _ngcontent-xlo-c119="" class="doc-title ng-star-inserted" title="ABR进行Buffer分辨率调整引起其他Pass渲染效果异常，该如何解决？"> ABR进行Buffer分辨率调整引起其他Pass渲染效果异常，该如何解决？ </h1>

<div _ngcontent-xlo-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;"> <div><p><strong>现象描述</strong></p> <p>以团结引擎URP管线为例，ABR对DrawOpaqueObjects绑定的Buffer进行分辨率调整时会引起SSAO shadow效果异常。</p> <p class="msonormal"><span><img height="242.06" originheight="242" originwidth="410" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211114411.74516992497112555416715036845644:50001231000000:2800:7134E76A93702CA8812ABE94684AB5D24A33D876AED13F5EC0B7C73C59A9BD21.png" title="点击放大" width="409.64000000000004"></span></p> <p><strong>原因分析</strong></p> <p>通过上述URP管线可以看到，SSAO在渲染管线中是一个“前处理”，SSAO输出的图像会作为DrawOpaqueObjects的输入。当ABR对DrawOpaqueObjects绑定的Buffer进行自适应分辨率调整时，SSAO输出的图像为原始分辨率，而DrawOpaqueObjects绑定的Buffer使用低分辨率，分辨率不一致导致SSAO shadow效果异常。</p> <p><strong>处理步骤</strong></p> <ol><li><strong>仅支持渲染线程的游戏引擎处理步骤</strong></li></ol> <p>针对该问题的解决方案，以下两种方案二选一即可。</p> <ul><li><strong>方案1</strong>：调整渲染管线，将SSAO作为“后处理”，SSAO不受DrawOpaqueObjects绑定的Buffer分辨率影响。<p>在URP资产中勾选“After Opaque”：</p> <p><span><img height="156.94" originheight="157" originwidth="439" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211114411.13065768128918694816283926680420:50001231000000:2800:D6F2707B42112EE65A96E7B040004CC769C4BE6599179195B92D2B97ABC99F88.png" title="点击放大" width="437.57000000000005"></span></p> </li></ul> <ul><li><strong>方案2</strong>：获取实时的ABR Buffer分辨率因子，并根据Buffer分辨率因子对相关渲染数据进行同步调整。<p>SSAO的shader会根据scaledScreenParams参数进行计算，该变量与渲染分辨率相关，在集成ABR后，scaledScreenParams需要根据实时的ABR Buffer分辨率因子调整。</p> <p>对于团结引擎，可在ScriptableRenderer.cs的SetPerCameraShaderVariables函数中根据Buffer分辨率因子设置scaledScreenParams参数。</p> <div _ngcontent-xlo-c106="" class="highlight-div"><div _ngcontent-xlo-c106="" class="highlight-div-header"><div _ngcontent-xlo-c106="" class="highlight-div-header-left"><div _ngcontent-xlo-c106="" class="handle-button expand-button"><div _ngcontent-xlo-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-xlo-c106="" class="highlight-div-header-right"><div _ngcontent-xlo-c106="" class="handle-button ai-button"></div><div _ngcontent-xlo-c106="" class="handle-button line-button"><div _ngcontent-xlo-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-xlo-c106="" class="handle-button theme-button"><div _ngcontent-xlo-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-xlo-c106="" class="handle-button copy-button"><div _ngcontent-xlo-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-xlo-c106="" class="highlight-scroll-div"><pre class="cs prettyprint linenums hljs language-csharp" hw-language="cs" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetPerCameraShaderVariables</span>(<span class="hljs-params">CommandBuffer cmd, <span class="hljs-keyword">ref</span> CameraData cameraData, <span class="hljs-built_in">bool</span> isTargetFlipped</span>)</span></li><li>{</li><li>    Camera camera = cameraData.camera;</li><li>    <span class="hljs-built_in">float</span> scaledCameraWidth = (<span class="hljs-built_in">float</span>)cameraData.cameraTargetDescriptor.width;</li><li>    <span class="hljs-built_in">float</span> scaledCameraHeight = (<span class="hljs-built_in">float</span>)cameraData.cameraTargetDescriptor.height;</li><li><span class="">    <span class="hljs-comment">// scale为通过HMS_ABR_GetScale接口获取的ABR Buffer分辨率因子</span></span></li><li><span class="">    scaledCameraWidth *= scale;</span></li><li><span class="">    scaledCameraHeight *= scale;</span></li><li>    cmd.SetGlobalVector(ShaderPropertyId.scaledScreenParams, <span class="hljs-keyword">new</span> Vector4(scaledCameraWidth, scaledCameraHeight, <span class="hljs-number">1.0f</span> + <span class="hljs-number">1.0f</span> / scaledCameraWidth, <span class="hljs-number">1.0f</span> + <span class="hljs-number">1.0f</span> / scaledCameraHeight));</li><li>}</li></ol></pre></div></div> </li></ul> <ol start="2"><li><strong>支持渲染线程、RHI线程的游戏引擎处理步骤</strong></li></ol> <p>对于同时支持渲染线程、RHI线程的游戏引擎，而且RHI线程延迟于渲染线程的场景，渲染线程通过<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/_graphics_accelerate#ga936129328fea3a5f77b2aae4935f67c6" target="_blank">HMS_ABR_GetScale</a>接口获取的ABR Buffer分辨率因子无法解决上述问题。</p> <div class="p">对于该场景，渲染线程在Buffer渲染后调用<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/_graphics_accelerate#section157311245143415" target="_blank">HMS_ABR_GetNextScale</a>接口获取下一帧的ABR Buffer分辨率因子，并根据Buffer分辨率因子对相关渲染数据进行同步调整。<div _ngcontent-xlo-c106="" class="highlight-div"><div _ngcontent-xlo-c106="" class="highlight-div-header"><div _ngcontent-xlo-c106="" class="highlight-div-header-left"><div _ngcontent-xlo-c106="" class="handle-button expand-button"><div _ngcontent-xlo-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-xlo-c106="" class="highlight-div-header-right"><div _ngcontent-xlo-c106="" class="handle-button ai-button"></div><div _ngcontent-xlo-c106="" class="handle-button line-button"><div _ngcontent-xlo-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-xlo-c106="" class="handle-button theme-button"><div _ngcontent-xlo-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-xlo-c106="" class="handle-button copy-button"><div _ngcontent-xlo-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-xlo-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// 在Buffer渲染后调用</span></li><li><span class="hljs-type">float</span> scale = <span class="hljs-number">1.0f</span>;</li><li>errorCode = <span class="hljs-built_in">HMS_ABR_GetNextScale</span>(context_, &amp;scale);</li><li><span class="hljs-keyword">if</span> (errorCode != ABR_SUCCESS) {</li><li>    <span class="hljs-built_in">GOLOGE</span>(<span class="hljs-string">"HMS_ABR_GetNextScale execution failed, error code: %d."</span>, errorCode);</li><li>}</li><li>
</li><li><span class="hljs-comment">// 根据Buffer分辨率因子对渲染数据进行同步调整</span></li><li><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetViewUniformParameters</span><span class="hljs-params">()</span></span></li><li><span class="hljs-function"></span>{</li><li>    ViewUniformParameters.BufferSize.X = (<span class="hljs-type">int</span>)(ViewUniformParameters.BufferSize.X * scale);</li><li>    ViewUniformParameters.BufferSize.Y = (<span class="hljs-type">int</span>)(ViewUniformParameters.BufferSize.Y * scale);</li><li>    ViewUniformParameters.BufferInvSize.X /= scale;</li><li>    ViewUniformParameters.BufferInvSize.Y /= scale;</li><li>}</li></ol></pre></div></div> </div> </div> <div></div></div>