<h1 _ngcontent-kmr-c119="" class="doc-title ng-star-inserted" title="Function Flow Runtime串行队列(C)"> Function Flow Runtime串行队列(C) </h1>

<div _ngcontent-kmr-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;"> <div> <div class="tiledSection"><h2 id="概述">概述<i class="anchor-icon anchor-icon-link" anchorid="概述" tips="复制节点链接"></i></h2><p>FFRT串行队列基于协程调度模型实现，提供高效的消息队列功能，支持异步通信、流量削峰、无锁化状态和资源管理以及架构解耦等多种业务场景。FFRT串行队列支持以下功能：</p> <ul><li><strong>​队列创建销毁</strong>​，支持创建和销毁队列，创建时可指定队列名称和优先级。每个队列功能上相当于一个单独的线程，队列中的任务相对于用户线程异步执行。</li><li><strong>任务延迟</strong>​，支持在任务提交时设置延迟时间（delay），单位为微秒（us）。延迟任务将在uptime（提交时刻+延迟时间）后调度执行。</li><li><strong>​串行调度</strong>​，同一队列中的任务按照uptime升序排列，严格串行执行。确保队列中上一个任务完成后，下一个任务才会开始执行。</li><li><strong>​任务取消</strong>​，支持根据任务句柄取消未出队的任务。若任务已开始执行或执行完成，则无法取消。</li><li><strong>​任务等待</strong>​，支持根据任务句柄等待任务完成。指定任务完成时，队列中所有uptime早于该任务的任务均已执行完成。</li><li><strong>任务优先级</strong>​，支持在任务提交时设置单个任务的优先级。优先级仅在任务出队后相对于系统其他负载生效，不影响同一队列内任务的串行顺序。若未设置任务优先级，则默认继承队列的优先级。</li></ul> </div>  <div class="tiledSection"><h2 id="示例异步日志系统">示例：异步日志系统<i class="anchor-icon anchor-icon-link" anchorid="示例异步日志系统" tips="复制节点链接"></i></h2><p>举例实现一个异步日志系统，主线程将日志任务提交到队列，后台线程从队列中取出任务并写入文件。这种方式既能保证日志的顺序性，又能避免文件写入操作阻塞主线程。</p> <p>借助FFRT并行化框架API，开发者只需专注于业务逻辑的实现，无需关注异步线程管理、线程安全及调度效率等问题。</p> <p>用例简化了异常处理和线程安全相关的一些逻辑，实现代码如下所示：</p> <div _ngcontent-kmr-c106="" class="highlight-div"><div _ngcontent-kmr-c106="" class="highlight-div-header"><div _ngcontent-kmr-c106="" class="highlight-div-header-left"><div _ngcontent-kmr-c106="" class="handle-button expand-button"><div _ngcontent-kmr-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-kmr-c106="" class="highlight-div-header-right"><div _ngcontent-kmr-c106="" class="handle-button ai-button"></div><div _ngcontent-kmr-c106="" class="handle-button line-button"><div _ngcontent-kmr-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-kmr-c106="" class="handle-button theme-button"><div _ngcontent-kmr-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-kmr-c106="" class="handle-button copy-button"><div _ngcontent-kmr-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-kmr-c106="" class="highlight-scroll-div"><pre class="c prettyprint linenums hljs language-c" hw-language="c" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span></li><li><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span></li><li><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span></li><li><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span></li><li><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"ffrt/ffrt.h"</span> <span class="hljs-comment">// 来自 OpenHarmony 第三方库 "@ppd/ffrt"</span></span></li><li>
</li><li><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span></li><li>    FILE *logFile;          <span class="hljs-comment">// 日志文件指针</span></li><li>    <span class="hljs-type">ffrt_queue_t</span> <span class="hljs-built_in">queue</span>;     <span class="hljs-comment">// 任务队列</span></li><li>} <span class="hljs-type">logger_t</span>;</li><li>
</li><li><span class="hljs-comment">// 全局Logger变量</span></li><li><span class="hljs-type">logger_t</span>* g_logger = <span class="hljs-literal">NULL</span>;</li><li>
</li><li><span class="hljs-comment">// 初始化日志系统</span></li><li><span class="hljs-type">logger_t</span> *<span class="hljs-title function_">logger_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename)</span></li><li>{</li><li>    <span class="hljs-type">logger_t</span> *logger = (<span class="hljs-type">logger_t</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">logger_t</span>));</li><li>    <span class="hljs-keyword">if</span> (!logger) {</li><li>        perror(<span class="hljs-string">"Failed to allocate memory for logger_t"</span>);</li><li>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;</li><li>    }</li><li>
</li><li>    <span class="hljs-comment">// 打开日志文件</span></li><li>    logger-&gt;logFile = fopen(filename, <span class="hljs-string">"a"</span>);</li><li>    <span class="hljs-keyword">if</span> (!logger-&gt;logFile) {</li><li>        perror(<span class="hljs-string">"Failed to open log file"</span>);</li><li>        <span class="hljs-built_in">free</span>(logger);</li><li>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;</li><li>    }</li><li>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Log file opened: %s\n"</span>, filename);</li><li>
</li><li>    <span class="hljs-comment">// 创建任务队列</span></li><li>    logger-&gt;<span class="hljs-built_in">queue</span> = ffrt_queue_create(ffrt_queue_serial, <span class="hljs-string">"logger_queue_c"</span>, <span class="hljs-literal">NULL</span>);</li><li>    <span class="hljs-keyword">if</span> (!logger-&gt;<span class="hljs-built_in">queue</span>) {</li><li>        perror(<span class="hljs-string">"Failed to create queue"</span>);</li><li>        fclose(logger-&gt;logFile);</li><li>        <span class="hljs-built_in">free</span>(logger);</li><li>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;</li><li>    }</li><li>
</li><li>    <span class="hljs-keyword">return</span> logger;</li><li>}</li><li>
</li><li><span class="hljs-comment">// 销毁日志系统</span></li><li><span class="hljs-type">void</span> <span class="hljs-title function_">logger_destroy</span><span class="hljs-params">(<span class="hljs-type">logger_t</span> *logger)</span></li><li>{</li><li>    <span class="hljs-keyword">if</span> (logger) {</li><li>        <span class="hljs-comment">// 销毁队列</span></li><li>        <span class="hljs-keyword">if</span> (logger-&gt;<span class="hljs-built_in">queue</span>) {</li><li>            ffrt_queue_destroy(logger-&gt;<span class="hljs-built_in">queue</span>);</li><li>        }</li><li>
</li><li>        <span class="hljs-comment">// 关闭日志文件</span></li><li>        <span class="hljs-keyword">if</span> (logger-&gt;logFile) {</li><li>            fclose(logger-&gt;logFile);</li><li>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Log file closed\n"</span>);</li><li>        }</li><li>
</li><li>        <span class="hljs-built_in">free</span>(logger);</li><li>    }</li><li>}</li><li>
</li><li><span class="hljs-comment">// 日志任务</span></li><li><span class="hljs-type">void</span> <span class="hljs-title function_">write_task</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></li><li>{</li><li>    <span class="hljs-type">char</span> *message = (<span class="hljs-type">char</span> *)arg;</li><li>    <span class="hljs-keyword">if</span> (g_logger &amp;&amp; g_logger-&gt;logFile) {</li><li>        <span class="hljs-built_in">fprintf</span>(g_logger-&gt;logFile, <span class="hljs-string">"%s\n"</span>, message);</li><li>        fflush(g_logger-&gt;logFile);</li><li>    }</li><li>
</li><li>    <span class="hljs-built_in">free</span>(message);</li><li>}</li><li>
</li><li><span class="hljs-comment">// 添加日志任务</span></li><li><span class="hljs-type">void</span> <span class="hljs-title function_">logger_log</span><span class="hljs-params">(<span class="hljs-type">logger_t</span> *logger, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *message)</span></li><li>{</li><li>    <span class="hljs-keyword">if</span> (!logger || !logger-&gt;<span class="hljs-built_in">queue</span>) {</li><li>        <span class="hljs-keyword">return</span>;</li><li>    }</li><li>
</li><li>    <span class="hljs-comment">// 复制消息字符串</span></li><li>    <span class="hljs-type">char</span> *messageCopy = strdup(message);</li><li>    <span class="hljs-keyword">if</span> (!messageCopy) {</li><li>        perror(<span class="hljs-string">"Failed to allocate memory for message"</span>);</li><li>        <span class="hljs-keyword">return</span>;</li><li>    }</li><li>
</li><li>    ffrt_queue_submit_f(logger-&gt;<span class="hljs-built_in">queue</span>, write_task, messageCopy, <span class="hljs-literal">NULL</span>);</li><li>}</li><li>
</li><li><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span></li><li>{</li><li>    <span class="hljs-comment">// 初始化全局logger</span></li><li>    g_logger = logger_create(<span class="hljs-string">"log_c.txt"</span>);</li><li>    <span class="hljs-keyword">if</span> (!g_logger) {</li><li>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;</li><li>    }</li><li>
</li><li>    <span class="hljs-comment">// 使用全局logger添加日志任务</span></li><li>    logger_log(g_logger, <span class="hljs-string">"Log message 1"</span>);</li><li>    logger_log(g_logger, <span class="hljs-string">"Log message 2"</span>);</li><li>    logger_log(g_logger, <span class="hljs-string">"Log message 3"</span>);</li><li>
</li><li>    <span class="hljs-comment">// 模拟主线程继续执行其他任务</span></li><li>    sleep(<span class="hljs-number">1</span>);</li><li>
</li><li>    <span class="hljs-comment">// 销毁全局logger</span></li><li>    logger_destroy(g_logger);</li><li>    g_logger = <span class="hljs-literal">NULL</span>;</li><li>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</li><li>}</li></ol></pre></div></div> <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"> <p>ffrt_queue_submit_h_f接口可以接收裸函数指针任务作为参数，如果任务存在前后处理可以参见<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ffrt-api-guideline-c#ffrt_alloc_auto_managed_function_storage_base">ffrt_alloc_auto_managed_function_storage_base</a>函数查看如何构造任务结构体。</p>  </div></div></div> </div>  <div class="tiledSection"><h2 id="接口说明">接口说明<i class="anchor-icon anchor-icon-link" anchorid="接口说明" tips="复制节点链接"></i></h2><p>上述样例中涉及到主要的FFRT的接口包括：</p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.3.3.1.3.1.1" valign="top" width="50%">名称</th> <th align="left" class="cellrowborder" id="mcps1.3.3.3.1.3.1.2" valign="top" width="50%">描述</th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="50%"><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ffrt-api-guideline-c#ffrt_queue_t">ffrt_queue_create</a></td> <td class="cellrowborder" valign="top" width="50%">创建队列。</td> </tr> <tr><td class="cellrowborder" valign="top" width="50%"><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ffrt-api-guideline-c#ffrt_queue_t">ffrt_queue_destroy</a></td> <td class="cellrowborder" valign="top" width="50%">销毁队列。</td> </tr> <tr><td class="cellrowborder" valign="top" width="50%"><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ffrt-api-guideline-c#ffrt_queue_t">ffrt_queue_submit_f</a></td> <td class="cellrowborder" valign="top" width="50%"><p>向队列提交一个任务。</p> <p><strong>说明</strong>：从API version 20开始，支持该接口。</p> </td> </tr>  </tbody></table></div> </div> <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"> <ul><li>如何使用FFRT C++ API详见：<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ffrt-development-guideline#using-ffrt-c-api-1">FFRT C++接口三方库使用指导</a>。</li><li>使用FFRT C接口或C++接口时，都可以通过FFRT C++接口三方库简化头文件包含，即使用#include "ffrt/ffrt.h"头文件包含语句。</li></ul>  </div></div></div> </div>  <div class="tiledSection"><h2 id="约束限制">约束限制<i class="anchor-icon anchor-icon-link" anchorid="约束限制" tips="复制节点链接"></i></h2><ul><li><strong>避免提交超长任务</strong> FFRT内置进程级队列任务超时检测机制。当串行任务执行时间超过预设阈值（默认30秒）时，系统将打印和上报异常日志，并触发预设的进程超时回调函数（如已配置）。</li><li><strong>同步原语使用规范</strong> 在提交给FFRT的任务闭包中，避免使用std::mutex、std::condition_variable和std::recursive_mutex，标准库同步原语会长时间占用FFRT Worker线程。请替换为FFRT提供的同步原语：ffrt::mutex、ffrt::condition_variable或ffrt::recursive_mutex，其用法与标准库相同。</li><li><strong>全局变量中的队列管理</strong> 若在全局变量中管理串行队列，随业务进程销毁，测试程序中需注意生命周期解耦问题。在测试用例结束时，需显式释放串行队列，其他资源可随全局变量释放。原因是全局变量在主函数结束后析构，而串行队列的释放依赖于FFRT框架中的其他资源，此时这些资源可能已被销毁。</li></ul> </div> </div> <div></div></div>