<h1 _ngcontent-qfw-c119="" class="doc-title ng-star-inserted" title="Function Flow Runtime串行队列(C++)"> Function Flow Runtime串行队列(C++) </h1>

<div _ngcontent-qfw-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;"> <div> <div class="tiledSection"><h2 id="概述">概述<i class="anchor-icon anchor-icon-link" anchorid="概述" tips="复制节点链接"></i></h2><p>FFRT串行队列基于协程调度模型实现，提供高效的消息队列功能，支持异步通信、流量削峰、无锁化状态和资源管理以及架构解耦等多种业务场景。FFRT串行队列支持以下功能：</p> <ul><li><strong>​队列创建销毁</strong>​，支持创建和销毁队列，创建时可指定队列名称和优先级。每个队列功能上相当于一个单独的线程，队列中的任务相对于用户线程异步执行。</li><li><strong>任务延迟</strong>​，支持在任务提交时设置延迟时间（delay），单位为微秒（us）。延迟任务将在uptime（提交时刻+延迟时间）后调度执行。</li><li><strong>​串行调度</strong>​，同一队列中的任务按照uptime升序排列，严格串行执行。确保队列中上一个任务完成后，下一个任务才会开始执行。</li><li><strong>​任务取消</strong>​，支持根据任务句柄取消未出队的任务。若任务已开始执行或执行完成，则无法取消。</li><li><strong>​任务等待</strong>​，支持根据任务句柄等待任务完成。指定任务完成时，队列中所有uptime早于该任务的任务均已执行完成。</li><li><strong>任务优先级</strong>​，支持在任务提交时设置单个任务的优先级。优先级仅在任务出队后相对于系统其他负载生效，不影响同一队列内任务的串行顺序。若未设置任务优先级，则默认继承队列的优先级。</li></ul> </div>  <div class="tiledSection"><h2 id="示例异步日志系统">示例：异步日志系统<i class="anchor-icon anchor-icon-link" anchorid="示例异步日志系统" tips="复制节点链接"></i></h2><p>举例实现一个异步日志系统，主线程将日志任务提交到队列，后台线程从队列中取出任务并写入文件。这种方式既能保证日志的顺序性，又能避免文件写入操作阻塞主线程。</p> <p>借助FFRT并行化框架API，开发者只需专注于业务逻辑的实现，无需关注异步线程管理、线程安全及调度效率等问题。</p> <p>用例简化了异常处理和线程安全相关的一些逻辑，实现代码如下所示：</p> <div _ngcontent-qfw-c106="" class="highlight-div"><div _ngcontent-qfw-c106="" class="highlight-div-header"><div _ngcontent-qfw-c106="" class="highlight-div-header-left"><div _ngcontent-qfw-c106="" class="handle-button expand-button"><div _ngcontent-qfw-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-qfw-c106="" class="highlight-div-header-right"><div _ngcontent-qfw-c106="" class="handle-button ai-button"></div><div _ngcontent-qfw-c106="" class="handle-button line-button"><div _ngcontent-qfw-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-qfw-c106="" class="handle-button theme-button"><div _ngcontent-qfw-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-qfw-c106="" class="handle-button copy-button"><div _ngcontent-qfw-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-qfw-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span></li><li><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span></li><li><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span></li><li><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span></li><li><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"ffrt/ffrt.h"</span> <span class="hljs-comment">// 来自 OpenHarmony 第三方库 "@ppd/ffrt"</span></span></li><li>
</li><li><span class="hljs-keyword">class</span> <span class="hljs-title class_">Logger</span> {</li><li><span class="hljs-keyword">public</span>:</li><li>    <span class="hljs-built_in">Logger</span>(<span class="hljs-type">const</span> std::string&amp; filename)</li><li>    {</li><li>        <span class="hljs-comment">// 创建队列</span></li><li>        queue_ = std::<span class="hljs-built_in">make_unique</span>&lt;ffrt::queue&gt;(<span class="hljs-string">"loggerQueue"</span>);</li><li>
</li><li>        <span class="hljs-comment">// 以追加模式打开文件</span></li><li>        logFile_.<span class="hljs-built_in">open</span>(filename, std::ios::app);</li><li>        <span class="hljs-keyword">if</span> (!logFile_.<span class="hljs-built_in">is_open</span>()) {</li><li>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">"Failed to open log file: "</span> + filename);</li><li>        }</li><li>        std::cout &lt;&lt; <span class="hljs-string">"Log file opened: "</span> &lt;&lt; filename &lt;&lt; std::endl;</li><li>    }</li><li>
</li><li>    ~<span class="hljs-built_in">Logger</span>() {</li><li>        <span class="hljs-comment">// 销毁队列</span></li><li>        queue_ = <span class="hljs-literal">nullptr</span>;</li><li>
</li><li>        <span class="hljs-keyword">if</span> (logFile_.<span class="hljs-built_in">is_open</span>()) {</li><li>            logFile_.<span class="hljs-built_in">close</span>();</li><li>            std::cout &lt;&lt; <span class="hljs-string">"Log file closed"</span> &lt;&lt; std::endl;</li><li>        }</li><li>    }</li><li>
</li><li>    <span class="hljs-comment">// 添加日志任务</span></li><li>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; message)</span> </span>{</li><li>        queue_-&gt;<span class="hljs-built_in">submit</span>([<span class="hljs-keyword">this</span>, message] {</li><li>            logFile_ &lt;&lt; message &lt;&lt; std::endl;</li><li>        });</li><li>    }</li><li>
</li><li><span class="hljs-keyword">private</span>:</li><li>    std::ofstream logFile_;</li><li>    std::unique_ptr&lt;ffrt::queue&gt; queue_;</li><li>};</li><li>
</li><li><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></li><li><span class="hljs-function"></span>{</li><li>    <span class="hljs-function">Logger <span class="hljs-title">logger</span><span class="hljs-params">(<span class="hljs-string">"log.txt"</span>)</span></span>;</li><li>
</li><li>    <span class="hljs-comment">// 主线程添加日志任务</span></li><li>    logger.<span class="hljs-built_in">log</span>(<span class="hljs-string">"Log message 1"</span>);</li><li>    logger.<span class="hljs-built_in">log</span>(<span class="hljs-string">"Log message 2"</span>);</li><li>    logger.<span class="hljs-built_in">log</span>(<span class="hljs-string">"Log message 3"</span>);</li><li>
</li><li>    <span class="hljs-comment">// 模拟主线程继续执行其他任务</span></li><li>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));</li><li>
</li><li>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</li><li>}</li></ol></pre></div></div> </div>  <div class="tiledSection"><h2 id="接口说明">接口说明<i class="anchor-icon anchor-icon-link" anchorid="接口说明" tips="复制节点链接"></i></h2><p>上述样例中涉及到主要的FFRT的接口包括：</p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.3.3.1.3.1.1" valign="top" width="50%">名称</th> <th align="left" class="cellrowborder" id="mcps1.3.3.3.1.3.1.2" valign="top" width="50%">描述</th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="50%">class <a href="https://gitcode.com/openharmony/resourceschedule_ffrt/blob/master/docs/ffrt-api-guideline-cpp.md#queue" target="_blank">queue</a></td> <td class="cellrowborder" valign="top" width="50%">队列类。</td> </tr> <tr><td class="cellrowborder" valign="top" width="50%"><a href="https://gitcode.com/openharmony/resourceschedule_ffrt/blob/master/docs/ffrt-api-guideline-cpp.md#sleep_for" target="_blank">sleep_for</a></td> <td class="cellrowborder" valign="top" width="50%">延迟一定时间。</td> </tr>  </tbody></table></div> </div> <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"> <ul><li>如何使用FFRT C++ API详见：<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ffrt-development-guideline#using-ffrt-c-api-1">FFRT C++接口三方库使用指导</a>。</li><li>使用FFRT C接口或C++接口时，都可以通过FFRT C++接口三方库简化头文件包含，即使用#include "ffrt/ffrt.h"头文件包含语句。</li></ul>  </div></div></div> </div>  <div class="tiledSection"><h2 id="约束限制">约束限制<i class="anchor-icon anchor-icon-link" anchorid="约束限制" tips="复制节点链接"></i></h2><ul><li><strong>避免提交超长任务</strong> FFRT内置进程级队列任务超时检测机制。当串行任务执行时间超过预设阈值（默认30秒）时，系统将打印和上报异常日志，并触发预设的进程超时回调函数（如已配置）。</li><li><strong>同步原语使用规范</strong> 在提交给FFRT的任务闭包中，避免使用std::mutex、std::condition_variable和std::recursive_mutex，标准库同步原语会长时间占用FFRT Worker线程。请替换为FFRT提供的同步原语：ffrt::mutex、ffrt::condition_variable或ffrt::recursive_mutex，其用法与标准库相同。</li><li><strong>全局变量中的队列管理</strong> 若在全局变量中管理串行队列，随业务进程销毁，测试程序中需注意生命周期解耦问题。在测试用例结束时，需显式释放串行队列，其他资源可随全局变量释放。原因是全局变量在主函数结束后析构，而串行队列的释放依赖于FFRT框架中的其他资源，此时这些资源可能已被销毁。</li></ul> </div> </div> <div></div></div>