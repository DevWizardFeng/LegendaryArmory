<h1 _ngcontent-gjm-c119="" class="doc-title ng-star-inserted" title="Function Flow Runtime任务伙伴(C++)"> Function Flow Runtime任务伙伴(C++) </h1>

<div _ngcontent-gjm-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;"> <div> <div class="tiledSection"><h2 id="概述">概述<i class="anchor-icon anchor-icon-link" anchorid="概述" tips="复制节点链接"></i></h2><p>从API version 20开始，FFRT支持Job_Partner功能。在实际业务中，可能会遇到某一个线程（比如UI绘制线程）耗时很长，难以充分利用CPU多核能力的情况。此时，将原有线程的大任务拆分为多个小任务交给其他线程去执行是解决该问题的有效方法。但是，在实践中，会遇到两个问题：</p> <ul><li>问题1：小任务中的部分片段受限于某些原因，必须执行在指定的线程上（比如访问JS虚拟机中的变量）。</li><li>问题2：小任务会被拆分为多个小片段（可能由于问题1或者其他原因），单次执行时间可能在微秒级，而单次线程唤醒的开销在几十个微秒级，难以获得并发收益。</li></ul> <p>为解决以上问题，Job Partner并发范式应运而生。</p> <p><span><img originheight="351" originwidth="994" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211115051.52727109307259784635934085948215:50001231000000:2800:A388E9ECB912F3D92953449C8602170A3A2F7ADD083C58C1BE93E9FC3A9BF3FE.png" width="920" height="324.8692152917505"></span></p> <p>Job Partner并发范式中定义原先的线程为master线程，并支持动态管理partner线程（伙伴线程）。它有两个特性：</p> <ul><li>特性1：针对问题1，支持partner线程在执行任务过程中暂停当前任务的执行，之后将任务发送到master线程执行，直到master线程执行完成之后在partner线程继续执行原有任务。</li><li>特性2：针对问题2，利用批量小任务的特征，动态将多个小任务合并为更大的FFRT任务，以均摊单个小任务的调度开销。</li></ul> </div>  <div class="tiledSection"><h2 id="示例某商城系统">示例：某商城系统<i class="anchor-icon anchor-icon-link" anchorid="示例某商城系统" tips="复制节点链接"></i></h2><p>实现一个商城系统的节点并行化创建，要求节点创建的部分代码片段必须在JS线程中运行，其他片段可以在任意线程执行。</p> <p>以下是原有伪代码实现：</p> <div _ngcontent-gjm-c106="" class="highlight-div"><div _ngcontent-gjm-c106="" class="highlight-div-header"><div _ngcontent-gjm-c106="" class="highlight-div-header-left"><div _ngcontent-gjm-c106="" class="handle-button expand-button"><div _ngcontent-gjm-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-gjm-c106="" class="highlight-div-header-right"><div _ngcontent-gjm-c106="" class="handle-button ai-button"></div><div _ngcontent-gjm-c106="" class="handle-button line-button"><div _ngcontent-gjm-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-gjm-c106="" class="handle-button theme-button"><div _ngcontent-gjm-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-gjm-c106="" class="handle-button copy-button"><div _ngcontent-gjm-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-gjm-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">namespace</span> market_system {</li><li>    <span class="hljs-comment">// 批量创建节点，在js线程上被调用</span></li><li>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">create_nodes</span><span class="hljs-params">(std::array&lt;Node&gt;&amp; nodes)</span></span></li><li><span class="hljs-function">    </span>{</li><li>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nodes.<span class="hljs-built_in">size</span>(); i++) {</li><li>            <span class="hljs-built_in">code1</span>(); <span class="hljs-comment">// 可以在任意线程上执行的代码片段</span></li><li>            <span class="hljs-built_in">code2</span>(); <span class="hljs-comment">// 必须在js线程上执行的代码片段</span></li><li>            <span class="hljs-built_in">code3</span>(); <span class="hljs-comment">// 可以在任意线程上执行的代码片段</span></li><li>        }</li><li>    }</li><li>};</li></ol></pre></div></div> <p>使用Job Partner并行化后的伪代码如下：</p> <div _ngcontent-gjm-c106="" class="highlight-div"><div _ngcontent-gjm-c106="" class="highlight-div-header"><div _ngcontent-gjm-c106="" class="highlight-div-header-left"><div _ngcontent-gjm-c106="" class="handle-button expand-button"><div _ngcontent-gjm-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-gjm-c106="" class="highlight-div-header-right"><div _ngcontent-gjm-c106="" class="handle-button ai-button"></div><div _ngcontent-gjm-c106="" class="handle-button line-button"><div _ngcontent-gjm-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-gjm-c106="" class="handle-button theme-button"><div _ngcontent-gjm-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-gjm-c106="" class="handle-button copy-button"><div _ngcontent-gjm-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-gjm-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;array&gt;</span></span></li><li><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span></li><li><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"ffrt/ffrt.h"</span> <span class="hljs-comment">// 来自 OpenHarmony 第三方库 "@ppd/ffrt"</span></span></li><li>
</li><li><span class="hljs-keyword">namespace</span> market_system {</li><li>    <span class="hljs-comment">// 批量创建节点，在js线程上被调用</span></li><li>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">create_nodes</span><span class="hljs-params">(std::array&lt;Node&gt;&amp; nodes)</span></span></li><li><span class="hljs-function">    </span>{</li><li>        <span class="hljs-keyword">constexpr</span> <span class="hljs-type">uint64_t</span> stack_size = <span class="hljs-number">16</span> * <span class="hljs-number">1024</span>;</li><li>        <span class="hljs-keyword">auto</span> stack = std::make_unique&lt;std::array&lt;<span class="hljs-type">char</span>, stack_size&gt;[]&gt;(nodes.<span class="hljs-built_in">size</span>()); <span class="hljs-comment">// 创建job_num个执行栈</span></li><li>        <span class="hljs-keyword">auto</span> partner = ffrt::job_partner&lt;&gt;::<span class="hljs-built_in">get_partner_of_this_thread</span>(); <span class="hljs-comment">// 获得当前js线程的伙伴</span></li><li>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nodes.<span class="hljs-built_in">size</span>(); i++) {</li><li>            partner-&gt;<span class="hljs-built_in">submit</span>([&amp;] { <span class="hljs-comment">// 每个节点的创建提交给partner</span></li><li>                <span class="hljs-built_in">code1</span>(); <span class="hljs-comment">// 可以在任意线程上执行的代码片段</span></li><li>                ffrt::job_partner&lt;&gt;::<span class="hljs-built_in">submit_to_master</span>([&amp;] { <span class="hljs-comment">// 遇到必须在master线程执行的任务时发给主线程并同步等待</span></li><li>                    <span class="hljs-built_in">code2</span>(); <span class="hljs-comment">// 必须在js线程上执行的代码片段</span></li><li>                });</li><li>                <span class="hljs-built_in">code3</span>(); <span class="hljs-comment">// 可以在任意线程上执行的代码片段</span></li><li>            }, &amp;stack[i], stack_size);</li><li>        }</li><li>        partner-&gt;<span class="hljs-built_in">wait</span>(); <span class="hljs-comment">// 等待所有节点创建完成</span></li><li>    }</li><li>};</li></ol></pre></div></div> </div>  <div class="tiledSection"><h2 id="接口说明">接口说明<i class="anchor-icon anchor-icon-link" anchorid="接口说明" tips="复制节点链接"></i></h2><p>上述样例中涉及的主要FFRT接口及其功能包括：</p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.3.3.1.3.1.1" valign="top" width="50%">名称</th> <th align="left" class="cellrowborder" id="mcps1.3.3.3.1.3.1.2" valign="top" width="50%">描述</th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="50%"><a href="https://gitcode.com/openharmony/resourceschedule_ffrt/blob/master/docs/ffrt-api-guideline-cpp.md#job_partner" target="_blank">job_partner</a></td> <td class="cellrowborder" valign="top" width="50%">细粒度任务伙伴接口。</td> </tr>  </tbody></table></div> </div> <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"> <ul><li>如何使用FFRT C++ API详见：<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ffrt-development-guideline#using-ffrt-c-api-1">FFRT C++接口三方库使用指导</a>。</li><li>使用FFRT C接口或C++接口时，都可以通过FFRT C++接口三方库简化头文件包含，即使用#include "ffrt/ffrt.h"头文件包含语句。</li></ul>  </div></div></div> </div>  <div class="tiledSection"><h2 id="约束限制">约束限制<i class="anchor-icon anchor-icon-link" anchorid="约束限制" tips="复制节点链接"></i></h2><ul><li>适用Job Partner并发范式的场景应该是粒度较小且不会长时间阻塞线程的大批量任务。</li><li>如果任务粒度较大（比如数百微秒以上），推荐使用FFRT更为通用的任务提交接口。</li><li>如果任务不满足大批量的特征，使用Job Partner并发范式并不能显著降低调度开销。</li></ul> </div> </div> <div></div></div>