<h1 _ngcontent-vwa-c119="" class="doc-title ng-star-inserted" title="Function Flow Runtime图依赖并发(C++)"> Function Flow Runtime图依赖并发(C++) </h1>

<div _ngcontent-vwa-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;"> <div> <div class="tiledSection"><h2 id="概述">概述<i class="anchor-icon anchor-icon-link" anchorid="概述" tips="复制节点链接"></i></h2><p>FFRT图依赖并发范式支持任务依赖和数据依赖两种方式构建任务依赖图。任务依赖图中每个节点表示一个任务，边表示任务之间的依赖关系。任务依赖分为输入依赖in_deps和输出依赖out_deps。</p> <p>构建任务依赖图的两种不同方式：</p> <ul><li>当使用任务依赖方式构建任务依赖图时，使用任务句柄handle来对应一个任务对象。</li><li>当使用数据依赖方式构建任务依赖图时，数据对象表达抽象为数据签名，每个数据签名唯一对应一个数据对象。</li></ul> </div>  <div class="tiledSection"><h3 id="任务依赖" class="firsth2">任务依赖<i class="anchor-icon anchor-icon-link" anchorid="任务依赖" tips="复制节点链接"></i></h3><div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"> <p>当任务句柄出现在一个任务的in_deps中时，任务句柄对应的任务是该任务的前置任务；当任务句柄出现在一个任务的out_deps中时，任务句柄对应的任务是该任务的后继任务。</p>  </div></div></div> <p>任务依赖适用于任务之间有明确顺序或逻辑流程要求的场景，例如：</p> <ul><li>顺序执行的任务，例如：先进行数据预处理任务，然后再进行模型训练任务。</li><li>逻辑流程控制，例如：商品交易过程中，通常是先下单，然后是制作，最后是物流运输。</li><li>多级任务链，例如：流媒体视频处理过程中，视频解析后可以进行视频转码和视频生成缩略图，然后是视频添加水印，最后是视频发布。</li></ul> </div>  <div class="tiledSection"><h3 id="数据依赖">数据依赖<i class="anchor-icon anchor-icon-link" anchorid="数据依赖" tips="复制节点链接"></i></h3><div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"> <p>当数据对象的签名出现在一个任务的in_deps中时，该任务称为数据对象的消费者任务，消费者任务执行不改变其输入数据对象的内容；</p> <p>当数据对象的签名出现在任务的out_deps中时，该任务称为数据对象的生产者任务，生产者任务执行改变其输出数据对象的内容，从而生成该数据对象的一个新的版本。</p>  </div></div></div> <p>数据依赖适用于任务之间通过数据生产和消费关系来触发执行的场景。</p> <p>一个数据对象可能存在多个版本，每个版本对应一个生产者任务和零个，一个或多个消费者任务，根据生产者任务和消费者任务的下发顺序定义数据对象的多个版本的顺序，以及每个版本所对应的生产者和消费者任务。</p> <p>数据依赖解除的任务进入就绪状态允许被调度执行，依赖解除状态指任务所有输入数据对象版本的生产者任务执行完成，且所有输出数据对象版本的所有消费者任务执行完成的状态。</p> <p>FFRT在运行时可动态构建任务之间的基于生产者/消费者的数据依赖关系并遵循任务数据依赖状态执行调度，包括：</p> <ul><li><p>Producer-Consumer依赖</p>  <p>一个数据对象版本的生产者任务和该数据对象版本的消费者任务之间形成的依赖关系，也称为Read-after-Write依赖。</p>  </li><li><p>Consumer-Producer依赖</p>  <p>一个数据对象版本的消费者任务和该数据对象的下一个版本的生产者任务之间形成的依赖关系，也称为Write-after-Read依赖。</p>  </li><li><p>Producer-Producer依赖</p>  <p>一个数据对象版本的生产者任务和该数据对象的下一个版本的生产者任务之间形成的依赖关系，也称为Write-after-Write依赖。</p>  </li></ul> <p>例如，存在一组任务与数据A的关系表述为：</p> <div _ngcontent-vwa-c106="" class="highlight-div"><div _ngcontent-vwa-c106="" class="highlight-div-header"><div _ngcontent-vwa-c106="" class="highlight-div-header-left"><div _ngcontent-vwa-c106="" class="handle-button expand-button"><div _ngcontent-vwa-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-vwa-c106="" class="highlight-div-header-right"><div _ngcontent-vwa-c106="" class="handle-button ai-button"></div><div _ngcontent-vwa-c106="" class="handle-button line-button"><div _ngcontent-vwa-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-vwa-c106="" class="handle-button theme-button"><div _ngcontent-vwa-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-vwa-c106="" class="handle-button copy-button"><div _ngcontent-vwa-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-vwa-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-built_in">task1</span>(OUT A);</li><li><span class="hljs-built_in">task2</span>(IN A);</li><li><span class="hljs-built_in">task3</span>(IN A);</li><li><span class="hljs-built_in">task4</span>(OUT A);</li><li><span class="hljs-built_in">task5</span>(OUT A);</li></ol></pre></div></div> <p><span><img originheight="1138" originwidth="548" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211115047.42526314374161488614968436358356:50001231000000:2800:CB8DC98FE122E3A0DE703DBF3BF3C06D65BD2FDCC64668FF0EFF2D9524880825.png" width="548" height="1138"></span></p> <p>为表述方便，本文中的数据流图均以圆圈表示Task，方块表示数据。</p> <p>可以得出以下结论：</p> <ul><li>task1与task2/task3构成Producer-Consumer依赖，即：task2/task3需要等到task1写完A之后才能读A。</li><li>task2/task3与task4构成Consumer-Producer依赖，即：task4需要等到task2/task3读完A之后才能写A。</li><li>task4与task5构成Producer-Producer依赖，即：task5需要等到task4写完A之后才能写A。</li></ul> </div>  <div class="tiledSection"><h2 id="示例流媒体视频处理">示例：流媒体视频处理<i class="anchor-icon anchor-icon-link" anchorid="示例流媒体视频处理" tips="复制节点链接"></i></h2><p>用户上传视频到流媒体平台，处理步骤包含：视频解析A、视频转码B、视频缩略图生成C、视频水印添加D和视频发布E，其中步骤B和步骤C可以并行执行。任务流程如下图所示：</p> <p><span><img originheight="351" originwidth="872" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211115047.45025314250903790807181676263783:50001231000000:2800:9A633F6010E847960ABE289F9F83E64236F68723F30660D15BA9A17CBDE1F083.png" width="872" height="351"></span></p> <p>借助FFRT提供了图依赖并发范式，可以描述任务依赖关系，同时并行化上述视频处理流程，代码如下所示：</p> <div _ngcontent-vwa-c106="" class="highlight-div"><div _ngcontent-vwa-c106="" class="highlight-div-header"><div _ngcontent-vwa-c106="" class="highlight-div-header-left"><div _ngcontent-vwa-c106="" class="handle-button expand-button"><div _ngcontent-vwa-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-vwa-c106="" class="highlight-div-header-right"><div _ngcontent-vwa-c106="" class="handle-button ai-button"></div><div _ngcontent-vwa-c106="" class="handle-button line-button"><div _ngcontent-vwa-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-vwa-c106="" class="handle-button theme-button"><div _ngcontent-vwa-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-vwa-c106="" class="handle-button copy-button"><div _ngcontent-vwa-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-vwa-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span></li><li><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"ffrt/ffrt.h"</span> <span class="hljs-comment">// 来自 OpenHarmony 第三方库 "@ppd/ffrt"</span></span></li><li>
</li><li><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></li><li><span class="hljs-function"></span>{</li><li>    <span class="hljs-comment">// 提交任务</span></li><li>    <span class="hljs-keyword">auto</span> handle_A = ffrt::<span class="hljs-built_in">submit_h</span>([] () { std::cout &lt;&lt; <span class="hljs-string">"视频解析"</span> &lt;&lt; std::endl; });</li><li>    <span class="hljs-keyword">auto</span> handle_B = ffrt::<span class="hljs-built_in">submit_h</span>([] () { std::cout &lt;&lt; <span class="hljs-string">"视频转码"</span> &lt;&lt; std::endl; }, {handle_A});</li><li>    <span class="hljs-keyword">auto</span> handle_C = ffrt::<span class="hljs-built_in">submit_h</span>([] () { std::cout &lt;&lt; <span class="hljs-string">"视频生成缩略图"</span> &lt;&lt; std::endl; }, {handle_A});</li><li>    <span class="hljs-keyword">auto</span> handle_D = ffrt::<span class="hljs-built_in">submit_h</span>([] () { std::cout &lt;&lt; <span class="hljs-string">"视频添加水印"</span> &lt;&lt; std::endl; }, {handle_B, handle_C});</li><li>    ffrt::<span class="hljs-built_in">submit</span>([] () { std::cout &lt;&lt; <span class="hljs-string">"视频发布"</span> &lt;&lt; std::endl; }, {handle_D});</li><li>
</li><li>    <span class="hljs-comment">// 等待所有任务完成</span></li><li>    ffrt::<span class="hljs-built_in">wait</span>();</li><li>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</li><li>}</li></ol></pre></div></div> <p>预期的输出可能为：</p> <div _ngcontent-vwa-c106="" class="highlight-div"><div _ngcontent-vwa-c106="" class="highlight-div-header"><div _ngcontent-vwa-c106="" class="highlight-div-header-left"><div _ngcontent-vwa-c106="" class="handle-button expand-button"><div _ngcontent-vwa-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-vwa-c106="" class="highlight-div-header-right"><div _ngcontent-vwa-c106="" class="handle-button ai-button"></div><div _ngcontent-vwa-c106="" class="handle-button line-button"><div _ngcontent-vwa-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-vwa-c106="" class="handle-button theme-button"><div _ngcontent-vwa-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-vwa-c106="" class="handle-button copy-button"><div _ngcontent-vwa-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-vwa-c106="" class="highlight-scroll-div"><pre class="plain prettyprint linenums hljs language-undefined" hw-language="plain" data-highlighted="yes"><ol class="linenums"><li>视频解析</li><li>视频转码</li><li>视频生成缩略图</li><li>视频添加水印</li><li>视频发布</li></ol></pre></div></div> </div>  <div class="tiledSection"><h2 id="示例斐波那契数列">示例：斐波那契数列<i class="anchor-icon anchor-icon-link" anchorid="示例斐波那契数列" tips="复制节点链接"></i></h2><p>斐波那契数列中每个数字是前两个数字之和，计算斐波那契数的过程可以很好地通过数据对象来表达任务依赖关系。使用FFRT并发编程框架计算斐波那契数的代码如下所示：</p> <div _ngcontent-vwa-c106="" class="highlight-div"><div _ngcontent-vwa-c106="" class="highlight-div-header"><div _ngcontent-vwa-c106="" class="highlight-div-header-left"><div _ngcontent-vwa-c106="" class="handle-button expand-button"><div _ngcontent-vwa-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-vwa-c106="" class="highlight-div-header-right"><div _ngcontent-vwa-c106="" class="handle-button ai-button"></div><div _ngcontent-vwa-c106="" class="handle-button line-button"><div _ngcontent-vwa-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-vwa-c106="" class="handle-button theme-button"><div _ngcontent-vwa-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-vwa-c106="" class="handle-button copy-button"><div _ngcontent-vwa-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-vwa-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span></li><li><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"ffrt/ffrt.h"</span> <span class="hljs-comment">// 来自 OpenHarmony 第三方库 "@ppd/ffrt"</span></span></li><li>
</li><li><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Fib</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span>&amp; y)</span></span></li><li><span class="hljs-function"></span>{</li><li>    <span class="hljs-keyword">if</span> (x &lt;= <span class="hljs-number">1</span>) {</li><li>        y = x;</li><li>    } <span class="hljs-keyword">else</span> {</li><li>        <span class="hljs-type">int</span> y1, y2;</li><li>
</li><li>        <span class="hljs-comment">// 提交任务并构建数据依赖</span></li><li>        ffrt::<span class="hljs-built_in">submit</span>([&amp;]() { <span class="hljs-built_in">Fib</span>(x - <span class="hljs-number">1</span>, y1); }, {&amp;x}, {&amp;y1});</li><li>        ffrt::<span class="hljs-built_in">submit</span>([&amp;]() { <span class="hljs-built_in">Fib</span>(x - <span class="hljs-number">2</span>, y2); }, {&amp;x}, {&amp;y2});</li><li>
</li><li>        <span class="hljs-comment">// 等待任务完成</span></li><li>        ffrt::<span class="hljs-built_in">wait</span>({&amp;y1, &amp;y2});</li><li>        y = y1 + y2;</li><li>    }</li><li>}</li><li>
</li><li><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></li><li><span class="hljs-function"></span>{</li><li>    <span class="hljs-type">int</span> y;</li><li>    <span class="hljs-built_in">Fib</span>(<span class="hljs-number">5</span>, y);</li><li>    std::cout &lt;&lt; <span class="hljs-string">"Fibonacci(5) is "</span> &lt;&lt; y &lt;&lt; std::endl;</li><li>}</li></ol></pre></div></div> <p>预期输出为：</p> <div _ngcontent-vwa-c106="" class="highlight-div"><div _ngcontent-vwa-c106="" class="highlight-div-header"><div _ngcontent-vwa-c106="" class="highlight-div-header-left"><div _ngcontent-vwa-c106="" class="handle-button expand-button"><div _ngcontent-vwa-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-vwa-c106="" class="highlight-div-header-right"><div _ngcontent-vwa-c106="" class="handle-button ai-button"></div><div _ngcontent-vwa-c106="" class="handle-button line-button"><div _ngcontent-vwa-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-vwa-c106="" class="handle-button theme-button"><div _ngcontent-vwa-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-vwa-c106="" class="handle-button copy-button"><div _ngcontent-vwa-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-vwa-c106="" class="highlight-scroll-div"><pre class="plain prettyprint linenums hljs language-scss" hw-language="plain" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-built_in">Fibonacci</span>(<span class="hljs-number">5</span>) is <span class="hljs-number">5</span></li></ol></pre></div></div> <p>示例中将fibonacci(x-1)和fibonacci(x-2)作为两个任务提交给FFRT，在两个任务完成之后将结果进行累加。虽然单个任务只是拆分成两个子任务，但是子任务又可以继续进行拆分，因此整个计算图的并行度是非常高的。</p> <p>各个任务在FFRT内部形成了一颗调用树：</p> <p><span><img originheight="998" originwidth="1104" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211115047.97465607687222076281828679699624:50001231000000:2800:8D52FA89B8471B637688278FC8B15FDDF5F0727BAC5EAE93DD697FD45FD41A62.png" width="920" height="831.6666666666667"></span></p> </div>  <div class="tiledSection"><h2 id="接口说明">接口说明<i class="anchor-icon anchor-icon-link" anchorid="接口说明" tips="复制节点链接"></i></h2><p>上述样例中涉及到主要的FFRT的接口包括：</p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.6.3.1.3.1.1" valign="top" width="50%">名称</th> <th align="left" class="cellrowborder" id="mcps1.3.6.3.1.3.1.2" valign="top" width="50%">描述</th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="50%"><a href="https://gitcode.com/openharmony/resourceschedule_ffrt/blob/master/docs/ffrt-api-guideline-cpp.md#submit" target="_blank">submit</a></td> <td class="cellrowborder" valign="top" width="50%">提交任务调度执行。</td> </tr> <tr><td class="cellrowborder" valign="top" width="50%"><a href="https://gitcode.com/openharmony/resourceschedule_ffrt/blob/master/docs/ffrt-api-guideline-cpp.md#submit_h" target="_blank">submit_h</a></td> <td class="cellrowborder" valign="top" width="50%">提交任务调度执行并返回任务句柄。</td> </tr> <tr><td class="cellrowborder" valign="top" width="50%"><a href="https://gitcode.com/openharmony/resourceschedule_ffrt/blob/master/docs/ffrt-api-guideline-cpp.md#wait" target="_blank">wait</a></td> <td class="cellrowborder" valign="top" width="50%">等待上下文所有任务完成。</td> </tr>  </tbody></table></div> </div> <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"> <ul><li>如何使用FFRT C++ API详见：<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ffrt-development-guideline#using-ffrt-c-api-1">FFRT C++接口三方库使用指导</a>。</li><li>使用FFRT C接口或C++接口时，都可以通过FFRT C++接口三方库简化头文件包含，即使用#include "ffrt/ffrt.h"头文件包含语句。</li></ul>  </div></div></div> </div>  <div class="tiledSection"><h2 id="约束限制">约束限制<i class="anchor-icon anchor-icon-link" anchorid="约束限制" tips="复制节点链接"></i></h2><ul><li>使用submit接口进行任务提交时，每个任务的输入依赖和输出依赖的数量之和不能超过8个。</li><li>使用submit_h接口进行任务提交时，每个任务的输入依赖和输出依赖的数量之和不能超过7个。</li><li>参数既作为输入依赖又作为输出依赖的时候，统计依赖数量时只统计一次，如输入依赖是{&amp;x}，输出依赖也是{&amp;x}，实际依赖的数量是 1。</li></ul> </div> </div> <div></div></div>