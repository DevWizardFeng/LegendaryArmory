<h1 _ngcontent-bhj-c119="" class="doc-title ng-star-inserted" title="Function Flow Runtime并发范式"> Function Flow Runtime并发范式 </h1>

<div _ngcontent-bhj-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;"> <div><p>为了应对实际业务中，任务执行顺序固定、灵活优先级调度以及复杂的任务依赖关系等场景，FFRT支持串行队列、并发队列和图依赖三种不同的并发范式。</p>  <div class="tiledSection"><h2 id="串行队列serial-queue">串行队列（Serial Queue）<i class="anchor-icon anchor-icon-link" anchorid="串行队列serial-queue" tips="复制节点链接"></i></h2><p>串行队列并发范式常用于解决以下场景中的问题：</p> <ol><li><strong>顺序执行</strong>: 某些任务需要按特定顺序执行，串行队列可以确保任务按添加的顺序逐一执行，避免了乱序执行带来的数据不一致性和错误。</li><li><strong>数据安全</strong>: 在并发环境中访问和修改共享资源时，容易出现竞争条件。使用串行队列可以避免多个线程同时访问共享资源，确保数据的一致性和安全性。</li><li><strong>任务协调</strong>: 串行队列可以用来协调复杂任务的执行顺序，例如在进行多个依赖关系的任务时，确保前一个任务完成后再开始下一个任务。</li><li><strong>简化开发</strong>: 相较于手动管理锁和同步机制，串行队列的使用更加简洁明了。开发者只需将任务添加到队列中，系统会自动处理任务的调度和执行顺序，减少了开发和调试的复杂性。</li><li><strong>资源管理</strong>: 在某些情况下，限制并发任务的数量可以避免资源争用和过载。串行队列可以控制并发任务的数量，优化系统资源的使用。</li></ol> <p><span><img originheight="115" originwidth="994" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211115011.24176323630919997889542679056794:50001231000000:2800:4C2F024DA6FF64C265A4FB8929CECA58DFDD5EF1E5B2FB9626C7D2ED68137808.png" width="920" height="106.43863179074447"></span></p> <p>串行队列并发范式开发样例可以参考<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ffrt-concurrency-serial-queue-c">串行队列(C)</a>/<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ffrt-concurrency-serial-queue-cpp">串行队列(C++)</a></p> </div>  <div class="tiledSection"><h2 id="并发队列concurrent-queue">并发队列（Concurrent Queue）<i class="anchor-icon anchor-icon-link" anchorid="并发队列concurrent-queue" tips="复制节点链接"></i></h2><p>并发队列并发范式常用于解决以下场景中的问题：</p> <ol><li><strong>提高并发度</strong>: 并发队列允许多个任务同时执行，充分利用多核处理器的计算能力，显著提高系统的并发度和整体性能。</li><li><strong>资源高效利用</strong>: 并发队列能将任务分配到可用的CPU核心上，优化资源的使用，减少任务的等待时间和资源争用。</li><li><strong>任务调度灵活</strong>: 并发队列允许任务按照不同的优先级（Priority）和QoS进行调度，确保关键任务能够及时执行，提高系统的响应速度。</li><li><strong>避免资源冲击</strong>: 并发队列允许设置最大并发度，避免任务并发过多对系统资源造成的冲击，从而保证系统的稳定性和性能。</li></ol> <p><span><img originheight="300" originwidth="994" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211115011.10735475281326085808387205386738:50001231000000:2800:4A825565D6E574B4D85C2CBCF201C766DE204C61EE6C182C9787688A6EBADE08.png" width="920" height="277.66599597585514"></span></p> <p>并发队列并发范式开发样例可以参考<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ffrt-concurrency-concurrent-queue-c">并发队列(C)</a>/<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ffrt-concurrency-concurrent-queue-cpp">并发队列(C++)</a></p> </div>  <div class="tiledSection"><h2 id="图依赖并发task-graph">图依赖并发（Task Graph）<i class="anchor-icon anchor-icon-link" anchorid="图依赖并发task-graph" tips="复制节点链接"></i></h2><p>图依赖并发范式常用于解决以下场景中的问题：</p> <ol><li><strong>复杂任务依赖关系</strong>: 在许多实际应用中，任务之间存在复杂的依赖关系。图依赖并发范式通过使用有向图来表示任务及其依赖关系，能够清晰地管理和调度这些任务。</li><li><strong>动态任务调度</strong>: 当任务的依赖关系和执行顺序需要根据运行时的条件动态决定时，图依赖并发范式可以灵活地调整任务的调度，确保任务按正确的顺序执行。</li><li><strong>并行任务执行</strong>: 图依赖并发范式允许多个不相互依赖的任务并行执行，从而最大化利用系统的计算资源，提高并发度和执行效率。</li><li><strong>结构化并发</strong>：图依赖并发范式中可以通过明确的任务生命周期和依赖关系，确保并发任务的创建和完成在代码结构中清晰可见，减少并发编程的复杂性和错误。</li></ol> <p><span><img originheight="196" originwidth="994" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211115011.54683862637673475485561327503377:50001231000000:2800:D9F6F9B1962A51342321457E6F96B4127B0D9D8B735E77B3CFAFD24326C8BCD4.png" width="920" height="181.40845070422534"></span></p> <p>图依赖并发范式开发样例可以参考<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ffrt-concurrency-graph-c">图依赖并发(C)</a>/<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ffrt-concurrency-graph-cpp">图依赖并发(C++)</a></p> </div>  <div class="tiledSection"><h2 id="任务伙伴job-partner">任务伙伴（Job Partner）<i class="anchor-icon anchor-icon-link" anchorid="任务伙伴job-partner" tips="复制节点链接"></i></h2><p>从API version 20开始，FFRT支持Job_Partner(任务伙伴)功能。任务伙伴任务并发范式常用于解决以下场景中的问题：</p> <ol><li><p><strong>多线程协作</strong>: 在许多实际应用中，某些功能需要在特定环境进行运行，而其他功能可以在任何环境运行，这个时候需要多线程协作，部分功能在A线程运行，然后回到B线程，最后再回到A线程。</p>  <p> <span><img originheight="351" originwidth="994" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211115011.94213099663485123814084586398846:50001231000000:2800:9EC78766408512278E2E2B82D64A400B860D7F838705AF5FF6CC54AAB8BC1678.png" width="920" height="324.8692152917505"></span></p>  </li><li><p><strong>动态并发调度</strong>: 有些场景并发任务数量动态变化，时多时少，所以可以通过动态调整worker数量来最大提升性能，降低调度开销。</p>  <p> <span><img originheight="328" originwidth="734" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211115011.99703039741052004443624457309267:50001231000000:2800:66A839E5A945A9550463C337D62D7FD9DEE32D98A428E1D2E69FF5839AF5BEA8.png" width="734" height="328"></span></p>  <p> 图中的参数如下所示：</p>  <ul><li>job_num 提交的任务数。</li><li>partner_num worker数量。</li><li>threshold 表示任务堆积到指定数量后才会启动worker。</li><li>ratio 表示任务数和worker数的比例。</li><li>max 表示最大worker数。</li></ul>  </li></ol> <p>协作并发范式开发样例可以参考<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ffrt-concurrency-job-partner-cpp">任务伙伴(C++)</a></p> </div> </div> <div></div></div>