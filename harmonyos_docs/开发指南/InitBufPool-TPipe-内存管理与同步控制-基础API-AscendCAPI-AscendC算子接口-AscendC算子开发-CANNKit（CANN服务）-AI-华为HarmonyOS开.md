<h1 _ngcontent-njk-c119="" class="doc-title ng-star-inserted" title="InitBufPool"> InitBufPool </h1>

<div _ngcontent-njk-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;"> <div><div class="tiledSection"><h2 id="section26857mcpsimp">功能说明<i class="anchor-icon anchor-icon-link" anchorid="section26857mcpsimp" tips="复制节点链接"></i></h2><p>初始化TBufPool内存资源池。本接口适用于内存资源有限时，希望手动指定UB/L1内存资源复用的场景。本接口初始化后在整体内存资源中划分出一块子资源池。划分出的子资源池TBufPool，提供了如下方式进行资源管理：</p> <ul><li>TPipe::InitBufPool的重载接口指定与其他TBufPool子资源池复用。</li><li>TBufPool::InitBufPool接口对子资源池继续划分。</li><li>TBufPool::InitBuffer接口分配Buffer。</li></ul> <p>关于TBufPool的具体介绍及资源划分图示请参考<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cannkit-tbufpool">TBufPool</a>。</p> </div> <div class="tiledSection"><h2 id="section26869mcpsimp">函数原型<i class="anchor-icon anchor-icon-link" anchorid="section26869mcpsimp" tips="复制节点链接"></i></h2><div _ngcontent-njk-c106="" class="highlight-div"><div _ngcontent-njk-c106="" class="highlight-div-header"><div _ngcontent-njk-c106="" class="highlight-div-header-left"><div _ngcontent-njk-c106="" class="handle-button expand-button"><div _ngcontent-njk-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-njk-c106="" class="highlight-div-header-right"><div _ngcontent-njk-c106="" class="handle-button ai-button"></div><div _ngcontent-njk-c106="" class="handle-button line-button"><div _ngcontent-njk-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-njk-c106="" class="handle-button theme-button"><div _ngcontent-njk-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-njk-c106="" class="handle-button copy-button"><div _ngcontent-njk-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-njk-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; </li><li><span class="hljs-function">__aicore__ <span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">InitBufPool</span><span class="hljs-params">(T&amp; bufPool, <span class="hljs-type">uint32_t</span> len)</span> </span></li><li><span class="hljs-function"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> T, <span class="hljs-keyword">class</span> U&gt; </span></li><li><span class="hljs-function">__aicore__ <span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">InitBufPool</span><span class="hljs-params">(T&amp; bufPool, <span class="hljs-type">uint32_t</span> len, U&amp; shareBuf)</span></span></li></ol></pre></div></div> </div> <div class="tiledSection"><h2 id="section26872mcpsimp">参数说明<i class="anchor-icon anchor-icon-link" anchorid="section26872mcpsimp" tips="复制节点链接"></i></h2><p>表1 InitBufPool(T&amp; bufPool, uint32_t len) 原型定义参数说明</p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.3.3.1.4.1.1" valign="top" width="12.120000000000001%"><p>参数名称</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.3.3.1.4.1.2" valign="top" width="12.120000000000001%"><p>输入/输出</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.3.3.1.4.1.3" valign="top" width="75.76%"><p>含义</p> </th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="12.120000000000001%"><p>bufPool</p> </td> <td class="cellrowborder" valign="top" width="12.120000000000001%"><p>输入</p> </td> <td class="cellrowborder" valign="top" width="75.76%"><p>新划分的资源池，类型为TBufPool。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="12.120000000000001%"><p>len</p> </td> <td class="cellrowborder" valign="top" width="12.120000000000001%"><p>输入</p> </td> <td class="cellrowborder" valign="top" width="75.76%"><p>新划分资源池长度，单位为Byte，非32Bytes对齐会自动补齐至32Bytes对齐。</p> </td> </tr>  </tbody></table></div> </div> <p>表2 InitBufPool(T&amp; bufPool, uint32_t len, U&amp; shareBuf)原型定义参数说明</p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.3.5.1.4.1.1" valign="top" width="12.120000000000001%"><p>参数名称</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.3.5.1.4.1.2" valign="top" width="12.120000000000001%"><p>输入/输出</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.3.5.1.4.1.3" valign="top" width="75.76%"><p>含义</p> </th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="12.120000000000001%"><p>bufPool</p> </td> <td class="cellrowborder" valign="top" width="12.120000000000001%"><p>输入</p> </td> <td class="cellrowborder" valign="top" width="75.76%"><p>新划分的资源池，类型为TBufPool。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="12.120000000000001%"><p>len</p> </td> <td class="cellrowborder" valign="top" width="12.120000000000001%"><p>输入</p> </td> <td class="cellrowborder" valign="top" width="75.76%"><p>新划分资源池长度，单位为Byte，非32Bytes对齐会自动补齐至32Bytes对齐。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="12.120000000000001%"><p>shareBuf</p> </td> <td class="cellrowborder" valign="top" width="12.120000000000001%"><p>输入</p> </td> <td class="cellrowborder" valign="top" width="75.76%"><p>被复用资源池，类型为TBufPool，新划分资源池与被复用资源池共享起始地址及长度。</p> </td> </tr>  </tbody></table></div> </div> </div> <div class="tiledSection"><h2 id="section26939mcpsimp">支持的型号<i class="anchor-icon anchor-icon-link" anchorid="section26939mcpsimp" tips="复制节点链接"></i></h2><p>Kirin9020系列处理器</p> <p>KirinX90系列处理器</p> </div> <div class="tiledSection"><h2 id="section26945mcpsimp">注意事项<i class="anchor-icon anchor-icon-link" anchorid="section26945mcpsimp" tips="复制节点链接"></i></h2><ul><li>新划分的资源池与被复用资源池的硬件属性需要一致，两者共享起始地址及长度。</li><li>输入长度需要小于等于被复用资源池长度。</li><li>其他泛用约束参考<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cannkit-tbufpool">TBufPool</a>。</li></ul> </div> <div class="tiledSection"><h2 id="section26953mcpsimp">返回值<i class="anchor-icon anchor-icon-link" anchorid="section26953mcpsimp" tips="复制节点链接"></i></h2><p>无</p> </div> <div class="tiledSection"><h2 id="section26956mcpsimp">调用示例<i class="anchor-icon anchor-icon-link" anchorid="section26956mcpsimp" tips="复制节点链接"></i></h2><p>由于物理内存的大小有限，在计算过程没有数据依赖的场景或数据依赖串行、没有内存踩踏的场景下，可以通过指定内存复用解决资源不足的问题。本示例中Tpipe::InitBufPool初始化子资源池tbufPool1，并且指定tbufPool2复用tbufPool1的起始地址及长度。tbufPool1及tbufPool2的后续计算串行，不存在数据踩踏，实现了内存复用及自动同步的能力。</p> <div _ngcontent-njk-c106="" class="highlight-div"><div _ngcontent-njk-c106="" class="highlight-div-header"><div _ngcontent-njk-c106="" class="highlight-div-header-left"><div _ngcontent-njk-c106="" class="handle-button expand-button"><div _ngcontent-njk-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-njk-c106="" class="highlight-div-header-right"><div _ngcontent-njk-c106="" class="handle-button ai-button"></div><div _ngcontent-njk-c106="" class="handle-button line-button"><div _ngcontent-njk-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-njk-c106="" class="handle-button theme-button"><div _ngcontent-njk-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-njk-c106="" class="handle-button copy-button"><div _ngcontent-njk-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-njk-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"kernel_operator.h"</span> </span></li><li><span class="hljs-keyword">class</span> <span class="hljs-title class_">ResetApi</span> { </li><li><span class="hljs-keyword">public</span>: </li><li>    <span class="hljs-function">__aicore__ <span class="hljs-keyword">inline</span> <span class="hljs-title">ResetApi</span><span class="hljs-params">()</span> </span>{} </li><li>    <span class="hljs-function">__aicore__ <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Init</span><span class="hljs-params">(__gm__ <span class="hljs-type">uint8_t</span>* </span></span><em><span class="hljs-function"><span class="hljs-params">src0Gm</span></span></em><span class="hljs-function"><span class="hljs-params">, __gm__ <span class="hljs-type">uint8_t</span>* </span></span><em><span class="hljs-function"><span class="hljs-params">src1Gm</span></span></em><span class="hljs-function"><span class="hljs-params">, __gm__ <span class="hljs-type">uint8_t</span>* </span></span><em><span class="hljs-function"><span class="hljs-params">dstGm</span></span></em><span class="hljs-function"><span class="hljs-params">)</span> </span></li><li><span class="hljs-function">    </span>{ </li><li>        src0Global.<span class="hljs-built_in">SetGlobalBuffer</span>((__gm__ half*)<em>src0Gm</em>); </li><li>        src1Global.<span class="hljs-built_in">SetGlobalBuffer</span>((__gm__ half*)<em>src1Gm</em>); </li><li>        dstGlobal.<span class="hljs-built_in">SetGlobalBuffer</span>((__gm__ half*)<em>dstGm</em>); </li><li>        pipe.<span class="hljs-built_in">InitBufPool</span>(tbufPool1, <span class="hljs-number">196608</span>); </li><li>        pipe.<span class="hljs-built_in">InitBufPool</span>(tbufPool2, <span class="hljs-number">196608</span>, tbufPool1); </li><li>    } </li><li>    <span class="hljs-function">__aicore__ <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Process</span><span class="hljs-params">()</span> </span></li><li><span class="hljs-function">    </span>{ </li><li>        tbufPool1.<span class="hljs-built_in">InitBuffer</span>(queSrc0, <span class="hljs-number">1</span>, <span class="hljs-number">65536</span>); </li><li>        tbufPool1.<span class="hljs-built_in">InitBuffer</span>(queSrc1, <span class="hljs-number">1</span>, <span class="hljs-number">65536</span>); </li><li>        tbufPool1.<span class="hljs-built_in">InitBuffer</span>(queDst0, <span class="hljs-number">1</span>, <span class="hljs-number">65536</span>); </li><li>        <span class="hljs-built_in">CopyIn</span>(); </li><li>        <span class="hljs-built_in">Compute</span>();  </li><li>        <span class="hljs-built_in">CopyOut</span>(); </li><li>        tbufPool1.<span class="hljs-built_in">Reset</span>(); </li><li>        tbufPool2.<span class="hljs-built_in">InitBuffer</span>(queSrc2, <span class="hljs-number">1</span>, <span class="hljs-number">65536</span>); </li><li>        tbufPool2.<span class="hljs-built_in">InitBuffer</span>(queSrc3, <span class="hljs-number">1</span>, <span class="hljs-number">65536</span>); </li><li>        tbufPool2.<span class="hljs-built_in">InitBuffer</span>(queDst1, <span class="hljs-number">1</span>, <span class="hljs-number">65536</span>); </li><li>        <span class="hljs-built_in">CopyIn1</span>(); </li><li>        <span class="hljs-built_in">Compute1</span>(); </li><li>        <span class="hljs-built_in">CopyOut1</span>(); </li><li>        tbufPool2.<span class="hljs-built_in">Reset</span>(); </li><li>    } </li><li><span class="hljs-keyword">private</span>: </li><li>    <span class="hljs-function">__aicore__ <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">CopyIn</span><span class="hljs-params">()</span> </span></li><li><span class="hljs-function">    </span>{ </li><li>        AscendC::LocalTensor&lt;half&gt; src0Local = queSrc0.<span class="hljs-built_in">AllocTensor</span>&lt;half&gt;(); </li><li>        AscendC::LocalTensor&lt;half&gt; src1Local = queSrc1.<span class="hljs-built_in">AllocTensor</span>&lt;half&gt;(); </li><li>        AscendC::<span class="hljs-built_in">DataCopy</span>(src0Local, src0Global, <span class="hljs-number">512</span>); </li><li>        AscendC::<span class="hljs-built_in">DataCopy</span>(src1Local, src1Global, <span class="hljs-number">512</span>); </li><li>        queSrc0.<span class="hljs-built_in">EnQue</span>(src0Local); </li><li>        queSrc1.<span class="hljs-built_in">EnQue</span>(src1Local); </li><li>    } </li><li>    <span class="hljs-function">__aicore__ <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Compute</span><span class="hljs-params">()</span> </span></li><li><span class="hljs-function">    </span>{ </li><li>        AscendC::LocalTensor&lt;half&gt; src0Local = queSrc0.<span class="hljs-built_in">DeQue</span>&lt;half&gt;(); </li><li>        AscendC::LocalTensor&lt;half&gt; src1Local = queSrc1.<span class="hljs-built_in">DeQue</span>&lt;half&gt;(); </li><li>        AscendC::LocalTensor&lt;half&gt; dstLocal = queDst0.<span class="hljs-built_in">AllocTensor</span>&lt;half&gt;(); </li><li>        AscendC::<span class="hljs-built_in">Add</span>(dstLocal, src0Local, src1Local, <span class="hljs-number">512</span>); </li><li>        queDst0.<span class="hljs-built_in">EnQue</span>&lt;half&gt;(dstLocal); </li><li>        queSrc0.<span class="hljs-built_in">FreeTensor</span>(src0Local); </li><li>        queSrc1.<span class="hljs-built_in">FreeTensor</span>(src1Local); </li><li>    } </li><li>    <span class="hljs-function">__aicore__ <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">CopyOut</span><span class="hljs-params">()</span> </span></li><li><span class="hljs-function">    </span>{ </li><li>        AscendC::LocalTensor&lt;half&gt; dstLocal = queDst0.<span class="hljs-built_in">DeQue</span>&lt;half&gt;(); </li><li>        AscendC::<span class="hljs-built_in">DataCopy</span>(dstGlobal, dstLocal, <span class="hljs-number">512</span>); </li><li>        queDst0.<span class="hljs-built_in">FreeTensor</span>(dstLocal); </li><li>    } </li><li>    <span class="hljs-function">__aicore__ <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">CopyIn1</span><span class="hljs-params">()</span> </span></li><li><span class="hljs-function">    </span>{ </li><li>        AscendC::LocalTensor&lt;half&gt; src0Local = queSrc2.<span class="hljs-built_in">AllocTensor</span>&lt;half&gt;(); </li><li>        AscendC::LocalTensor&lt;half&gt; src1Local = queSrc3.<span class="hljs-built_in">AllocTensor</span>&lt;half&gt;(); </li><li>        AscendC::<span class="hljs-built_in">DataCopy</span>(src0Local, src0Global, <span class="hljs-number">512</span>); </li><li>        AscendC::<span class="hljs-built_in">DataCopy</span>(src1Local, src1Global, <span class="hljs-number">512</span>); </li><li>        queSrc2.<span class="hljs-built_in">EnQue</span>(src0Local); </li><li>        queSrc3.<span class="hljs-built_in">EnQue</span>(src1Local); </li><li>    } </li><li>    <span class="hljs-function">__aicore__ <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Compute1</span><span class="hljs-params">()</span> </span></li><li><span class="hljs-function">    </span>{ </li><li>        AscendC::LocalTensor&lt;half&gt; src0Local = queSrc2.<span class="hljs-built_in">DeQue</span>&lt;half&gt;(); </li><li>        AscendC::LocalTensor&lt;half&gt; src1Local = queSrc3.<span class="hljs-built_in">DeQue</span>&lt;half&gt;(); </li><li>        AscendC::LocalTensor&lt;half&gt; dstLocal = queDst1.<span class="hljs-built_in">AllocTensor</span>&lt;half&gt;(); </li><li>        AscendC::<span class="hljs-built_in">Add</span>(dstLocal, src0Local, src1Local, <span class="hljs-number">512</span>); </li><li>        queDst1.<span class="hljs-built_in">EnQue</span>&lt;half&gt;(dstLocal); </li><li>        queSrc2.<span class="hljs-built_in">FreeTensor</span>(src0Local); </li><li>        queSrc3.<span class="hljs-built_in">FreeTensor</span>(src1Local); </li><li>    } </li><li>    <span class="hljs-function">__aicore__ <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">CopyOut1</span><span class="hljs-params">()</span> </span></li><li><span class="hljs-function">    </span>{ </li><li>        AscendC::LocalTensor&lt;half&gt; dstLocal = queDst1.<span class="hljs-built_in">DeQue</span>&lt;half&gt;(); </li><li>        AscendC::<span class="hljs-built_in">DataCopy</span>(dstGlobal, dstLocal, <span class="hljs-number">512</span>); </li><li>        queDst1.<span class="hljs-built_in">FreeTensor</span>(dstLocal); </li><li>    } </li><li><span class="hljs-keyword">private</span>: </li><li>    AscendC::TPipe pipe; </li><li>    AscendC::TBufPool&lt;AscendC::TPosition::VECCALC&gt; tbufPool1, tbufPool2; </li><li>    AscendC::TQue&lt;AscendC::QuePosition::VECIN, <span class="hljs-number">1</span>&gt; queSrc0, queSrc1, queSrc2, queSrc3; </li><li>    AscendC::TQue&lt;AscendC::QuePosition::VECOUT, <span class="hljs-number">1</span>&gt; queDst0, queDst1; </li><li>    AscendC::GlobalTensor&lt;half&gt; src0Global, src1Global, dstGlobal; </li><li>}; </li><li><span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> <span class="hljs-function">__global__ __aicore__ <span class="hljs-type">void</span> <span class="hljs-title">tbufpool_kernel</span><span class="hljs-params">(__gm__ <span class="hljs-type">uint8_t</span>* </span></span><em><span class="hljs-function"><span class="hljs-params">src0Gm</span></span></em><span class="hljs-function"><span class="hljs-params">, __gm__ <span class="hljs-type">uint8_t</span>* </span></span><em><span class="hljs-function"><span class="hljs-params">src1Gm</span></span></em><span class="hljs-function"><span class="hljs-params">, __gm__ <span class="hljs-type">uint8_t</span>* </span></span><em><span class="hljs-function"><span class="hljs-params">dstGm</span></span></em><span class="hljs-function"><span class="hljs-params">)</span> </span></li><li><span class="hljs-function"></span>{ </li><li>    ResetApi op; </li><li>    op.<span class="hljs-built_in">Init</span>(<em>src0Gm</em>, <em>src1Gm</em>, <em>dstGm</em>); </li><li>    op.<span class="hljs-built_in">Process</span>(); </li><li>}</li></ol></pre></div></div> </div> </div> <div></div></div>