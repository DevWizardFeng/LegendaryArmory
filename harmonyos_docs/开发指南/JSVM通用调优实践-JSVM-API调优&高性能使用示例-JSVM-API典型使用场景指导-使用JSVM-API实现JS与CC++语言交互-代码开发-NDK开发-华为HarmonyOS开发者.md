<h1 _ngcontent-fhy-c119="" class="doc-title ng-star-inserted" title="JSVM通用调优实践"> JSVM通用调优实践 </h1>

<div _ngcontent-fhy-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;"> <div> <div class="tiledSection"><h2 id="jsvm调用结构">JSVM调用结构<i class="anchor-icon anchor-icon-link" anchorid="jsvm调用结构" tips="复制节点链接"></i></h2><p>小程序使用JSVM执行JS代码的过程大概可以分为 Native，JSVM-API，JSVM 三层：</p> <ul><li>Native：小程序运行JS的逻辑层，使用JSVM提供的接口完成JS代码编译，运行，code cache生成等操作的逻辑排布和组合</li><li>JSVM-API：连接native和v8的接口兼容层，保持对不同版本JS引擎的兼容，提供JS引擎标准化的使用实践</li><li>JSVM：JS引擎层，负责JS代码实际的编译运行</li></ul> <p>使用JSVM的过程中，可能会因为多种原因产生不必要的开销，导致启动速度变慢。可以从以下三个层面进行分析。</p> </div>  <div class="tiledSection"><h2 id="提升启动速度">提升启动速度<i class="anchor-icon anchor-icon-link" anchorid="提升启动速度" tips="复制节点链接"></i></h2><p>对于使用JSVM的应用启动场景，我们可以区分冷热启动用于分别进行不同的优化。</p> <p>首先是冷启动，是没有任何profile或者cache可以用于优化的场景，通常是首次启动；</p> <p>热启动则是已经充分预热，在多次启动之后获取了足量用于优化的cache的场景。</p> </div>  <div class="tiledSection"><h3 id="减少-js-引擎层的开销" class="firsth2">减少 JS 引擎层的开销<i class="anchor-icon anchor-icon-link" anchorid="减少-js-引擎层的开销" tips="复制节点链接"></i></h3><p>引擎层的开销很大程度上来源于编译。通过合理调整调用JSVM-API时传入的选项，可以降低主线程上JS引擎的编译开销。</p> <p>以下面的编译接口为例，其中eagerCompile这个参数的开关可以调控编译行为，通过在不同的启动场景打开这个选项可以实现优化效果。</p> <div _ngcontent-fhy-c106="" class="highlight-div"><div _ngcontent-fhy-c106="" class="highlight-div-header"><div _ngcontent-fhy-c106="" class="highlight-div-header-left"><div _ngcontent-fhy-c106="" class="handle-button expand-button"><div _ngcontent-fhy-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-fhy-c106="" class="highlight-div-header-right"><div _ngcontent-fhy-c106="" class="handle-button ai-button"></div><div _ngcontent-fhy-c106="" class="handle-button line-button"><div _ngcontent-fhy-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-fhy-c106="" class="handle-button theme-button"><div _ngcontent-fhy-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-fhy-c106="" class="handle-button copy-button"><div _ngcontent-fhy-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-fhy-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">/**</span></li><li><span class="hljs-comment"> * ...</span></li><li><span class="hljs-comment"> * @param eagerCompile: Whether to compile the script eagerly.</span></li><li><span class="hljs-comment"> * ...</span></li><li><span class="hljs-comment"> */</span></li><li><span class="hljs-function">JSVM_EXTERN JSVM_Status <span class="hljs-title">OH_JSVM_CompileScript</span><span class="hljs-params">(JSVM_Env env,</span></span></li><li><span class="hljs-function">                                              JSVM_Value script,</span></li><li><span class="hljs-function">                                              <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span>* cachedData,</span></li><li><span class="hljs-function">                                              <span class="hljs-type">size_t</span> cacheDataLength,</span></li><li><span class="hljs-function">                                              <span class="hljs-type">bool</span> eagerCompile, <span class="hljs-comment">// 开启全量编译</span></span></li><li><span class="hljs-function">                                              <span class="hljs-type">bool</span>* cacheRejected,</span></li><li><span class="hljs-function">                                              JSVM_Script* result)</span>;</li></ol></pre></div></div> <p>同时，code cache的生成和使用也会对编译产生影响，这部分可以参考 <a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/use-jsvm-about-code-cache">使用code cache加速编译</a>。</p> <p><strong>热启动：生成足够多的code cache</strong></p> <p>热启动场景下，我们会在热启动前生成code cache以减少编译带来的开销。这个时候生成的code cache的覆盖率会影响code cache对热启动的优化效果。</p> <p>有一个简单的策略可以生成足够的code cache：在生成code cache之前的那次编译中，打开eager compile选项。这样，V8会在编译时进行全量编译，确保生成的code cache是全量的。</p> <p>这个方法会增加额外的编译时间开销，可能影响冷启动时间。后续将详细讨论native层的冷启动优化方法。</p> <p><strong>冷启动：使用lazy compile代替eager compile</strong></p> <p>在冷启动时，eager compile会增加不必要的编译时间。这其中主要的原因是没有拿到v8 lazy compile优化效果：v8会将不在必经路径上的函数推迟编译，在实际运行到的时候才进行编译，这样会减少一些不被运行到函数的编译，从而优化冷启动的时间。</p> <p>因此，在冷启动时，可以通过关闭eager compile选项来避免阻塞主线程，从而获得足够的冷启动优化效果。</p> </div>  <div class="tiledSection"><h3 id="在native层减少时间开销">在native层减少时间开销<i class="anchor-icon anchor-icon-link" anchorid="在native层减少时间开销" tips="复制节点链接"></i></h3><p><strong>冷启动：减少code cache的影响</strong></p> <p>上面在考虑减少v8层开销的时候，提到了为了热启动的性能可以开启eager compile进行编译，而为了冷启动性能却又需要关闭eager compile选项，看起来是矛盾的。为了解决这个矛盾，避免在冷热启动性能上的权衡，关键点是在code cache生成本身。</p> <p>首先，生成code cache需要进行前置编译，其次，生成code cache本身也会产生开销。</p> <p>在native层，要解决冷启动与生成code cache之间的矛盾，可以另起一个线程用于生成code cache，这样可以避免生成code cache操作对冷启动的影响。</p> <p>有两个方法可以参考（以下伪代码仅用于展示逻辑流程，不涉及实际的API调用）：</p> <ul><li>将生成code cache必需的前置编译也放到新增的线程上，这样编译选项可以分开使用：生成code cache打开eager compile，冷启动运行则关闭，这样做的缺点是可能进一步提高运行时的峰值资源占用，优点是code cache生成和运行可以完全解耦，不再需要考虑生成code cache的时间点。该流程的伪代码如下所示</li></ul> <div _ngcontent-fhy-c106="" class="highlight-div"><div _ngcontent-fhy-c106="" class="highlight-div-header"><div _ngcontent-fhy-c106="" class="highlight-div-header-left"><div _ngcontent-fhy-c106="" class="handle-button expand-button"><div _ngcontent-fhy-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-fhy-c106="" class="highlight-div-header-right"><div _ngcontent-fhy-c106="" class="handle-button ai-button"></div><div _ngcontent-fhy-c106="" class="handle-button line-button"><div _ngcontent-fhy-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-fhy-c106="" class="handle-button theme-button"><div _ngcontent-fhy-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-fhy-c106="" class="handle-button copy-button"><div _ngcontent-fhy-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-fhy-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-scss" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-built_in">async_create_code_cache</span>() {</li><li>  <span class="hljs-built_in">compile_with_eager_compile</span>();</li><li>  <span class="hljs-built_in">create_code_cache</span>();</li><li>  <span class="hljs-built_in">save_code_cache</span>();</li><li>}</li><li>
</li><li>...</li><li>
</li><li>if (has_code_cache) {</li><li>  <span class="hljs-built_in">evaluate_script_with_code_cache</span>();</li><li>} else {</li><li>  <span class="hljs-built_in">start_thread</span>(async_create_code_cache());</li><li>  <span class="hljs-built_in">evaluate_script_without_code_cache</span>();</li><li>}</li></ol></pre></div></div> <ul><li>在启动过程中的所有路径运行完之后，再启动新线程生成code cache，这样不必使用eager compile也能获取足量的code cache，同时保证热启动性能不受影响，这样做的缺点是生成code cache的时间点受限，优点是峰值资源占用相对更少，且不必生成过量的code cache导致io变慢。这个流程可以用如下所示的伪代码来表示</li></ul> <div _ngcontent-fhy-c106="" class="highlight-div"><div _ngcontent-fhy-c106="" class="highlight-div-header"><div _ngcontent-fhy-c106="" class="highlight-div-header-left"><div _ngcontent-fhy-c106="" class="handle-button expand-button"><div _ngcontent-fhy-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-fhy-c106="" class="highlight-div-header-right"><div _ngcontent-fhy-c106="" class="handle-button ai-button"></div><div _ngcontent-fhy-c106="" class="handle-button line-button"><div _ngcontent-fhy-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-fhy-c106="" class="handle-button theme-button"><div _ngcontent-fhy-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-fhy-c106="" class="handle-button copy-button"><div _ngcontent-fhy-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-fhy-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-scss" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-built_in">async_create_code_cache</span>() {</li><li>  <span class="hljs-built_in">compile_with_out_eager_compile</span>();</li><li>  <span class="hljs-built_in">create_code_cache</span>();</li><li>  <span class="hljs-built_in">save_code_cache</span>();</li><li>}</li><li>
</li><li>...</li><li>
</li><li>if (has_code_cache) {</li><li>  <span class="hljs-built_in">evaluate_script_with_code_cache</span>();</li><li>} else {</li><li>  <span class="hljs-built_in">evaluate_script_without_code_cache</span>();</li><li>}</li><li>
</li><li>...</li><li>
</li><li>if (script_run_completed) {</li><li>  <span class="hljs-built_in">start_thread</span>(async_create_code_cache());</li><li>}</li></ol></pre></div></div> </div>  <div class="tiledSection"><h3 id="使用更高效的jsvm-api">使用更高效的JSVM-API<i class="anchor-icon anchor-icon-link" anchorid="使用更高效的jsvm-api" tips="复制节点链接"></i></h3><p>在能达到相同效果时，使用更高效的JSVM-API是一种有效的性能优化方法，以下是一些具体的实践示例。</p> <p><strong>使用IsXXX代替TypeOf</strong></p> <p>过去发现，针对仅需要判断对象类型的场景，存在一种相对低效的使用方法：</p> <p>从OH_JSVM_TypeOf接口获取类型后，再判断是否与某个类型相同。</p> <p>这种方法需要先查询object的类型，这种方法相对于直接使用is方法会更慢，因此我们新增了针对基础类型的IsXXX系列方法，用更高效的接口代替了相对低效的接口。下面的示例中使用到的JSVM-API可以参考 <a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/jsvm-data-types-interfaces">JSVM数据类型与接口说明</a>，这里仅展示调用的步骤。</p> <ul><li>低效用例</li></ul> <div _ngcontent-fhy-c106="" class="highlight-div"><div _ngcontent-fhy-c106="" class="highlight-div-header"><div _ngcontent-fhy-c106="" class="highlight-div-header-left"><div _ngcontent-fhy-c106="" class="handle-button expand-button"><div _ngcontent-fhy-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-fhy-c106="" class="highlight-div-header-right"><div _ngcontent-fhy-c106="" class="handle-button ai-button"></div><div _ngcontent-fhy-c106="" class="handle-button line-button"><div _ngcontent-fhy-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-fhy-c106="" class="handle-button theme-button"><div _ngcontent-fhy-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-fhy-c106="" class="handle-button copy-button"><div _ngcontent-fhy-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-fhy-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Test::IsFunction</span><span class="hljs-params">(JSVM_Env env, JSVM_Value jsvmValue)</span> <span class="hljs-type">const</span> </span>{</li><li>    <span class="hljs-comment">// type judgment</span></li><li>    JSVM_ValueType valueType;</li><li>    <span class="hljs-built_in">OH_JSVM_TypeOf</span>(*env, jsvmValue, &amp;valueType);</li><li>    <span class="hljs-keyword">return</span> valueType == JSVM_FUNCTION;</li><li>}</li></ol></pre></div></div> <ul><li>高效用例</li></ul> <div _ngcontent-fhy-c106="" class="highlight-div"><div _ngcontent-fhy-c106="" class="highlight-div-header"><div _ngcontent-fhy-c106="" class="highlight-div-header-left"><div _ngcontent-fhy-c106="" class="handle-button expand-button"><div _ngcontent-fhy-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-fhy-c106="" class="highlight-div-header-right"><div _ngcontent-fhy-c106="" class="handle-button ai-button"></div><div _ngcontent-fhy-c106="" class="handle-button line-button"><div _ngcontent-fhy-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-fhy-c106="" class="handle-button theme-button"><div _ngcontent-fhy-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-fhy-c106="" class="handle-button copy-button"><div _ngcontent-fhy-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-fhy-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Test::IsFunction</span><span class="hljs-params">(JSVM_Env env, JSVM_Value jsvmValue)</span> <span class="hljs-type">const</span> </span>{</li><li>    <span class="hljs-comment">// type judgment</span></li><li>    <span class="hljs-type">bool</span> result = <span class="hljs-literal">false</span>;</li><li>    <span class="hljs-built_in">OH_JSVM_IsFunction</span>(*env, jsvmValue, &amp;result); <span class="hljs-comment">// 可直接判断是否为Function类型</span></li><li>    <span class="hljs-keyword">return</span> result;</li><li>}</li></ol></pre></div></div> <p>以某生态应用小程序场景为例，这个优化可以带来的性能收益端到端有150ms，总占比约5%。</p> <p><strong>直接使用OH_JSVM_CreateReference，避免创建冗余的object</strong></p> <p>过去存在这样一种创建reference的路径：</p> <p>创建一个新的object-&gt;设置object的值-&gt;创建object的reference。</p> <p>在已有值的情况下，直接创建值的引用即可。</p> <p>下面的示例中使用的JSVM-API可以参考 <a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/jsvm-data-types-interfaces">JSVM数据类型与接口说明</a>，这里仅展示调用的步骤。</p> <ul><li>低效用例</li></ul> <div _ngcontent-fhy-c106="" class="highlight-div"><div _ngcontent-fhy-c106="" class="highlight-div-header"><div _ngcontent-fhy-c106="" class="highlight-div-header-left"><div _ngcontent-fhy-c106="" class="handle-button expand-button"><div _ngcontent-fhy-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-fhy-c106="" class="highlight-div-header-right"><div _ngcontent-fhy-c106="" class="handle-button ai-button"></div><div _ngcontent-fhy-c106="" class="handle-button line-button"><div _ngcontent-fhy-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-fhy-c106="" class="handle-button theme-button"><div _ngcontent-fhy-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-fhy-c106="" class="handle-button copy-button"><div _ngcontent-fhy-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-fhy-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// (1) open handle scope</span></li><li>JSVM_HandleScope scope;</li><li><span class="hljs-built_in">OH_JSVM_OpenHandleScope</span>(*env, &amp;scope);</li><li><span class="hljs-comment">// (2) get JSVM_Value</span></li><li>JSVM_Value jsvmValue;</li><li><span class="hljs-built_in">OH_JSVM_GetNull</span>(*env, &amp;jsvmValue);</li><li><span class="hljs-comment">// (3) create and store Reference for JSVM_Value</span></li><li>JSVM_Value wrappingObject;</li><li><span class="hljs-built_in">OH_JSVM_CreateObject</span>(*env, &amp;wrappingObject);</li><li><span class="hljs-built_in">OH_JSVM_SetElement</span>(*env, wrappingObject, <span class="hljs-number">1</span>, jsvmValue);</li><li><span class="hljs-built_in">OH_JSVM_CreateReference</span>(*env, wrappingObject, <span class="hljs-number">1</span>, &amp;result-&gt;p_member-&gt;jsvmRef);</li><li><span class="hljs-comment">// (4) close handle scope</span></li><li><span class="hljs-built_in">OH_JSVM_CloseHandleScope</span>(*env, scope);</li></ol></pre></div></div> <ul><li>高效用例</li></ul> <div _ngcontent-fhy-c106="" class="highlight-div"><div _ngcontent-fhy-c106="" class="highlight-div-header"><div _ngcontent-fhy-c106="" class="highlight-div-header-left"><div _ngcontent-fhy-c106="" class="handle-button expand-button"><div _ngcontent-fhy-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-fhy-c106="" class="highlight-div-header-right"><div _ngcontent-fhy-c106="" class="handle-button ai-button"></div><div _ngcontent-fhy-c106="" class="handle-button line-button"><div _ngcontent-fhy-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-fhy-c106="" class="handle-button theme-button"><div _ngcontent-fhy-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-fhy-c106="" class="handle-button copy-button"><div _ngcontent-fhy-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-fhy-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// (1) open handle scope</span></li><li>JSVM_HandleScope scope;</li><li><span class="hljs-built_in">OH_JSVM_OpenHandleScope</span>(*env, &amp;scope);</li><li><span class="hljs-comment">// (2) get JSVM_Value</span></li><li>JSVM_Value jsvmValue;</li><li><span class="hljs-built_in">OH_JSVM_GetNull</span>(*env, &amp;jsvmValue);</li><li><span class="hljs-comment">// (3) create and store Reference for JSVM_Value</span></li><li><span class="hljs-built_in">OH_JSVM_CreateReference</span>(*env, jsvmValue, <span class="hljs-number">1</span>, &amp;result-&gt;p_member-&gt;jsvmRef); <span class="hljs-comment">// 可从任意对象类型直接创建Reference，代码更为简洁高效</span></li><li><span class="hljs-comment">// (4) close handle scope</span></li><li><span class="hljs-built_in">OH_JSVM_CloseHandleScope</span>(*env, scope);</li></ol></pre></div></div> <p>同样以某生态应用小程序场景为例，这个改动减少了大量冗余的接口调用，最终带来的端到端时间收益有100+ms，约3%。</p> </div> </div> <div></div></div>