<h1 _ngcontent-aqd-c119="" class="doc-title ng-star-inserted" title="LocalTensor"> LocalTensor </h1>

<div _ngcontent-aqd-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;"> <div><div class="tiledSection"><h2 id="section8364mcpsimp">功能说明<i class="anchor-icon anchor-icon-link" anchorid="section8364mcpsimp" tips="复制节点链接"></i></h2><p>用于存放AI Core中Local Memory（内部存储）的数据，支持QuePosition为VECIN、VECOUT、VECCALC、A1、A2、B1、B2、CO1、CO2。</p> </div> <div class="tiledSection"><h2 id="section8367mcpsimp">定义原型<i class="anchor-icon anchor-icon-link" anchorid="section8367mcpsimp" tips="复制节点链接"></i></h2><div _ngcontent-aqd-c106="" class="highlight-div"><div _ngcontent-aqd-c106="" class="highlight-div-header"><div _ngcontent-aqd-c106="" class="highlight-div-header-left"><div _ngcontent-aqd-c106="" class="handle-button expand-button"><div _ngcontent-aqd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-aqd-c106="" class="highlight-div-header-right"><div _ngcontent-aqd-c106="" class="handle-button ai-button"></div><div _ngcontent-aqd-c106="" class="handle-button line-button"><div _ngcontent-aqd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-aqd-c106="" class="handle-button theme-button"><div _ngcontent-aqd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-aqd-c106="" class="handle-button copy-button"><div _ngcontent-aqd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-aqd-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalTensor</span> : <span class="hljs-keyword">public</span> BaseLocalTensor&lt;T&gt; { </li><li><span class="hljs-keyword">public</span>: </li><li>    <span class="hljs-keyword">using</span> PrimType = PrimT&lt;T&gt;; </li><li>    __aicore__ <span class="hljs-keyword">inline</span> <span class="hljs-built_in">LocalTensor</span>&lt;T&gt;() {}; </li><li><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(ASCENDC_CPU_DEBUG) &amp;&amp; ASCENDC_CPU_DEBUG == 1 </span></li><li>    ~<span class="hljs-built_in">LocalTensor</span>(); </li><li>    <span class="hljs-keyword">explicit</span> <span class="hljs-built_in">LocalTensor</span>&lt;T&gt;(TBuffAddr&amp; address); </li><li>    <span class="hljs-built_in">LocalTensor</span>&lt;T&gt;(<span class="hljs-type">const</span> LocalTensor&lt;T&gt;&amp; other); </li><li>    LocalTensor&lt;T&gt; <span class="hljs-keyword">operator</span> = (<span class="hljs-type">const</span> LocalTensor&lt;T&gt;&amp; other); </li><li>    <span class="hljs-function">PrimType* <span class="hljs-title">GetPhyAddr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> offset)</span> <span class="hljs-type">const</span></span>; </li><li>    <span class="hljs-function">PrimType* <span class="hljs-title">GetPhyAddr</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; </li><li>    __inout_pipe__(S) <span class="hljs-function">PrimType <span class="hljs-title">GetValue</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> offset)</span> <span class="hljs-type">const</span></span>; </li><li>    __inout_pipe__(S) <span class="hljs-function">PrimType&amp; <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> offset)</span> <span class="hljs-type">const</span></span>; </li><li>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> CAST_T&gt; <span class="hljs-function">__aicore__ <span class="hljs-keyword">inline</span> LocalTensor&lt;CAST_T&gt; <span class="hljs-title">ReinterpretCast</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; </li><li>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1&gt; __inout_pipe__(S) <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetValue</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> index, <span class="hljs-type">const</span> T1 value)</span> <span class="hljs-type">const</span></span>; </li><li>    LocalTensor <span class="hljs-keyword">operator</span>[](<span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> offset) <span class="hljs-type">const</span>; </li><li>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1&gt; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetAddrWithOffset</span><span class="hljs-params">(LocalTensor&lt;T1&gt; &amp;src, <span class="hljs-type">uint32_t</span> offset)</span></span>; </li><li>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span>; </li><li>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> len)</span></span>; </li><li>    <span class="hljs-function"><span class="hljs-type">int32_t</span> <span class="hljs-title">ToFile</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; fileName)</span> <span class="hljs-type">const</span></span>; </li><li><span class="hljs-meta">#<span class="hljs-keyword">else</span> </span></li><li>    <span class="hljs-function">__aicore__ <span class="hljs-keyword">inline</span> <span class="hljs-type">uint64_t</span> <span class="hljs-title">GetPhyAddr</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; </li><li>    <span class="hljs-function">__aicore__ <span class="hljs-keyword">inline</span> <span class="hljs-type">uint64_t</span> <span class="hljs-title">GetPhyAddr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> offset)</span> <span class="hljs-type">const</span></span>; </li><li>    __aicore__ <span class="hljs-keyword">inline</span> __inout_pipe__(S) <span class="hljs-function">PrimType <span class="hljs-title">GetValue</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> index)</span> <span class="hljs-type">const</span></span>; </li><li>    __aicore__ <span class="hljs-keyword">inline</span> __inout_pipe__(S) <span class="hljs-function">__ubuf__ PrimType&amp; <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> offset)</span> <span class="hljs-type">const</span></span>; </li><li>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> CAST_T&gt; <span class="hljs-function">__aicore__ <span class="hljs-keyword">inline</span> LocalTensor&lt;CAST_T&gt; <span class="hljs-title">ReinterpretCast</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; </li><li>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1&gt; __aicore__ <span class="hljs-keyword">inline</span> __inout_pipe__(S) </li><li>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetValue</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> index, <span class="hljs-type">const</span> T1 value)</span> <span class="hljs-type">const</span></span>; </li><li>    __aicore__ <span class="hljs-keyword">inline</span> LocalTensor <span class="hljs-keyword">operator</span>[](<span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> offset) <span class="hljs-type">const</span>; </li><li>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1&gt; </li><li>    [[<span class="hljs-built_in">deprecated</span>(<span class="hljs-string">"NOTICE: SetAddrWithOffset has been deprecated and will be removed in the next version. "</span> </li><li>        <span class="hljs-string">"Please do not use it!"</span>)]] </li><li>    <span class="hljs-function">__aicore__ <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">SetAddrWithOffset</span><span class="hljs-params">(LocalTensor&lt;T1&gt; &amp;src, <span class="hljs-type">uint32_t</span> offset)</span></span>; </li><li><span class="hljs-meta">#<span class="hljs-keyword">endif</span> </span></li><li>    <span class="hljs-function">__aicore__ <span class="hljs-keyword">inline</span> <span class="hljs-type">int32_t</span> <span class="hljs-title">GetPosition</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; </li><li>    <span class="hljs-function">__aicore__ <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">SetSize</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> size)</span></span>; </li><li>    <span class="hljs-function">__aicore__ <span class="hljs-keyword">inline</span> <span class="hljs-type">uint32_t</span> <span class="hljs-title">GetSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; </li><li>    [[<span class="hljs-built_in">deprecated</span>(<span class="hljs-string">"NOTICE: GetLength has been deprecated and will be removed in the next version. Please do not use "</span> </li><li>                 <span class="hljs-string">"it!"</span>)]] </li><li>    <span class="hljs-function">__aicore__ <span class="hljs-keyword">inline</span> <span class="hljs-type">uint32_t</span> <span class="hljs-title">GetLength</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; </li><li>    [[<span class="hljs-built_in">deprecated</span>(<span class="hljs-string">"NOTICE: SetBufferLen has been deprecated and will be removed in the next version. Please do not use "</span> </li><li>                 <span class="hljs-string">"it!"</span>)]] </li><li>    <span class="hljs-function">__aicore__ <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">SetBufferLen</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> dataLen)</span></span>; </li><li>    <span class="hljs-function">__aicore__ <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">SetUserTag</span><span class="hljs-params">(<span class="hljs-type">const</span> TTagType tag)</span></span>; </li><li>    <span class="hljs-function">__aicore__ <span class="hljs-keyword">inline</span> TTagType <span class="hljs-title">GetUserTag</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; </li><li>    <span class="hljs-comment">// ... </span></li><li>    <span class="hljs-function">__aicore__ <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">SetShapeInfo</span><span class="hljs-params">(<span class="hljs-type">const</span> ShapeInfo&amp; shapeInfo)</span></span>; </li><li>    <span class="hljs-function">__aicore__ <span class="hljs-keyword">inline</span> ShapeInfo <span class="hljs-title">GetShapeInfo</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; </li><li>    <span class="hljs-comment">// ... </span></li><li>};</li></ol></pre></div></div> </div> <div class="tiledSection"><h2 id="section8370mcpsimp">函数说明<i class="anchor-icon anchor-icon-link" anchorid="section8370mcpsimp" tips="复制节点链接"></i></h2><p>类型T支持基础数据类型，但需要遵循使用此LocalTensor的指令的数据类型支持情况。</p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><caption><b>表1 </b>函数说明</caption><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.3.3.2.4.1.1" valign="top" width="15.15%"><p>函数名称</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.3.3.2.4.1.2" valign="top" width="21.21%"><p>入参说明</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.3.3.2.4.1.3" valign="top" width="63.63999999999999%"><p>含义</p> </th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="15.15%"><p>GetValue</p> </td> <td class="cellrowborder" valign="top" width="21.21%"><p>offset：偏移量，单位为'element'</p> </td> <td class="cellrowborder" valign="top" width="63.63999999999999%"><p>获取LocalTensor中的某个值，返回PrimType类型的数值。</p> <p><strong>该接口仅在LocalTensor的TPosition为VECIN/VECCALC/VECOUT时支持。</strong></p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="15.15%"><p>SetValue</p> </td> <td class="cellrowborder" valign="top" width="21.21%"><p>offset：偏移值，单位为'element'</p> <p>value：设置值，单位为任意类型</p> </td> <td class="cellrowborder" valign="top" width="63.63999999999999%"><p>设置LocalTensor中的某个值。</p> <p><strong>该接口仅在LocalTensor的TPosition为VECIN/VECCALC/VECOUT时支持。</strong></p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="15.15%"><p>operator[]</p> </td> <td class="cellrowborder" valign="top" width="21.21%"><p>offset：偏移量</p> </td> <td class="cellrowborder" valign="top" width="63.63999999999999%"><p>获取距原LocalTensor起始地址偏移量为offset的新LocalTensor，注意offset不能超过原有LocalTensor的size大小。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="15.15%"><p>operator()</p> </td> <td class="cellrowborder" valign="top" width="21.21%"><p>offset:  下标索引</p> </td> <td class="cellrowborder" valign="top" width="63.63999999999999%"><p>获取本LocalTensor的第offset个变量的引用。用于左值，相当于SetValue接口，用于右值，相当于GetValue接口。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="15.15%"><p>GetSize</p> </td> <td class="cellrowborder" valign="top" width="21.21%"><p>无</p> </td> <td class="cellrowborder" valign="top" width="63.63999999999999%"><p>获取当前LocalTensor size大小。单位为元素。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="15.15%"><p>SetSize</p> </td> <td class="cellrowborder" valign="top" width="21.21%"><p>size：元素个数，单位为'element'</p> </td> <td class="cellrowborder" valign="top" width="63.63999999999999%"><p>设置当前LocalTensor size大小。单位为元素。当开发者重用local tensor变量且使用长度发生变化的时候，需要使用此接口重新设置Size。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="15.15%"><p>SetUserTag</p> </td> <td class="cellrowborder" valign="top" width="21.21%"><p>tag：设置的Tag信息，类型TTagType对应为int32_t</p> </td> <td class="cellrowborder" valign="top" width="63.63999999999999%"><p>为Tensor添加开发者自定义信息，开发者可以根据需要设置对应的Tag。后续可通过GetUserTag获取指定Tensor的Tag信息，并根据Tag信息对Tensor进行相应操作。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="15.15%"><p>GetUserTag</p> </td> <td class="cellrowborder" valign="top" width="21.21%"><p>-</p> </td> <td class="cellrowborder" valign="top" width="63.63999999999999%"><p>获取指定Tensor块的Tag信息，开发者可以根据Tag信息对Tensor进行不同操作。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="15.15%"><p>ReinterpretCast</p> </td> <td class="cellrowborder" valign="top" width="21.21%"><p>-</p> </td> <td class="cellrowborder" valign="top" width="63.63999999999999%"><p>将当前Tensor重解释为开发者指定的新类型，转换后的Tensor与原Tensor地址及内容完全相同，Tensor的大小(字节数)保持不变。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="15.15%"><p>GetPhyAddr</p> </td> <td class="cellrowborder" valign="top" width="21.21%"><p>-</p> </td> <td class="cellrowborder" valign="top" width="63.63999999999999%"><p>返回LocalTensor的地址，如果传入offset，则表示偏移offset个元素。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="15.15%"><p>GetPosition</p> </td> <td class="cellrowborder" valign="top" width="21.21%"><p>-</p> </td> <td class="cellrowborder" valign="top" width="63.63999999999999%"><p>获取QuePosition抽象的逻辑位置，支持QuePosition为VECIN、VECOUT、VECCALC、A1、A2、B1、B2、CO1、CO2。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="15.15%"><p>GetLength</p> </td> <td class="cellrowborder" valign="top" width="21.21%"><p>无</p> </td> <td class="cellrowborder" valign="top" width="63.63999999999999%"><p>获取LocalTensor数据长度，单位为Byte。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="15.15%"><p>SetShapeInfo</p> </td> <td class="cellrowborder" valign="top" width="21.21%"><p>shapeInfo：ShapeInfo结构体</p> </td> <td class="cellrowborder" valign="top" width="63.63999999999999%"><p>设置LocalTensor的shapeInfo。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="15.15%"><p>GetShapeInfo</p> </td> <td class="cellrowborder" valign="top" width="21.21%"><p>无</p> </td> <td class="cellrowborder" valign="top" width="63.63999999999999%"><p>获取LocalTensor的shapeInfo。</p> <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"><p>Shape信息没有默认值，只有通过SetShapeInfo设置过Shape信息后，才可以调用该接口获取正确的ShapeInfo。</p> </div></div></div> </td> </tr> <tr><td class="cellrowborder" valign="top" width="15.15%"><p>SetAddrWithOffset</p> </td> <td class="cellrowborder" valign="top" width="21.21%"><p>src：基础地址的Tensor，将该Tensor的地址作为基础地址，设置偏移后的Tensor地址</p> <p>offset：偏移的长度</p> </td> <td class="cellrowborder" valign="top" width="63.63999999999999%"><p>设置带有偏移的Tensor地址。用于快速获取定义一个Tensor，同时指定新Tensor相对于旧Tensor首地址的偏移。偏移的长度为旧Tensor的元素个数。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="15.15%"><p>SetBufferLen</p> </td> <td class="cellrowborder" valign="top" width="21.21%"><p>dataLen：buffer长度</p> </td> <td class="cellrowborder" valign="top" width="63.63999999999999%"><p>设置buffer长度。单位为字节。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="15.15%"><p>ToFile</p> </td> <td class="cellrowborder" valign="top" width="21.21%"><p>fileName：文件名称</p> </td> <td class="cellrowborder" valign="top" width="63.63999999999999%"><p>只限于CPU调试，将LocalTensor数据Dump到文件中，用于精度调试，文件保存在执行目录。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="15.15%"><p>Print</p> </td> <td class="cellrowborder" valign="top" width="21.21%"><p>dataLen：打印元素个数</p> </td> <td class="cellrowborder" valign="top" width="63.63999999999999%"><p>只限于CPU调试，在调试窗口中打印LocalTensor数据用于精度调试，每一行打印一个datablock(32Bytes)的数据。</p> </td> </tr>  </tbody></table></div> </div> </div> <div class="tiledSection"><h2 id="section8522mcpsimp">注意事项<i class="anchor-icon anchor-icon-link" anchorid="section8522mcpsimp" tips="复制节点链接"></i></h2><p>不要大量使用SetValue对LocalTensor进行赋值，会使性能下降。</p> </div> <div class="tiledSection"><h2 id="section8531mcpsimp">调用示例<i class="anchor-icon anchor-icon-link" anchorid="section8531mcpsimp" tips="复制节点链接"></i></h2><div _ngcontent-aqd-c106="" class="highlight-div"><div _ngcontent-aqd-c106="" class="highlight-div-header"><div _ngcontent-aqd-c106="" class="highlight-div-header-left"><div _ngcontent-aqd-c106="" class="handle-button expand-button"><div _ngcontent-aqd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-aqd-c106="" class="highlight-div-header-right"><div _ngcontent-aqd-c106="" class="handle-button ai-button"></div><div _ngcontent-aqd-c106="" class="handle-button line-button"><div _ngcontent-aqd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-aqd-c106="" class="handle-button theme-button"><div _ngcontent-aqd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-aqd-c106="" class="handle-button copy-button"><div _ngcontent-aqd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-aqd-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// srcLen = 256, num = 100, M=50 </span></li><li><span class="hljs-comment">// 示例1 </span></li><li><span class="hljs-keyword">for</span> (<span class="hljs-type">int32_t</span> i = <span class="hljs-number">0</span>; i &lt; srcLen; ++i) { </li><li>    inputLocal.<span class="hljs-built_in">SetValue</span>(i, num); <span class="hljs-comment">// 对inputLocal中第i个位置进行赋值为num </span></li><li>} </li><li><span class="hljs-comment">// 示例1结果如下： </span></li><li><span class="hljs-comment">// 数据(inputLocal): [100 100 100  ... 100] </span></li><li> </li><li><span class="hljs-comment">// 示例2 </span></li><li><span class="hljs-keyword">for</span> (<span class="hljs-type">int32_t</span> i = <span class="hljs-number">0</span>; i &lt; srcLen; ++i) { </li><li>    <span class="hljs-keyword">auto</span> element = inputLocal.<span class="hljs-built_in">GetValue</span>(i); <span class="hljs-comment">// 获取inputLocal中第i个位置的数值 </span></li><li>} </li><li><span class="hljs-comment">// 示例2结果如下： </span></li><li><span class="hljs-comment">// element 为100 </span></li><li> </li><li><span class="hljs-comment">// 示例3 </span></li><li><span class="hljs-keyword">for</span> (<span class="hljs-type">int32_t</span> i = <span class="hljs-number">0</span>; i &lt; srcLen; ++i) { </li><li>    <span class="hljs-built_in">inputLocal</span>(i) = num; <span class="hljs-comment">// 对inputLocal中第i个位置进行赋值为num </span></li><li>} </li><li><span class="hljs-comment">// 示例3结果如下： </span></li><li><span class="hljs-comment">// 数据(inputLocal): [100 100 100  ... 100] </span></li><li> </li><li><span class="hljs-comment">// 示例4 </span></li><li><span class="hljs-keyword">for</span> (<span class="hljs-type">int32_t</span> i = <span class="hljs-number">0</span>; i &lt; srcLen; ++i) { </li><li>    <span class="hljs-keyword">auto</span> element = <span class="hljs-built_in">inputLocal</span>(i); <span class="hljs-comment">// 获取inputLocal中第i个位置的数值 </span></li><li>} </li><li><span class="hljs-comment">// 示例4结果如下： </span></li><li><span class="hljs-comment">// element 为100 </span></li><li> </li><li><span class="hljs-comment">// 示例5 </span></li><li><span class="hljs-keyword">auto</span> size = inputLocal.<span class="hljs-built_in">GetSize</span>(); <span class="hljs-comment">// 获取inputLocal的长度，size大小为inputLocal有多少个element </span></li><li><span class="hljs-comment">// 示例5结果如下： </span></li><li><span class="hljs-comment">// size大小为srcLen，256。 </span></li><li> </li><li><span class="hljs-comment">// 示例6 </span></li><li><span class="hljs-comment">// operator[]使用方法, inputLocal[16]为从起始地址开始偏移量为16的新tensor </span></li><li>AscendC::<span class="hljs-built_in">Add</span>(outputLocal[<span class="hljs-number">16</span>], inputLocal[<span class="hljs-number">16</span>], inputLocal2[<span class="hljs-number">16</span>], M); </li><li><span class="hljs-comment">// 示例6结果如下： </span></li><li><span class="hljs-comment">// 输入数据(inputLocal): [100 100 100 ... 100] </span></li><li><span class="hljs-comment">// 输入数据(inputLocal2): [1 2 3 ... 66] </span></li><li><span class="hljs-comment">// 输出数据(outputLocal): [... 117 118 119 ... 166] </span></li><li> </li><li><span class="hljs-comment">// 示例7 </span></li><li>AscendC::TTagType tag = <span class="hljs-number">10</span>; </li><li>inputLocal.<span class="hljs-built_in">SetUserTag</span>(tag); <span class="hljs-comment">// 对LocalTensor设置tag信息。 </span></li><li> </li><li><span class="hljs-comment">// 示例8 </span></li><li>AscendC::LocalTensor&lt;half&gt; tensor1 = que1.<span class="hljs-built_in">DeQue</span>&lt;half&gt;(); </li><li>AscendC::TTagType tag1 = tensor1.<span class="hljs-built_in">GetUserTag</span>(); </li><li>AscendC::LocalTensor&lt;half&gt; tensor2 = que2.<span class="hljs-built_in">DeQue</span>&lt;half&gt;(); </li><li>AscendC::TTagType tag2 = tensor2.<span class="hljs-built_in">GetUserTag</span>(); </li><li>AscendC::LocalTensor&lt;half&gt; tensor3 = que3.<span class="hljs-built_in">AllocTensor</span>&lt;half&gt;(); </li><li><span class="hljs-comment">/* 使用Tag控制条件语句执行*/</span> </li><li><span class="hljs-keyword">if</span> ((tag1 &lt;= <span class="hljs-number">10</span>) &amp;&amp; (tag2 &gt;= <span class="hljs-number">9</span>)) { </li><li>    AscendC::<span class="hljs-built_in">Add</span>(tensor3, tensor1, tensor2, TILE_LENGTH); <span class="hljs-comment">// 当tag1小于等于10，tag2大于等于9的时候，才能进行相加操作。 </span></li><li>} </li><li><span class="hljs-comment">// 示例9 </span></li><li><span class="hljs-comment">// input_local为int32_t 类型，包含16个元素(64字节) </span></li><li><span class="hljs-keyword">for</span> (<span class="hljs-type">int32_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; ++i) { </li><li>    inputLocal.<span class="hljs-built_in">SetValue</span>(i, i); <span class="hljs-comment">// 对inputLocal中第i个位置进行赋值为i </span></li><li>} </li><li> </li><li><span class="hljs-comment">// 调用ReinterpretCast将input_local重解释为int16_t类型 </span></li><li>AscendC::LocalTensor&lt;<span class="hljs-type">int16_t</span>&gt; interpreTensor = inputLocal.<span class="hljs-built_in">ReinterpretCast</span>&lt;<span class="hljs-type">int16_t</span>&gt;(); </li><li><span class="hljs-comment">// 示例9结果如下，二者数据完全一致，在物理内存上也是同一地址，仅根据不同类型进行了重解释 </span></li><li><span class="hljs-comment">// inputLocal:0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 </span></li><li><span class="hljs-comment">// interpreTensor:0 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 9 0 10 0 11 0 12 0 13 0 14 0 15 0 </span></li><li> </li><li><span class="hljs-comment">// 示例10 </span></li><li><span class="hljs-comment">// 调用GetPhyAddr()返回LocalTensor地址，CPU上返回的是指针类型(T*)，NPU上返回的是物理存储的地址(uint64_t) </span></li><li><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> ASCEND_CPU_DEBUG </span></li><li><span class="hljs-type">float</span> *inputLocalCpuPtr = inputLocal.<span class="hljs-built_in">GetPhyAddr</span>(); </li><li><span class="hljs-type">uint64_t</span> realAddr = (<span class="hljs-type">uint64_t</span>)inputLocalCpuPtr - (<span class="hljs-type">uint64_t</span>)(<span class="hljs-built_in">GetTPipePtr</span>()-&gt;<span class="hljs-built_in">GetBaseAddr</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int8_t</span>&gt;(AscendC::QuePosition::VECCALC))); </li><li><span class="hljs-meta">#<span class="hljs-keyword">else</span> </span></li><li><span class="hljs-type">uint64_t</span> realAddr = inputLocal.<span class="hljs-built_in">GetPhyAddr</span>(); </li><li><span class="hljs-meta">#<span class="hljs-keyword">endif</span> </span></li><li> </li><li><span class="hljs-comment">// 示例11 </span></li><li>AscendC::QuePosition srcPos = (AscendC::QuePosition)inputLocal.<span class="hljs-built_in">GetPosition</span>(); </li><li><span class="hljs-keyword">if</span> (srcPos == AscendC::QuePosition::VECCALC) { </li><li>    <span class="hljs-comment">// 处理逻辑1 </span></li><li>} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (srcPos == AscendC::QuePosition::A1) { </li><li>    <span class="hljs-comment">// 处理逻辑2 </span></li><li>} <span class="hljs-keyword">else</span> { </li><li>    <span class="hljs-comment">// 处理逻辑3 </span></li><li>} </li><li> </li><li><span class="hljs-comment">// 示例12 </span></li><li><span class="hljs-comment">// 获取localTensor的长度(单位为Byte)，数据类型为int32_t，所以是16*sizeof(int32_t) </span></li><li><span class="hljs-type">uint32_t</span> len = inputLocal.<span class="hljs-built_in">GetLength</span>(); </li><li><span class="hljs-comment">// inputLocal:0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 </span></li><li><span class="hljs-comment">// len: 64 </span></li><li> </li><li><span class="hljs-comment">// 示例13 设置Tensor的ShapeInfo信息 </span></li><li>AscendC::LocalTensor&lt;<span class="hljs-type">float</span>&gt; maxUb = softmaxMaxBuf.<span class="hljs-keyword">template</span> <span class="hljs-built_in">Get</span>&lt;<span class="hljs-type">float</span>&gt;(); </li><li><span class="hljs-type">uint32_t</span> shapeArray[] = {<span class="hljs-number">16</span>, <span class="hljs-number">1024</span>}; </li><li>maxUb.<span class="hljs-built_in">SetShapeInfo</span>(AscendC::<span class="hljs-built_in">ShapeInfo</span>(<span class="hljs-number">2</span>, shapeArray, AscendC::DataFormat::ND)); </li><li> </li><li><span class="hljs-comment">// 示例14 获取Tensor的ShapeInfo信息 </span></li><li>AscendC::ShapeInfo maxShapeInfo = maxUb.<span class="hljs-built_in">GetShapeInfo</span>(); </li><li><span class="hljs-type">uint32_t</span> orgShape0 = maxShapeInfo.originalShape[<span class="hljs-number">0</span>]; </li><li><span class="hljs-type">uint32_t</span> orgShape1 = maxShapeInfo.originalShape[<span class="hljs-number">1</span>]; </li><li><span class="hljs-type">uint32_t</span> orgShape2 = maxShapeInfo.originalShape[<span class="hljs-number">2</span>]; </li><li><span class="hljs-type">uint32_t</span> orgShape3 = maxShapeInfo.originalShape[<span class="hljs-number">3</span>]; </li><li><span class="hljs-type">uint32_t</span> shape2 = maxShapeInfo.shape[<span class="hljs-number">2</span>]; </li><li> </li><li><span class="hljs-comment">// 示例15 SetAddrWithOffset，用于快速获取定义一个Tensor，同时指定新Tensor相对于旧Tensor首地址的偏移 </span></li><li><span class="hljs-comment">// 需要注意，偏移的长度为旧Tensor的元素个数 </span></li><li>AscendC::LocalTensor&lt;<span class="hljs-type">float</span>&gt; tmpBuffer1 = tempBmm2Queue.<span class="hljs-built_in">AllocTensor</span>&lt;<span class="hljs-type">float</span>&gt;(); </li><li>AscendC::LocalTensor&lt;half&gt; tmpHalfBuffer; </li><li>tmpHalfBuffer.<span class="hljs-built_in">SetAddrWithOffset</span>(tmpBuffer1, calcSize * <span class="hljs-number">2</span>); </li><li> </li><li><span class="hljs-comment">// 示例16 SetBufferLen 如下示例将申请的Tensor长度修改为1024(单位为字节) </span></li><li>AscendC::LocalTensor&lt;<span class="hljs-type">float</span>&gt; tmpBuffer2 = tempBmm2Queue.<span class="hljs-built_in">AllocTensor</span>&lt;<span class="hljs-type">float</span>&gt;(); </li><li>tmpBuffer2.<span class="hljs-built_in">SetBufferLen</span>(<span class="hljs-number">1024</span>); </li><li> </li><li><span class="hljs-comment">// 示例17 SetSize 如下示例将申请的Tensor长度修改为256(单位为元素) </span></li><li>AscendC::LocalTensor&lt;<span class="hljs-type">float</span>&gt; tmpBuffer3 = tempBmm2Queue.<span class="hljs-built_in">AllocTensor</span>&lt;<span class="hljs-type">float</span>&gt;(); </li><li>tmpBuffer3.<span class="hljs-built_in">SetSize</span>(<span class="hljs-number">256</span>); </li><li> </li><li><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> ASCEND_CPU_DEBUG </span></li><li><span class="hljs-comment">// 示例18 只限于CPU调试，将LocalTensor数据Dump到文件中，用于精度调试，文件保存在执行目录 </span></li><li>AscendC::LocalTensor&lt;<span class="hljs-type">float</span>&gt; tmpTensor = softmaxMaxBuf.<span class="hljs-keyword">template</span> <span class="hljs-built_in">Get</span>&lt;<span class="hljs-type">float</span>&gt;(); </li><li>tmpTensor.<span class="hljs-built_in">ToFile</span>(<span class="hljs-string">"tmpTensor.bin"</span>); </li><li> </li><li><span class="hljs-comment">// 示例19 只限于CPU调试，在调试窗口中打印LocalTensor数据用于精度调试，每一行打印一个datablock(32Bytes)的数据 </span></li><li>AscendC::LocalTensor&lt;<span class="hljs-type">int32_t</span>&gt; inputLocal = softmaxMaxBuf.<span class="hljs-keyword">template</span> <span class="hljs-built_in">Get</span>&lt;<span class="hljs-type">int32_t</span>&gt;(); </li><li><span class="hljs-keyword">for</span> (<span class="hljs-type">int32_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; ++i) { </li><li>    inputLocal.<span class="hljs-built_in">SetValue</span>(i, i); <span class="hljs-comment">// 对input_local中第i个位置进行赋值为i </span></li><li>} </li><li>inputLocal.<span class="hljs-built_in">Print</span>(); </li><li><span class="hljs-comment">// 0000: 0 1 2 3 4 5 6 7 8 </span></li><li><span class="hljs-comment">// 0008: 9 10 11 12 13 14 15 </span></li><li><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></li></ol></pre></div></div> </div> </div> <div></div></div>