<h1 _ngcontent-vpm-c119="" class="doc-title ng-star-inserted" title="Matmul模板参数"> Matmul模板参数 </h1>

<div _ngcontent-vpm-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;"> <div><div class="tiledSection"><h2 id="section20970114375616">功能说明<i class="anchor-icon anchor-icon-link" anchorid="section20970114375616" tips="复制节点链接"></i></h2><p>创建Matmul对象时需要传入：</p> <ul><li>A、B、C、Bias的参数类型信息，类型信息通过MatmulType来定义，包括：内存逻辑位置、数据格式、数据类型、是否转置、数据排布和是否使能L1复用。</li><li>MatmulConfig信息（可选），用于配置Matmul模板信息以及相关的配置参数。不配置默认使能Norm模板。<p>针对Kirin9020系列处理器，当前只支持使能默认的MDL模板。</p> </li><li>MatmulCallBack回调函数信息（可选），用于配置左右矩阵从GM拷贝到L1、计算结果从CO1拷贝到GM的自定义函数。</li><li>MatmulPolicy信息（可选），预留参数。</li></ul> </div> <div class="tiledSection"><h2 id="section7975144345611">实现原理<i class="anchor-icon anchor-icon-link" anchorid="section7975144345611" tips="复制节点链接"></i></h2><p>以输入矩阵A (GM, ND, half)、矩阵B(GM, ND, half)，输出矩阵C (GM, ND, float)，无Bias场景为例，其中(GM, ND, half)表示数据存放在GM上，数据格式为ND，数据类型为half，描述Matmul高阶API典型场景的内部算法框图，如下图所示。</p> <div class="fignone"><span class="figcap"><b>图1 </b>Matmul算法框图</span><br><span><img height="513.917187" originheight="789" originwidth="804" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211114328.32005493517800564953355216479396:50001231000000:2800:2D1047DD681E1806D8B8C3D6EE8A0E95E4A0D5154D363A0E822A4D8C60DFDD1C.png" title="点击放大" width="523.6875"></span></div> <p></p> <p>计算过程分为如下几步：</p> <ol><li>数据从GM搬到A1：DataCopy每次从矩阵A，搬出一个<span style="color: rgb(25,25,25);">stepM*baseM*stepKa*baseK</span><span style="color: rgb(25,25,25);">的矩阵块</span><span style="color: rgb(25,25,25);">a1</span><span style="color: rgb(25,25,25);">，循环多次完成矩阵</span><span style="color: rgb(25,25,25);">A</span><span style="color: rgb(25,25,25);">的搬运；</span>数据从GM搬到B1：DataCopy每次从矩阵B，搬出一个<span style="color: rgb(25,25,25);">stepKb*baseK*stepN*baseN</span><span style="color: rgb(25,25,25);">的矩阵块</span><span style="color: rgb(25,25,25);">b1</span><span style="color: rgb(25,25,25);">，循环多次完成矩阵</span><span style="color: rgb(25,25,25);">B</span><span style="color: rgb(25,25,25);">的搬运。</span></li><li>数据从A1搬到A2：LoadData每次从矩阵块a1，搬出一个baseM * baseK的矩阵块a0；数据从B1搬到B2，并完成转置：LoadData每次从矩阵块b1，搬出一个baseK * baseN的矩阵块，并将其转置为baseN * baseK的矩阵块b0。</li><li>矩阵乘：每次完成一个矩阵块a0 * b0的计算，得到baseM * baseN的矩阵块co1。</li><li>数据从矩阵块co1搬到矩阵块co2： DataCopy每次搬运一块baseM * baseN的矩阵块co1到singleCoreM * singleCoreN的矩阵块co2中。</li><li>重复2-4步骤，完成<span style="color: rgb(25,25,25);">矩阵块</span><span style="color: rgb(25,25,25);">a1 * b1</span><span style="color: rgb(25,25,25);">的计算。</span></li><li>数据从矩阵块co2搬到矩阵块C：DataCopy每次搬运一块singleCoreM * singleCoreN的矩阵块co2到矩阵块C中。</li><li>重复1-6步骤，完成矩阵A * B = C的计算。</li></ol> </div> <div class="tiledSection"><h2 id="section5979164325611">函数原型<i class="anchor-icon anchor-icon-link" anchorid="section5979164325611" tips="复制节点链接"></i></h2><div _ngcontent-vpm-c106="" class="highlight-div"><div _ngcontent-vpm-c106="" class="highlight-div-header"><div _ngcontent-vpm-c106="" class="highlight-div-header-left"><div _ngcontent-vpm-c106="" class="handle-button expand-button"><div _ngcontent-vpm-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-vpm-c106="" class="highlight-div-header-right"><div _ngcontent-vpm-c106="" class="handle-button ai-button"></div><div _ngcontent-vpm-c106="" class="handle-button line-button"><div _ngcontent-vpm-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-vpm-c106="" class="handle-button theme-button"><div _ngcontent-vpm-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-vpm-c106="" class="handle-button copy-button"><div _ngcontent-vpm-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-vpm-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">A_TYPE</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">B_TYPE</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">C_TYPE</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">BIAS_TYPE</span> = C_TYPE, <span class="hljs-type">const</span> MatmulConfig&amp; MM_CFG = CFG_NORM, <span class="hljs-keyword">class</span> MM_CB = MatmulCallBackFunc&lt;<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>&gt;, <span class="hljs-built_in">MATMUL_POLICY_DEFAULT_OF</span>(MatmulPolicy)&gt; </li><li><span class="hljs-keyword">using</span> Matmul = matmul::MatmulImpl&lt;A_TYPE, B_TYPE, C_TYPE, BIAS_TYPE, MM_CFG, MM_CB, MATMUL_POLICY&gt;;</li></ol></pre></div></div> <ul><li>A_TYPE、B_TYPE、C_TYPE类型信息通过<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cannkit-matmul-usage-description">使用说明</a>表1来定义。</li><li>MatmulConfig（可选），参数说明见表2。<ul><li>该参数可选取提供的模板默认值之一，当前提供的MatmulConfig模板取值范围为[CFG_NORM、CFG_MDL、CFG_IBSHARE_NORM、MM_CFG_BB]，分别对应默认的Norm、MDL、IBShare、BasicBlock模板。各模板的介绍请参考表3。</li><li>该参数可以通过MatmulConfig章节中介绍的获取模板的接口，自定义模板参数配置。</li><li>另外，MatmulConfig可拆分为表5、表6、表7、表8二级子Config，使用GetMMConfig接口，设置需要的二级子Config和表4，可以更加灵活的获取自定义的模板参数配置MatmulConfig。</li></ul> </li><li>MM_CB（可选），用于支持不同的搬入搬出需求，实现定制化的搬入搬出功能，如非连续搬入或针对搬出设置不同的数据片段间隔等。MM_CB中3个函数指针分别对应计算结果从CO1拷贝到GM、左矩阵从GM拷贝到L1、右矩阵从GM拷贝到L1的回调函数指针，各个功能回调函数接口定义及参数释义见表9。</li><li>MATMUL_POLICY_DEFAULT_OF(MatmulPolicy)（可选），当前为预留参数，无须配置。<div _ngcontent-vpm-c106="" class="highlight-div"><div _ngcontent-vpm-c106="" class="highlight-div-header"><div _ngcontent-vpm-c106="" class="highlight-div-header-left"><div _ngcontent-vpm-c106="" class="handle-button expand-button"><div _ngcontent-vpm-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-vpm-c106="" class="highlight-div-header-right"><div _ngcontent-vpm-c106="" class="handle-button ai-button"></div><div _ngcontent-vpm-c106="" class="handle-button line-button"><div _ngcontent-vpm-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-vpm-c106="" class="handle-button theme-button"><div _ngcontent-vpm-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-vpm-c106="" class="handle-button copy-button"><div _ngcontent-vpm-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-vpm-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-meta">#<span class="hljs-keyword">define</span> MATMUL_POLICY_DEFAULT_OF(DEFAULT)      \ </span></li><li><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; = MM_CFG, <span class="hljs-keyword">typename</span> ...&gt; <span class="hljs-keyword">class</span> MATMUL_POLICY = DEFAULT</li></ol></pre></div></div> </li></ul> </div> <div class="tiledSection"><h2 id="section7983164315613">参数说明<i class="anchor-icon anchor-icon-link" anchorid="section7983164315613" tips="复制节点链接"></i></h2> <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><caption><b>表1 </b>MatmulType参数说明</caption><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.4.2.2.3.1.1" valign="top" width="17.169999999999998%"><p>参数</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.4.2.2.3.1.2" valign="top" width="82.83%"><p>说明</p> </th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="17.169999999999998%"><p>POSITION</p> </td> <td class="cellrowborder" valign="top" width="82.83%"><p>内存逻辑位置</p> <p>Kirin9020系列处理器：</p> <ul><li>A矩阵可设置为TPosition::GM，TPosition::TSCM。</li><li>B矩阵可设置为TPosition::GM，TPosition::TSCM。</li><li>C矩阵可设置为TPosition::GM。</li></ul> </td> </tr> <tr><td class="cellrowborder" valign="top" width="17.169999999999998%"><p>CubeFormat</p> </td> <td class="cellrowborder" valign="top" width="82.83%"><p>Kirin9020系列处理器：</p> <ul><li>A矩阵在GM时，支持CubeFormat::ND。</li><li>A矩阵在TSCM时，支持CubeFormat::NZ/CubeFormat::VECTOR。</li><li>B矩阵在GM时，支持CubeFormat::ND/CubeFormat::NZ。</li><li>B矩阵在TSCM时支持CubeFormat::NZ。</li><li>C矩阵在GM时，支持CubeFormat::ND。</li></ul> </td> </tr> <tr><td class="cellrowborder" valign="top" width="17.169999999999998%"><p>TYPE</p> </td> <td class="cellrowborder" valign="top" width="82.83%"><p>Kirin9020系列处理器：</p> <ul><li>A矩阵可设置为half。</li><li>B矩阵可设置为half。</li><li>C矩阵可设置为half。</li></ul> </td> </tr> <tr><td class="cellrowborder" valign="top" width="17.169999999999998%"><p>ISTRANS</p> </td> <td class="cellrowborder" valign="top" width="82.83%"><p>是否开启使能矩阵转置的功能。当前不支持转置，只支持设为false。</p> <p>false为不开启使能矩阵转置的功能，通过<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cannkit-settensora">SetTensorA</a>和<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cannkit-settensorb">SetTensorB</a>不能设置A、B矩阵是否转置。Matmul会认为A矩阵形状为[M, K]，B矩阵形状为[K, N]。</p> <p>默认为false不使能转置。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="17.169999999999998%"><p>LAYOUT</p> </td> <td class="cellrowborder" valign="top" width="82.83%"><p>表征数据的排布。</p> <p>NONE：默认值，表示不使用BatchMatmul，其他选项表示使用BatchMatmul。</p> </td> </tr>  </tbody></table></div> </div>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><caption><b>表2 </b>MatmulConfig参数说明</caption><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.4.3.2.4.1.1" valign="top" width="21.21%"><p>参数</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.4.3.2.4.1.2" valign="top" width="55.559999999999995%"><p>说明</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.4.3.2.4.1.3" valign="top" width="23.23%"><p>支持模板：Norm, MDL, SpecialMDL, IBShare, BasicBlock</p> </th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="21.21%"><p>doNorm</p> </td> <td class="cellrowborder" valign="top" width="55.559999999999995%"><p>使能Norm模板。参数取值如下。</p> <ul><li>true：使能Norm模板</li><li>false：不使能Norm模板</li></ul> <p>不指定模板的情况默认使能Norm模板。</p> </td> <td class="cellrowborder" valign="top" width="23.23%"><p>Norm</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="21.21%"><p>doMultiDataLoad</p> </td> <td class="cellrowborder" valign="top" width="55.559999999999995%"><p>使能MDL模板。参数取值如下。</p> <ul><li>true：使能MDL模板</li><li>false：不使能MDL模板</li></ul> </td> <td class="cellrowborder" valign="top" width="23.23%"><p>MDL</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="21.21%"><p>doSpecialMDL</p> </td> <td class="cellrowborder" valign="top" width="55.559999999999995%"><p>使能SpecialMDL模板。参数取值如下。</p> <ul><li>true：使能SpecialMDL模板</li><li>false：不使能SpecialMDL模板</li></ul> <p>本质上也是MDL模板。MDL模板Matmul K方向不全载时（singleCoreK/baseK &gt; stepKb），仅支持stepN设置为1，开启后支持stepN=2。</p> </td> <td class="cellrowborder" valign="top" width="23.23%"><p>SpecialMDL</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="21.21%"><p>doIBShareNorm</p> </td> <td class="cellrowborder" valign="top" width="55.559999999999995%"><p>使能IBShare模板。参数取值如下。</p> <ul><li>false：不使能IBShare（默认值）</li><li>true：使能IBShare</li></ul> <p>IBShare的功能是能够复用L1上相同的A矩阵或B矩阵数据，开启后在数据复用场景能够避免重复搬运数据到L1。</p> </td> <td class="cellrowborder" valign="top" width="23.23%"><p>IBShare</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="21.21%"><p>intrinsicsLimit</p> </td> <td class="cellrowborder" valign="top" width="55.559999999999995%"><p>当左矩阵或右矩阵在单核上内轴（即尾轴）大于等于65535时，是否使能循环执行数据的搬入。例如，左矩阵A[M, K]，单核上的内轴数据singleCoreK大于65535，配置该参数为true后，API内部通过循环执行数据的搬入。参数取值如下。</p> <ul><li>false：当左矩阵或右矩阵在单核上内轴大于等于65535时，不使能循环执行数据的搬入（默认值）</li><li>true：当左矩阵或右矩阵在单核上内轴大于等于65535时，使能数循环执行数据的搬入</li></ul> </td> <td class="cellrowborder" valign="top" width="23.23%"><p>所有模板</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="21.21%"><p>batchLoop</p> </td> <td class="cellrowborder" valign="top" width="55.559999999999995%"><p>是否多Batch输入多Batch输出。参数取值如下。</p> <ul><li>false：不使能多Batch（默认值）</li><li>true：使能多Batch</li></ul> <p>仅对BatchMatmul有效。</p> </td> <td class="cellrowborder" valign="top" width="23.23%"><p>所有模板</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="21.21%"><p>isVecND2NZ</p> </td> <td class="cellrowborder" valign="top" width="55.559999999999995%"><p>使能通过vector进行ND2NZ。参数取值如下。</p> <ul><li>false：不使能通过vector进行ND2NZ（默认值）</li><li>true：使能通过vector进行ND2NZ</li></ul> <p>使能时需要设置SetLocalWorkspace。</p> </td> <td class="cellrowborder" valign="top" width="23.23%"><p>所有模板</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="21.21%"><p>enableInit</p> </td> <td class="cellrowborder" valign="top" width="55.559999999999995%"><p>是否启用Init函数，不使能Init函数能够提升常量传播效果，优化性能。默认使能。</p> </td> <td class="cellrowborder" valign="top" width="23.23%"><p>所有模板</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="21.21%"><p>bmmMode</p> </td> <td class="cellrowborder" valign="top" width="55.559999999999995%"><p>Layout类型为NORMAL时，设置BatchMatmul输入A/B矩阵的多batch数据总和与L1 Buffer的大小关系。参数取值如下。</p> <ul><li>BatchMode::BATCH_LESS_THAN_L1：多batch数据总和&lt;L1 Buffer Size。</li><li>BatchMode::BATCH_LARGE_THAN_L1：多batch数据总和&gt;L1 Buffer Size。</li><li>BatchMode::SINGLE_LARGE_THAN_L1：单batch数据总和&gt;L1 Buffer Size。</li></ul> </td> <td class="cellrowborder" valign="top" width="23.23%"><p>Norm, IBShare</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="21.21%"><p>enUnitFlag</p> </td> <td class="cellrowborder" valign="top" width="55.559999999999995%"><p>使能unitflag功能，使计算与搬运流水并行，提高性能。Norm, IBShare下默认使能，MDL下默认不使能。参数取值如下。</p> <ul><li>false：不使能unitflag功能</li><li>true：使能unitflag功能</li></ul> </td> <td class="cellrowborder" valign="top" width="23.23%"><p>MDL, Norm, IBShare</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="21.21%"><p>isPerTensor</p> </td> <td class="cellrowborder" valign="top" width="55.559999999999995%"><p>A矩阵half类型输入且B矩阵int8类型输入场景，使能B矩阵量化时是否为per tensor，true为per tensor，false为per channel。</p> </td> <td class="cellrowborder" valign="top" width="23.23%"><p>MDL, SpecialMDL</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="21.21%"><p>hasAntiQuantOffset</p> </td> <td class="cellrowborder" valign="top" width="55.559999999999995%"><p>A矩阵half类型输入且B矩阵int8类型输入场景，使能B矩阵量化时是否使用offset系数。</p> </td> <td class="cellrowborder" valign="top" width="23.23%"><p>MDL, SpecialMDL</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="21.21%"><p>doMTE2Preload</p> </td> <td class="cellrowborder" valign="top" width="55.559999999999995%"><p>在MTE2流水间隙较大，且M/N数值较大时可通过该参数开启对应M/N方向的预加载功能，开启后能减小MTE2间隙，提升性能。预加载功能仅在MDL模板有效。参数取值如下。</p> <ul><li>0：不开启（默认值）</li><li>1：开启M方向preload</li><li>2：开启N方向preload</li></ul> <p>注意，开启M/N预加载功能时需保证K全载，且M/N开启Double Buffer。</p> </td> <td class="cellrowborder" valign="top" width="23.23%"><p>MDL, SpecialMDL</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="21.21%"><p>isMsgReuse</p> </td> <td class="cellrowborder" valign="top" width="55.559999999999995%"><p>SetSelfDefineData函数设置的回调函数中的dataPtr是否直接传递计算数据。参数取值如下。</p> <ul><li>true：直接传递计算数据，仅限单个值</li><li>false：传递GM上存储的数据地址信息</li></ul> </td> <td class="cellrowborder" valign="top" width="23.23%"><p>Norm, MDL</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="21.21%"><p>enableUBReuse</p> </td> <td class="cellrowborder" valign="top" width="55.559999999999995%"><p>是否使能UB复用。参数取值如下。</p> <ul><li>true：使能UB复用</li><li>false：不使能UB复用</li></ul> </td> <td class="cellrowborder" valign="top" width="23.23%"><p>MDL</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="21.21%"><p>enableL1CacheUB</p> </td> <td class="cellrowborder" valign="top" width="55.559999999999995%"><p>是否使能L1缓存UB计算块。参数取值如下。</p> <ul><li>true：使能L1缓存UB计算块</li><li>false：不使能L1缓存UB计算块</li></ul> <p>若要使能L1缓存UB计算块，必须在tiling实现中调用SetMatmulConfigParams接口配置相关信息。</p> </td> <td class="cellrowborder" valign="top" width="23.23%"><p>MDL</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="21.21%"><p>isDoubleCache</p> </td> <td class="cellrowborder" valign="top" width="55.559999999999995%"><p>开启IBShare模板后，在L1上是否同时缓存两块数据。注意，需要控制base块大小，防止两块缓存超过L1大小限制。参数取值如下。</p> <ul><li>false：L1上同时缓存一块数据（默认值）</li><li>true：使能L1上同时缓存两块数据</li></ul> </td> <td class="cellrowborder" valign="top" width="23.23%"><p>IBShare</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="21.21%"><p>IterateOrder</p> </td> <td class="cellrowborder" valign="top" width="55.559999999999995%"><p>Matmul做矩阵运算的循环迭代顺序，与<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cannkit-tcubetiling-structure">TCubeTiling结构体</a>表1中的iterateOrder参数含义相同。当ScheduleType参数取值为ScheduleType::OUTER_PRODUCT或1时，本参数生效。参数取值如下。</p> <div _ngcontent-vpm-c106="" class="highlight-div"><div _ngcontent-vpm-c106="" class="highlight-div-header"><div _ngcontent-vpm-c106="" class="highlight-div-header-left"><div _ngcontent-vpm-c106="" class="handle-button expand-button"><div _ngcontent-vpm-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-vpm-c106="" class="highlight-div-header-right"><div _ngcontent-vpm-c106="" class="handle-button ai-button"></div><div _ngcontent-vpm-c106="" class="handle-button line-button"><div _ngcontent-vpm-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-vpm-c106="" class="handle-button theme-button"><div _ngcontent-vpm-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-vpm-c106="" class="handle-button copy-button"><div _ngcontent-vpm-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-vpm-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">IterateOrder</span> { </li><li>     ORDER_M = <span class="hljs-number">0</span>,   <span class="hljs-comment">// 先往M轴方向偏移再往N轴方向偏移 </span></li><li>     ORDER_N,       <span class="hljs-comment">// 先往N轴方向偏移再往M轴方向偏移 </span></li><li>     UNDEF,         <span class="hljs-comment">// 当前无效 </span></li><li> };</li></ol></pre></div></div> <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"><p>MDL模板使用时，若IterateOrder取值ORDER_M，<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cannkit-tcubetiling-structure">TCubeTiling结构体</a>表1中的stepN需要大于1，IterateOrder取值ORDER_N时，TCubeTiling结构中的stepM需要大于1。</p> </div></div></div> </td> <td class="cellrowborder" valign="top" width="23.23%"><p>Norm、MDL</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="21.21%"><p>ScheduleType</p> </td> <td class="cellrowborder" valign="top" width="55.559999999999995%"><p>配置Matmul数据搬运模式。参数取值如下。</p> <ul><li>ScheduleType::INNER_PRODUCT或0：默认模式，在K方向上做MTE1的循环搬运。</li><li>ScheduleType::OUTER_PRODUCT或1：在M或N方向上做MTE1的循环搬运。使能后，需要与IterateOrder参数配合使用。该配置当前只在Norm模板的Batch Matmul场景、MDL模板生效。<ul><li>若IterateOrder取值ORDER_M，则N方向循环搬运（在singleCoreN大于baseN场景可能有性能提升），即B矩阵的MTE1搬运并行。</li><li>若IterateOrder取值ORDER_N，则M方向循环搬运（在singleCoreM大于baseM场景可能有性能提升），即A矩阵的MTE1搬运并行。</li><li>不能同时使能M方向和N方向循环搬运。</li></ul> </li></ul> <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"><ul><li>singleCoreK&gt;baseK的场景，不能使能ScheduleType::OUTER_PRODUCT取值，需使用默认模式。</li><li>MDL模板仅在调用IterateAll计算的场景支持配置ScheduleType::OUTER_PRODUCT或1。</li></ul> </div></div></div> </td> <td class="cellrowborder" valign="top" width="23.23%"><p>Norm、MDL</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="21.21%"><p>isBiasBatch</p> </td> <td class="cellrowborder" valign="top" width="55.559999999999995%"><p>批量多Batch的Matmul场景，即BatchMatmul场景，Bias的大小是否带有Batch轴。参数取值如下。</p> <ul><li>true：Bias带有Batch轴，Bias大小为Batch * N（默认值）。</li><li>false：Bias不带Batch轴，Bias大小为N，多Batch计算Matmul时，会复用Bias。</li></ul> </td> <td class="cellrowborder" valign="top" width="23.23%"><p>Norm</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="21.21%"><p>doBasicBlock</p> </td> <td class="cellrowborder" valign="top" width="55.559999999999995%"><p>是否使能BasicBlock模板。模板参数取值如下。</p> <ul><li>true：使能BasicBlock模板</li><li>false：不使能BasicBlock模板</li></ul> <p>调用GetBasicConfig接口获取BasicBlock模板时，该参数被置为true。</p> <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"><ul><li>BasicBlock模板暂不支持输入为int8，int4数据类型的A、B矩阵，支持half/float/bfloat16_t数据类型的A、B矩阵。</li><li>BasicBlock模板暂不支持A矩阵的格式为标量数据Scalar或向量数据Vector。</li><li>BasicBlock模板暂不支持ScheduleType::OUTER_PRODUCT的数据搬运模式。</li></ul> </div></div></div> </td> <td class="cellrowborder" valign="top" width="23.23%"><p>BasicBlock</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="21.21%"><p>basicM</p> </td> <td class="cellrowborder" valign="top" width="55.559999999999995%"><p>相当于baseM。</p> </td> <td class="cellrowborder" valign="top" width="23.23%"><p>BasicBlock</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="21.21%"><p>basicN</p> </td> <td class="cellrowborder" valign="top" width="55.559999999999995%"><p>相当于baseN。</p> </td> <td class="cellrowborder" valign="top" width="23.23%"><p>BasicBlock</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="21.21%"><p>basicK</p> </td> <td class="cellrowborder" valign="top" width="55.559999999999995%"><p>相当于baseK。</p> </td> <td class="cellrowborder" valign="top" width="23.23%"><p>BasicBlock</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="21.21%"><p>doSpecialBasicBlock</p> </td> <td class="cellrowborder" valign="top" width="55.559999999999995%"><p>使能SpecialBasicBlock模板。参数取值如下。</p> <ul><li>true：使能SpecialBasicBlock模板。</li><li>false：不使能SpecialBasicBlock模板。</li></ul> <p>本质上也是BasicBlock模板，但消除了头开销scalar计算。</p> </td> <td class="cellrowborder" valign="top" width="23.23%"><p>预留参数</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="21.21%"><p>singleCoreM</p> </td> <td class="cellrowborder" valign="top" width="55.559999999999995%"><p>单核内M轴shape大小，以元素为单位。</p> </td> <td class="cellrowborder" valign="top" width="23.23%"><p>预留参数</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="21.21%"><p>singleCoreN</p> </td> <td class="cellrowborder" valign="top" width="55.559999999999995%"><p>单核内N轴shape大小，以元素为单位。</p> </td> <td class="cellrowborder" valign="top" width="23.23%"><p>预留参数</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="21.21%"><p>singleCoreK</p> </td> <td class="cellrowborder" valign="top" width="55.559999999999995%"><p>单核内K轴shape大小，以元素为单位。</p> </td> <td class="cellrowborder" valign="top" width="23.23%"><p>预留参数</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="21.21%"><p>stepM</p> </td> <td class="cellrowborder" valign="top" width="55.559999999999995%"><p>左矩阵在A1中缓存的bufferM方向上baseM的倍数。</p> </td> <td class="cellrowborder" valign="top" width="23.23%"><p>预留参数</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="21.21%"><p>stepN</p> </td> <td class="cellrowborder" valign="top" width="55.559999999999995%"><p>右矩阵在B1中缓存的bufferN方向上baseN的倍数。</p> </td> <td class="cellrowborder" valign="top" width="23.23%"><p>预留参数</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="21.21%"><p>baseMN</p> </td> <td class="cellrowborder" valign="top" width="55.559999999999995%"><p>baseM*baseN的大小。</p> </td> <td class="cellrowborder" valign="top" width="23.23%"><p>预留参数</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="21.21%"><p>singleCoreMN</p> </td> <td class="cellrowborder" valign="top" width="55.559999999999995%"><p>singleCoreM*singleCoreN的大小。</p> </td> <td class="cellrowborder" valign="top" width="23.23%"><p>预留参数</p> </td> </tr>  </tbody></table></div> </div>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><caption><b>表3 </b>模板特性</caption><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.4.4.2.5.1.1" valign="top" width="12.24%"><p>模板</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.4.4.2.5.1.2" valign="top" width="47.96%"><p>实现</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.4.4.2.5.1.3" valign="top" width="19.39%"><p>优点</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.4.4.2.5.1.4" valign="top" width="20.41%"><p>推荐使用场景</p> </th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="12.24%"><p>Norm</p> </td> <td class="cellrowborder" valign="top" width="47.96%"><p>支持L1缓存多个基本块，MTE2分多次从GM搬运基本块到L1，每次搬运一份基本块，已搬的基本块不清空。（举例说明：depthA1=6，代表搬入6份A矩阵基本块到L1，1次搬运一份基本块，MTE2进行6次搬运）</p> </td> <td class="cellrowborder" valign="top" width="19.39%"><p>可以提前启动MTE1流水（因为搬1份基本块就可以做MTE1后面的运算）</p> </td> <td class="cellrowborder" valign="top" width="20.41%"><p>默认使能Norm模板</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="12.24%"><p>MDL，SpecialMDL</p> </td> <td class="cellrowborder" valign="top" width="47.96%"><p>支持L1缓存多个基本块，MTE2从GM到L1的搬运为一次性"大包"搬运。（举例说明：depthA1=6，代表一次性搬入6份A矩阵基本块到L1，MTE2进行1次搬运）</p> </td> <td class="cellrowborder" valign="top" width="19.39%"><p>对于一般的大shape场景，可以减少MTE2的循环搬运，提升性能</p> </td> <td class="cellrowborder" valign="top" width="20.41%"><p>大shape场景</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="12.24%"><p>IBShare</p> </td> <td class="cellrowborder" valign="top" width="47.96%"><p>MIX场景下，多个AIV的A矩阵或B矩阵GM地址相同的时候，通过共享L1 Buffer，减少MTE2搬运。</p> </td> <td class="cellrowborder" valign="top" width="19.39%"><p>减少MTE2搬运，提升性能</p> </td> <td class="cellrowborder" valign="top" width="20.41%"><p>MIX场景多个AIV的A矩阵或B矩阵GM地址相同</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="12.24%"><p>BasicBlock</p> </td> <td class="cellrowborder" valign="top" width="47.96%"><p>在无尾块的场景，base块大小确定的情况下，通过GetBasicConfig接口配置输入的基本块大小，固定MTE1每次搬运的矩阵大小及Mmad每次计算的矩阵大小，减少参数计算量。</p> </td> <td class="cellrowborder" valign="top" width="19.39%"><p>减少MTE1矩阵搬运和Mmad矩阵计算过程中的参数计算开销</p> </td> <td class="cellrowborder" valign="top" width="20.41%"><p>无尾块，base块(baseM, baseN)大小确定</p> </td> </tr>  </tbody></table></div> </div>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><caption><b>表4 </b>MatmulConfigMode参数说明</caption><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.4.5.2.3.1.1" valign="top" width="35.35%"><p>参数</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.4.5.2.3.1.2" valign="top" width="64.64999999999999%"><p>说明</p> </th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="35.35%"><p>CONFIG_NORM</p> </td> <td class="cellrowborder" valign="top" width="64.64999999999999%"><p>表示设置MatmulConfig默认值为Norm模板。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="35.35%"><p>CONFIG_MDL</p> </td> <td class="cellrowborder" valign="top" width="64.64999999999999%"><p>表示设置MatmulConfig默认值为MDL模板。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="35.35%"><p>CONFIG_SPECIALMDL</p> </td> <td class="cellrowborder" valign="top" width="64.64999999999999%"><p>表示设置MatmulConfig默认值为SpecialMDL模板。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="35.35%"><p>CONFIG_IBSHARE</p> </td> <td class="cellrowborder" valign="top" width="64.64999999999999%"><p>表示设置MatmulConfig默认值为IBShare模板。</p> </td> </tr>  </tbody></table></div> </div>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><caption><b>表5 </b>MatmulShapeParams参数说明</caption><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.4.6.2.4.1.1" valign="top" width="22.220000000000002%"><p>参数</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.4.6.2.4.1.2" valign="top" width="18.18%"><p>数据类型</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.4.6.2.4.1.3" valign="top" width="59.599999999999994%"><p>说明</p> </th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="22.220000000000002%"><p>singleCoreM</p> </td> <td class="cellrowborder" valign="top" width="18.18%"><p>uint32_t</p> </td> <td class="cellrowborder" valign="top" width="59.599999999999994%"><p>单核内M轴shape大小，以元素为单位。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="22.220000000000002%"><p>singleCoreN</p> </td> <td class="cellrowborder" valign="top" width="18.18%"><p>uint32_t</p> </td> <td class="cellrowborder" valign="top" width="59.599999999999994%"><p>单核内N轴shape大小，以元素为单位。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="22.220000000000002%"><p>singleCoreK</p> </td> <td class="cellrowborder" valign="top" width="18.18%"><p>uint32_t</p> </td> <td class="cellrowborder" valign="top" width="59.599999999999994%"><p>单核内K轴shape大小，以元素为单位。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="22.220000000000002%"><p>basicM</p> </td> <td class="cellrowborder" valign="top" width="18.18%"><p>uint32_t</p> </td> <td class="cellrowborder" valign="top" width="59.599999999999994%"><p>相当于baseM。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="22.220000000000002%"><p>basicN</p> </td> <td class="cellrowborder" valign="top" width="18.18%"><p>uint32_t</p> </td> <td class="cellrowborder" valign="top" width="59.599999999999994%"><p>相当于baseN。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="22.220000000000002%"><p>basicK</p> </td> <td class="cellrowborder" valign="top" width="18.18%"><p>uint32_t</p> </td> <td class="cellrowborder" valign="top" width="59.599999999999994%"><p>相当于baseK。</p> </td> </tr>  </tbody></table></div> </div>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><caption><b>表6 </b>MatmulQuantParams参数说明</caption><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.4.7.2.4.1.1" valign="top" width="22.220000000000002%"><p>参数</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.4.7.2.4.1.2" valign="top" width="18.18%"><p>数据类型</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.4.7.2.4.1.3" valign="top" width="59.599999999999994%"><p>说明</p> </th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="22.220000000000002%"><p>isPerTensor</p> </td> <td class="cellrowborder" valign="top" width="18.18%"><p>bool</p> </td> <td class="cellrowborder" valign="top" width="59.599999999999994%"><p>A矩阵half类型输入且B矩阵int8类型输入场景，使能B矩阵量化时是否为per tensor，true为per tensor，false为per channel。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="22.220000000000002%"><p>hasAntiQuantOffset</p> </td> <td class="cellrowborder" valign="top" width="18.18%"><p>bool</p> </td> <td class="cellrowborder" valign="top" width="59.599999999999994%"><p>A矩阵half类型输入且B矩阵int8类型输入场景，使能B矩阵量化时是否使用offset系数，true为使用offset系数，false为不使用offset系数。</p> </td> </tr>  </tbody></table></div> </div>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><caption><b>表7 </b>MatmulBatchParams参数说明</caption><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.4.8.2.4.1.1" valign="top" width="22.220000000000002%"><p>参数</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.4.8.2.4.1.2" valign="top" width="18.279999999999998%"><p>数据类型</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.4.8.2.4.1.3" valign="top" width="59.5%"><p>说明</p> </th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="22.220000000000002%"><p>batchLoop</p> </td> <td class="cellrowborder" valign="top" width="18.279999999999998%"><p>bool</p> </td> <td class="cellrowborder" valign="top" width="59.5%"><p>是否多Batch输入多Batch输出。参数取值如下。</p> <ul><li>false：不使能多Batch（默认值）</li><li>true：使能多Batch</li></ul> <p>仅对BatchMatmul有效。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="22.220000000000002%"><p>bmmMode</p> </td> <td class="cellrowborder" valign="top" width="18.279999999999998%"><p>BatchMode</p> </td> <td class="cellrowborder" valign="top" width="59.5%"><p>Layout类型为NORMAL时，设置BatchMatmul输入A/B矩阵的多batch数据总和与L1 Buffer的大小关系。参数取值如下。</p> <ul><li>BatchMode::BATCH_LESS_THAN_L1：多batch数据总和&lt;L1 Buffer Size。</li><li>BatchMode::BATCH_LARGE_THAN_L1：多batch数据总和&gt;L1 Buffer Size。</li><li>BatchMode::SINGLE_LARGE_THAN_L1：单batch数据总和&gt;L1 Buffer Size。</li></ul> </td> </tr> <tr><td class="cellrowborder" valign="top" width="22.220000000000002%"><p>isBiasBatch</p> </td> <td class="cellrowborder" valign="top" width="18.279999999999998%"><p>bool</p> </td> <td class="cellrowborder" valign="top" width="59.5%"><p>批量多Batch的Matmul场景，即BatchMatmul场景，Bias的大小是否带有Batch轴。参数取值如下。</p> <ul><li>true：Bias带有Batch轴，Bias大小为Batch * N（默认值）</li><li>false：Bias不带Batch轴，Bias大小为N，多Batch计算Matmul时，会复用Bias。</li></ul> </td> </tr>  </tbody></table></div> </div>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><caption><b>表8 </b>MatmulFuncParams参数说明</caption><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.4.9.2.4.1.1" valign="top" width="22.220000000000002%"><p>参数</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.4.9.2.4.1.2" valign="top" width="18.18%"><p>数据类型</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.4.9.2.4.1.3" valign="top" width="59.599999999999994%"><p>说明</p> </th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="22.220000000000002%"><p>intrinsicsLimit</p> </td> <td class="cellrowborder" valign="top" width="18.18%"><p>bool</p> </td> <td class="cellrowborder" valign="top" width="59.599999999999994%"><p>进行芯片指令搬运地址偏移量校验，影响性能。参数取值如下。</p> <ul><li>false：不进行芯片指令搬运地址偏移量校验（默认值）</li><li>true：进行芯片指令搬运地址偏移量校验</li></ul> </td> </tr> <tr><td class="cellrowborder" valign="top" width="22.220000000000002%"><p>enVecND2NZ</p> </td> <td class="cellrowborder" valign="top" width="18.18%"><p>bool</p> </td> <td class="cellrowborder" valign="top" width="59.599999999999994%"><p>使能通过vector进行ND2NZ。参数取值如下。</p> <ul><li>false：不使能通过vector进行ND2NZ（默认值）</li><li>true：使能通过vector进行ND2NZ</li></ul> <p>使能时需要设置SetLocalWorkspace。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="22.220000000000002%"><p>doMTE2Preload</p> </td> <td class="cellrowborder" valign="top" width="18.18%"><p>uint32_t</p> </td> <td class="cellrowborder" valign="top" width="59.599999999999994%"><p>在MTE2流水间隙较大，且M/N数值较大时可通过该参数开启对应M/N方向的预加载功能，开启后能减小MTE2间隙，提升性能。预加载功能仅在MDL模板有效。参数取值如下。</p> <ul><li>0：不开启（默认值）</li><li>1：开启M方向preload</li><li>2：开启N方向preload</li></ul> <p>注意，开启M/N预加载功能时需保证K全载，且M/N开启Double Buffer。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="22.220000000000002%"><p>enableReuse</p> </td> <td class="cellrowborder" valign="top" width="18.18%"><p>bool</p> </td> <td class="cellrowborder" valign="top" width="59.599999999999994%"><p>SetSelfDefineData函数设置的回调函数中的dataPtr是否直接传递计算数据。参数取值如下。</p> <ul><li>true：直接传递计算数据，仅限单个值</li><li>false：传递GM上存储的数据地址信息</li></ul> </td> </tr> <tr><td class="cellrowborder" valign="top" width="22.220000000000002%"><p>enableUBReuse</p> </td> <td class="cellrowborder" valign="top" width="18.18%"><p>bool</p> </td> <td class="cellrowborder" valign="top" width="59.599999999999994%"><p>是否使能UB复用。参数取值如下。</p> <ul><li>true：使能UB复用</li><li>false：不使能UB复用</li></ul> </td> </tr> <tr><td class="cellrowborder" valign="top" width="22.220000000000002%"><p>enableL1CacheUB</p> </td> <td class="cellrowborder" valign="top" width="18.18%"><p>bool</p> </td> <td class="cellrowborder" valign="top" width="59.599999999999994%"><p>是否使能L1缓存UB计算块。参数取值如下。</p> <ul><li>true：使能L1缓存UB计算块</li><li>false：不使能L1缓存UB计算块</li></ul> <p>若要使能L1缓存UB计算块，必须在tiling实现中调用SetMatmulConfigParams接口配置相关信息。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="22.220000000000002%"><p>iterateOrder</p> </td> <td class="cellrowborder" valign="top" width="18.18%"><p>IterateOrder</p> </td> <td class="cellrowborder" valign="top" width="59.599999999999994%"><p>Matmul做矩阵运算的循环迭代顺序，与<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cannkit-tcubetiling-structure">TCubeTiling结构体</a>表1中的iterateOrder参数含义相同。当ScheduleType参数取值为ScheduleType::OUTER_PRODUCT或1时，本参数生效。参数取值如下。</p> <div _ngcontent-vpm-c106="" class="highlight-div"><div _ngcontent-vpm-c106="" class="highlight-div-header"><div _ngcontent-vpm-c106="" class="highlight-div-header-left"><div _ngcontent-vpm-c106="" class="handle-button expand-button"><div _ngcontent-vpm-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-vpm-c106="" class="highlight-div-header-right"><div _ngcontent-vpm-c106="" class="handle-button ai-button"></div><div _ngcontent-vpm-c106="" class="handle-button line-button"><div _ngcontent-vpm-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-vpm-c106="" class="handle-button theme-button"><div _ngcontent-vpm-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-vpm-c106="" class="handle-button copy-button"><div _ngcontent-vpm-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-vpm-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">IterateOrder</span> { </li><li>     ORDER_M = <span class="hljs-number">0</span>,   <span class="hljs-comment">// 先往M轴方向偏移再往N轴方向偏移 </span></li><li>     ORDER_N,       <span class="hljs-comment">// 先往N轴方向偏移再往M轴方向偏移 </span></li><li>     UNDEF,         <span class="hljs-comment">// 当前无效 </span></li><li> };</li></ol></pre></div></div> <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"><p>MDL模板使用时，若IterateOrder取值ORDER_M，<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cannkit-tcubetiling-structure">TCubeTiling结构体</a>表1中的stepN需要大于1，IterateOrder取值ORDER_N时，TCubeTiling结构中的stepM需要大于1。</p> </div></div></div> </td> </tr> <tr><td class="cellrowborder" valign="top" width="22.220000000000002%"><p>scheduleType</p> </td> <td class="cellrowborder" valign="top" width="18.18%"><p>ScheduleType</p> </td> <td class="cellrowborder" valign="top" width="59.599999999999994%"><p>配置Matmul数据搬运模式。参数取值如下。</p> <ul><li>ScheduleType::INNER_PRODUCT或0：默认模式，在K方向上做MTE1的循环搬运。</li><li>ScheduleType::OUTER_PRODUCT或1：在M或N方向上做MTE1的循环搬运。使能后，需要与IterateOrder参数配合使用。该配置当前只在Norm模板的Batch Matmul场景、MDL模板生效。<ul><li>若IterateOrder取值ORDER_M，则N方向循环搬运（在singleCoreN大于baseN场景可能有性能提升），即B矩阵的MTE1搬运并行。</li><li>若IterateOrder取值ORDER_N，则M方向循环搬运（在singleCoreM大于baseM场景可能有性能提升），即A矩阵的MTE1搬运并行。</li><li>不能同时使能M方向和N方向循环搬运。</li></ul> </li></ul> <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"><ul><li>singleCoreK&gt;baseK的场景，不能使能ScheduleType::OUTER_PRODUCT取值，需使用默认模式。</li><li>MDL模板仅在调用IterateAll计算的场景支持配置ScheduleType::OUTER_PRODUCT或1。</li></ul> </div></div></div> </td> </tr> <tr><td class="cellrowborder" valign="top" width="22.220000000000002%"><p>enableDoubleCache</p> </td> <td class="cellrowborder" valign="top" width="18.18%"><p>bool</p> </td> <td class="cellrowborder" valign="top" width="59.599999999999994%"><p>开启IBShare模板后，在L1上是否同时缓存两块数据。注意，需要控制base块大小，防止两块缓存超过L1大小限制。参数取值如下。</p> <ul><li>false：L1上同时缓存一块数据（默认值）。</li><li>true：使能L1上同时缓存两块数据。</li></ul> </td> </tr>  </tbody></table></div> </div>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><caption><b>表9 </b>MatmulCallBackFunc回调函数接口及参数说明</caption><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.4.10.2.4.1.1" valign="top" width="13.270000000000001%"><p>回调函数功能</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.4.10.2.4.1.2" valign="top" width="36.730000000000004%"><p>回调函数接口</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.4.10.2.4.1.3" valign="top" width="50%"><p>参数说明</p> </th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="13.270000000000001%"><p>可自定义设置不同的搬出数据片段数目等参数，实现将Matmul计算结果从CO1搬出到GM的功能</p> </td> <td class="cellrowborder" valign="top" width="36.730000000000004%"><p>void DataCopyOut(const __gm__ void *gm, const LocalTensor&lt;int8_t&gt; &amp;co1Local, const void *dataCopyOutParams, const uint64_t tilingPtr, const uint64_t dataPtr)</p> </td> <td class="cellrowborder" valign="top" width="50%"><p>gm：输出的GM地址。</p> <p>co1Local：CO1上的计算结果。</p> <p>dataCopyOutParams：</p> <p>Matmul定义的DataCopyOutParams结构体指针，供开发者参考使用。</p> <div _ngcontent-vpm-c106="" class="highlight-div"><div _ngcontent-vpm-c106="" class="highlight-div-header"><div _ngcontent-vpm-c106="" class="highlight-div-header-left"><div _ngcontent-vpm-c106="" class="handle-button expand-button"><div _ngcontent-vpm-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-vpm-c106="" class="highlight-div-header-right"><div _ngcontent-vpm-c106="" class="handle-button ai-button"></div><div _ngcontent-vpm-c106="" class="handle-button line-button"><div _ngcontent-vpm-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-vpm-c106="" class="handle-button theme-button"><div _ngcontent-vpm-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-vpm-c106="" class="handle-button copy-button"><div _ngcontent-vpm-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-vpm-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DataCopyOutParams</span> {</li><li><span class="hljs-type">uint16_t</span> cBurstNum; <span class="hljs-comment">// 传输数据片段数目</span></li><li><span class="hljs-type">uint16_t</span> burstLen; <span class="hljs-comment">// 连续传输数据片段长度</span></li><li><span class="hljs-type">uint16_t</span> srcStride;<span class="hljs-comment">// 源tensor相邻连续数据片段间隔</span></li><li><span class="hljs-type">uint32_t</span> dstStride; <span class="hljs-comment">// 目的tensor相邻连续数据片段间隔</span></li><li><span class="hljs-type">uint16_t</span> oriNSize; <span class="hljs-comment">// NZ转ND时，源tensorN方向大小</span></li><li><span class="hljs-type">bool</span> enUnitFlag; <span class="hljs-comment">// 是否使能UnitFlag</span></li><li><span class="hljs-type">uint64_t</span> quantScalar; <span class="hljs-comment">// 量化场景下量化Scalar的值</span></li><li><span class="hljs-type">uint64_t</span> cbufWorkspaceAddr; <span class="hljs-comment">// 量化场景下量化Tensor地址</span></li><li>}</li></ol></pre></div></div> <p>tilingPtr：开发者使用SetUserDefInfo设置的tiling参数地址。</p> <p>dataPtr：开发者使用SetSelfDefineData设置的计算数据地址。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="13.270000000000001%"><p>可自定义左矩阵搬入首地址、搬运块位置、搬运块大小，实现左矩阵从GM搬入L1的功能</p> </td> <td class="cellrowborder" valign="top" width="36.730000000000004%"><p>void CopyA1(const LocalTensor&lt;int8_t&gt; &amp;aMatrix, const __gm__ void *gm, int row, int col, int useM, int useK, const uint64_t tilingPtr, const uint64_t dataPtr)</p> </td> <td class="cellrowborder" valign="top" width="50%"><p>aMatrix：目标L1Buffer地址。</p> <p>gm：左矩阵GM首地址。</p> <p>row、col：搬运块左上角坐标在左矩阵中的位置。</p> <p>useM、useK：搬运块M、K方向大小。</p> <p>tilingPtr：开发者使用SetUserDefInfo设置的tiling参数地址。</p> <p>dataPtr：开发者使用SetSelfDefineData设置的计算数据地址。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="13.270000000000001%"><p>可自定义右矩阵搬入首地址、搬运块位置、搬运块大小，实现右矩阵从GM搬入L1的功能</p> </td> <td class="cellrowborder" valign="top" width="36.730000000000004%"><p>void CopyB1(const LocalTensor&lt;int8_t&gt; &amp;bMatrix, const __gm__ void *gm, int row, int col, int useK, int useN, const uint64_t tilingPtr, const uint64_t dataPtr)</p> </td> <td class="cellrowborder" valign="top" width="50%"><p>bMatrix：目标L1Buffer地址。</p> <p>gm：右矩阵GM首地址。</p> <p>row、col：搬运块左上角坐标在右矩阵中的位置。</p> <p>useK、useN：搬运块K、N方向大小。</p> <p>tilingPtr：开发者使用SetUserDefInfo设置的tiling参数地址。</p> <p>dataPtr：开发者使用SetSelfDefineData设置的计算数据地址。</p> </td> </tr>  </tbody></table></div> </div>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><caption><b>表10 </b>MatmulApiStaticTiling常量化Tiling参数说明</caption><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.4.11.2.4.1.1" valign="top" width="16.16161616161616%"><p>参数</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.4.11.2.4.1.2" valign="top" width="34.34343434343434%"><p>数据类型</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.4.11.2.4.1.3" valign="top" width="49.494949494949495%"><p>说明</p> </th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="16.16161616161616%"><p>M, N, Ka, Kb,</p> <p>singleCoreM, singleCoreN, singleCoreK,</p> <p>baseM, baseN, baseK,</p> <p>depthA1, depthB1,</p> <p>stepM， stepN，stepKa，stepKb,</p> <p>isBias,</p> <p>transLength,</p> <p>iterateOrder,</p> <p>dbL0A, dbL0B,</p> <p>dbL0C,</p> <p>shareMode,</p> <p>shareL1Size,</p> <p>shareL0CSize,</p> <p>shareUbSize,</p> <p>batchM,</p> <p>batchN,</p> <p>singleBatchM,</p> <p>singleBatchN</p> </td> <td class="cellrowborder" valign="top" width="34.34343434343434%"><p>int</p> </td> <td class="cellrowborder" valign="top" width="49.494949494949495%"><p>与TCubeTiling结构体结构体中各同名参数含义一致。本结构体中的参数是常量化后的常数值。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="16.16161616161616%"><p>cfg</p> </td> <td class="cellrowborder" valign="top" width="34.34343434343434%"><p><a href="/consumer/cn/doc/harmonyos-guides/cannkit-template-parameters#section7983164315613">参数说明</a>下的表2</p> </td> <td class="cellrowborder" valign="top" width="49.494949494949495%"><p>Matmul模板的参数配置。</p> </td> </tr>  </tbody></table></div> </div> </div> <div class="tiledSection"><h2 id="section142411944105611">返回值<i class="anchor-icon anchor-icon-link" anchorid="section142411944105611" tips="复制节点链接"></i></h2><p>无</p> </div> <div class="tiledSection"><h2 id="section18241154495615">支持的型号<i class="anchor-icon anchor-icon-link" anchorid="section18241154495615" tips="复制节点链接"></i></h2><p>Kirin9020系列处理器</p> <p>KirinX90系列处理器</p> </div> <div class="tiledSection"><h2 id="section162422443565">注意事项<i class="anchor-icon anchor-icon-link" anchorid="section162422443565" tips="复制节点链接"></i></h2><p>无</p> </div> <div class="tiledSection"><h2 id="section324204425616">调用示例<i class="anchor-icon anchor-icon-link" anchorid="section324204425616" tips="复制节点链接"></i></h2><div _ngcontent-vpm-c106="" class="highlight-div"><div _ngcontent-vpm-c106="" class="highlight-div-header"><div _ngcontent-vpm-c106="" class="highlight-div-header-left"><div _ngcontent-vpm-c106="" class="handle-button expand-button"><div _ngcontent-vpm-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-vpm-c106="" class="highlight-div-header-right"><div _ngcontent-vpm-c106="" class="handle-button ai-button"></div><div _ngcontent-vpm-c106="" class="handle-button line-button"><div _ngcontent-vpm-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-vpm-c106="" class="handle-button theme-button"><div _ngcontent-vpm-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-vpm-c106="" class="handle-button copy-button"><div _ngcontent-vpm-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-vpm-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// 开发者自定义回调函数 </span></li><li><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DataCopyOut</span><span class="hljs-params">(<span class="hljs-type">const</span> __gm__ <span class="hljs-type">void</span> *gm, <span class="hljs-type">const</span> LocalTensor&lt;<span class="hljs-type">int8_t</span>&gt; &amp;co1Local, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *dataCopyOutParams, <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> tilingPtr, <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> dataPtr)</span></span>; </li><li><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CopyA1</span><span class="hljs-params">(<span class="hljs-type">const</span> AscendC::LocalTensor&lt;<span class="hljs-type">int8_t</span>&gt; &amp;aMatrix, <span class="hljs-type">const</span> __gm__ <span class="hljs-type">void</span> *gm, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">int</span> useM, <span class="hljs-type">int</span> useK, <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> tilingPtr, <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> dataPtr)</span></span>; </li><li><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CopyB1</span><span class="hljs-params">(<span class="hljs-type">const</span> AscendC::LocalTensor&lt;<span class="hljs-type">int8_t</span>&gt; &amp;bMatrix, <span class="hljs-type">const</span> __gm__ <span class="hljs-type">void</span> *gm, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, <span class="hljs-type">int</span> useK, <span class="hljs-type">int</span> useN, <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> tilingPtr, <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> dataPtr)</span></span>; </li><li> </li><li><span class="hljs-keyword">typedef</span> matmul::MatmulType&lt;AscendC::TPosition::GM, CubeFormat::ND, half&gt; aType;  </li><li><span class="hljs-keyword">typedef</span> matmul::MatmulType&lt;AscendC::TPosition::GM, CubeFormat::ND, half&gt; bType;  </li><li><span class="hljs-keyword">typedef</span> matmul::MatmulType&lt;AscendC::TPosition::GM, CubeFormat::ND, <span class="hljs-type">float</span>&gt; cType;  </li><li><span class="hljs-keyword">typedef</span> matmul::MatmulType&lt;AscendC::TPosition::GM, CubeFormat::ND, <span class="hljs-type">float</span>&gt; biasType;  </li><li>matmul::Matmul&lt;aType, bType, cType, biasType, CFG_MDL&gt; mm1;  </li><li>matmul::MatmulConfig mmConfig{<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>, <span class="hljs-number">64</span>}; </li><li>mmConfig.enUnitFlag = <span class="hljs-literal">false</span>; </li><li>matmul::Matmul&lt;aType, bType, cType, biasType, mmConfig&gt; mm2; </li><li>matmul::Matmul&lt;aType, bType, cType, biasType, CFG_NORM, matmul::MatmulCallBackFunc&lt;DataCopyOut, CopyA1, CopyB1&gt;&gt; mm3;</li></ol></pre></div></div> </div> </div> <div></div></div>