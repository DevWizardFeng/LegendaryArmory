<h1 _ngcontent-uxd-c119="" class="doc-title ng-star-inserted" title="Node-API开发规范"> Node-API开发规范 </h1>

<div _ngcontent-uxd-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;"> <div> <div class="tiledSection"><h2 id="获取js传入参数及其数量">获取JS传入参数及其数量<i class="anchor-icon anchor-icon-link" anchorid="获取js传入参数及其数量" tips="复制节点链接"></i></h2><p><strong>【规则】</strong> 当传入napi_get_cb_info的argv不为nullptr时，argv的长度必须大于等于传入argc声明的大小。</p> <p>当argv不为nullptr时，napi_get_cb_info会根据argc声明的数量将JS实际传入的参数写入argv。如果argc小于等于实际JS传入参数的数量，该接口仅会将声明的argc数量的参数写入argv；而当argc大于实际参数数量时，该接口会在argv的尾部填充undefined。</p> <p><strong>错误示例</strong></p> <div _ngcontent-uxd-c106="" class="highlight-div"><div _ngcontent-uxd-c106="" class="highlight-div-header"><div _ngcontent-uxd-c106="" class="highlight-div-header-left"><div _ngcontent-uxd-c106="" class="handle-button expand-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-uxd-c106="" class="highlight-div-header-right"><div _ngcontent-uxd-c106="" class="handle-button ai-button"></div><div _ngcontent-uxd-c106="" class="handle-button line-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-uxd-c106="" class="handle-button theme-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-uxd-c106="" class="handle-button copy-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-uxd-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-function"><span class="hljs-type">static</span> napi_value <span class="hljs-title">IncorrectDemo1</span><span class="hljs-params">(napi_env env, napi_callback_info info)</span> </span>{</li><li>    <span class="hljs-comment">// argc 未正确的初始化，其值为不确定的随机值，导致 argv 的长度可能小于 argc 声明的数量，数据越界。</span></li><li>    <span class="hljs-type">size_t</span> argc;</li><li>    napi_value argv[<span class="hljs-number">10</span>] = {<span class="hljs-literal">nullptr</span>};</li><li>    <span class="hljs-built_in">napi_get_cb_info</span>(env, info, &amp;argc, argv, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);</li><li>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;</li><li>}</li><li>
</li><li><span class="hljs-function"><span class="hljs-type">static</span> napi_value <span class="hljs-title">IncorrectDemo2</span><span class="hljs-params">(napi_env env, napi_callback_info info)</span> </span>{</li><li>    <span class="hljs-comment">// argc 声明的数量大于 argv 实际初始化的长度，导致 napi_get_cb_info 接口在写入 argv 时数据越界。</span></li><li>    <span class="hljs-type">size_t</span> argc = <span class="hljs-number">5</span>;</li><li>    napi_value argv[<span class="hljs-number">3</span>] = {<span class="hljs-literal">nullptr</span>};</li><li>    <span class="hljs-built_in">napi_get_cb_info</span>(env, info, &amp;argc, argv, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);</li><li>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;</li><li>}</li></ol></pre></div></div> <p><strong>正确示例</strong></p> <div _ngcontent-uxd-c106="" class="highlight-div"><div _ngcontent-uxd-c106="" class="highlight-div-header"><div _ngcontent-uxd-c106="" class="highlight-div-header-left"><div _ngcontent-uxd-c106="" class="handle-button expand-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-uxd-c106="" class="highlight-div-header-right"><div _ngcontent-uxd-c106="" class="handle-button ai-button"></div><div _ngcontent-uxd-c106="" class="handle-button line-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-uxd-c106="" class="handle-button theme-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-uxd-c106="" class="handle-button copy-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-uxd-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-function"><span class="hljs-type">static</span> napi_value <span class="hljs-title">GetArgvDemo1</span><span class="hljs-params">(napi_env env, napi_callback_info info)</span> </span>{</li><li>    <span class="hljs-type">size_t</span> argc = <span class="hljs-number">0</span>;</li><li>    <span class="hljs-comment">// argv 传入 nullptr 来获取传入参数真实数量</span></li><li>    <span class="hljs-built_in">napi_get_cb_info</span>(env, info, &amp;argc, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);</li><li>    <span class="hljs-comment">// JS 传入参数为0，不执行后续逻辑</span></li><li>    <span class="hljs-keyword">if</span> (argc == <span class="hljs-number">0</span>) {</li><li>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;</li><li>    }</li><li>    <span class="hljs-comment">// 创建数组用以获取JS传入的参数</span></li><li>    napi_value* argv = <span class="hljs-keyword">new</span> napi_value[argc];</li><li>    <span class="hljs-built_in">napi_get_cb_info</span>(env, info, &amp;argc, argv, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);</li><li>    <span class="hljs-comment">// 业务代码</span></li><li>    <span class="hljs-comment">// ... ...</span></li><li>    <span class="hljs-comment">// argv 为 new 创建的对象，在使用完成后手动释放</span></li><li>    <span class="hljs-keyword">delete</span>[] argv;</li><li>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;</li><li>}</li><li>
</li><li><span class="hljs-function"><span class="hljs-type">static</span> napi_value <span class="hljs-title">GetArgvDemo2</span><span class="hljs-params">(napi_env env, napi_callback_info info)</span> </span>{</li><li>    <span class="hljs-type">size_t</span> argc = <span class="hljs-number">2</span>;</li><li>    napi_value argv[<span class="hljs-number">2</span>] = {<span class="hljs-literal">nullptr</span>};</li><li>    <span class="hljs-comment">// napi_get_cb_info 会向 argv 中写入 argc 个 JS 传入参数或 undefined</span></li><li>    <span class="hljs-built_in">napi_get_cb_info</span>(env, info, &amp;argc, argv, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);</li><li>    <span class="hljs-comment">// 业务代码</span></li><li>    <span class="hljs-comment">// ... ...</span></li><li>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;</li><li>}</li></ol></pre></div></div> </div>  <div class="tiledSection"><h2 id="生命周期管理">生命周期管理<i class="anchor-icon anchor-icon-link" anchorid="生命周期管理" tips="复制节点链接"></i></h2><p><strong>【规则】</strong> 合理使用napi_open_handle_scope和napi_close_handle_scope管理napi_value的生命周期，做到生命周期最小化，避免发生内存泄漏问题。</p> <p>每个napi_value属于特定的HandleScope，HandleScope通过napi_open_handle_scope和napi_close_handle_scope来建立和关闭，HandleScope关闭后，所属的napi_value就会自动释放。</p> <p><strong>正确示例</strong>：</p> <div _ngcontent-uxd-c106="" class="highlight-div"><div _ngcontent-uxd-c106="" class="highlight-div-header"><div _ngcontent-uxd-c106="" class="highlight-div-header-left"><div _ngcontent-uxd-c106="" class="handle-button expand-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-uxd-c106="" class="highlight-div-header-right"><div _ngcontent-uxd-c106="" class="handle-button ai-button"></div><div _ngcontent-uxd-c106="" class="handle-button line-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-uxd-c106="" class="handle-button theme-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-uxd-c106="" class="handle-button copy-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-uxd-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// 在for循环中频繁调用napi接口创建js对象时，要加handle_scope及时释放不再使用的资源。</span></li><li><span class="hljs-comment">// 下面例子中，每次循环结束局部变量res的生命周期已结束，因此加scope及时释放其持有的js对象，防止内存泄漏</span></li><li><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) {</li><li>    napi_handle_scope scope = <span class="hljs-literal">nullptr</span>;</li><li>    <span class="hljs-built_in">napi_open_handle_scope</span>(env, &amp;scope);</li><li>    <span class="hljs-keyword">if</span> (scope == <span class="hljs-literal">nullptr</span>) {</li><li>        <span class="hljs-keyword">return</span>;</li><li>    }</li><li>    napi_value res;</li><li>    <span class="hljs-built_in">napi_create_object</span>(env, &amp;res);</li><li>    <span class="hljs-built_in">napi_close_handle_scope</span>(env, scope);</li><li>}</li></ol></pre></div></div> </div>  <div class="tiledSection"><h2 id="上下文敏感">上下文敏感<i class="anchor-icon anchor-icon-link" anchorid="上下文敏感" tips="复制节点链接"></i></h2><p><strong>【规则】</strong> 多引擎实例场景下，禁止通过Node-API跨引擎实例访问JS对象。</p> <p>引擎实例是一个独立运行环境，JS对象创建访问等操作必须在同一个引擎实例中进行。若在不同引擎实例中操作同一个对象，可能会引发程序崩溃。引擎实例在接口中体现为napi_env。</p> <p><strong>错误示例</strong>：</p> <div _ngcontent-uxd-c106="" class="highlight-div"><div _ngcontent-uxd-c106="" class="highlight-div-header"><div _ngcontent-uxd-c106="" class="highlight-div-header-left"><div _ngcontent-uxd-c106="" class="handle-button expand-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-uxd-c106="" class="highlight-div-header-right"><div _ngcontent-uxd-c106="" class="handle-button ai-button"></div><div _ngcontent-uxd-c106="" class="handle-button line-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-uxd-c106="" class="handle-button theme-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-uxd-c106="" class="handle-button copy-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-uxd-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// 线程1执行，在env1创建string对象，值为"bar"、</span></li><li><span class="hljs-built_in">napi_create_string_utf8</span>(env1, <span class="hljs-string">"bar"</span>, NAPI_AUTO_LENGTH, &amp;string);</li><li><span class="hljs-comment">// 线程2执行，在env2创建object对象，并将上述的string对象设置到object对象中</span></li><li>napi_status status = <span class="hljs-built_in">napi_create_object</span>(env2, &amp;object);</li><li><span class="hljs-keyword">if</span> (status != napi_ok) {</li><li>    <span class="hljs-built_in">napi_throw_error</span>(env, ...);</li><li>    <span class="hljs-keyword">return</span>;</li><li>}</li><li>
</li><li>status = <span class="hljs-built_in">napi_set_named_property</span>(env2, object, <span class="hljs-string">"foo"</span>, string);</li><li><span class="hljs-keyword">if</span> (status != napi_ok) {</li><li>    <span class="hljs-built_in">napi_throw_error</span>(env, ...);</li><li>    <span class="hljs-keyword">return</span>;</li><li>}</li></ol></pre></div></div> <p>所有的JS对象都隶属于具体的某一napi_env，不可将env1的对象，设置到env2中的对象中。在env2中一旦访问到env1的对象，程序可能会发生崩溃。</p> </div>  <div class="tiledSection"><h2 id="异常处理">异常处理<i class="anchor-icon anchor-icon-link" anchorid="异常处理" tips="复制节点链接"></i></h2><p><strong>【建议】</strong> Node-API接口调用发生异常需要及时处理，不能遗漏异常到后续逻辑，否则程序可能发生不可预期行为。</p> <p><strong>正确示例</strong>：</p> <div _ngcontent-uxd-c106="" class="highlight-div"><div _ngcontent-uxd-c106="" class="highlight-div-header"><div _ngcontent-uxd-c106="" class="highlight-div-header-left"><div _ngcontent-uxd-c106="" class="handle-button expand-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-uxd-c106="" class="highlight-div-header-right"><div _ngcontent-uxd-c106="" class="handle-button ai-button"></div><div _ngcontent-uxd-c106="" class="handle-button line-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-uxd-c106="" class="handle-button theme-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-uxd-c106="" class="handle-button copy-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-uxd-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// 1.创建对象</span></li><li>napi_status status = <span class="hljs-built_in">napi_create_object</span>(env, &amp;object);</li><li><span class="hljs-keyword">if</span> (status != napi_ok) {</li><li>    <span class="hljs-built_in">napi_throw_error</span>(env, ...);</li><li>    <span class="hljs-keyword">return</span>;</li><li>}</li><li><span class="hljs-comment">// 2.创建属性值</span></li><li>status = <span class="hljs-built_in">napi_create_string_utf8</span>(env, <span class="hljs-string">"bar"</span>, NAPI_AUTO_LENGTH, &amp;string);</li><li><span class="hljs-keyword">if</span> (status != napi_ok) {</li><li>    <span class="hljs-built_in">napi_throw_error</span>(env, ...);</li><li>    <span class="hljs-keyword">return</span>;</li><li>}</li><li><span class="hljs-comment">// 3.将步骤2的结果设置为对象object属性foo的值</span></li><li>status = <span class="hljs-built_in">napi_set_named_property</span>(env, object, <span class="hljs-string">"foo"</span>, string);</li><li><span class="hljs-keyword">if</span> (status != napi_ok) {</li><li>    <span class="hljs-built_in">napi_throw_error</span>(env, ...);</li><li>    <span class="hljs-keyword">return</span>;</li><li>}</li></ol></pre></div></div> <p>如上示例中，步骤1或者步骤2出现异常时，步骤3都不会正常进行。只有当方法的返回值是napi_ok时，才能保持继续正常运行；否则后续流程可能会出现不可预期的行为。</p> </div>  <div class="tiledSection"><h2 id="异步任务">异步任务<i class="anchor-icon anchor-icon-link" anchorid="异步任务" tips="复制节点链接"></i></h2><p><strong>【规则】</strong> 当使用uv_queue_work方法将任务抛到JS线程上面执行的时候，对JS线程的回调方法，一般情况下需要加上napi_handle_scope来管理回调方法创建的napi_value的生命周期。</p> <p>使用uv_queue_work方法，不会走Node-API框架，此时需要开发者自己合理使用napi_handle_scope来管理napi_value的生命周期。</p> <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"> <p>本规则旨在强调napi_value生命周期情况，若只想往JS线程抛任务，<strong>不推荐</strong>使用uv_queue_work方法。如有抛任务的需要，请使用<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/use-napi-thread-safety">napi_threadsafe_function系列</a>接口。</p>  </div></div></div> <p><strong>正确示例</strong>：</p> <div _ngcontent-uxd-c106="" class="highlight-div"><div _ngcontent-uxd-c106="" class="highlight-div-header"><div _ngcontent-uxd-c106="" class="highlight-div-header-left"><div _ngcontent-uxd-c106="" class="handle-button expand-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-uxd-c106="" class="highlight-div-header-right"><div _ngcontent-uxd-c106="" class="handle-button ai-button"></div><div _ngcontent-uxd-c106="" class="handle-button line-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-uxd-c106="" class="handle-button theme-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-uxd-c106="" class="handle-button copy-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-uxd-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CallbackTest</span><span class="hljs-params">(CallbackContext* context)</span></span></li><li><span class="hljs-function"></span>{</li><li>    uv_loop_s* loop = <span class="hljs-literal">nullptr</span>;</li><li>    <span class="hljs-built_in">napi_get_uv_event_loop</span>(context-&gt;env, &amp;loop);</li><li>    <span class="hljs-type">uv_work_t</span>* work = <span class="hljs-keyword">new</span> <span class="hljs-type">uv_work_t</span>;</li><li>    context-&gt;retData = <span class="hljs-number">1</span>;</li><li>    work-&gt;data = (<span class="hljs-type">void</span>*)context;</li><li>    <span class="hljs-built_in">uv_queue_work</span>(</li><li>        loop, work,</li><li>        <span class="hljs-comment">// 请注意，uv_queue_work会创建一个线程并执行该回调函数，若开发者只想往JS线程抛任务，不推荐使用uv_queue_work，以避免冗余的线程创建</span></li><li>        [](<span class="hljs-type">uv_work_t</span>* work) {</li><li>            <span class="hljs-comment">// 执行一些业务逻辑</span></li><li>        },</li><li>        <span class="hljs-comment">// 该回调会执行在loop所在的JS线程上</span></li><li>        [](<span class="hljs-type">uv_work_t</span>* work, <span class="hljs-type">int</span> status) {</li><li>            CallbackContext* context = (CallbackContext*)work-&gt;data;</li><li>            napi_handle_scope scope = <span class="hljs-literal">nullptr</span>;</li><li>            <span class="hljs-built_in">napi_open_handle_scope</span>(context-&gt;env, &amp;scope);</li><li>            <span class="hljs-keyword">if</span> (scope == <span class="hljs-literal">nullptr</span>) {</li><li>                <span class="hljs-keyword">if</span> (work != <span class="hljs-literal">nullptr</span>) {</li><li>                    <span class="hljs-keyword">delete</span> work;</li><li>                }</li><li>                <span class="hljs-keyword">return</span>;</li><li>            }</li><li>            napi_value callback = <span class="hljs-literal">nullptr</span>;</li><li>            <span class="hljs-built_in">napi_get_reference_value</span>(context-&gt;env, context-&gt;callbackRef, &amp;callback);</li><li>            napi_value retArg;</li><li>            <span class="hljs-built_in">napi_create_int32</span>(context-&gt;env, context-&gt;retData, &amp;retArg);</li><li>            napi_value ret;</li><li>            <span class="hljs-built_in">napi_call_function</span>(context-&gt;env, <span class="hljs-literal">nullptr</span>, callback, <span class="hljs-number">1</span>, &amp;retArg, &amp;ret);</li><li>            <span class="hljs-built_in">napi_delete_reference</span>(context-&gt;env, context-&gt;callbackRef);</li><li>            <span class="hljs-built_in">napi_close_handle_scope</span>(context-&gt;env, scope);</li><li>            <span class="hljs-keyword">if</span> (work != <span class="hljs-literal">nullptr</span>) {</li><li>                <span class="hljs-keyword">delete</span> work;</li><li>            }</li><li>            <span class="hljs-keyword">delete</span> context;</li><li>        }</li><li>    );</li><li>}</li></ol></pre></div></div> </div>  <div class="tiledSection"><h2 id="对象绑定">对象绑定<i class="anchor-icon anchor-icon-link" anchorid="对象绑定" tips="复制节点链接"></i></h2><p><strong>【规则】</strong> 使用napi_wrap接口，如果最后一个参数result传递不为nullptr，需要开发者在合适的时机调用napi_remove_wrap函数主动删除创建的napi_ref。</p> <p>napi_wrap接口定义如下：</p> <div _ngcontent-uxd-c106="" class="highlight-div"><div _ngcontent-uxd-c106="" class="highlight-div-header"><div _ngcontent-uxd-c106="" class="highlight-div-header-left"><div _ngcontent-uxd-c106="" class="handle-button expand-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-uxd-c106="" class="highlight-div-header-right"><div _ngcontent-uxd-c106="" class="handle-button ai-button"></div><div _ngcontent-uxd-c106="" class="handle-button line-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-uxd-c106="" class="handle-button theme-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-uxd-c106="" class="handle-button copy-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-uxd-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-built_in">napi_wrap</span>(napi_env env, napi_value js_object, <span class="hljs-type">void</span>* native_object, napi_finalize finalize_cb, <span class="hljs-type">void</span>* finalize_hint, napi_ref* result)</li></ol></pre></div></div> <p>当最后一个参数result不为空时，框架会创建一个napi_ref对象，指向js_object。此时开发者需要自己管理js_object的生命周期，即需要在合适的时机调用napi_remove_wrap删除napi_ref，这样GC才能正常释放js_object，从而触发绑定C++对象native_object的析构函数finalize_cb。</p> <p>一般情况下，根据业务情况最后一个参数result可以直接传递为nullptr。</p> <p><strong>正确示例</strong>：</p> <div _ngcontent-uxd-c106="" class="highlight-div"><div _ngcontent-uxd-c106="" class="highlight-div-header"><div _ngcontent-uxd-c106="" class="highlight-div-header-left"><div _ngcontent-uxd-c106="" class="handle-button expand-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-uxd-c106="" class="highlight-div-header-right"><div _ngcontent-uxd-c106="" class="handle-button ai-button"></div><div _ngcontent-uxd-c106="" class="handle-button line-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-uxd-c106="" class="handle-button theme-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-uxd-c106="" class="handle-button copy-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-uxd-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// 用法1：napi_wrap不需要接收创建的napi_ref，最后一个参数传递nullptr，创建的napi_ref是弱引用，由系统管理，不需要用户手动释放</span></li><li><span class="hljs-built_in">napi_wrap</span>(env, jsobject, nativeObject, cb, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);</li><li>
</li><li><span class="hljs-comment">// 用法2：napi_wrap需要接收创建的napi_ref，最后一个参数不为nullptr，返回的napi_ref是强引用，需要用户手动释放，否则会内存泄漏</span></li><li>napi_ref result;</li><li><span class="hljs-built_in">napi_wrap</span>(env, jsobject, nativeObject, cb, <span class="hljs-literal">nullptr</span>, &amp;result);</li><li><span class="hljs-comment">// 当js_object和result后续不再使用时，及时调用napi_remove_wrap释放result</span></li><li><span class="hljs-type">void</span>* nativeObjectResult = <span class="hljs-literal">nullptr</span>;</li><li><span class="hljs-built_in">napi_remove_wrap</span>(env, jsobject, &amp;nativeObjectResult);</li></ol></pre></div></div> </div>  <div class="tiledSection"><h2 id="高性能数组">高性能数组<i class="anchor-icon anchor-icon-link" anchorid="高性能数组" tips="复制节点链接"></i></h2><p><strong>【建议】</strong> 存储值类型数据时，使用ArrayBuffer代替JSArray来提高应用性能。</p> <p>使用JSArray作为容器储存数据，支持几乎所有的JS数据类型。</p> <p>使用napi_set_element方法对JSArray存储值类型数据（如int32）时，同样会涉及到与运行时的交互，造成不必要的开销。</p> <p>ArrayBuffer进行增改是直接对缓冲区进行更改，具有远优于使用napi_set_element操作JSArray的性能表现。</p> <p>因此此种场景下，更推荐使用napi_create_arraybuffer接口创建的ArrayBuffer对象。</p> <p><strong>示例：</strong></p> <div _ngcontent-uxd-c106="" class="highlight-div"><div _ngcontent-uxd-c106="" class="highlight-div-header"><div _ngcontent-uxd-c106="" class="highlight-div-header-left"><div _ngcontent-uxd-c106="" class="handle-button expand-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-uxd-c106="" class="highlight-div-header-right"><div _ngcontent-uxd-c106="" class="handle-button ai-button"></div><div _ngcontent-uxd-c106="" class="handle-button line-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-uxd-c106="" class="handle-button theme-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-uxd-c106="" class="handle-button copy-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-uxd-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// 以下代码使用常规JSArray作为容器，但其仅存储int32类型数据。</span></li><li><span class="hljs-comment">// 但因为是JS对象，因此只能使用napi方法对其进行增改，性能较低。</span></li><li><span class="hljs-function"><span class="hljs-type">static</span> napi_value <span class="hljs-title">ArrayDemo</span><span class="hljs-params">(napi_env env, napi_callback_info info)</span></span></li><li><span class="hljs-function"></span>{</li><li>    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">size_t</span> arrSize = <span class="hljs-number">1000</span>;</li><li>    napi_value jsArr = <span class="hljs-literal">nullptr</span>;</li><li>    <span class="hljs-built_in">napi_create_array</span>(env, &amp;jsArr);</li><li>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arrSize; i++) {</li><li>        napi_value arrValue = <span class="hljs-literal">nullptr</span>;</li><li>        <span class="hljs-built_in">napi_create_int32</span>(env, i, &amp;arrValue);</li><li>        <span class="hljs-comment">// 常规JSArray使用napi方法对array进行读写，性能较差。</span></li><li>        <span class="hljs-built_in">napi_set_element</span>(env, jsArr, i, arrValue);</li><li>    }</li><li>    <span class="hljs-keyword">return</span> jsArr;</li><li>}</li><li>
</li><li><span class="hljs-comment">// 推荐写法：</span></li><li><span class="hljs-comment">// 同样以int32类型数据为例，但以下代码使用ArrayBuffer作为容器。</span></li><li><span class="hljs-comment">// 因此可以使用C/C++的方法直接对缓冲区进行增改。</span></li><li><span class="hljs-function"><span class="hljs-type">static</span> napi_value <span class="hljs-title">ArrayBufferDemo</span><span class="hljs-params">(napi_env env, napi_callback_info info)</span></span></li><li><span class="hljs-function"></span>{</li><li>    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">size_t</span> arrSize = <span class="hljs-number">1000</span>;</li><li>    napi_value arrBuffer = <span class="hljs-literal">nullptr</span>;</li><li>    <span class="hljs-type">void</span>* data = <span class="hljs-literal">nullptr</span>;</li><li>
</li><li>    <span class="hljs-built_in">napi_create_arraybuffer</span>(env, arrSize * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int32_t</span>), &amp;data, &amp;arrBuffer);</li><li>    <span class="hljs-comment">// data为空指针，取消对data进行写入</span></li><li>    <span class="hljs-keyword">if</span> (data == <span class="hljs-literal">nullptr</span>) {</li><li>        <span class="hljs-keyword">return</span> arrBuffer;</li><li>    }</li><li>    <span class="hljs-type">int32_t</span>* i32Buffer = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">int32_t</span>*&gt;(data);</li><li>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arrSize; i++) {</li><li>        <span class="hljs-comment">// arrayBuffer直接对缓冲区进行修改，跳过运行时，</span></li><li>        <span class="hljs-comment">// 与操作原生C/C++对象性能相当</span></li><li>        i32Buffer[i] = i;</li><li>    }</li><li>
</li><li>    <span class="hljs-keyword">return</span> arrBuffer;</li><li>}</li></ol></pre></div></div> <p>napi_create_arraybuffer等同于JS代码中的new ArrayBuffer(size)，其生成的对象不可直接在TS/JS中进行读取，需要将其包装为TypedArray或DataView后方可进行读写。</p> <p><strong>基准性能测试结果如下：</strong></p> <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"> <p>以下数据为千次循环写入累计数据，为更好的体现出差异，已对设备核心频率进行限制。</p>  </div></div></div>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.7.12.1.3.1.1" valign="top" width="50%">容器类型</th> <th align="left" class="cellrowborder" id="mcps1.3.7.12.1.3.1.2" valign="top" width="50%">Benchmark数据（us）</th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="50%">JSArray</td> <td class="cellrowborder" valign="top" width="50%">1566.174</td> </tr> <tr><td class="cellrowborder" valign="top" width="50%">ArrayBuffer</td> <td class="cellrowborder" valign="top" width="50%">3.609</td> </tr>  </tbody></table></div> </div> </div>  <div class="tiledSection"><h2 id="数据转换">数据转换<i class="anchor-icon anchor-icon-link" anchorid="数据转换" tips="复制节点链接"></i></h2><p><strong>【建议】</strong> 尽可能的减少数据转换次数，避免不必要的复制。</p> <ul><li><strong>减少数据转换次数：</strong> 频繁的数据转换可能会导致性能下降，可以通过批量处理数据或者使用更高效的数据结构来优化性能。</li><li><strong>避免不必要的数据复制：</strong> 在进行数据转换时，可以使用Node-API提供的接口来直接访问原始数据，而不是创建新的副本。</li><li><strong>使用缓存：</strong> 如果某些数据在多次转换中都会被使用到，可以考虑使用缓存来避免重复的数据转换。缓存可以减少不必要的计算，提高性能。</li></ul> </div>  <div class="tiledSection"><h2 id="模块注册与模块命名">模块注册与模块命名<i class="anchor-icon anchor-icon-link" anchorid="模块注册与模块命名" tips="复制节点链接"></i></h2><p><strong>【规则】</strong></p> <p>nm_register_func对应的函数需要加上修饰符static，防止与其他二进制so文件里的符号冲突。</p> <p>模块注册的入口，即使用__attribute__((constructor))修饰函数的函数名需要确保与其他模块不同。</p> <p>模块实现中.nm_modname字段需要与二进制so文件的名字完全匹配，区分大小写。</p> <p><strong>错误示例</strong></p> <p>以下代码为二进制so文件的名为nativerender时的错误示例</p> <div _ngcontent-uxd-c106="" class="highlight-div"><div _ngcontent-uxd-c106="" class="highlight-div-header"><div _ngcontent-uxd-c106="" class="highlight-div-header-left"><div _ngcontent-uxd-c106="" class="handle-button expand-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-uxd-c106="" class="highlight-div-header-right"><div _ngcontent-uxd-c106="" class="handle-button ai-button"></div><div _ngcontent-uxd-c106="" class="handle-button line-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-uxd-c106="" class="handle-button theme-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-uxd-c106="" class="handle-button copy-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-uxd-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-function">EXTERN_C_START</span></li><li><span class="hljs-function">napi_value <span class="hljs-title">Init</span><span class="hljs-params">(napi_env env, napi_value exports)</span></span></li><li><span class="hljs-function"></span>{</li><li>    <span class="hljs-comment">// ...</span></li><li>    <span class="hljs-keyword">return</span> exports;</li><li>}</li><li>EXTERN_C_END</li><li>
</li><li><span class="hljs-type">static</span> napi_module nativeModule = {</li><li>    .nm_version = <span class="hljs-number">1</span>,</li><li>    .nm_flags = <span class="hljs-number">0</span>,</li><li>    .nm_filename = <span class="hljs-literal">nullptr</span>,</li><li>    <span class="hljs-comment">// 没有在nm_register_func对应的函数加上static</span></li><li>    .nm_register_func = Init,</li><li>    <span class="hljs-comment">// 模块实现中.nm_modname字段没有与模块名完全匹配，会导致多线程场景模块加载失败</span></li><li>    .nm_modname = <span class="hljs-string">"entry"</span>,</li><li>    .nm_priv = <span class="hljs-literal">nullptr</span>,</li><li>    .reserved = { <span class="hljs-number">0</span> },</li><li>};</li><li>
</li><li><span class="hljs-comment">// 模块注册的入口函数名为RegisterModule，容易与其他模块重复</span></li><li><span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> __attribute__((constructor)) <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RegisterModule</span><span class="hljs-params">()</span></span></li><li><span class="hljs-function"></span>{</li><li>    <span class="hljs-built_in">napi_module_register</span>(&amp;nativeModule);</li><li>}</li></ol></pre></div></div> <p>图一</p> <p><span><img originheight="276" originwidth="589" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211114337.99894569131071972301560826905320:50001231000000:2800:40CB1309B2E285F4E78DB62414012E64856A4CAD93A7369E9192369E3B6295BB.png" width="589" height="276"></span></p> <p>图二</p> <p><span><img originheight="385" originwidth="569" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211114337.57720318849981507685252355735699:50001231000000:2800:D0463249F4EF72020C2370E8D64D49E399B7AC886FECA724599E92B478D183CF.png" width="569" height="385"></span></p> <p><strong>正确示例</strong>：</p> <p>以下代码为模块名为nativerender时的正确示例</p> <div _ngcontent-uxd-c106="" class="highlight-div"><div _ngcontent-uxd-c106="" class="highlight-div-header"><div _ngcontent-uxd-c106="" class="highlight-div-header-left"><div _ngcontent-uxd-c106="" class="handle-button expand-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-uxd-c106="" class="highlight-div-header-right"><div _ngcontent-uxd-c106="" class="handle-button ai-button"></div><div _ngcontent-uxd-c106="" class="handle-button line-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-uxd-c106="" class="handle-button theme-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-uxd-c106="" class="handle-button copy-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-uxd-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-function">EXTERN_C_START</span></li><li><span class="hljs-function"><span class="hljs-type">static</span> napi_value <span class="hljs-title">Init</span><span class="hljs-params">(napi_env env, napi_value exports)</span></span></li><li><span class="hljs-function"></span>{</li><li>    <span class="hljs-comment">// ...</span></li><li>    <span class="hljs-keyword">return</span> exports;</li><li>}</li><li>EXTERN_C_END</li><li>
</li><li><span class="hljs-type">static</span> napi_module nativeModule = {</li><li>    .nm_version = <span class="hljs-number">1</span>,</li><li>    .nm_flags = <span class="hljs-number">0</span>,</li><li>    .nm_filename = <span class="hljs-literal">nullptr</span>,</li><li>    .nm_register_func = Init,</li><li>    .nm_modname = <span class="hljs-string">"nativerender"</span>,</li><li>    .nm_priv = <span class="hljs-literal">nullptr</span>,</li><li>    .reserved = { <span class="hljs-number">0</span> },</li><li>};</li><li>
</li><li><span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> __attribute__((constructor)) <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RegisterNativeRenderModule</span><span class="hljs-params">()</span></span></li><li><span class="hljs-function"></span>{</li><li>    <span class="hljs-built_in">napi_module_register</span>(&amp;nativeModule);</li><li>}</li></ol></pre></div></div> </div>  <div class="tiledSection"><h2 id="dlopen与模块注册">dlopen与模块注册<i class="anchor-icon anchor-icon-link" anchorid="dlopen与模块注册" tips="复制节点链接"></i></h2><p><strong>【规则】</strong></p> <p>如果注册的模块事先有被dlopen，需使用以下方式注册模块。</p> <p>模块需对外导出固定名称为napi_onLoad的函数，在该函数内调用注册函数。napi_onLoad函数只会在ArkTS代码的import语句中被主动调用，从而避免dlopen时提前触发模块的注册。</p> <p><strong>示例</strong></p> <div _ngcontent-uxd-c106="" class="highlight-div"><div _ngcontent-uxd-c106="" class="highlight-div-header"><div _ngcontent-uxd-c106="" class="highlight-div-header-left"><div _ngcontent-uxd-c106="" class="handle-button expand-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-uxd-c106="" class="highlight-div-header-right"><div _ngcontent-uxd-c106="" class="handle-button ai-button"></div><div _ngcontent-uxd-c106="" class="handle-button line-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-uxd-c106="" class="handle-button theme-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-uxd-c106="" class="handle-button copy-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-uxd-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-function">EXTERN_C_START</span></li><li><span class="hljs-function"><span class="hljs-type">static</span> napi_value <span class="hljs-title">Init</span><span class="hljs-params">(napi_env env, napi_value exports)</span></span></li><li><span class="hljs-function"></span>{</li><li>    <span class="hljs-comment">// ...</span></li><li>    <span class="hljs-keyword">return</span> exports;</li><li>}</li><li>EXTERN_C_END</li><li>
</li><li><span class="hljs-type">static</span> napi_module nativeModule = {</li><li>    .nm_version = <span class="hljs-number">1</span>,</li><li>    .nm_flags = <span class="hljs-number">0</span>,</li><li>    .nm_filename = <span class="hljs-literal">nullptr</span>,</li><li>    .nm_register_func = Init,</li><li>    .nm_modname = <span class="hljs-string">"nativerender"</span>,</li><li>    .nm_priv = <span class="hljs-literal">nullptr</span>,</li><li>    .reserved = { <span class="hljs-number">0</span> },</li><li>};</li><li>
</li><li><span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">napi_onLoad</span><span class="hljs-params">()</span></span></li><li><span class="hljs-function"></span>{</li><li>    <span class="hljs-built_in">napi_module_register</span>(&amp;nativeModule);</li><li>}</li></ol></pre></div></div> </div>  <div class="tiledSection"><h2 id="正确的使用napi_create_external系列接口创建的js-object">正确的使用napi_create_external系列接口创建的JS Object<i class="anchor-icon anchor-icon-link" anchorid="正确的使用napi_create_external系列接口创建的js-object" tips="复制节点链接"></i></h2><p><strong>【规则】</strong> napi_create_external系列接口创建出来的JS对象仅允许在当前线程传递和使用，跨线程传递（如使用worker的post_message）将会导致应用crash。若需跨线程传递绑定有Native对象的JS对象，请使用napi_coerce_to_native_binding_object接口绑定JS对象和Native对象。具体API说明详见<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/use-napi-about-object#napi_create_external" target="_blank">API参考</a>。</p> <p><strong>错误示例</strong></p> <div _ngcontent-uxd-c106="" class="highlight-div"><div _ngcontent-uxd-c106="" class="highlight-div-header"><div _ngcontent-uxd-c106="" class="highlight-div-header-left"><div _ngcontent-uxd-c106="" class="handle-button expand-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-uxd-c106="" class="highlight-div-header-right"><div _ngcontent-uxd-c106="" class="handle-button ai-button"></div><div _ngcontent-uxd-c106="" class="handle-button line-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-uxd-c106="" class="handle-button theme-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-uxd-c106="" class="handle-button copy-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-uxd-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">MyFinalizeCB</span><span class="hljs-params">(napi_env env, <span class="hljs-type">void</span> *finalize_data, <span class="hljs-type">void</span> *finalize_hint)</span> </span>{ <span class="hljs-keyword">return</span>; }</li><li>
</li><li><span class="hljs-function"><span class="hljs-type">static</span> napi_value <span class="hljs-title">CreateMyExternal</span><span class="hljs-params">(napi_env env, napi_callback_info info)</span> </span>{</li><li>    napi_value result = <span class="hljs-literal">nullptr</span>;</li><li>    <span class="hljs-built_in">napi_create_external</span>(env, <span class="hljs-literal">nullptr</span>, MyFinalizeCB, <span class="hljs-literal">nullptr</span>, &amp;result);</li><li>    <span class="hljs-keyword">return</span> result;</li><li>}</li><li>
</li><li><span class="hljs-comment">// 此处已省略模块注册的代码，你可能需要自行注册 CreateMyExternal 方法</span></li></ol></pre></div></div> <div _ngcontent-uxd-c106="" class="highlight-div"><div _ngcontent-uxd-c106="" class="highlight-div-header"><div _ngcontent-uxd-c106="" class="highlight-div-header-left"><div _ngcontent-uxd-c106="" class="handle-button expand-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-uxd-c106="" class="highlight-div-header-right"><div _ngcontent-uxd-c106="" class="handle-button ai-button"></div><div _ngcontent-uxd-c106="" class="handle-button line-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-uxd-c106="" class="handle-button theme-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-uxd-c106="" class="handle-button copy-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-uxd-c106="" class="highlight-scroll-div"><pre class="ts prettyprint linenums hljs language-typescript" hw-language="ts" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// index.d.ts</span></li><li><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">createMyExternal</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Object</span>;</li><li>
</li><li><span class="hljs-comment">// 应用代码</span></li><li><span class="hljs-keyword">import</span> testNapi <span class="hljs-keyword">from</span> <span class="hljs-string">'libentry.so'</span>;</li><li><span class="hljs-keyword">import</span> { worker } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.ArkTS'</span>;</li><li>
</li><li><span class="hljs-keyword">const</span> mWorker = <span class="hljs-keyword">new</span> worker.<span class="hljs-title class_">ThreadWorker</span>(<span class="hljs-string">'../workers/Worker'</span>);</li><li>
</li><li>{</li><li>    <span class="hljs-keyword">const</span> mExternalObj = testNapi.<span class="hljs-title function_">createMyExternal</span>();</li><li>
</li><li>    mWorker.<span class="hljs-title function_">postMessage</span>(mExternalObj);</li><li>
</li><li>}</li><li>
</li><li><span class="hljs-comment">// 关闭worker线程</span></li><li><span class="hljs-comment">// 应用可能在此步骤崩溃，或在后续引擎进行GC的时候崩溃</span></li><li>mWorker.<span class="hljs-title function_">terminate</span>();</li><li><span class="hljs-comment">// Worker的实现为默认模板，此处省略</span></li></ol></pre></div></div> </div>  <div class="tiledSection"><h2 id="防止重复释放获取的buffer">防止重复释放获取的buffer<i class="anchor-icon anchor-icon-link" anchorid="防止重复释放获取的buffer" tips="复制节点链接"></i></h2><p><strong>【规则】</strong> 使用napi_get_arraybuffer_info等接口，参数data资源开发者不允许释放，data的生命周期受引擎管理。</p> <p>这里以napi_get_arraybuffer_info为例，该接口定义如下：</p> <div _ngcontent-uxd-c106="" class="highlight-div"><div _ngcontent-uxd-c106="" class="highlight-div-header"><div _ngcontent-uxd-c106="" class="highlight-div-header-left"><div _ngcontent-uxd-c106="" class="handle-button expand-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-uxd-c106="" class="highlight-div-header-right"><div _ngcontent-uxd-c106="" class="handle-button ai-button"></div><div _ngcontent-uxd-c106="" class="handle-button line-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-uxd-c106="" class="handle-button theme-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-uxd-c106="" class="handle-button copy-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-uxd-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-built_in">napi_get_arraybuffer_info</span>(napi_env env, napi_value arraybuffer, <span class="hljs-type">void</span>** data, <span class="hljs-type">size_t</span>* byte_length)</li></ol></pre></div></div> <p>data获取的是ArrayBuffer的Buffer头指针，开发者只可以在范围内读写该Buffer区域，不可以进行释放操作。该段内存由引擎内部的ArrayBuffer Allocator管理，随JS对象ArrayBuffer的生命周期释放。</p> <p><strong>错误示例：</strong></p> <div _ngcontent-uxd-c106="" class="highlight-div"><div _ngcontent-uxd-c106="" class="highlight-div-header"><div _ngcontent-uxd-c106="" class="highlight-div-header-left"><div _ngcontent-uxd-c106="" class="handle-button expand-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-uxd-c106="" class="highlight-div-header-right"><div _ngcontent-uxd-c106="" class="handle-button ai-button"></div><div _ngcontent-uxd-c106="" class="handle-button line-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-uxd-c106="" class="handle-button theme-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-uxd-c106="" class="handle-button copy-button"><div _ngcontent-uxd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-uxd-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-type">void</span>* arrayBufferPtr = <span class="hljs-literal">nullptr</span>;</li><li>napi_value arrayBuffer = <span class="hljs-literal">nullptr</span>;</li><li><span class="hljs-type">size_t</span> createBufferSize = ARRAY_BUFFER_SIZE;</li><li>napi_status verification = <span class="hljs-built_in">napi_create_arraybuffer</span>(env, createBufferSize, &amp;arrayBufferPtr, &amp;arrayBuffer);</li><li><span class="hljs-type">size_t</span> arrayBufferSize;</li><li>napi_status result = <span class="hljs-built_in">napi_get_arraybuffer_info</span>(env, arrayBuffer, &amp;arrayBufferPtr, &amp;arrayBufferSize);</li><li><span class="hljs-keyword">delete</span> arrayBufferPtr; <span class="hljs-comment">// 这一步是禁止的，创建的arrayBufferPtr生命周期由引擎管理，不允许用户自己delete，否则会double free</span></li></ol></pre></div></div>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.12.8.1.2.1.1" valign="top" width="100%">Node-API中受当前规则约束的接口有：</th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="100%">napi_create_arraybuffer</td> </tr> <tr><td class="cellrowborder" valign="top" width="100%">napi_create_sendable_arraybuffer</td> </tr> <tr><td class="cellrowborder" valign="top" width="100%">napi_get_arraybuffer_info</td> </tr> <tr><td class="cellrowborder" valign="top" width="100%">napi_create_buffer</td> </tr> <tr><td class="cellrowborder" valign="top" width="100%">napi_get_buffer_info</td> </tr> <tr><td class="cellrowborder" valign="top" width="100%">napi_get_typedarray_info</td> </tr> <tr><td class="cellrowborder" valign="top" width="100%">napi_get_dataview_info</td> </tr>  </tbody></table></div> </div> </div>  <div class="tiledSection"><h2 id="其他">其他<i class="anchor-icon anchor-icon-link" anchorid="其他" tips="复制节点链接"></i></h2><p><strong>【建议】</strong> 合理使用napi_object_freeze和napi_object_seal来控制对象以及对象属性的可变性。</p> <p>napi_object_freeze等同于Object.freeze语义，freeze后对象的所有属性都不可能以任何方式被修改；napi_object_seal等同于Object.seal语义，对象不可增删属性。两者的主要区别是，freeze不能改属性的值，seal还可以改属性的值。</p> <p>开发者使用以上语义时，需确保约束条件是自己需要的，一旦违背以上语义严格模式下就会抛出Error（默认严格模式）。</p> </div>  <div class="tiledSection"><h2 id="参考文档">参考文档<i class="anchor-icon anchor-icon-link" anchorid="参考文档" tips="复制节点链接"></i></h2><p><a href="https://developer.huawei.com/consumer/cn/doc/best-practices-V5/bpta-native-sub-main-comm-V5" target="_blank">Native侧子线程与UI主线程通信开发</a>;</p> <p><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs-V5/faqs-ndk-8-V5" target="_blank">如何在Native侧C++子线程直接调用ArkTS接口，不用通过ArkTS侧触发回调</a>;</p> <p><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs-V5/faqs-ndk-55-V5" target="_blank">napi_env、napi_value实例是否可以跨worker线程共享</a>;</p> <p><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs-V5/faqs-ndk-68-V5" target="_blank">Native如何创建子线程，有什么约束，与主线程如何通信</a>.</p> </div> </div> <div></div></div>