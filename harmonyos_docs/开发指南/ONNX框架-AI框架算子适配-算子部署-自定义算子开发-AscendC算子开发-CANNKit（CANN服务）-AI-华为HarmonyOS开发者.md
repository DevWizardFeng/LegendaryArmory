<h1 _ngcontent-yao-c119="" class="doc-title ng-star-inserted" title="ONNX框架"> ONNX框架 </h1>

<div _ngcontent-yao-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;"> <div><div class="tiledSection"><h2 id="section12848101213218">适配插件开发<i class="anchor-icon anchor-icon-link" anchorid="section12848101213218" tips="复制节点链接"></i></h2><p>开发者可以参考本章节进行算子适配插件的开发，将ONNX框架的算子映射成适配Kirin AI处理器的算子（下文简称AscendC算子），从而完成从ONNX框架调用AscendC自定义算子的过程。如下样例展示了一个基础的开发流程：</p> </div> <div _ngcontent-yao-c106="" class="highlight-div"><div _ngcontent-yao-c106="" class="highlight-div-header"><div _ngcontent-yao-c106="" class="highlight-div-header-left"><div _ngcontent-yao-c106="" class="handle-button expand-button"><div _ngcontent-yao-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-yao-c106="" class="highlight-div-header-right"><div _ngcontent-yao-c106="" class="handle-button ai-button"></div><div _ngcontent-yao-c106="" class="handle-button line-button"><div _ngcontent-yao-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-yao-c106="" class="handle-button theme-button"><div _ngcontent-yao-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-yao-c106="" class="handle-button copy-button"><div _ngcontent-yao-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-yao-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"register/register.h"</span> </span></li><li><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"nlohmann/json.hpp"</span></span></li><li><span class="hljs-keyword">namespace</span> domi { </li><li>    <span class="hljs-function">Status </span><em><span class="hljs-function"><span class="hljs-title">ParseParamByOpFunc</span></span></em><span class="hljs-function"><span class="hljs-params">(<span class="hljs-type">const</span> ge::Operator&amp; op_src, ge::Operator&amp; op_dest)</span> </span>{ </li><li>        <span class="hljs-comment">// ... </span></li><li>    } </li><li>    <span class="hljs-built_in">REGISTER_CUSTOM_OP</span>(<span class="hljs-string">"</span><em><span class="hljs-string">OpType</span></em><span class="hljs-string">"</span>)    <span class="hljs-comment">// 映射的自定义算子类型</span></li><li>        .<span class="hljs-built_in">FrameworkType</span>(ONNX)  </li><li>        .<span class="hljs-built_in">OriginOpType</span>(<span class="hljs-string">"</span><em><span class="hljs-string">OriginOpType</span></em><span class="hljs-string">"</span>)  <span class="hljs-comment">// ONNX模型中的算子类型</span></li><li>        .<span class="hljs-built_in">ParseParamsByOperatorFn</span>(<em>ParseParamByOpFunc</em>);   <span class="hljs-comment">// 用来注册解析算子属性的函数 </span></li><li>   }</li></ol></pre></div></div> <ol><li><span>包含所需头文件。</span><p></p><ul><li>register.h，存储在DDK软件安装后文件存储路径的"ddk/ai_ddk_lib/include/register"目录下，包含该头文件，可使用算子注册相关类，调用算子注册相关的接口。</li><li>json.hpp，用于进行ONNX数据定义的解析，将String类型的算子参数定义转换为json格式。若样例工程中未提供"json.hpp"文件，开发者可以自行下载，并将"json.hpp"放在工程可以找到的任意路径下，然后包含此头文件即可，推荐放在DDK安装目录的"tools/tools_ascendc/json-develop"下，按如下目录放置。下载路径可参见<a href="https://github.com/nlohmann/json/blob/develop/single_include/nlohmann/json.hpp" target="_blank">json.hpp</a>。<div _ngcontent-yao-c106="" class="highlight-div"><div _ngcontent-yao-c106="" class="highlight-div-header"><div _ngcontent-yao-c106="" class="highlight-div-header-left"><div _ngcontent-yao-c106="" class="handle-button expand-button"><div _ngcontent-yao-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-yao-c106="" class="highlight-div-header-right"><div _ngcontent-yao-c106="" class="handle-button ai-button"></div><div _ngcontent-yao-c106="" class="handle-button line-button"><div _ngcontent-yao-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-yao-c106="" class="handle-button theme-button"><div _ngcontent-yao-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-yao-c106="" class="handle-button copy-button"><div _ngcontent-yao-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-yao-c106="" class="highlight-scroll-div"><pre class="text prettyprint linenums hljs language-plaintext" hw-language="text" data-highlighted="yes"><ol class="linenums"><li>json-develop</li><li>├── include</li><li>│   └── nlohmann</li><li>│       └── json.hpp</li><li>└── README.md</li></ol></pre></div></div> </li></ul> <p></p></li><li><span>使用REGISTER_CUSTOM_OP宏，完成DDK算子和ONNX框架的算子映射关系注册。使用方法如下。</span><p></p><ul><li>REGISTER_CUSTOM_OP：注册自定义算子，<em>OpType</em>为算子类型名称，需要与<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cannkit-operator-prototype-definition">算子原型定义实现</a>中的<em>OpType</em>保持一致。</li><li><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cannkit-frameworktype">FrameworkType</a>：ONNX代表原始框架为ONNX。</li><li><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cannkit-originoptype">OriginOpType</a>：算子在原始框架中的类型。例如自定义算子<em>OpTypeA</em>，对应ONNX算子库版本opset_version=11，应传入"ai.onnx::11::<em>OpTypeA</em>"，当前支持的ONNX版本范围为9~15。</li><li><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cannkit-parseparamsbyoperatorfn">ParseParamsByOperatorFn</a>(<em>ParseParamByOpFunc</em>)：用来注册解析算子参数实现映射关系的回调函数，需要开发者自定义实现<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cannkit-parseparamsbyoperatorfn">ParseParamsByOperatorFn</a>。具体实现方式参考<a href="/consumer/cn/doc/harmonyos-guides/cannkit-onnx-framework#zh-cn_topic_0000002083404722_li213610403113">步骤3</a>。</li></ul> <p></p></li><li id="zh-cn_topic_0000002083404722_li213610403113"><a name="ZH-CN_TOPIC_0000002479472501__zh-cn_topic_0000002083404722_li213610403113"></a><a name="zh-cn_topic_0000002083404722_li213610403113"></a><span>实现回调函数ParseParamByOpFunc。其函数声明如下所示：</span><p></p><div _ngcontent-yao-c106="" class="highlight-div"><div _ngcontent-yao-c106="" class="highlight-div-header"><div _ngcontent-yao-c106="" class="highlight-div-header-left"><div _ngcontent-yao-c106="" class="handle-button expand-button"><div _ngcontent-yao-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-yao-c106="" class="highlight-div-header-right"><div _ngcontent-yao-c106="" class="handle-button ai-button"></div><div _ngcontent-yao-c106="" class="handle-button line-button"><div _ngcontent-yao-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-yao-c106="" class="handle-button theme-button"><div _ngcontent-yao-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-yao-c106="" class="handle-button copy-button"><div _ngcontent-yao-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-yao-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-function">Status <span class="hljs-title">ParseParamByOpFunc</span><span class="hljs-params">(<span class="hljs-type">const</span> ge::Operator&amp; op_src, ge::Operator&amp; op_dest)</span></span></li></ol></pre></div></div> <ul><li><em>ParseParamByOpFunc</em>：函数名称，开发者自定义。</li><li>op_src：ONNX框架定义的Operator类对象，包含ONNX模型中自定义的算子属性信息，定义来源于ONNX框架的原始模型文件。</li><li>op_dest：DDK算子数据结构，保存算子信息，Operator类的详细描述请参见<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cannkit-operator-construction-and-destructor">Operator</a>。</li></ul> <p>开发者需要在回调函数中实现属性的解析和映射，具体实现方式如下。</p> <p>ONNX原始模型中，属性为repeated message类型，对于repeated message类型的参数，可使用<strong>GetAttr(const char *name, ge::AscendString &amp;attr_value)</strong>接口获取其属性值，然后将AscendString类型的属性值转换为String类型，再将其转换为json格式进行属性字段的解析。</p> <p>实现如下所示：</p> <div _ngcontent-yao-c106="" class="highlight-div"><div _ngcontent-yao-c106="" class="highlight-div-header"><div _ngcontent-yao-c106="" class="highlight-div-header-left"><div _ngcontent-yao-c106="" class="handle-button expand-button"><div _ngcontent-yao-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-yao-c106="" class="highlight-div-header-right"><div _ngcontent-yao-c106="" class="handle-button ai-button"></div><div _ngcontent-yao-c106="" class="handle-button line-button"><div _ngcontent-yao-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-yao-c106="" class="handle-button theme-button"><div _ngcontent-yao-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-yao-c106="" class="handle-button copy-button"><div _ngcontent-yao-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-yao-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-function">SStatus <span class="hljs-title">ParseParamAddCustom</span><span class="hljs-params">(<span class="hljs-type">const</span> ge::Operator&amp; op_src, ge::Operator&amp; op_dest)</span> </span>{</li><li>ge::AscendString attrs_string;</li><li><span class="hljs-comment">// 使用固定属性名称“attribute”获取ONNX算子中的属性，并赋值给AscendString类型对象</span></li><li>    <span class="hljs-keyword">if</span> (ge::GRAPH_SUCCESS == op_src.<span class="hljs-built_in">GetAttr</span>(<span class="hljs-string">"attribute"</span>, attrs_string)) {</li><li>        nlohmann::json attrs = nlohmann::json::<span class="hljs-built_in">parse</span>(attrs_string.<span class="hljs-built_in">GetString</span>());</li><li>        <span class="hljs-keyword">for</span> (nlohmann::json attr : attrs[<span class="hljs-string">"attribute"</span>]) {</li><li>            <span class="hljs-keyword">if</span> (attr[<span class="hljs-string">"name"</span>] == <span class="hljs-string">"bias"</span>) {</li><li>                <span class="hljs-type">int64_t</span> bias  = attr[<span class="hljs-string">"i"</span>];</li><li>                op_dest.<span class="hljs-built_in">SetAttr</span>(<span class="hljs-string">"bias"</span>, bias);</li><li>            }</li><li>        }</li><li>    }</li><li>    <span class="hljs-keyword">return</span> SUCCESS;</li><li>}</li></ol></pre></div></div> <p>开发者也可以使用自动解析和映射的回调函数AutoMappingByOpFn，使用方式如下。</p> <div _ngcontent-yao-c106="" class="highlight-div"><div _ngcontent-yao-c106="" class="highlight-div-header"><div _ngcontent-yao-c106="" class="highlight-div-header-left"><div _ngcontent-yao-c106="" class="handle-button expand-button"><div _ngcontent-yao-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-yao-c106="" class="highlight-div-header-right"><div _ngcontent-yao-c106="" class="handle-button ai-button"></div><div _ngcontent-yao-c106="" class="handle-button line-button"><div _ngcontent-yao-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-yao-c106="" class="handle-button theme-button"><div _ngcontent-yao-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-yao-c106="" class="handle-button copy-button"><div _ngcontent-yao-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-yao-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"register/register.h"</span> </span></li><li><span class="hljs-keyword">namespace</span> domi { </li><li>    <span class="hljs-built_in">REGISTER_CUSTOM_OP</span>(<span class="hljs-string">"</span><em><span class="hljs-string">OpType</span></em><span class="hljs-string">"</span>) </li><li>        .<span class="hljs-built_in">FrameworkType</span>(ONNX)  </li><li>        .<span class="hljs-built_in">OriginOpType</span>(<span class="hljs-string">"</span><em><span class="hljs-string">OriginOpType</span></em><span class="hljs-string">"</span>) </li><li>        .<span class="hljs-built_in">ParseParamsByOperatorFn</span>(AutoMappingByOpFn);   <span class="hljs-comment">// 用来注册解析算子属性的函数 </span></li><li>}</li></ol></pre></div></div> <div><div class="hw-editor-tip warn"><div class="title">注意</div><div class="content"><ul><li>当前版本GetAttr与SetAttr接口不支持对原始文件中数据类型为double和uint64的字段进行解析。</li></ul> <ul><li>使用omg工具执行模型转换时，对属性的获取情况不会进行强校验。所以进行算子适配插件实现时，若开发者调用GetAttr失败，建议根据算子实际情况增加相应的处理逻辑，例如，针对必选属性，可返回失败，针对可选属性，可设置默认值。</li><li>对于float32的非常量输入，如果算子注册只支持float16,  框架会自动插 cast算子 将float32的输入转成float16的输入，计算完成后通过cast算子将输出转回float32的输出。对于float32的常量输入，框架不会自动转换，需要开发者自行修改权重格式、类型，以匹配算子的输入。</li></ul> </div></div></div> <p></p></li></ol> <div class="tiledSection"><h2 id="section137354294210">调用样例<i class="anchor-icon anchor-icon-link" anchorid="section137354294210" tips="复制节点链接"></i></h2><p>完成了ONNX框架的适配插件开发后，即可实现从ONNX框架调用AscendC自定义算子。下面以一个仅包含AddCustom算子的ONNX框架网络为例（该网络中的AddCustom算子通过适配插件映射为自定义的AddCustom算子），呈现一个使用推理工具进行推理的过程，目的在于让开发者快速体验推理场景下网络中自定义算子调用的过程。</p> </div> <p>在完成如下步骤之前，开发者需要先参考上文内容完成自定义AddCustom算子kernel侧和host侧的开发、ONNX适配插件的开发，并完成算子的编译部署。</p> <p>完整样例请参考<a href="https://gitcode.com/HarmonyOS_Samples/cannkit_samplecode_add_custom_cpp" target="_blank">AddCustom算子实现</a>和<a href="https://gitcode.com/HarmonyOS_Samples/cannkit_samplecode_add_custom_cpp/blob/master/FrameworkLaunch/Onnx/create_addcustom_onnx.py" target="_blank">ONNX框架调用示例</a> 。</p> <ol><li><span>通过pytorch代码生成该自定义算子。</span><p></p><div _ngcontent-yao-c106="" class="highlight-div"><div _ngcontent-yao-c106="" class="highlight-div-header"><div _ngcontent-yao-c106="" class="highlight-div-header-left"><div _ngcontent-yao-c106="" class="handle-button expand-button"><div _ngcontent-yao-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-yao-c106="" class="highlight-div-header-right"><div _ngcontent-yao-c106="" class="handle-button ai-button"></div><div _ngcontent-yao-c106="" class="handle-button line-button"><div _ngcontent-yao-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-yao-c106="" class="handle-button theme-button"><div _ngcontent-yao-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-yao-c106="" class="handle-button copy-button"><div _ngcontent-yao-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-yao-c106="" class="highlight-scroll-div"><pre class="python prettyprint linenums hljs language-python" hw-language="python" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">import</span> os</li><li><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np</li><li><span class="hljs-keyword">import</span> onnx</li><li><span class="hljs-keyword">from</span> onnx <span class="hljs-keyword">import</span> helper</li><li><span class="hljs-keyword">from</span> onnx <span class="hljs-keyword">import</span> TensorProto</li><li>
</li><li>
</li><li><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_model</span>():</li><li>    AddCustom = helper.make_node(</li><li>        <span class="hljs-string">"AddCustom"</span>,</li><li>        inputs = [<span class="hljs-string">"input1"</span>, <span class="hljs-string">"input2"</span>],</li><li>        outputs = [<span class="hljs-string">"output"</span>],</li><li>        name = <span class="hljs-string">"add"</span>,</li><li>        bias = <span class="hljs-number">1</span></li><li>    )</li><li>
</li><li>    input1_input = helper.make_tensor_value_info(<span class="hljs-string">"input1"</span>, TensorProto.FLOAT, [<span class="hljs-number">8</span>, <span class="hljs-number">2048</span>])</li><li>    input2_input = helper.make_tensor_value_info(<span class="hljs-string">"input2"</span>, TensorProto.FLOAT, [<span class="hljs-number">8</span>, <span class="hljs-number">2048</span>])</li><li>    add_output = helper.make_tensor_value_info(<span class="hljs-string">'output'</span>, TensorProto.FLOAT, [<span class="hljs-number">8</span>, <span class="hljs-number">2048</span>])</li><li>
</li><li>    graph = helper.make_graph(</li><li>        nodes = [AddCustom],</li><li>        name = <span class="hljs-string">'custom_graph'</span>,</li><li>        inputs = [input1_input, input2_input],</li><li>        outputs = [add_output]</li><li>    )</li><li>
</li><li>    model = helper.make_model(graph, producer_name=<span class="hljs-string">'onnx-example'</span>)</li><li>    model.opset_import[<span class="hljs-number">0</span>].version = <span class="hljs-number">11</span></li><li>    model.ir_version = <span class="hljs-number">6</span></li><li>
</li><li>    <span class="hljs-keyword">return</span> model</li><li>
</li><li>model = create_model()</li><li><span class="hljs-built_in">print</span>(onnx.helper.printable_graph(model.graph))</li><li>onnx.save(model, <span class="hljs-string">"./add_custom.onnx"</span>)</li></ol></pre></div></div> <p></p></li></ol><ol start="2"><li><span>在%{DDK_INSTALL_PATH}/tools/tools_omg执行如下命令生成离线模型。（如下命令中使用的目录以及文件均为样例，请以实际为准）</span><p></p><div _ngcontent-yao-c106="" class="highlight-div"><div _ngcontent-yao-c106="" class="highlight-div-header"><div _ngcontent-yao-c106="" class="highlight-div-header-left"><div _ngcontent-yao-c106="" class="handle-button expand-button"><div _ngcontent-yao-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-yao-c106="" class="highlight-div-header-right"><div _ngcontent-yao-c106="" class="handle-button ai-button"></div><div _ngcontent-yao-c106="" class="handle-button line-button"><div _ngcontent-yao-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-yao-c106="" class="handle-button theme-button"><div _ngcontent-yao-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-yao-c106="" class="handle-button copy-button"><div _ngcontent-yao-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-yao-c106="" class="highlight-scroll-div"><pre class="shell prettyprint linenums hljs language-shell" hw-language="shell" data-highlighted="yes"><ol class="linenums"><li>./omg --model ./add_custom.onnx --framework 5 --output out/custom_graph --target=omc</li></ol></pre></div></div> <p>关键参数的解释如下。</p> <ul><li>--model：ONNX框架网络模型文件（*.onnx）的路径。</li><li>--framework：原始框架类型。5表示ONNX。</li><li>--output：转换后的离线模型的路径以及文件名。请注意，记录保存该omc模型文件的路径，后续开发应用时需要使用。</li><li>--target：转换后的模型类型，自定义算子场景仅支持omc。</li><li>--platform：omc模型为硬件相关模型，指定omc模型运行的芯片平台。<div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"><p>模型转换命令相关参数参考<a href="https://developer.huawei.com/consumer/cn/doc/hiai-Guides/offline-model-conversion-0000001053807006" target="_blank">离线模型转换</a>。</p> </div></div></div> </li></ul> <p></p></li><li><span>若提示有出现如下信息，则说明进入了AscendC自定义算子编译流程且模型转换成功。</span><p></p><div _ngcontent-yao-c106="" class="highlight-div"><div _ngcontent-yao-c106="" class="highlight-div-header"><div _ngcontent-yao-c106="" class="highlight-div-header-left"><div _ngcontent-yao-c106="" class="handle-button expand-button"><div _ngcontent-yao-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-yao-c106="" class="highlight-div-header-right"><div _ngcontent-yao-c106="" class="handle-button ai-button"></div><div _ngcontent-yao-c106="" class="handle-button line-button"><div _ngcontent-yao-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-yao-c106="" class="handle-button theme-button"><div _ngcontent-yao-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-yao-c106="" class="handle-button copy-button"><div _ngcontent-yao-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-yao-c106="" class="highlight-scroll-div"><pre class="text prettyprint linenums hljs language-plaintext" hw-language="text" data-highlighted="yes"><ol class="linenums"><li>// ... </li><li>"the node AddCustom is custom node"</li><li>// ... </li><li>"OMG generate offline model success."</li></ol></pre></div></div> <p>成功执行命令后，在--output参数指定的路径下，可查看离线模型（如：leaky_relu.om）。</p> <p></p></li><li><span>参考<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cannkit-graph-compilation-and-execution#section5480mcpsimp">生成输入数据</a>准备符合模型输入要求的*.bin格式的输入数据。</span></li><li><span>参考<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cannkit-graph-compilation-and-execution#section5499mcpsimp">APP集成代码</a>，完成模型集成。</span></li></ol> </div> <div></div></div>