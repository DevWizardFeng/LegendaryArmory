<h1 _ngcontent-pjf-c119="" class="doc-title ng-star-inserted" title="SPMD模型"> SPMD模型 </h1>

<div _ngcontent-pjf-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;"> <div><p>AscendC算子编程是SPMD(Single-Program Multiple-Data)编程，SPMD是一种常用的并行计算的方法，是提高计算速度的有效手段。</p> <p>假设，从输入数据到输出数据需要经过3个阶段任务的处理（T1、T2、T3）。如下图所示，SPMD模式下，系统会启动一组进程，并行处理待处理的数据：首先待处理数据会被切分成多个数据分片，切分后的数据分片随后被分发给不同进程处理，每个进程接收到一个或多个数据分片，并独立地对这些分片进行3个任务的处理。</p> <div class="fignone"><span class="figcap"><b>图1 </b>SPMD数据并行示意图</span><br><span><img height="324.52000000000004" originheight="322" originwidth="526" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211114302.64039527814636372714321822750831:50001231000000:2800:E22FAA58F59F00BEC143A5273AE549C03FC8E726663CA9EC4A813B6272C0A977.png" title="点击放大" width="526.6800000000001"></span></div> <p>具体到AscendC编程模型中的应用，是将需要处理的数据拆分并同时在多个计算核心（类比于上文介绍中的多个进程）上运行，从而获取更高的性能。多个AI Core共享相同的指令代码，每个核上的运行实例唯一的区别是block_idx不同，每个核通过不同的block_idx来识别自己的身份。block的概念类似于上文中进程的概念，block_idx就是标识进程唯一性的进程ID。并行计算过程如下图所示。</p> <div class="fignone"><span class="figcap"><b>图2 </b>SPMD并行计算示意图</span><br><span><img height="307.23" originheight="497" originwidth="842" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211114302.95572358256053936609697385168974:50001231000000:2800:1510EC320ACFA6F1B68D868B31F170B3950D2680719E252C66B3C4451394ED0A.png" title="点击放大" width="526.6800000000001"></span></div> <p>下面的代码片段取自于AscendC Add算子的实现代码，算子被调用时，所有的计算核心都执行相同的实现代码，入口函数的入参也是相同的。每个核上处理的数据地址需要在起始地址上增加<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cannkit-getblockidx">GetBlockIdx</a>*BLOCK_LENGTH（每个block处理的数据长度）的偏移来获取。这样也就实现了多核并行计算的数据切分。</p> <div _ngcontent-pjf-c106="" class="highlight-div"><div _ngcontent-pjf-c106="" class="highlight-div-header"><div _ngcontent-pjf-c106="" class="highlight-div-header-left"><div _ngcontent-pjf-c106="" class="handle-button expand-button"><div _ngcontent-pjf-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-pjf-c106="" class="highlight-div-header-right"><div _ngcontent-pjf-c106="" class="handle-button ai-button"></div><div _ngcontent-pjf-c106="" class="handle-button line-button"><div _ngcontent-pjf-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-pjf-c106="" class="handle-button theme-button"><div _ngcontent-pjf-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-pjf-c106="" class="handle-button copy-button"><div _ngcontent-pjf-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-pjf-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">class</span> <span class="hljs-title class_">KernelAdd</span> { </li><li><span class="hljs-keyword">public</span>: </li><li>    <span class="hljs-function">__aicore__ <span class="hljs-keyword">inline</span> <span class="hljs-title">KernelAdd</span><span class="hljs-params">()</span> </span>{} </li><li>    <span class="hljs-function">__aicore__ <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Init</span><span class="hljs-params">(GM_ADDR x, GM_ADDR y, GM_ADDR z)</span> </span></li><li><span class="hljs-function">    </span>{ </li><li>        <span class="hljs-comment">// get start index for current core, core parallel </span></li><li>        xGm.<span class="hljs-built_in">SetGlobalBuffer</span>((__gm__ half*)x + BLOCK_LENGTH * <span class="hljs-built_in">GetBlockIdx</span>(), BLOCK_LENGTH); </li><li>        yGm.<span class="hljs-built_in">SetGlobalBuffer</span>((__gm__ half*)y + BLOCK_LENGTH * <span class="hljs-built_in">GetBlockIdx</span>(), BLOCK_LENGTH); </li><li>        zGm.<span class="hljs-built_in">SetGlobalBuffer</span>((__gm__ half*)z + BLOCK_LENGTH * <span class="hljs-built_in">GetBlockIdx</span>(), BLOCK_LENGTH); </li><li>        <span class="hljs-comment">// pipe alloc memory to queue, the unit is Bytes </span></li><li>        pipe.<span class="hljs-built_in">InitBuffer</span>(inQueueX, BUFFER_NUM, TILE_LENGTH * <span class="hljs-built_in">sizeof</span>(half)); </li><li>        pipe.<span class="hljs-built_in">InitBuffer</span>(inQueueY, BUFFER_NUM, TILE_LENGTH * <span class="hljs-built_in">sizeof</span>(half)); </li><li>        pipe.<span class="hljs-built_in">InitBuffer</span>(outQueueZ, BUFFER_NUM, TILE_LENGTH * <span class="hljs-built_in">sizeof</span>(half)); </li><li>    } </li><li>    <span class="hljs-comment">// ... </span></li><li>} </li><li> </li><li> </li><li><span class="hljs-comment">// 实现核函数 </span></li><li><span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> <span class="hljs-function">__global__ __aicore__ <span class="hljs-type">void</span> <span class="hljs-title">add_custom</span><span class="hljs-params">(GM_ADDR x, GM_ADDR y, GM_ADDR z)</span> </span></li><li><span class="hljs-function"></span>{ </li><li>    <span class="hljs-comment">// 初始化算子类，算子类提供算子初始化和核心处理等方法 </span></li><li>    KernelAdd op; </li><li>    <span class="hljs-comment">// 初始化函数，获取该核函数需要处理的输入输出地址，同时完成必要的内存初始化工作 </span></li><li>    op.<span class="hljs-built_in">Init</span>(x, y, z); </li><li>    <span class="hljs-comment">// 核心处理函数，完成算子的数据搬运与计算等核心逻辑 </span></li><li>    op.<span class="hljs-built_in">Process</span>(); </li><li>}</li></ol></pre></div></div> </div> <div></div></div>