<h1 _ngcontent-ntr-c119="" class="doc-title ng-star-inserted" title="TCubeTiling结构体"> TCubeTiling结构体 </h1>

<div _ngcontent-ntr-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;"> <div><p>TCubeTiling结构体包含Matmul Tiling切分算法的相关参数，被传递给Matmul kernel侧，用于Matmul的切块、搬运和计算过程等。TCubeTiling结构体的参数说明见表1。</p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><caption><b>表1 </b>TCubeTiling结构说明</caption><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.2.2.4.1.1" valign="top" width="15.15%"><p>参数名称</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.2.2.4.1.2" valign="top" width="8.08%"><p>数据类型</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.2.2.4.1.3" valign="top" width="76.77000000000001%"><p>说明</p> </th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="15.15%"><p>usedCoreNum</p> </td> <td class="cellrowborder" valign="top" width="8.08%"><p>int</p> </td> <td class="cellrowborder" valign="top" width="76.77000000000001%"><p>使用的AI处理器核数，请根据实际情况设置。取值范围为：[1, AI处理器最大核数]。该参数与shape相关参数的关系为：usedCoreNum = (M / singleCoreM) * (N / singleCoreN)。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="15.15%"><p>M, N, Ka, Kb</p> </td> <td class="cellrowborder" valign="top" width="8.08%"><p>int</p> </td> <td class="cellrowborder" valign="top" width="76.77000000000001%"><p>A、B、C矩阵原始输入的shape大小，以元素为单位。M, Ka为A矩阵原始输入的Shape, Kb, N为B矩阵原始输入的Shape。</p> <ul><li>大小约束<ul><li>若A矩阵为ND格式，不进行转置时，Ka取值范围为[1, 65535]，M无大小限制；进行转置时，M取值范围为[1, 65535]，Ka无大小限制。</li><li>若B矩阵为ND格式，不进行转置时，N取值范围为[1, 65535]，Kb无大小限制；进行转置时，Kb取值范围为[1, 65535]，N无大小限制。</li></ul> </li><li>对齐约束<ul><li>若A矩阵以NZ格式输入，则M需要以16个元素对齐，K需要以C0_size对齐；若B矩阵以NZ格式输入，则K需要以C0_size对齐，N需要以16个元素对齐。</li><li>若A、B矩阵为ND格式，无对齐约束。</li></ul> </li></ul> <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"><p>NZ格式的输入，half/bfloat16_t数据类型的C0_size为16，float数据类型的C0_size为8，int8_t数据类型的C0_size为32，int4_t数据类型的C0_size为64。</p> </div></div></div> </td> </tr> <tr><td class="cellrowborder" valign="top" width="15.15%"><p>singleCoreM, singleCoreN, singleCoreK</p> </td> <td class="cellrowborder" valign="top" width="8.08%"><p>int</p> </td> <td class="cellrowborder" valign="top" width="76.77000000000001%"><p>A、B、C矩阵单核内shape大小，以元素为单位。</p> <p>singleCoreK = K，多核处理时不对K进行切分；singleCoreM &lt;= M；singleCoreN &lt;= N。</p> <p>若A矩阵以NZ格式输入，则singleCoreM需要以16个元素对齐，singleCoreK需要以C0_size * fractal_num对齐；若B矩阵以NZ格式输入，则singleCoreK需要以C0_size * fractal_num对齐，singleCoreN需要以16个元素对齐。</p> <p>NZ格式的输入，half/bfloat16_t数据类型的C0_size为16，float数据类型的C0_size为8，int8_t数据类型的C0_size为32，int4_t数据类型的C0_size为64。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="15.15%"><p>baseM, baseN, baseK</p> </td> <td class="cellrowborder" valign="top" width="8.08%"><p>int</p> </td> <td class="cellrowborder" valign="top" width="76.77000000000001%"><p>A、B、C矩阵参与一次矩阵乘指令的shape大小，以元素为单位。</p> <ul><li>baseM * baseN * sizeof(l0c_dtype) &lt;= L0C_size，其中l0c_dtype为int32_t或者float数据类型</li><li>baseM * baseK * sizeof(Input_dtype) &lt;= L0A_size</li><li>baseK * baseN * sizeof(Input_dtype) &lt;= L0B_size</li></ul> <p>A、B、C矩阵参与一次矩阵乘的shape大小需要按分形对齐，其含义请参考Mmad中的数据格式说明。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="15.15%"><p>depthA1, depthB1</p> </td> <td class="cellrowborder" valign="top" width="8.08%"><p>int</p> </td> <td class="cellrowborder" valign="top" width="76.77000000000001%"><p>A、B矩阵片全载A2/B2的份数，depthA1为baseM * baseK的整数倍，depthB1为baseN * baseK的整数倍。取值大于0。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="15.15%"><p>stepM， stepN，stepKa，stepKb</p> </td> <td class="cellrowborder" valign="top" width="8.08%"><p>int</p> </td> <td class="cellrowborder" valign="top" width="76.77000000000001%"><p>stepM为左矩阵在A1中缓存的bufferM方向上baseM的倍数。</p> <p>stepN为右矩阵在B1中缓存的bufferN方向上baseN的倍数。</p> <p>stepKa为左矩阵在A1中缓存的bufferKa方向上baseK的倍数。</p> <p>stepKb为右矩阵在B1中缓存的bufferKb方向上baseK的倍数。</p> <p>取值大于0。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="15.15%"><p>isBias</p> </td> <td class="cellrowborder" valign="top" width="8.08%"><p>int</p> </td> <td class="cellrowborder" valign="top" width="76.77000000000001%"><p>是否使能Bias，0代表不使能Bias，1代表使能Bias。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="15.15%"><p>transLength</p> </td> <td class="cellrowborder" valign="top" width="8.08%"><p>int</p> </td> <td class="cellrowborder" valign="top" width="76.77000000000001%"><p>max(A1Length, B1Length, C1Length, BiasLength)。其中，A1Length, B1Length, C1Length, BiasLength分别表示A/B/C/Bias矩阵在计算过程中需要临时占用的UB空间大小。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="15.15%"><p>iterateOrder</p> </td> <td class="cellrowborder" valign="top" width="8.08%"><p>int</p> </td> <td class="cellrowborder" valign="top" width="76.77000000000001%"><p>一次Iterate计算出[baseM, baseN]大小的C矩阵分片，Iterate完成后，Matmul会自动偏移下一次Iterate输出的C矩阵位置，iterateOrder表示自动偏移的顺序。参数取值如下。</p> <ul><li>0：先往M轴方向偏移再往N轴方向偏移</li><li>1：先往N轴方向偏移再往M轴方向偏移</li></ul> </td> </tr> <tr><td class="cellrowborder" valign="top" width="15.15%"><p>dbL0A, dbL0B,</p> <p>dbL0C</p> </td> <td class="cellrowborder" valign="top" width="8.08%"><p>int</p> </td> <td class="cellrowborder" valign="top" width="76.77000000000001%"><p>MTE1是否开启double buffer。</p> <p>dbL0A：左矩阵MTE1是否开启double buffer。dbL0B：右矩阵MTE1是否开启double buffer；dbL0C：Mmad是否开启double buffer。参数取值如下。</p> <ul><li>1：不开启double buffer</li><li>2：开启double buffer</li></ul> </td> </tr> <tr><td class="cellrowborder" valign="top" width="15.15%"><p>shareMode</p> </td> <td class="cellrowborder" valign="top" width="8.08%"><p>int</p> </td> <td class="cellrowborder" valign="top" width="76.77000000000001%"><p>该参数预留，开发者无需关注。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="15.15%"><p>shareL1Size</p> </td> <td class="cellrowborder" valign="top" width="8.08%"><p>int</p> </td> <td class="cellrowborder" valign="top" width="76.77000000000001%"><p>该参数预留，开发者无需关注。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="15.15%"><p>shareL0CSize</p> </td> <td class="cellrowborder" valign="top" width="8.08%"><p>int</p> </td> <td class="cellrowborder" valign="top" width="76.77000000000001%"><p>该参数预留，开发者无需关注。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="15.15%"><p>shareUbSize</p> </td> <td class="cellrowborder" valign="top" width="8.08%"><p>int</p> </td> <td class="cellrowborder" valign="top" width="76.77000000000001%"><p>该参数预留，开发者无需关注。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="15.15%"><p>batchM</p> </td> <td class="cellrowborder" valign="top" width="8.08%"><p>int</p> </td> <td class="cellrowborder" valign="top" width="76.77000000000001%"><p>该参数预留，开发者无需关注。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="15.15%"><p>batchN</p> </td> <td class="cellrowborder" valign="top" width="8.08%"><p>int</p> </td> <td class="cellrowborder" valign="top" width="76.77000000000001%"><p>该参数预留，开发者无需关注。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="15.15%"><p>singleBatchM</p> </td> <td class="cellrowborder" valign="top" width="8.08%"><p>int</p> </td> <td class="cellrowborder" valign="top" width="76.77000000000001%"><p>该参数预留，开发者无需关注。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="15.15%"><p>singleBatchN</p> </td> <td class="cellrowborder" valign="top" width="8.08%"><p>int</p> </td> <td class="cellrowborder" valign="top" width="76.77000000000001%"><p>该参数预留，开发者无需关注。</p> </td> </tr>  </tbody></table></div> </div> <p>开发者通过调用GetTiling接口获取TCubeTiling结构体，具体流程请参考<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cannkit-matmul-tiling-usage-description">使用说明</a>。若开发者需要修改调整Tiling，请参考如下TCubeTiling参数约束和性能调优推荐取值，进行参数的设置。</p> <ul><li>TCubeTiling参数约束<div class="p">TCubeTiling参数需要同时满足表1中的所有约束条件。若Matmul对象的MatmulConfig模板为MDL模板，除表1外，还同时需要满足表 MDL模板补充约束条件。 <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><caption><b>表2 </b>TCubeTiling约束条件</caption><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.4.1.1.1.2.3.1.1" valign="top" width="61%"><p>约束条件</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.4.1.1.1.2.3.1.2" valign="top" width="39%"><p>说明</p> </th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="61%"><p>usedCoreNum &lt;= aiCoreCnt</p> </td> <td class="cellrowborder" valign="top" width="39%"><p>使用核数小于等于当前AI处理器的最大核数。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="61%"><p>baseM * baseK * sizeof(A_type) * dbL0A&lt; l0a_size</p> </td> <td class="cellrowborder" valign="top" width="39%"><p>A矩阵base块不超过l0a buffer大小。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="61%"><p>baseN * baseK * sizeof(B_type) * dbL0B &lt; l0b_size</p> </td> <td class="cellrowborder" valign="top" width="39%"><p>B矩阵base块不超过l0b buffer大小。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="61%"><p>baseM * baseN * sizeof(int32_t) * dbL0C &lt; l0c_size</p> </td> <td class="cellrowborder" valign="top" width="39%"><p>C矩阵base块不超过l0c buffer大小。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="61%"><p>baseN * sizeof(Bias_type) &lt; biasT_size</p> </td> <td class="cellrowborder" valign="top" width="39%"><p>Bias的base块不超过BiasTable buffer大小。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="61%"><p>stepM * stepKa * db = depthA1</p> <p>db这里表示为左矩阵MTE2是否开启double buffer，即L1是否开启double buffer，取值1（不开启double buffer）或2（开启double buffer）</p> </td> <td class="cellrowborder" valign="top" width="39%"><p>depthA1的取值与stepM * stepKa  * db相同。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="61%"><p>stepN * stepKb * db = depthB1</p> <p>db这里表示为右矩阵MTE2是否开启double buffer，即L1是否开启double buffer，取值1（不开启double buffer）或2（开启double buffer）</p> </td> <td class="cellrowborder" valign="top" width="39%"><p>depthB1的取值与stepN * stepKb  * db相同。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="61%"><p>baseM * baseK * depthA1 * sizeof(A_type) + baseN * baseK * depthB1 * sizeof(B_type) &lt;= L1_size</p> </td> <td class="cellrowborder" valign="top" width="39%"><p>A矩阵和B矩阵在L1缓存块满足L1 buffer大小限制。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="61%"><p>baseM * baseK, baseK * baseN和baseM * baseN按照NZ格式的分形对齐</p> </td> <td class="cellrowborder" valign="top" width="39%"><p>A矩阵、B矩阵、C矩阵的base块需要满足对齐约束：</p> <p>baseM和baseN需要以16个元素对齐，baseK需要以C0_size对齐。</p> <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"><p>half/bfloat16_t数据类型的C0_size为16，float数据类型的C0_size为8，int8_t数据类型的C0_size为32，int4_t数据类型的C0_size为64。</p> </div></div></div> </td> </tr>  </tbody></table></div> </div> </div>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><caption><b>表3 </b>MDL模板补充约束条件</caption><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.4.1.2.2.3.1.1" valign="top" width="60.61%"><p>约束条件</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.4.1.2.2.3.1.2" valign="top" width="39.39%"><p>说明</p> </th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="60.61%"><p>Ka不全载时，即Ka / baseK &gt; stepKa，stepM = 1</p> </td> <td class="cellrowborder" valign="top" width="39.39%"><p>K方向非全载时，M方向只能逐块搬运。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="60.61%"><p>Kb不全载时，即Kb / baseK &gt; stepKb，stepN = 1</p> </td> <td class="cellrowborder" valign="top" width="39.39%"><p>K方向非全载时，N方向只能逐块搬运。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="60.61%"><p>kaStepIter_ % kbStepIter_ = 0或者kbStepIter_ % kaStepIter_ = 0</p> <p>kaStepIter_ = CeilDiv(tiling_-&gt;singleCoreK_, tiling_-&gt;baseK * tiling_-&gt;stepKa)</p> <p>kbStepIter_ = CeilDiv(tiling_-&gt;singleCoreK_, tiling_-&gt;baseK * tiling_-&gt;stepKb)</p> </td> <td class="cellrowborder" valign="top" width="39.39%"><p>MDL模板K方向循环搬运要求Ka和Kb方向迭代次数为倍数关系。</p> <p>kaStepIter_ ：Ka方向循环搬运迭代次数。</p> <p>kbStepIter_ ：Kb方向循环搬运迭代次数。</p> </td> </tr>  </tbody></table></div> </div> </li></ul> <ul><li>性能调优推荐取值<p>根据Tiling调优经验，部分TCubeTiling参数值或取值方式推荐如下。</p> <ul><li>base块推荐(baseM, baseN, baseK)：(128, 256, 64)</li><li>dbl0a / dbl0b = 2</li><li>depthA1 / (stepM * stepKa) = 2</li><li>depthB1 / (stepN * stepKb) = 2</li><li>优先设置参数stepKa/stepKb，使得K方向全载，再考虑M方向或N方向全载。</li></ul> </li></ul> </div> <div></div></div>