<h1 _ngcontent-mga-c119="" class="doc-title ng-star-inserted" title="TaskPool和Worker的对比 (TaskPool和Worker)"> TaskPool和Worker的对比 (TaskPool和Worker) </h1>

<div _ngcontent-mga-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;"> <div><p>TaskPool和Worker的作用是为应用程序提供多线程运行环境，用于处理耗时计算任务或其他密集型任务，避免任务阻塞宿主线程，提高系统性能和资源利用率。</p> <p>本文将从<a href="/consumer/cn/doc/harmonyos-guides/taskpool-vs-worker#实现特点对比">实现特点</a>和<a href="/consumer/cn/doc/harmonyos-guides/taskpool-vs-worker#适用场景对比">适用场景</a>两个方面比较TaskPool与Worker。</p>  <div class="tiledSection"><h2 id="实现特点对比">实现特点对比<i class="anchor-icon anchor-icon-link" anchorid="实现特点对比" tips="复制节点链接"></i></h2><p><strong>表1</strong> TaskPool和Worker的实现特点对比</p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.3.3.1.4.1.1" valign="top" width="33.33333333333333%">实现</th> <th align="left" class="cellrowborder" id="mcps1.3.3.3.1.4.1.2" valign="top" width="33.33333333333333%">TaskPool</th> <th align="left" class="cellrowborder" id="mcps1.3.3.3.1.4.1.3" valign="top" width="33.33333333333333%">Worker</th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="33.33333333333333%">内存模型</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">线程间隔离，内存不共享。</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">线程间隔离，内存不共享。</td> </tr> <tr><td class="cellrowborder" valign="top" width="33.33333333333333%">参数传递机制</td> <td class="cellrowborder" valign="top" width="33.33333333333333%"><p>采用标准的结构化克隆算法（Structured Clone）进行序列化、反序列化，完成参数传递。</p> <p>支持ArrayBuffer转移、SharedArrayBuffer共享和Sendable引用传递。</p> </td> <td class="cellrowborder" valign="top" width="33.33333333333333%"><p>采用标准的结构化克隆算法（Structured Clone）进行序列化、反序列化，完成参数传递。</p> <p>支持ArrayBuffer转移、SharedArrayBuffer共享和Sendable引用传递。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="33.33333333333333%">参数传递</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">直接传递，无需封装。</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">消息对象唯一参数，需要自己封装。</td> </tr> <tr><td class="cellrowborder" valign="top" width="33.33333333333333%">方法调用</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">直接传入并调用@Concurrent修饰的方法。</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">在Worker线程中解析消息并调用对应方法。</td> </tr> <tr><td class="cellrowborder" valign="top" width="33.33333333333333%">返回值</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">异步调用后默认返回。</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">主动发送消息，需在onmessage中解析并赋值。</td> </tr> <tr><td class="cellrowborder" valign="top" width="33.33333333333333%">生命周期</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">TaskPool自动管理其生命周期，无需关注任务负载。</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">开发者需自行管理Worker的数量和生命周期。</td> </tr> <tr><td class="cellrowborder" valign="top" width="33.33333333333333%">任务池个数上限</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">自动管理，无需配置。</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">同个进程下，最多支持同时开启64个Worker线程，实际数量由进程内存决定。</td> </tr> <tr><td class="cellrowborder" valign="top" width="33.33333333333333%">任务执行时长上限</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">3分钟（不包含Promise和async/await异步调用的耗时，例如网络下载、文件读写等I/O任务的耗时），长时任务无执行时长上限。</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">无限制。</td> </tr> <tr><td class="cellrowborder" valign="top" width="33.33333333333333%">设置任务的优先级</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">支持配置任务优先级。</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">从API version 18开始，支持配置Worker线程优先级。</td> </tr> <tr><td class="cellrowborder" valign="top" width="33.33333333333333%">执行任务的取消</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">支持取消已经发起的任务。</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">不支持。</td> </tr> <tr><td class="cellrowborder" valign="top" width="33.33333333333333%">线程复用</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">支持。</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">不支持。</td> </tr> <tr><td class="cellrowborder" valign="top" width="33.33333333333333%">任务延时执行</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">支持。</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">不支持。</td> </tr> <tr><td class="cellrowborder" valign="top" width="33.33333333333333%">设置任务依赖关系</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">支持。</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">不支持。</td> </tr> <tr><td class="cellrowborder" valign="top" width="33.33333333333333%">串行队列</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">支持。</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">不支持。</td> </tr> <tr><td class="cellrowborder" valign="top" width="33.33333333333333%">任务组</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">支持。</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">不支持。</td> </tr> <tr><td class="cellrowborder" valign="top" width="33.33333333333333%">周期任务</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">支持。</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">不支持。</td> </tr> <tr><td class="cellrowborder" valign="top" width="33.33333333333333%">异步队列</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">支持。</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">不支持。</td> </tr>  </tbody></table></div> </div> </div>  <div class="tiledSection"><h2 id="适用场景对比">适用场景对比<i class="anchor-icon anchor-icon-link" anchorid="适用场景对比" tips="复制节点链接"></i></h2><p>TaskPool和Worker均支持多线程并发能力。由于TaskPool的工作线程会绑定系统的调度优先级，并支持负载均衡（自动扩缩容），相比之下，Worker需要开发者自行创建，存在创建耗时。因此，性能方面TaskPool优于Worker，推荐在大多数场景中使用TaskPool。</p> <p>TaskPool偏向于独立任务，任务在线程中执行时，无需关注线程的生命周期。超长任务（大于3分钟且非长时任务）会被系统自动回收。而Worker适用于长时间占据线程的任务，需要开发者主动管理线程的生命周期。</p> <p>常见开发场景及适用说明如下：</p> <ul><li><p>运行时间超过3分钟的任务（不包括Promise和async/await异步调用的耗时，如网络下载、文件读写等I/O任务的耗时）：例如后台进行1小时的预测算法训练等CPU密集型任务，需要使用Worker。场景示例可参考<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/resident-task-guide">常驻任务开发指导</a>。</p>  </li><li><p>有关联的一系列同步任务：例如在一些需要创建、使用句柄的场景中，每次创建的句柄都不同，必须永久保存该句柄，以确保后续操作正确执行，需要使用Worker。场景示例可参考<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/sync-task-development#使用worker处理关联的同步任务">使用Worker处理关联的同步任务</a>。</p>  </li><li><p>需要设置优先级的任务：在API version 18 之前，Worker不支持设置调度优先级，需要使用TaskPool。从API version 18开始，Worker支持设置调度优先级，开发者可以根据使用场景和任务特性选择使用TaskPool或Worker。例如<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cpu-intensive-task-development#使用taskpool进行图像直方图处理">图像直方图绘制场景</a>，后台计算的直方图数据会用于前台界面的显示，影响用户体验，需要高优先级处理，且任务相对独立，推荐使用TaskPool。</p>  </li><li><p>需要频繁取消的任务：如图库大图浏览场景。为提升体验，系统会同时缓存当前图片左右各两张图片。当往一侧滑动跳到下一张图片时，需取消另一侧的缓存任务，此时需使用TaskPool。</p>  </li><li><p>大量或调度点分散的任务：例如大型应用中的多个模块包含多个耗时任务，不建议使用Worker进行负载管理，推荐使用TaskPool。场景示例可参考<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/batch-database-operations-guide">批量数据写数据库场景</a>。</p>  </li></ul> </div> </div> <div></div></div>