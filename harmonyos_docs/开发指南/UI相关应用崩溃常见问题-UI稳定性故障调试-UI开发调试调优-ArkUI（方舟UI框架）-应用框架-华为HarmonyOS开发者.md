<h1 _ngcontent-bar-c119="" class="doc-title ng-star-inserted" title="UI相关应用崩溃常见问题"> UI相关应用崩溃常见问题 </h1>

<div _ngcontent-bar-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;">   <div>    <p>本文档收集整理了一些常见的会导致应用崩溃的ArkUI API错误用法，旨在帮助开发者了解这些会导致应用崩溃问题的错误用法，从而避免在实际应用开发过程中犯类似错误。</p>    <div class="tiledSection">     <h2 id="oh_nativexcomponent注册的回调函数对象被提前释放">OH_NativeXComponent注册的回调函数对象被提前释放<i class="anchor-icon anchor-icon-link" anchorid="oh_nativexcomponent注册的回调函数对象被提前释放" tips="复制节点链接"></i></h2>          <p><strong>问题现象</strong></p>     <p>应用闪退并生成如下cppcrash崩溃栈：</p>     <div _ngcontent-bar-c106="" class="highlight-div"><div _ngcontent-bar-c106="" class="highlight-div-header"><div _ngcontent-bar-c106="" class="highlight-div-header-left"><div _ngcontent-bar-c106="" class="handle-button expand-button"><div _ngcontent-bar-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-bar-c106="" class="highlight-div-header-right"><div _ngcontent-bar-c106="" class="handle-button ai-button"></div><div _ngcontent-bar-c106="" class="handle-button line-button"><div _ngcontent-bar-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-bar-c106="" class="handle-button theme-button"><div _ngcontent-bar-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-bar-c106="" class="handle-button copy-button"><div _ngcontent-bar-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-bar-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li>Reason:Signal:<span class="hljs-built_in">SIGSEGV</span>(SEGV_ACCERR)@<span class="hljs-number">0x0000005c5f09a280</span></li><li>
</li><li>#<span class="hljs-number">00</span> pc <span class="hljs-number">0000000000</span>ac9280 [anon:native_heap:jemalloc]</li><li>#<span class="hljs-number">01</span> pc <span class="hljs-number">0000000002615120</span> /system/lib64/platformsdk/libace_compatible.z.<span class="hljs-built_in">so</span>(OHOS::Ace::NG::XComponentPattern::<span class="hljs-built_in">OnSurfaceDestroyed</span>()+<span class="hljs-number">468</span>)</li><li>#<span class="hljs-number">02</span> pc <span class="hljs-number">0000000002614b</span>18 /system/lib64/platformsdk/libace_compatible.z.<span class="hljs-built_in">so</span>(OHOS::Ace::NG::XComponentPattern::<span class="hljs-built_in">OnDetachFromFrameNode</span>(OHOS::Ace::NG::FrameNode*)+<span class="hljs-number">88</span>)</li><li>#<span class="hljs-number">03</span> pc <span class="hljs-number">0000000000875294</span> /system/lib64/platformsdk/libace_compatible.z.<span class="hljs-built_in">so</span>(OHOS::Ace::NG::FrameNode::~<span class="hljs-built_in">FrameNode</span>()+<span class="hljs-number">264</span>)</li></ol></pre></div></div>     <p>其中libace_compatible.z.so栈的最后一个调用帧为XComponentPattern类的OnSurfaceCreated、OnSurfaceChanged、OnSurfaceDestroyed、DispatchTouchEvent方法之一，且#00帧的pc是一个异常地址，通常其最后几位与Reason后面的地址内容一致，这表明某个函数指针存在问题，导致执行时跳转到异常地址。</p>     <p><strong>可能原因</strong></p>     <p>应用通过<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-native-interface-xcomponent-h#oh_nativexcomponent_registercallback" target="_blank">OH_NativeXComponent_RegisterCallback</a>接口注册的<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ent-native-xcomponent-oh-nativexcomponent-callback" target="_blank">OH_NativeXComponent_Callback</a>回调函数对象以裸指针形式保存在XComponentPattern对象中。这些回调的生命周期由应用控制。如果应用提前销毁了OH_NativeXComponent_Callback回调函数对象，将导致裸指针指向非法内存，引发Use-After-Free问题。</p>     <p><span><img originheight="562" originwidth="983" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211114822.99357289182411382345610681180732:50001231000000:2800:FC7894D349E7D05D481819C62A6095E51728A362BBDBE2117BE30BB5E607B5F6.png" width="920" height="525.9816887080366"></span></p>     <p><strong>解决措施</strong></p>     <p>onSurfaceDestroy回调是XComponentPattern销毁时调用的最后一个回调，该回调执行完表示组件已经销毁。因此，应用必须确保在onSurfaceDestroy回调执行前，这些回调是有效的。</p>     <p><strong>参考链接</strong></p>     <p>相关接口详见<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-oh-nativexcomponent-native-xcomponent" target="_blank">OH_NativeXComponent Native XComponent</a>。</p>    </div>    <div class="tiledSection">     <h2 id="oh_nativexcomponent对象被提前释放">OH_NativeXComponent对象被提前释放<i class="anchor-icon anchor-icon-link" anchorid="oh_nativexcomponent对象被提前释放" tips="复制节点链接"></i></h2>          <p><strong>问题现象</strong></p>     <p>应用闪退并生成如下cppcrash崩溃栈：</p>     <div _ngcontent-bar-c106="" class="highlight-div"><div _ngcontent-bar-c106="" class="highlight-div-header"><div _ngcontent-bar-c106="" class="highlight-div-header-left"><div _ngcontent-bar-c106="" class="handle-button expand-button"><div _ngcontent-bar-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-bar-c106="" class="highlight-div-header-right"><div _ngcontent-bar-c106="" class="handle-button ai-button"></div><div _ngcontent-bar-c106="" class="handle-button line-button"><div _ngcontent-bar-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-bar-c106="" class="handle-button theme-button"><div _ngcontent-bar-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-bar-c106="" class="handle-button copy-button"><div _ngcontent-bar-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-bar-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li>#<span class="hljs-number">00</span> pc <span class="hljs-number">00000000000</span>c8b3c /system/lib64/libc++.<span class="hljs-built_in">so</span>(std::__h::basic_string&lt;<span class="hljs-type">char</span>, std::__h::char_traits&lt;<span class="hljs-type">char</span>&gt;, std::__h::allocator&lt;<span class="hljs-type">char</span>&gt;&gt;::<span class="hljs-built_in">basic_string</span>(std::__h::basic_string&lt;<span class="hljs-type">char</span>, std::__h::char_traits&lt;<span class="hljs-type">char</span>&gt;, std::__h::allocator&lt;<span class="hljs-type">char</span>&gt;&gt; <span class="hljs-type">const</span>&amp;)+<span class="hljs-number">16</span>)</li><li>#<span class="hljs-number">01</span> pc <span class="hljs-number">0000000000034f</span>64 /system/lib64/libace_ndk.z.<span class="hljs-built_in">so</span>(OH_NativeXComponent::<span class="hljs-built_in">GetXComponentId</span>(<span class="hljs-type">char</span>*, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>*)+<span class="hljs-number">76</span>)</li><li>#<span class="hljs-number">02</span> pc <span class="hljs-number">00000000000867</span>c0 /data/storage/el1/bundle/libs/arm64/librenderer.so</li></ol></pre></div></div>     <p>其中栈顶附近内容为libace_ndk.z.so(OH_NativeXComponent::XXX...)，且下一帧是应用so。</p>     <p><strong>可能原因</strong></p>     <p>OH_NativeXComponent使用裸指针管理。应用侧持有其裸指针。如果在其生命周期结束后仍然调用相关接口，会导致Use-After-Free问题。</p>     <p><strong>解决措施</strong></p>     <p>系统通过onSurfaceDestroy回调通知应用OH_NativeXComponent已销毁。应用必须确保在onSurfaceDestroy回调执行完毕后不再调用OH_NativeXComponent相关接口。</p>     <p><strong>参考链接</strong></p>     <p>相关接口详见<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-oh-nativexcomponent-native-xcomponent" target="_blank">OH_NativeXComponent Native XComponent</a>。</p>    </div>    <div class="tiledSection">     <h2 id="consume缺少匹配的provide">@Consume缺少匹配的@Provide<i class="anchor-icon anchor-icon-link" anchorid="consume缺少匹配的provide" tips="复制节点链接"></i></h2>          <p><strong>问题现象</strong></p>     <p>应用闪退并生成如下jscrash崩溃栈：</p>     <p><span><img originheight="344" originwidth="765" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211114822.63748428460364099004520440422525:50001231000000:2800:72B204DB0B82F7B4B41F5BB64FD791DEBDF37CD0EECF3CC9FC8FEF9F4E11F7F6.png" width="765" height="344"></span></p>     <p><strong>可能原因</strong></p>     <p>报错发生在@Consume初始化阶段，原因是@Consume初始化时仅通过key匹配对应的@Provide变量。如果未找到对应的@Provide，就会出现报错（missing @Provide）。</p>     <p><span><img originheight="271" originwidth="985" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211114822.08390786682588888398399706524721:50001231000000:2800:0CD7DBC1A729CB1F3A309E3B56695C1823BAEF7DEF0EEF75D5200BE28BA22A88.png" width="920" height="253.11675126903555"></span></p>     <p><strong>解决措施</strong></p>     <p>排查组件树时，确保@Provide装饰的变量在祖先组件中定义，这些变量被视为提供给后代的状态变量。@Consume装饰的变量在后代组件中使用，用于绑定祖先组件提供的变量。如果@Consume绑定的key在祖先组件中未定义，会导致报错。请从用法角度进行排查。</p>     <p><strong>参考链接</strong></p>     <p><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-provider-and-consumer">跨组件层级双向同步</a>。</p>    </div>    <div class="tiledSection">     <h2 id="link数据源类型错误">@Link数据源类型错误<i class="anchor-icon anchor-icon-link" anchorid="link数据源类型错误" tips="复制节点链接"></i></h2>          <p><strong>问题现象</strong></p>     <p>应用闪退并生成如下jscrash崩溃栈：</p>     <p><span><img originheight="392" originwidth="820" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211114822.88252344919663166537600034141606:50001231000000:2800:14BA85DF21D6594F761559BD1DDE88DA2C63F56D1728F6A352420AB792233656.png" width="820" height="392"></span></p>     <p><strong>可能原因</strong></p>     <p>报错发生在@Link初始化阶段，原因是@Link初始化时会注册到父组件并调用父组件的addSubscriber方法。如果此时数据源的类型与@Link不完全一致，或者使用常量初始化@Link，会导致该方法无法调用，从而引发“is not callable”错误。</p>     <p><span><img originheight="368" originwidth="1258" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211114822.78276217942064823030451236094329:50001231000000:2800:D5F639422B49E7EB04C4C9D01D29B3BE192831C8663B254A072CAD223CB0C735.png" width="920" height="269.1255961844197"></span></p>     <p><strong>解决措施</strong></p>     <p>排查@Link的数据源，确认其是否为状态变量，并确保数据源的类型与@Link的类型一致。</p>     <p><strong>参考链接</strong></p>     <p><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-link">父子双向同步</a>。</p>    </div>    <div class="tiledSection">     <h2 id="provide缺少重写声明">@Provide缺少重写声明<i class="anchor-icon anchor-icon-link" anchorid="provide缺少重写声明" tips="复制节点链接"></i></h2>          <p><strong>问题现象</strong></p>     <p>应用闪退并生成如下jscrash崩溃栈：</p>     <p><span><img originheight="324" originwidth="1467" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211114822.73094032702615861178935859755293:50001231000000:2800:02F93E70AA9D590796431F14F0C908A4945F43ECD93BBBF6061FEEA23622D7EA.png" width="920" height="203.19018404907976"></span></p>     <p><strong>可能原因</strong></p>     <p>报错发生在@Provide初始化阶段，原因是@Provide重写需要声明allowOverride。声明后，别名和属性名都可以被覆盖。如果未声明且存在重复的别名或属性名，将导致错误（duplicate @Provide property with name xxxxx）。</p>     <p><span><img originheight="151" originwidth="1828" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211114822.29280623237814326054887370991140:50001231000000:2800:F7CAD4E7A8A40762F3998A6439809BB12EA27C2C711F1D309B062841ED70992D.png" width="920" height="75.99562363238512"></span></p>     <p><strong>解决措施</strong></p>     <p>需要检查@Provide是否使用了allowOverride声明。如果没有使用allowOverride，则这样使用是不合规的。只有在声明了allowOverride之后，才会允许重写，并且子组件的@Consume会根据别名或属性名找到并使用距离它最近的父节点上的@Provide值。</p>     <p><strong>参考链接</strong></p>     <p><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-new-provider-and-consumer">跨组件层级双向同步</a>。</p>    </div>   </div>   <div></div></div>