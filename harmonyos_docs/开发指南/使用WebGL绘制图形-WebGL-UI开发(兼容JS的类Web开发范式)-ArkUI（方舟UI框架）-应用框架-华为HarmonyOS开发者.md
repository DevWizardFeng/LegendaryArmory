<h1 _ngcontent-ilv-c119="" class="doc-title ng-star-inserted" title="使用WebGL绘制图形"> 使用WebGL绘制图形 </h1>

<div _ngcontent-ilv-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;"> <div> <div class="tiledSection"><h2 id="场景介绍">场景介绍<i class="anchor-icon anchor-icon-link" anchorid="场景介绍" tips="复制节点链接"></i></h2><p>WebGL的全称为Web Graphics Library（网页图形库），主要用于交互式渲染2D图形。目前HarmonyOS中使用的WebGL是基于OpenGL裁剪的OpenGL ES，可以在HTML5的Canvas元素对象中使用，无需使用插件，支持跨平台。WebGL程序是由JavaScript代码组成的，其中使用的API可以利用用户设备提供的GPU硬件完成图形渲染和加速。更多信息请参考<a href="https://www.khronos.org/registry/webgl/specs/latest/1.0/" target="_blank">WebGL™标准</a>。</p> <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"> <p>目前该功能仅支持使用兼容JS的类Web开发范式开发。</p>  </div></div></div> </div>  <div class="tiledSection"><h2 id="基本概念">基本概念<i class="anchor-icon anchor-icon-link" anchorid="基本概念" tips="复制节点链接"></i></h2></div>  <div class="tiledSection"><h3 id="着色器程序" class="firsth2">着色器程序<i class="anchor-icon anchor-icon-link" anchorid="着色器程序" tips="复制节点链接"></i></h3><p>将缓冲区中的数据推送到着色器中还需涉及“着色器程序”，一个负责关联着色器和缓冲区的JavaScript对象。一个WebGLProgram对象由两个编译过后的WebGLShader组成，即顶点着色器和片元着色器（均由GLSL语言所写）。</p> </div>  <div class="tiledSection"><h3 id="着色器">着色器<i class="anchor-icon anchor-icon-link" anchorid="着色器" tips="复制节点链接"></i></h3><p>着色器可以理解为运行在显卡中的指令和数据。在WebGL中，着色器是用OpenGL ES着色语言（GLSL）编写的。</p> <p>完整的着色器包括顶点着色器和片元着色器。顶点着色器和片元着色器的交互则涉及到图片光栅化。</p> <ul><li><p>顶点着色器：最基本的任务是接收三维空间中点的坐标，将其处理为二维空间中的坐标并输出。</p>  </li><li><p>片元着色器：最基本的任务是对需要处理的屏幕上的每个像素输出一个颜色值。</p>  </li></ul> </div>  <div class="tiledSection"><h3 id="图片光栅化">图片光栅化<i class="anchor-icon anchor-icon-link" anchorid="图片光栅化" tips="复制节点链接"></i></h3><p>将顶点着色器输出的二维空间中的点坐标，转化为需要处理的像素并传递给片元着色器的过程。</p> </div>  <div class="tiledSection"><h3 id="帧缓冲区对象">帧缓冲区对象<i class="anchor-icon anchor-icon-link" anchorid="帧缓冲区对象" tips="复制节点链接"></i></h3><p>帧缓冲区对象为绘图缓冲区提供替代呈现目标。它们是颜色、深度和模板缓冲区的集合，通常用于渲染图像。</p> </div>  <div class="tiledSection"><h3 id="纹理">纹理<i class="anchor-icon anchor-icon-link" anchorid="纹理" tips="复制节点链接"></i></h3><p>纹理是一种图像，可以应用到3D模型的表面上。WebGL中的纹理有许多属性，包括宽度、高度、格式和类型。在使用纹理时，需要将其加载到WebGL中，并将其绑定到一个纹理单元上。</p> </div>  <div class="tiledSection"><h2 id="变量与接口说明">变量与接口说明<i class="anchor-icon anchor-icon-link" anchorid="变量与接口说明" tips="复制节点链接"></i></h2></div>  <div class="tiledSection"><h3 id="变量类型" class="firsth2">变量类型<i class="anchor-icon anchor-icon-link" anchorid="变量类型" tips="复制节点链接"></i></h3> <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.9.2.1.4.1.1" valign="top" width="33.33333333333333%">类型</th> <th align="left" class="cellrowborder" id="mcps1.3.9.2.1.4.1.2" valign="top" width="33.33333333333333%">对应Web IDL类型</th> <th align="left" class="cellrowborder" id="mcps1.3.9.2.1.4.1.3" valign="top" width="33.33333333333333%">描述</th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="33.33333333333333%">GLenum</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">unsigned long</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">用于枚举。</td> </tr> <tr><td class="cellrowborder" valign="top" width="33.33333333333333%">GLboolean</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">boolean</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">true或者false。</td> </tr> <tr><td class="cellrowborder" valign="top" width="33.33333333333333%">GLbitfield</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">unsigned long</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">无符号整数，可以包含多个位标志。每个位标志都代表一个特定的选项。</td> </tr> <tr><td class="cellrowborder" valign="top" width="33.33333333333333%">GLbyte</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">byte</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">纹理八位（一个字节），2的补码表示的有符号整数。</td> </tr> <tr><td class="cellrowborder" valign="top" width="33.33333333333333%">GLshort</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">short</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">16位2的补码表示的有符号整数。</td> </tr> <tr><td class="cellrowborder" valign="top" width="33.33333333333333%">GLint</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">long</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">32位2的补码表示的有符号整数。</td> </tr> <tr><td class="cellrowborder" valign="top" width="33.33333333333333%">GLsizei</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">long</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">用来描述尺寸（例如：绘画缓冲drawing buffer 的宽和高）。</td> </tr> <tr><td class="cellrowborder" valign="top" width="33.33333333333333%">GLintptr</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">long long</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">用来表示指针的特殊类型，通常用于指定缓冲区对象的偏移量。</td> </tr> <tr><td class="cellrowborder" valign="top" width="33.33333333333333%">GLsizeiptr</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">long long</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">用来表示指针的特殊类型，通常用于指定缓冲区对象的大小。</td> </tr> <tr><td class="cellrowborder" valign="top" width="33.33333333333333%">GLubyte</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">octet</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">八位（一个字节）2的补码表示的无符号整数。</td> </tr> <tr><td class="cellrowborder" valign="top" width="33.33333333333333%">GLushort</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">unsigned short</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">16位2的补码表示的无符号整数。</td> </tr> <tr><td class="cellrowborder" valign="top" width="33.33333333333333%">GLuint</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">unsigned long</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">32位2的补码表示的无符号整数。</td> </tr> <tr><td class="cellrowborder" valign="top" width="33.33333333333333%">GLfloat</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">unrestricted float</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">32位的IEEE标准的浮点数。</td> </tr> <tr><td class="cellrowborder" valign="top" width="33.33333333333333%">GLclampf</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">unrestricted float</td> <td class="cellrowborder" valign="top" width="33.33333333333333%">限值32位IEEE浮点数。</td> </tr>  </tbody></table></div> </div> </div>  <div class="tiledSection"><h3 id="接口说明">接口说明<i class="anchor-icon anchor-icon-link" anchorid="接口说明" tips="复制节点链接"></i></h3> <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.10.2.1.3.1.1" valign="top" width="50%">接口名</th> <th align="left" class="cellrowborder" id="mcps1.3.10.2.1.3.1.2" valign="top" width="50%">描述</th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="50%">canvas.getContext</td> <td class="cellrowborder" valign="top" width="50%">获取canvas对象上下文。</td> </tr> <tr><td class="cellrowborder" valign="top" width="50%">webgl.createBuffer(): WebGLBuffer | null</td> <td class="cellrowborder" valign="top" width="50%">创建与初始化WebGL数据缓冲区。</td> </tr> <tr><td class="cellrowborder" valign="top" width="50%">webgl.bindBuffer(target: GLenum, buffer: WebGLBuffer | null): void</td> <td class="cellrowborder" valign="top" width="50%">将WebGL数据缓冲区与目标进行绑定。</td> </tr> <tr><td class="cellrowborder" valign="top" width="50%">webgl.bufferData(target: GLenum, srcData: ArrayBufferView, usage: GLenum, srcOffset: GLuint, length?: GLuint): void</td> <td class="cellrowborder" valign="top" width="50%">创建并初始化WebGL的数据存储区。</td> </tr> <tr><td class="cellrowborder" valign="top" width="50%">webgl.getAttribLocation(program: WebGLProgram, name: string): GLint</td> <td class="cellrowborder" valign="top" width="50%">从给定WebGL着色程序中获取着色器中attribute变量的地址。</td> </tr> <tr><td class="cellrowborder" valign="top" width="50%">webgl.vertexAttribPointer(index GLuint, size: GLint, type: GLenum, normalized: GLboolean, stride: GLsizei, offset: GLintptr): void</td> <td class="cellrowborder" valign="top" width="50%">将缓冲区对象分配给变量。</td> </tr> <tr><td class="cellrowborder" valign="top" width="50%">webgl.enableVertexAttribArray(index: GLuint): void</td> <td class="cellrowborder" valign="top" width="50%">连接变量与分配给它的缓冲区对象。</td> </tr> <tr><td class="cellrowborder" valign="top" width="50%">webgl.clearColor(red: GLclampf, green: GLclampf, blue: GLclampf, alpha: GLclampf): void</td> <td class="cellrowborder" valign="top" width="50%">清空&lt;canvas&gt;指定的颜色。</td> </tr> <tr><td class="cellrowborder" valign="top" width="50%">webgl.clear(mask: GLbitfield): void</td> <td class="cellrowborder" valign="top" width="50%">清空&lt;canvas&gt;。</td> </tr> <tr><td class="cellrowborder" valign="top" width="50%">webgl.drawArrays(mode: GLenum, first: GLint, count: GLsizei): void</td> <td class="cellrowborder" valign="top" width="50%">执行数据绘制。</td> </tr> <tr><td class="cellrowborder" valign="top" width="50%">webgl.flush(): void</td> <td class="cellrowborder" valign="top" width="50%">刷新数据至GPU，清空缓冲区。</td> </tr> <tr><td class="cellrowborder" valign="top" width="50%">webgl.createProgram(): WebGLProgram | null</td> <td class="cellrowborder" valign="top" width="50%">创建着色器程序对象。</td> </tr>  </tbody></table></div> </div> </div>  <div class="tiledSection"><h2 id="开发步骤">开发步骤<i class="anchor-icon anchor-icon-link" anchorid="开发步骤" tips="复制节点链接"></i></h2><p> 如下以实现一个彩色正方形为例，来演示使用WebGL绘制2D图形的过程。</p> <ol><li><p>使用WebGL进行3D渲染前，首先需要一个Canvas元素。以下示例创建了一个Canvas元素并设置一个onclick事件处理程序来初始化WebGL上下文。</p>  <div _ngcontent-ilv-c106="" class="highlight-div"><div _ngcontent-ilv-c106="" class="highlight-div-header"><div _ngcontent-ilv-c106="" class="highlight-div-header-left"><div _ngcontent-ilv-c106="" class="handle-button expand-button"><div _ngcontent-ilv-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-ilv-c106="" class="highlight-div-header-right"><div _ngcontent-ilv-c106="" class="handle-button ai-button"></div><div _ngcontent-ilv-c106="" class="handle-button line-button"><div _ngcontent-ilv-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-ilv-c106="" class="handle-button theme-button"><div _ngcontent-ilv-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-ilv-c106="" class="handle-button copy-button"><div _ngcontent-ilv-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-ilv-c106="" class="highlight-scroll-div"><pre class="hml prettyprint linenums hljs language-php-template" hw-language="hml" data-highlighted="yes"><ol class="linenums"><li><span class="language-xml"> <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span></span></li><li><span class="language-xml">     <span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"canvas1"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"width : 400px; height : 400px; background-color : lightyellow;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span></span></li><li><span class="language-xml">     <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn-button"</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"BtnColorTriangle"</span>&gt;</span>BtnColorTriangle<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span></li><li><span class="language-xml"> <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></li></ol></pre></div></div>  </li><li><p>设置WebGL的上下文。</p>  <ul><li><p>JavaScript 代码中的 main() 函数将会在文档加载完成之后被调用。它的任务是设置WebGL上下文并开始渲染内容。</p>  </li><li><p>当获取到canvas之后，会调用getContext函数并向它传递 "webgl" 参数，来尝试获取WebGLRenderingContext。如果浏览器不支持WebGL，getContext将会返回null，如果WebGL上下文成功初始化，变量'gl'会用来引用该上下文。</p>  </li></ul>  <div _ngcontent-ilv-c106="" class="highlight-div"><div _ngcontent-ilv-c106="" class="highlight-div-header"><div _ngcontent-ilv-c106="" class="highlight-div-header-left"><div _ngcontent-ilv-c106="" class="handle-button expand-button"><div _ngcontent-ilv-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-ilv-c106="" class="highlight-div-header-right"><div _ngcontent-ilv-c106="" class="handle-button ai-button"></div><div _ngcontent-ilv-c106="" class="handle-button line-button"><div _ngcontent-ilv-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-ilv-c106="" class="handle-button theme-button"><div _ngcontent-ilv-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-ilv-c106="" class="handle-button copy-button"><div _ngcontent-ilv-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-ilv-c106="" class="highlight-scroll-div"><pre class="js prettyprint linenums hljs language-javascript" hw-language="js" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) {</li><li>  <span class="hljs-keyword">const</span> canvas = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">"#glcanvas"</span>);</li><li>  <span class="hljs-comment">// 初始化WebGL上下文</span></li><li>  <span class="hljs-keyword">const</span> gl = canvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">"webgl"</span>);</li><li>
</li><li>  <span class="hljs-comment">// 确认WebGL支持性</span></li><li>  <span class="hljs-keyword">if</span> (!gl) {</li><li>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">"你的浏览器、操作系统或硬件等可能不支持WebGL。"</span>);</li><li>    <span class="hljs-keyword">return</span>;</li><li>  }</li><li>  <span class="hljs-comment">// 使用完全不透明的黑色清除所有图像</span></li><li>  gl.<span class="hljs-title function_">clearColor</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);</li><li>  <span class="hljs-comment">// 用上面指定的颜色清除缓冲区</span></li><li>  gl.<span class="hljs-title function_">clear</span>(gl.<span class="hljs-property">COLOR_BUFFER_BIT</span>);</li><li>}</li></ol></pre></div></div>  </li><li><p>定义顶点着色器。</p>  <p>顶点着色器需要对顶点坐标进行必要的转换，在每个顶点基础上进行其他调整或计算，然后通过将其保存在由GLSL提供的特殊变量中来返回变换后的顶点。</p>  <p>在矩阵计算之前需要先引入gl-matrix开源工具库，可以从<a href="https://glmatrix.net/" target="_blank">gl-matrix官网</a>下载，也可以使用npm命令下载：</p> <p>npm install gl-matrix</p>  <div _ngcontent-ilv-c106="" class="highlight-div"><div _ngcontent-ilv-c106="" class="highlight-div-header"><div _ngcontent-ilv-c106="" class="highlight-div-header-left"><div _ngcontent-ilv-c106="" class="handle-button expand-button"><div _ngcontent-ilv-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-ilv-c106="" class="highlight-div-header-right"><div _ngcontent-ilv-c106="" class="handle-button ai-button"></div><div _ngcontent-ilv-c106="" class="handle-button line-button"><div _ngcontent-ilv-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-ilv-c106="" class="handle-button theme-button"><div _ngcontent-ilv-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-ilv-c106="" class="handle-button copy-button"><div _ngcontent-ilv-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-ilv-c106="" class="highlight-scroll-div"><pre class="js prettyprint linenums hljs language-javascript" hw-language="js" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// 引入mat4</span></li><li><span class="hljs-keyword">import</span> { mat4 } <span class="hljs-keyword">from</span> <span class="hljs-string">'gl-matrix'</span></li><li><span class="hljs-keyword">const</span> vsSource = <span class="hljs-string">`</span></li><li><span class="hljs-string">    attribute vec4 aVertexPosition;</span></li><li><span class="hljs-string">    uniform mat4 uModelViewMatrix;</span></li><li><span class="hljs-string">    uniform mat4 uProjectionMatrix;</span></li><li><span class="hljs-string">    void main() {</span></li><li><span class="hljs-string">      gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;</span></li><li><span class="hljs-string">    }</span></li><li><span class="hljs-string">  `</span>;</li></ol></pre></div></div>  </li><li><p>定义片段着色器。</p>  <p>片段着色器在顶点着色器处理完图形的顶点后，会被要绘制的每个图形的每个像素点调用一次。</p>  <div _ngcontent-ilv-c106="" class="highlight-div"><div _ngcontent-ilv-c106="" class="highlight-div-header"><div _ngcontent-ilv-c106="" class="highlight-div-header-left"><div _ngcontent-ilv-c106="" class="handle-button expand-button"><div _ngcontent-ilv-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-ilv-c106="" class="highlight-div-header-right"><div _ngcontent-ilv-c106="" class="handle-button ai-button"></div><div _ngcontent-ilv-c106="" class="handle-button line-button"><div _ngcontent-ilv-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-ilv-c106="" class="handle-button theme-button"><div _ngcontent-ilv-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-ilv-c106="" class="handle-button copy-button"><div _ngcontent-ilv-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-ilv-c106="" class="highlight-scroll-div"><pre class="js prettyprint linenums hljs language-javascript" hw-language="js" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">const</span> fsSource = <span class="hljs-string">`</span></li><li><span class="hljs-string">    void main() {</span></li><li><span class="hljs-string">      gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);</span></li><li><span class="hljs-string">    }</span></li><li><span class="hljs-string"> `</span>;</li></ol></pre></div></div>  </li><li><p>将着色器传递给WebGL。</p>  <p>定义顶点着色器与片段着色器之后，需要将它们传递给WebGL，并将其编译连接在一起。</p>  <p>如下代码通过调用 loadShader()，为着色器传递类型和来源。创建了两个着色器。然后创建一个附加着色器的程序，将它们连接在一起。如果编译或链接失败，代码将弹出alert。</p>  <div _ngcontent-ilv-c106="" class="highlight-div"><div _ngcontent-ilv-c106="" class="highlight-div-header"><div _ngcontent-ilv-c106="" class="highlight-div-header-left"><div _ngcontent-ilv-c106="" class="handle-button expand-button"><div _ngcontent-ilv-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-ilv-c106="" class="highlight-div-header-right"><div _ngcontent-ilv-c106="" class="handle-button ai-button"></div><div _ngcontent-ilv-c106="" class="handle-button line-button"><div _ngcontent-ilv-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-ilv-c106="" class="handle-button theme-button"><div _ngcontent-ilv-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-ilv-c106="" class="handle-button copy-button"><div _ngcontent-ilv-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-ilv-c106="" class="highlight-scroll-div"><pre class="js prettyprint linenums hljs language-javascript" hw-language="js" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// 初始化着色器程序，让WebGL知道如何绘制数据</span></li><li><span class="hljs-keyword">function</span> <span class="hljs-title function_">initShaderProgram</span>(<span class="hljs-params">gl, vsSource, fsSource</span>) {</li><li>  <span class="hljs-keyword">const</span> vertexShader = <span class="hljs-title function_">loadShader</span>(gl, gl.<span class="hljs-property">VERTEX_SHADER</span>, vsSource);</li><li>  <span class="hljs-keyword">const</span> fragmentShader = <span class="hljs-title function_">loadShader</span>(gl, gl.<span class="hljs-property">FRAGMENT_SHADER</span>, fsSource);</li><li>  <span class="hljs-comment">// 创建着色器程序</span></li><li>  <span class="hljs-keyword">const</span> shaderProgram = gl.<span class="hljs-title function_">createProgram</span>();</li><li>  gl.<span class="hljs-title function_">attachShader</span>(shaderProgram, vertexShader);</li><li>  gl.<span class="hljs-title function_">attachShader</span>(shaderProgram, fragmentShader);</li><li>  gl.<span class="hljs-title function_">linkProgram</span>(shaderProgram);</li><li>  <span class="hljs-comment">// 如果创建失败，将会弹出alert</span></li><li>  <span class="hljs-keyword">if</span> (!gl.<span class="hljs-title function_">getProgramParameter</span>(shaderProgram, gl.<span class="hljs-property">LINK_STATUS</span>)) {</li><li>    <span class="hljs-title function_">alert</span>(</li><li>      <span class="hljs-string">"无法初始化着色器程序: "</span> +</li><li>     gl.<span class="hljs-title function_">getProgramInfoLog</span>(shaderProgram),</li><li>    );</li><li>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;</li><li>  }</li><li>  <span class="hljs-keyword">return</span> shaderProgram;</li><li>}</li><li><span class="hljs-comment">// 创建指定类型的着色器，上传source源码并编译</span></li><li><span class="hljs-keyword">function</span> <span class="hljs-title function_">loadShader</span>(<span class="hljs-params">gl, type, source</span>) {</li><li>  <span class="hljs-keyword">const</span> shader = gl.<span class="hljs-title function_">createShader</span>(type);</li><li>  <span class="hljs-comment">// 将资源发送到着色器对象</span></li><li>  gl.<span class="hljs-title function_">shaderSource</span>(shader, source);</li><li>  <span class="hljs-comment">// 编译着色器程序</span></li><li>  gl.<span class="hljs-title function_">compileShader</span>(shader);</li><li>  <span class="hljs-comment">// 查看是否编译成功</span></li><li>  <span class="hljs-keyword">if</span> (!gl.<span class="hljs-title function_">getShaderParameter</span>(shader, gl.<span class="hljs-property">COMPILE_STATUS</span>)) {</li><li>    <span class="hljs-title function_">alert</span>(</li><li>   <span class="hljs-string">"编译着色器时出错："</span> + gl.<span class="hljs-title function_">getShaderInfoLog</span>(shader),</li><li>    );</li><li>    gl.<span class="hljs-title function_">deleteShader</span>(shader);</li><li>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;</li><li>  }</li><li>  <span class="hljs-keyword">return</span> shader;</li><li>}</li></ol></pre></div></div>  </li><li><p>查找WebGL返回分配的输入位置。</p>  <ul><li><p>在创建着色器程序之后，需要查找WebGL返回分配的输入位置。上述有一个属性和两个Uniform。</p>  </li><li><p>属性从缓冲区接收值。顶点着色器的每次迭代都从分配给该属性的缓冲区接收下一个值。</p>  </li><li><p>Uniform类似于JavaScript全局变量。它们在着色器的所有迭代中保持相同的值。由于属性的位置是特定于单个着色器程序的，因此将它们存储在一起以易于传递。</p>  </li></ul>  <div _ngcontent-ilv-c106="" class="highlight-div"><div _ngcontent-ilv-c106="" class="highlight-div-header"><div _ngcontent-ilv-c106="" class="highlight-div-header-left"><div _ngcontent-ilv-c106="" class="handle-button expand-button"><div _ngcontent-ilv-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-ilv-c106="" class="highlight-div-header-right"><div _ngcontent-ilv-c106="" class="handle-button ai-button"></div><div _ngcontent-ilv-c106="" class="handle-button line-button"><div _ngcontent-ilv-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-ilv-c106="" class="handle-button theme-button"><div _ngcontent-ilv-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-ilv-c106="" class="handle-button copy-button"><div _ngcontent-ilv-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-ilv-c106="" class="highlight-scroll-div"><pre class="js prettyprint linenums hljs language-javascript" hw-language="js" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">const</span> programInfo = {</li><li>  <span class="hljs-attr">program</span>: shaderProgram,</li><li>  <span class="hljs-attr">attribLocations</span>: {</li><li>    <span class="hljs-attr">vertexPosition</span>: gl.<span class="hljs-title function_">getAttribLocation</span>(shaderProgram, <span class="hljs-string">"aVertexPosition"</span>),</li><li>  },</li><li>  <span class="hljs-attr">uniformLocations</span>: {</li><li>    <span class="hljs-attr">projectionMatrix</span>: gl.<span class="hljs-title function_">getUniformLocation</span>(shaderProgram, <span class="hljs-string">"uProjectionMatrix"</span>),</li><li>    <span class="hljs-attr">modelViewMatrix</span>: gl.<span class="hljs-title function_">getUniformLocation</span>(shaderProgram, <span class="hljs-string">"uModelViewMatrix"</span>),</li><li>  },</li><li>};</li></ol></pre></div></div>  </li><li><p>创建缓冲器对象。</p>  <ul><li><p>在画正方形前，需要创建一个缓冲器来存储它的顶点。</p>  </li><li><p>首先调用gl的成员函数createBuffer()得到缓冲对象并存储在顶点缓冲器。然后调用 bindBuffer() 函数绑定上下文。</p>  </li><li><p>创建一个Javascript数组去记录每一个正方体的每一个顶点。然后将其转化为WebGL浮点型类型的数组，并将其传到gl对象的bufferData()方法来建立对象的顶点。</p>  </li></ul>  <div _ngcontent-ilv-c106="" class="highlight-div"><div _ngcontent-ilv-c106="" class="highlight-div-header"><div _ngcontent-ilv-c106="" class="highlight-div-header-left"><div _ngcontent-ilv-c106="" class="handle-button expand-button"><div _ngcontent-ilv-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-ilv-c106="" class="highlight-div-header-right"><div _ngcontent-ilv-c106="" class="handle-button ai-button"></div><div _ngcontent-ilv-c106="" class="handle-button line-button"><div _ngcontent-ilv-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-ilv-c106="" class="handle-button theme-button"><div _ngcontent-ilv-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-ilv-c106="" class="handle-button copy-button"><div _ngcontent-ilv-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-ilv-c106="" class="highlight-scroll-div"><pre class="js prettyprint linenums hljs language-javascript" hw-language="js" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">function</span> <span class="hljs-title function_">initBuffers</span>(<span class="hljs-params">gl</span>) {</li><li>  <span class="hljs-keyword">const</span> positionBuffer = <span class="hljs-title function_">initPositionBuffer</span>(gl);</li><li>  <span class="hljs-keyword">return</span> {</li><li>    <span class="hljs-attr">position</span>: positionBuffer,</li><li>  };</li><li>}</li><li><span class="hljs-keyword">function</span> <span class="hljs-title function_">initPositionBuffer</span>(<span class="hljs-params">gl</span>) {</li><li>  <span class="hljs-comment">// 为正方形的位置创建一个缓冲区。</span></li><li>  <span class="hljs-keyword">const</span> positionBuffer = gl.<span class="hljs-title function_">createBuffer</span>();</li><li>  <span class="hljs-comment">// 选择positionBuffer作为应用缓冲区的位置。</span></li><li>  gl.<span class="hljs-title function_">bindBuffer</span>(gl.<span class="hljs-property">ARRAY_BUFFER</span>, positionBuffer);</li><li>  <span class="hljs-comment">// 创建一个正方形的位置数组。</span></li><li>  <span class="hljs-keyword">const</span> positions = [<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, -<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, -<span class="hljs-number">1.0</span>, -<span class="hljs-number">1.0</span>, -<span class="hljs-number">1.0</span>];</li><li>  <span class="hljs-comment">//将位置列表传递给WebGL以构建形状。</span></li><li>  gl.<span class="hljs-title function_">bufferData</span>(gl.<span class="hljs-property">ARRAY_BUFFER</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Float32Array</span>(positions), gl.<span class="hljs-property">STATIC_DRAW</span>);</li><li>  <span class="hljs-keyword">return</span> positionBuffer;</li><li>}</li><li><span class="hljs-keyword">export</span> { initBuffers };</li></ol></pre></div></div>  </li><li><p>渲染场景。</p>  <ul><li><p>用背景色擦除画布，然后建立摄像机透视矩阵。设置45度的视图角度，并且设置一个适合实际图像的宽高比。指定在摄像机距离0.1到100单位长度的范围内的物体可见。</p>  </li><li><p>加载特定位置，并把正方形放在距离摄像机6个单位的位置。然后，绑定正方形的顶点缓冲到上下文，并配置好，再通过调用drawArrays()方法来画出对象。</p>  </li></ul>  <div _ngcontent-ilv-c106="" class="highlight-div"><div _ngcontent-ilv-c106="" class="highlight-div-header"><div _ngcontent-ilv-c106="" class="highlight-div-header-left"><div _ngcontent-ilv-c106="" class="handle-button expand-button"><div _ngcontent-ilv-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-ilv-c106="" class="highlight-div-header-right"><div _ngcontent-ilv-c106="" class="handle-button ai-button"></div><div _ngcontent-ilv-c106="" class="handle-button line-button"><div _ngcontent-ilv-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-ilv-c106="" class="handle-button theme-button"><div _ngcontent-ilv-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-ilv-c106="" class="handle-button copy-button"><div _ngcontent-ilv-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-ilv-c106="" class="highlight-scroll-div"><pre class="js prettyprint linenums hljs language-javascript" hw-language="js" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">function</span> <span class="hljs-title function_">drawScene</span>(<span class="hljs-params">gl, programInfo, buffers</span>) {</li><li>  gl.<span class="hljs-title function_">clearColor</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);</li><li>  gl.<span class="hljs-title function_">clearDepth</span>(<span class="hljs-number">1.0</span>); <span class="hljs-comment">// 清除所有内容。</span></li><li>  gl.<span class="hljs-title function_">depthFunc</span>(gl.<span class="hljs-property">LEQUAL</span>);</li><li>  <span class="hljs-comment">// 清除画布。</span></li><li>   gl.<span class="hljs-title function_">clear</span>(gl.<span class="hljs-property">COLOR_BUFFER_BIT</span> | gl.<span class="hljs-property">DEPTH_BUFFER_BIT</span>);</li><li>  <span class="hljs-comment">//创建透视矩阵用于模拟相机中的透视变形。</span></li><li>  <span class="hljs-keyword">const</span> fieldOfView = (<span class="hljs-number">45</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>) / <span class="hljs-number">180</span>;</li><li>  <span class="hljs-keyword">const</span> aspect = gl.<span class="hljs-property">canvas</span>.<span class="hljs-property">clientWidth</span> / gl.<span class="hljs-property">canvas</span>.<span class="hljs-property">clientHeight</span>;</li><li>  <span class="hljs-keyword">const</span> zNear = <span class="hljs-number">0.1</span>;</li><li>  <span class="hljs-keyword">const</span> zFar = <span class="hljs-number">100.0</span>;</li><li>  <span class="hljs-keyword">const</span> projectionMatrix = mat4.<span class="hljs-title function_">create</span>();</li><li>  mat4.<span class="hljs-title function_">perspective</span>(projectionMatrix, fieldOfView, aspect, zNear, zFar);</li><li>  <span class="hljs-comment">// 将绘制位置设置为标识点，即场景的中心。</span></li><li>  <span class="hljs-keyword">const</span> modelViewMatrix = mat4.<span class="hljs-title function_">create</span>();</li><li>  <span class="hljs-comment">// 开始绘制正方形。</span></li><li>  mat4.<span class="hljs-title function_">translate</span>(</li><li>    modelViewMatrix, <span class="hljs-comment">// 目标矩阵</span></li><li>    modelViewMatrix, <span class="hljs-comment">// 要转换的矩阵</span></li><li>    [-<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, -<span class="hljs-number">6.0</span>],</li><li>  );</li><li>  {</li><li>    <span class="hljs-keyword">const</span> numComponents = <span class="hljs-number">2</span>;</li><li>    <span class="hljs-keyword">const</span> type = gl.<span class="hljs-property">FLOAT</span>;</li><li>    <span class="hljs-keyword">const</span> normalize = <span class="hljs-literal">false</span>;</li><li>    <span class="hljs-keyword">const</span> stride = <span class="hljs-number">0</span>; <span class="hljs-comment">// 从一组值到下一组值需要多少字节</span></li><li>    <span class="hljs-keyword">const</span> offset = <span class="hljs-number">0</span>;</li><li>    gl.<span class="hljs-title function_">bindBuffer</span>(gl.<span class="hljs-property">ARRAY_BUFFER</span>, buffers.<span class="hljs-property">position</span>);</li><li>    gl.<span class="hljs-title function_">vertexAttribPointer</span>(</li><li>      programInfo.<span class="hljs-property">attribLocations</span>.<span class="hljs-property">vertexPosition</span>,</li><li>      numComponents,</li><li>      type,</li><li>      normalize,</li><li>      stride,</li><li>      offset,</li><li>    );</li><li>    gl.<span class="hljs-title function_">enableVertexAttribArray</span>(programInfo.<span class="hljs-property">attribLocations</span>.<span class="hljs-property">vertexPosition</span>);</li><li>  }</li><li>  gl.<span class="hljs-title function_">useProgram</span>(programInfo.<span class="hljs-property">program</span>);</li><li>  gl.<span class="hljs-title function_">uniformMatrix4fv</span>(</li><li>    programInfo.<span class="hljs-property">uniformLocations</span>.<span class="hljs-property">projectionMatrix</span>,</li><li>    <span class="hljs-literal">false</span>,</li><li>    projectionMatrix,</li><li>  );</li><li>  gl.<span class="hljs-title function_">uniformMatrix4fv</span>(</li><li>    programInfo.<span class="hljs-property">uniformLocations</span>.<span class="hljs-property">modelViewMatrix</span>,</li><li>    <span class="hljs-literal">false</span>,</li><li>    modelViewMatrix,</li><li>  );</li><li>  {</li><li>    <span class="hljs-keyword">const</span> offset = <span class="hljs-number">0</span>;</li><li>    <span class="hljs-keyword">const</span> vertexCount = <span class="hljs-number">4</span>;</li><li>    gl.<span class="hljs-title function_">drawArrays</span>(gl.<span class="hljs-property">TRIANGLE_STRIP</span>, offset, vertexCount);</li><li>  }</li><li>}</li><li><span class="hljs-comment">// 告诉WebGL如何从位置中拉出位置缓冲到vertexPosition属性中。</span></li><li><span class="hljs-keyword">function</span> <span class="hljs-title function_">setPositionAttribute</span>(<span class="hljs-params">gl, buffers, programInfo</span>) {</li><li>  <span class="hljs-keyword">const</span> numComponents = <span class="hljs-number">2</span>;</li><li>  <span class="hljs-keyword">const</span> type = gl.<span class="hljs-property">FLOAT</span>;</li><li>  <span class="hljs-keyword">const</span> normalize = <span class="hljs-literal">false</span>;</li><li>  <span class="hljs-keyword">const</span> stride = <span class="hljs-number">0</span>; <span class="hljs-comment">// 从一组值到下一组值需要多少字节</span></li><li>  <span class="hljs-keyword">const</span> offset = <span class="hljs-number">0</span>;</li><li>  gl.<span class="hljs-title function_">bindBuffer</span>(gl.<span class="hljs-property">ARRAY_BUFFER</span>, buffers.<span class="hljs-property">position</span>);</li><li>  gl.<span class="hljs-title function_">vertexAttribPointer</span>(</li><li>    programInfo.<span class="hljs-property">attribLocations</span>.<span class="hljs-property">vertexPosition</span>,</li><li>    numComponents,</li><li>    type,</li><li>    normalize,</li><li>    stride,</li><li>    offset,</li><li>  );</li><li>  gl.<span class="hljs-title function_">enableVertexAttribArray</span>(programInfo.<span class="hljs-property">attribLocations</span>.<span class="hljs-property">vertexPosition</span>);</li><li>}</li><li><span class="hljs-keyword">export</span> { drawScene };</li></ol></pre></div></div>  </li></ol> <p>最终实现效果示意如下：</p> <p><span><img originheight="585" originwidth="781" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211114756.58127585214603399195115966342842:50001231000000:2800:8DEF6F7C616D803F69F1159A2B99BE90127E18EDC8391392E64E6ABFA92D63A8.png" width="781" height="585"></span></p> </div> </div> <div></div></div>