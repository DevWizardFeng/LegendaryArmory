<h1 _ngcontent-jib-c119="" class="doc-title ng-star-inserted" title="基础知识"> 基础知识 </h1>

<div _ngcontent-jib-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;"> <div><div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"><p>本节内容为使用高阶API进行矩阵乘法的编程指导。使用高阶API进行实际的矩阵编程时，需要通过<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cannkit-matmul-usage-description">Matmul</a>查看确认接口支持的产品型号。</p> </div></div></div> <div class="tiledSection"><h2 id="section2283mcpsimp">矩阵乘法概述<i class="anchor-icon anchor-icon-link" anchorid="section2283mcpsimp" tips="复制节点链接"></i></h2><p>MatMul的计算公式为：C = A * B + bias，其示意图如下。</p> <ul><li>A、B为源操作数，A为左矩阵，形状为[M, K]；B为右矩阵，形状为[K, N]。</li><li>C为目的操作数，存放矩阵乘结果的矩阵，形状为[M, N]。</li><li>bias为矩阵乘偏置，形状为[1, N]。对A*B结果矩阵的每一行都采用该bias进行偏置。</li></ul> <p><span><img height="133" originheight="153" originwidth="585" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211114303.34633313443197673314876253519730:50001231000000:2800:1466E8524BF13C34CC569DE71E61D5F5B5A4EC39CD7CC9800CE175243C4C8BBB.png" title="点击放大" width="526.6800000000001"></span></p> </div> <div class="tiledSection"><h2 id="section2292mcpsimp">矩阵乘法数据流<i class="anchor-icon anchor-icon-link" anchorid="section2292mcpsimp" tips="复制节点链接"></i></h2><p>在了解矩阵乘法数据流之前，需要先回顾一下几个重要的存储<strong>逻辑位置</strong>的概念：</p> <ul><li>搬入数据的存放位置：A1，用于存放整块A矩阵，可类比CPU多级缓存中的二级缓存。</li><li>搬入数据的存放位置：B1，用于存放整块B矩阵，可类比CPU多级缓存中的二级缓存。</li><li>搬入数据的存放位置：A2，用于存放切分后的小块A矩阵，可类比CPU多级缓存中的一级缓存。</li><li>搬入数据的存放位置：B2，用于存放切分后的小块B矩阵，可类比CPU多级缓存中的一级缓存。</li><li>结果数据的存放位置：CO1，用于存放小块结果C矩阵，可理解为Cube Out。</li><li>结果数据的存放位置：CO2，用于存放整块结果C矩阵，可理解为Cube Out。</li><li>搬入数据的存放位置：VECCALC，一般在计算需要临时变量时使用此位置。</li></ul> <p><strong>矩阵乘法数据流</strong>指矩阵乘的输入输出在各存储位置间的流向。逻辑位置的数据流向如下图所示（为了简化描述，没有列出bias）：</p> <ul><li>A矩阵从输入位置到A2的数据流如下（输入位置可以是GM或者VECOUT）：GM-&gt;A2，GM-&gt;A1-&gt;A2；VECOUT-&gt;A1-&gt;A2。</li><li>B矩阵从输入位置到B2的数据流如下（输入位置可以是GM或者VECOUT）：GM-&gt;B2，GM-&gt;B1-&gt;B2；VECOUT-&gt;B1-&gt;B2。</li><li>完成A2*B2=CO1计算。</li><li>CO1数据汇聚到CO2：CO1-&gt;CO2。</li><li>从CO2到输出位置（输出位置可以是GM或者VECIN）：CO2-&gt;GM/CO2-&gt;VECIN。</li></ul> <p class="msonormal"><span><img height="228.76000000000002" originheight="365" originwidth="838" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211114303.76226807629314490341728067710367:50001231000000:2800:2A50ED264EF2DC856849658CF4697EED489E398C257C6F8361186EDCB55E22EA.png" title="点击放大" width="526.6800000000001"></span></p> </div> <div class="tiledSection"><h2 id="section2313mcpsimp">数据格式<i class="anchor-icon anchor-icon-link" anchorid="section2313mcpsimp" tips="复制节点链接"></i></h2><p>在完成Matmul矩阵乘法时，涉及到两种分形格式ND和NZ。</p> <ul><li>ND：普通格式，N维张量。</li><li>NZ：为满足AICore中Cube计算单元高性能计算的需要，引入该特殊格式。<p>ND –&gt; NZ的变换过程为：</p> <p>(..., N，H, W )-&gt;pad-&gt;(..., N, H1*H0, W1*W0)-&gt;reshape-&gt;(..., N, H1, H0, W1, W0)-&gt;transpose-&gt;(..., N, W1, H1, H0, W0)</p> <p>如下图所示 （W，H）大小的矩阵被分为（H1*W1）个分形，按照column major排布，形状如N字形；每个分形内部有（H0*W0）个元素，按照row major排布，形状如z字形。所以这种数据格式称为NZ（大N小Z）格式。</p> <p class="msonormal"><span><img height="219.45000000000002" originheight="345" originwidth="813" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211114303.66072635712790315026602455857362:50001231000000:2800:E101DF2C518616AB55E4EB3892CB89BE098B273B4EBE0612C9D734FF5FB68DDB.png" title="点击放大" width="526.6800000000001"></span></p> <p>下面我们再通过一个具体的例子来深入理解ND和NZ格式的数据排布区别。假设分形格式为2*2，如下图所示4*4的矩阵，ND和NZ格式存储两种情况下，数据在内存中的排布格式分别为：</p> <p>ND：0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15</p> <p>NZ：0, 1, 4, 5, 8, 9, 12, 13, 2, 3, 6, 7, 10, 11, 14, 15</p> <p class="msonormal"><span><img height="162.26000000000002" originheight="161" originwidth="509" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211114303.98592430847606283387332782942660:50001231000000:2800:2B72E0BC107DC7519D2977AEB4AFEEB84430A3C991202DB3988E1533453C28A3.png" title="点击放大" width="516.0400000000001"></span></p> </li></ul> </div> <div class="tiledSection"><h2 id="section2326mcpsimp">数据分块(Tiling)<i class="anchor-icon anchor-icon-link" anchorid="section2326mcpsimp" tips="复制节点链接"></i></h2></div> <div class="tiledSection"><h3 id="section1685135811205" class="firsth2">多核切分<i class="anchor-icon anchor-icon-link" anchorid="section1685135811205" tips="复制节点链接"></i></h3><p>为了实现多核并行，需要将矩阵数据进行切分，分配到不同的核上进行处理。切分策略如下图所示：</p> <ul><li>对于A矩阵，沿着M轴进行切分，切分成多份的singleCoreM，单核上处理SingleCoreM * K大小的数据。</li><li>对于B矩阵，沿着N轴进行切分，切分成多份的singleCoreN，单核上处理K * SingleCoreN大小的数据。</li><li>对于C矩阵，SingleCoreM * K大小的A矩阵和K * SingleCoreN大小的B矩阵相乘得到SingleCoreM * SingleCoreN大小的C矩阵，即为单核上输出的C矩阵大小。</li></ul> <p>比如，下图中共有8个核参与计算，将A矩阵沿着M轴划分为4块，将B矩阵沿着N轴切分为两块，单核上仅处理某一分块（比如图中绿色部分为core3上参与计算的数据）：SingleCoreM * K大小的A矩阵分块和SingleCoreN* K大小的B矩阵分块相乘得到SingleCoreM * SingleCoreN大小的C矩阵分块。</p> <p><span><img height="293.430585" originheight="497" originwidth="865" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211114303.19008766847699774817890193571630:50001231000000:2800:C61077B41291E5BA734784C51E074FE1B97FDA60EAD2D3852E2EA9C578C547EF.png" title="点击放大" width="510.72"></span></p> </div> <div class="tiledSection"><h3 id="section134991055132114">核内切分<i class="anchor-icon anchor-icon-link" anchorid="section134991055132114" tips="复制节点链接"></i></h3><p>大多数情况下，Local Memory的存储，无法完整的容纳算子的输入与输出，需要每次搬运一部分输入进行计算然后搬出，再搬运下一部分输入进行计算，直到得到完整的最终结果，也就是需要做核内的输入切分。切分的策略如下所示：</p> <ul><li>对于A矩阵，沿M轴进行切分，切分成多份的baseM；沿K轴进行切分，切分成多份的baseK。</li><li>对于B矩阵，沿N轴进行切分，切分成多份的baseN，沿K轴进行切分，切分成多份的baseK。</li><li>对于C矩阵，A矩阵中baseM*baseK大小的分块和B矩阵中baseK*baseN大小的分块相乘并累加，得到C矩阵中对应位置baseM*baseN大小的分块。比如，图中结果矩阵中的蓝色矩阵块5是通过如下的累加过程得到的：a*a+b*b+c*c+d*d+e*e+f*f。</li></ul> <p class="msonormal"><span><img height="410.97" originheight="851" originwidth="1079" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211114303.58003947679063471692143090953339:50001231000000:2800:2496BFE8E11A7998E3B8096C800D9120B2587A5EE1B11AFDD475D4EC28C7E72C.png" title="点击放大" width="526.6800000000001"></span></p> <p>除了baseM, baseN, baseK外，还有一些常用的tiling参数，其含义如下。</p> <ul><li>iterateOrder：一次Iterate迭代计算出[baseM, baseN]大小的C矩阵分片。Iterate完成后，Matmul会自动偏移下一次Iterate输出的C矩阵位置，iterateOrder表示自动偏移的顺序。<ul><li>0代表先往M轴方向偏移再往N轴方向偏移。</li><li>1代表先往N轴方向偏移再往M轴方向偏移。</li></ul> </li><li>depthA1，depthB1：A1、B1上存储的矩阵片全载A2/B2的份数，A2、B2存储大小分别是baseM * baseK，baseN * baseK。</li><li>stepM，stepN：stepM为左矩阵在A1中缓存的buffer M方向上baseM的倍数。stepN为右矩阵在B1中缓存的buffer N方向上baseN的倍数。</li><li>stepKa，stepKb：stepKa为左矩阵在A1中缓存的buffer K方向上baseK的倍数，stepKb为右矩阵在B1中缓存的buffer K方向上baseK的倍数。</li></ul> </div> </div> <div></div></div>