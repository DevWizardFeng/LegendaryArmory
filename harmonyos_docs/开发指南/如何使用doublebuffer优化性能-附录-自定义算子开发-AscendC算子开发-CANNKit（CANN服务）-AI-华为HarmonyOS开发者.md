<h1 _ngcontent-lnt-c119="" class="doc-title ng-star-inserted" title="如何使用double buffer优化性能"> 如何使用double buffer优化性能 </h1>

<div _ngcontent-lnt-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;"> <div><p>执行于AI Core上的指令队列主要包括如下几类，即：Vector指令队列（V）、Matrix指令队列（M）和存储移动指令队列（MTE2、MTE3）。不同指令队列间的相互独立性和可并行执行性，是double buffer优化机制的基石。</p> <p>矢量计算CopyIn、CopyOut过程使用存储移动指令队列（MTE2、MTE3），Compute过程使用Vector指令队列（V），意味着CopyIn、CopyOut过程和Compute过程是可以并行的。</p> <p>如图1所示，考虑一个完整的数据搬运和计算过程，CopyIn过程将数据从Global Memory搬运到Local Memory，Vector计算单元完成计算后，经过CopyOut过程将计算结果搬回Global Memory。</p> <div class="fignone"><span class="figcap"><b>图1 </b>数据搬运与Vector计算过程</span><br><span><img height="324.52000000000004" originheight="320" originwidth="450" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211114257.23051949484207426778365620326536:50001231000000:2800:10D394218DC2B0FE0A938DE7DFDEDD2B067BC2DA4D775464C1377404D04C82ED.png" title="点击放大" width="449.54"></span></div> <p>在此过程中，数据搬运与Vector计算串行执行，Vector计算单元无可避免存在资源闲置问题。举例而言，若CopyIn、Compute、CopyOut三阶段分别耗时<em>t</em>，则Vector的时间利用率仅为1/3，等待时间过长，资源利用率严重不足。</p> <p>为减少Vector等待时间，double buffer机制将待处理的数据一分为二，比如Tensor1、Tensor2。如图2所示，当Vector对Tensor1中数据进行Compute时，Tensor2可以执行CopyIn的过程；而当Vector切换到计算Tensor2时，Tensor1可以执行CopyOut的过程。由此，数据的进出搬运和Vector计算实现并行执行，Vector闲置问题得以有效缓解。</p> <p>总体来说，double buffer是基于MTE指令队列与Vector指令队列的独立性和可并行性，通过将数据搬运与Vector计算并行执行以隐藏数据搬运时间并降低Vector指令的等待时间，最终提高Vector单元的利用效率。开发者可以通过为队列申请内存时设置内存块的个数来实现数据并行，简单代码示例如下。</p> <div _ngcontent-lnt-c106="" class="highlight-div"><div _ngcontent-lnt-c106="" class="highlight-div-header"><div _ngcontent-lnt-c106="" class="highlight-div-header-left"><div _ngcontent-lnt-c106="" class="handle-button expand-button"><div _ngcontent-lnt-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-lnt-c106="" class="highlight-div-header-right"><div _ngcontent-lnt-c106="" class="handle-button ai-button"></div><div _ngcontent-lnt-c106="" class="handle-button line-button"><div _ngcontent-lnt-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-lnt-c106="" class="handle-button theme-button"><div _ngcontent-lnt-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-lnt-c106="" class="handle-button copy-button"><div _ngcontent-lnt-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-lnt-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li>pipe.<span class="hljs-built_in">InitBuffer</span>(inQueueX, <span class="hljs-number">2</span>, <span class="hljs-number">256</span>);</li></ol></pre></div></div> <div class="fignone"><span class="figcap"><b>图2 </b>double buffer机制</span><br><span><img height="211.47" originheight="210" originwidth="315" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211114257.03761464242290920840499758955031:50001231000000:2800:2B5C51AD28F2150911BDDEC71D9DB61D29D6E66D576551EB9A9D13AFAF3E088E.png" title="点击放大" width="315.21000000000004"></span></div> <p>多数情况下，采用double buffer能有效提升Vector的时间利用率，缩减算子执行时间。然而，double buffer机制缓解Vector闲置问题并不代表它总能带来整体的性能提升。例如：</p> <ul><li>当数据搬运时间较短，而Vector计算时间显著较长时，由于数据搬运在整个计算过程中的时间占比较低，double buffer机制带来的性能收益会偏小。</li><li>又如，当原始数据较小且Vector可一次性完成所有计算时，强行使用double buffer会降低Vector计算资源的利用率，最终效果可能适得其反。</li></ul> <p>因此，double buffer的性能收益需综合考虑Vector算力、数据量大小、搬运与计算时间占比等多种因素。</p> </div> <div></div></div>