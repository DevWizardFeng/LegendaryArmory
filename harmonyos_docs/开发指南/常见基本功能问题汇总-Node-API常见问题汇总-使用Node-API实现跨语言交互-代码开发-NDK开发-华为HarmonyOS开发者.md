<h1 _ngcontent-yey-c119="" class="doc-title ng-star-inserted" title="常见基本功能问题汇总"> 常见基本功能问题汇总 </h1>

<div _ngcontent-yey-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;">   <div>    <div class="tiledSection">     <h2 id="模块加载失败报错信息显示error-message-is-not-callable">模块加载失败，报错信息显示Error message: is not callable.<i class="anchor-icon anchor-icon-link" anchorid="模块加载失败报错信息显示error-message-is-not-callable" tips="复制节点链接"></i></h2>          <ul>      <li>       <p>问题描述：</p>       <p>通过如下模块注册代码提供的libxxx.so，在部分项目中调用动态库的API，出现Error message: is not callable</p></li>     </ul>     <div _ngcontent-yey-c106="" class="highlight-div"><div _ngcontent-yey-c106="" class="highlight-div-header"><div _ngcontent-yey-c106="" class="highlight-div-header-left"><div _ngcontent-yey-c106="" class="handle-button expand-button"><div _ngcontent-yey-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-yey-c106="" class="highlight-div-header-right"><div _ngcontent-yey-c106="" class="handle-button ai-button"></div><div _ngcontent-yey-c106="" class="handle-button line-button"><div _ngcontent-yey-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-yey-c106="" class="handle-button theme-button"><div _ngcontent-yey-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-yey-c106="" class="handle-button copy-button"><div _ngcontent-yey-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-yey-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-type">static</span> napi_module demoModule = {</li><li>    .nm_version = <span class="hljs-number">1</span>,</li><li>    .nm_flags = <span class="hljs-number">0</span>,</li><li>    .nm_filename = <span class="hljs-literal">nullptr</span>,</li><li>    .nm_register_func = Init,</li><li>    .nm_modname = <span class="hljs-string">"xxx"</span>,</li><li>    .nm_priv = <span class="hljs-literal">nullptr</span>,</li><li>    .reserved = { <span class="hljs-number">0</span> },</li><li>};</li><li>
</li><li><span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> __attribute__((constructor)) <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RegisterEntryModule</span><span class="hljs-params">()</span></span></li><li><span class="hljs-function"></span>{</li><li>    <span class="hljs-built_in">napi_module_register</span>(&amp;demoModule);</li><li>}</li></ol></pre></div></div>     <ul>      <li>排查建议：</li>     </ul>     <ol>      <li>       <p>可根据以下文档进行排查：</p>       <p><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/napi-faq-about-common-basic#arkts侧报错显示undefined">ArkTS侧import xxx from libxxx.so后，使用xxx报错显示undefined/not callable或明确的Error message</a></p>       <p><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/napi-guidelines#模块注册与模块命名">模块注册与模块命名</a></p></li>      <li>       <p>同时也可参考动态加载能力是否可以满足该场景</p>       <p><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/use-napi-load-module-with-info#napi_load_module_with_info支持的场景">napi_load_module_with_info支持的场景</a></p>       <p><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/use-napi-load-module#napi_load_module支持的场景">napi_load_module支持的场景</a></p></li>     </ol>    </div>    <div class="tiledSection">     <h2 id="在大量需要调用arkts方法进行通信的场景中如何保证异步任务的有序性">在大量需要调用ArkTS方法进行通信的场景中如何保证异步任务的有序性<i class="anchor-icon anchor-icon-link" anchorid="在大量需要调用arkts方法进行通信的场景中如何保证异步任务的有序性" tips="复制节点链接"></i></h2>          <ul>      <li>具体问题：在大量需要通过C++调用ArkTS方法进行通信的场景，如何保证异步任务的有序性？</li>      <li>       <p>参考方案：</p>       <p>可参考线程安全函数来实现，napi_call_threadsafe_function可保证异步任务执行顺序, 需要注意的是这些异步任务会投递到ArkTS线程顺序执行，如果是投递到主线程，异步任务的执行时间过长可能导致应用冻结退出，所以不建议将长耗时的任务通过线程安全函数投递到主线程执行。</p>       <p><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/use-napi-thread-safety">使用Node-API接口进行线程安全开发</a></p></li>     </ul>     <p>此外，Node-API中常见的抛任务方法的差异如下：</p>     <ol>      <li>       <p>napi_async_work系列接口只能保证execute_cb在complete_cb之前执行，但无法保证不同napi_async_work的时序。</p>       <p><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/napi#napi_queue_async_work_with_qos" target="_blank">napi_queue_async_work_with_qos</a>是在普通napi_queue_async_work的基础上，支持自定义qos优先级，而这里只是指定libuv调度任务时使用线程的优先级，不是指任务的优先级，所以也无法保证任务的时序。</p></li>      <li>       <p>napi_threadsafe_function系列接口内部维护了一个队列，可以保证任务执行的顺序。</p>       <p>napi_call_threadsafe_function按先入先出的顺序执行。</p>       <p>napi_call_threadsafe_function_with_priority根据指定的入队方式执行。</p>       <p><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/use-call-threadsafe-function-with-priority">使用Node-API接口从异步线程向ArkTS线程投递指定优先级和入队方式的的任务</a></p></li>     </ol>    </div>    <div class="tiledSection">     <h2 id="是否存在便捷的回调arkts的方式">是否存在便捷的回调ArkTS的方式<i class="anchor-icon anchor-icon-link" anchorid="是否存在便捷的回调arkts的方式" tips="复制节点链接"></i></h2>          <ul>      <li>       <p>具体描述：</p>       <p>在进行多线程开发时，ArkTS函数只能在其创建线程上执行，C++线程不能直接通过napi_call_function的形式直接调用ArkTS回调，是否存在便捷的方法？</p>       <p>可参考文档：</p>       <p><a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-native-sub-main-comm" target="_blank">Native侧子线程与UI主线程通信</a></p>       <p><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/use-napi-asynchronous-task">使用Node-API接口进行异步任务开发</a></p></li>     </ul>    </div>    <div class="tiledSection">     <h2 id="如何在c代码中回调arkts方法">如何在C++代码中回调ArkTS方法<i class="anchor-icon anchor-icon-link" anchorid="如何在c代码中回调arkts方法" tips="复制节点链接"></i></h2>          <ul>      <li>       <p>参考文档：</p>       <p><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-26" target="_blank">如何在C++调用从ArkTS传递过来的function</a></p></li>     </ul>    </div>    <div class="tiledSection">     <h2 id="如何确保数据类型的正确映射与内存管理的安全性">如何确保数据类型的正确映射与内存管理的安全性<i class="anchor-icon anchor-icon-link" anchorid="如何确保数据类型的正确映射与内存管理的安全性" tips="复制节点链接"></i></h2>          <ul>      <li>具体问题：如何在遵循N-API单一返回值约束的前提下，安全、高效地将多个返回值（包括结构化数据和指针信息）传递给ArkTS运行时环境，并确保数据类型的正确映射与内存管理的安全性？</li>      <li>       <p>参考实现：</p>       <p>尽管napi_value接口仅支持单一返回值，但开发者可通过该返回值封装所需的全部信息。</p></li>     </ul>     <p>比如通过napi_create_object，创建出一个ArkTS对象，用这个对象来承载返回的所有信息，number和string都可以通过napi_set_property/napi_set_named_property等属性设置的接口设置到这个对象上。native对象也可以通过napi_wrap接口和ArkTS对象进行绑定，后续再通过napi_unwrap取出来。</p>     <p>此外，还可以使用ArkTS数组作为数据载体，其具有良好的灵活性。</p>     <ul>      <li>       <p>参考文档：</p>       <p><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/use-napi-about-object">使用Node-API接口进行object相关开发</a></p>       <p><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/use-napi-about-array">使用Node-API接口进行array相关开发</a></p></li>     </ul>    </div>    <div class="tiledSection">     <h2 id="napi_get_uv_event_loop接口错误码说明">napi_get_uv_event_loop接口错误码说明<i class="anchor-icon anchor-icon-link" anchorid="napi_get_uv_event_loop接口错误码说明" tips="复制节点链接"></i></h2>          <p>在HarmonyOS中，对使用非法的napi_env作为napi_get_uv_event_loop入参的行为加入了额外的参数校验，这一行为将直接反映到该接口的返回值上。该接口返回值详情如下：</p>     <ol>      <li>当env且（或）loop为nullptr时，返回napi_invalid_arg。</li>      <li>当env为有效的napi_env且loop为合法指针，返回napi_ok。</li>      <li>当env不是有效的napi_env（如已释放的env），返回napi_generic_failure。</li>     </ol>     <ul>      <li>常见错误场景示例如下：</li>     </ul>     <div _ngcontent-yey-c106="" class="highlight-div"><div _ngcontent-yey-c106="" class="highlight-div-header"><div _ngcontent-yey-c106="" class="highlight-div-header-left"><div _ngcontent-yey-c106="" class="handle-button expand-button"><div _ngcontent-yey-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-yey-c106="" class="highlight-div-header-right"><div _ngcontent-yey-c106="" class="handle-button ai-button"></div><div _ngcontent-yey-c106="" class="handle-button line-button"><div _ngcontent-yey-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-yey-c106="" class="handle-button theme-button"><div _ngcontent-yey-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-yey-c106="" class="handle-button copy-button"><div _ngcontent-yey-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-yey-c106="" class="highlight-scroll-div"><pre class="prettyprint linenums hljs language-cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-function">napi_value <span class="hljs-title">NapiInvalidArg</span><span class="hljs-params">(napi_env env, napi_callback_info)</span></span></li><li><span class="hljs-function"></span>{</li><li>    napi_status status = napi_ok;</li><li>    status = <span class="hljs-built_in">napi_get_uv_event_loop</span>(env, <span class="hljs-literal">nullptr</span>); <span class="hljs-comment">// loop为nullptr, 状态码napi_invalid_arg</span></li><li>    <span class="hljs-keyword">if</span> (status == napi_ok) {</li><li>        <span class="hljs-comment">// do something</span></li><li>    }</li><li>
</li><li>    uv_loop_s* loop = <span class="hljs-literal">nullptr</span>;</li><li>    status = <span class="hljs-built_in">napi_get_uv_event_loop</span>(<span class="hljs-literal">nullptr</span>, &amp;loop); <span class="hljs-comment">// env为nullptr, 状态码napi_invalid_arg</span></li><li>    <span class="hljs-keyword">if</span> (status == napi_ok) {</li><li>        <span class="hljs-comment">// do something</span></li><li>    }</li><li>
</li><li>    status = <span class="hljs-built_in">napi_get_uv_event_loop</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>); <span class="hljs-comment">// env, loop均为nullptr, 状态码napi_invalid_arg</span></li><li>    <span class="hljs-keyword">if</span> (status == napi_ok) {</li><li>        <span class="hljs-comment">// do something</span></li><li>    }</li><li>
</li><li>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;</li><li>}</li><li>
</li><li><span class="hljs-function">napi_value <span class="hljs-title">NapiGenericFailure</span><span class="hljs-params">(napi_env env, napi_callback_info)</span></span></li><li><span class="hljs-function"></span>{</li><li>    std::<span class="hljs-built_in">thread</span>([]() {</li><li>        napi_env env = <span class="hljs-literal">nullptr</span>;</li><li>        <span class="hljs-built_in">napi_create_ark_runtime</span>(&amp;env); <span class="hljs-comment">// 通常情况下，需要对该接口返回值进行判断</span></li><li>        <span class="hljs-comment">// napi_destroy_ark_runtime 会将指针置空，拷贝一份用以构造问题场景</span></li><li>        napi_env copiedEnv = env;</li><li>        <span class="hljs-built_in">napi_destroy_ark_runtime</span>(&amp;env);</li><li>        uv_loop_s* loop = <span class="hljs-literal">nullptr</span>;</li><li>        napi_status status = <span class="hljs-built_in">napi_get_uv_event_loop</span>(copiedEnv, &amp;loop); <span class="hljs-comment">// env无效, 状态码napi_generic_failure</span></li><li>        <span class="hljs-keyword">if</span> (status == napi_ok) {</li><li>            <span class="hljs-comment">// do something</span></li><li>        }</li><li>    }).<span class="hljs-built_in">detach</span>();</li><li>}</li></ol></pre></div></div>    </div>    <div class="tiledSection">     <h2 id="native层调用arkts层对象方法必须传入一个function给native层吗">Native层调用ArkTS层对象方法必须传入一个function给Native层吗<i class="anchor-icon anchor-icon-link" anchorid="native层调用arkts层对象方法必须传入一个function给native层吗" tips="复制节点链接"></i></h2>          <ul>      <li>具体问题：Node-API的Native层调用ArkTS层对象方法，必须传入一个function给Native层吗？</li>      <li>       <p>参考方案：</p>       <p>如果想要在Native层调用ArkTS层对象方法，则Native层需获取该ArkTS Function对象。</p>       <p>获取的途径有多种，比如：</p></li>     </ul>     <ol>      <li>通过传递的方式，ArkTS层传给Native层，也就是问题描述的方案</li>      <li>可以把这个ArkTS function通过属性设置方式绑定到Native层可访问的对象上，这样Native层通过这个对象也能拿到function进行调用</li>      <li>Node-API层也提供了一个创建ArkTS Function对象的能力，即napi_create_function，可以直接在Native层中创建出来，这样，Native层自然就能拿到这个ArkTS Function对象</li>     </ol>    </div>    <div class="tiledSection">     <h2 id="是否能调用arkts的方法并获取到结果">是否能调用ArkTS的方法并获取到结果<i class="anchor-icon anchor-icon-link" anchorid="是否能调用arkts的方法并获取到结果" tips="复制节点链接"></i></h2>          <ul>      <li>       <p>具体问题：在C++通过pthread或std::thread创建的线程，是否能调用ArkTS的方法并获取到结果？</p>       <p>问题分析：</p>       <p>如果是直接创建出来的C++线程，该线程没有ArkTS运行环境，即该线程上没有对应的napi_env。直接在该线程上调用ArkTS方法，存在多线程安全问题，属于未定义行为。</p></li>      <li>       <p>解决方案参考：</p></li>     </ul>     <ol>      <li>       <p>使用napi_threadsafe_function系列的Node-API接口，这系列接口，相当于在C++线程抛任务回到ArkTS线程执行ArkTS方法</p>       <p><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/use-napi-thread-safety">使用Node-API接口进行线程安全开发</a></p></li>      <li>       <p>在C++线程创建出ArkTS运行环境</p>       <p><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/use-napi-ark-runtime">使用Node-API接口创建ArkTS运行时环境</a></p></li>     </ol>    </div>    <div class="tiledSection">     <h2 id="是否有不拷贝的napi_get_value_string_utf8接口或者能力">是否有不拷贝的napi_get_value_string_utf8接口或者能力<i class="anchor-icon anchor-icon-link" anchorid="是否有不拷贝的napi_get_value_string_utf8接口或者能力" tips="复制节点链接"></i></h2>          <ul>      <li>具体问题：当前Node-API的napi_get_value_string_utf8每次调用的时候都要进行拷贝，是否有不拷贝的napi_get_value_string_utf8接口或者能力？</li>      <li>       <p>问题解答：</p>       <p>不支持该功能，每次napi_get_value_string_utf8都需要有一个拷贝过程。</p></li>     </ul>     <p>拷贝是必要的，因为会涉及到string生命周期。当触发GC的时候，ArkTS对象可能会在虚拟机里面被搬移，可能搬移到其它地方，也可能直接对象被回收。如果直接返回类似char*的地址，对象被移动或回收后，原地址的指向的内存可能发生变化。</p>    </div>    <div class="tiledSection">     <h2 id="多线程下napi_env的使用注意事项">多线程下napi_env的使用注意事项<i class="anchor-icon anchor-icon-link" anchorid="多线程下napi_env的使用注意事项" tips="复制节点链接"></i></h2>          <ul>      <li>       <p>具体问题：</p>       <p>多线程下napi_env的使用注意事项是什么？是否存在napi_env切换导致的异常问题？是否必须在主线程？</p></li>      <li>       <p>注意事项：</p></li>     </ul>     <ol>      <li>       <p>napi_env和ArkTS线程是绑定的，napi_env不能跨线程使用，否则会导致稳定性问题。</p>       <p><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/use-napi-process#多线程限制" target="_blank">多线程限制</a></p></li>      <li>       <p>在使用env调用napi接口时，需要注意，大部分的napi接口只能在env所在的ArkTS线程上调用，不然会出现多线程安全问题。</p>       <p>参考该文档的第四点【multi-thread】 <a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-coding-standard-api#section1219614634615" target="_blank">开发者使用napi接口时，跨线程使用napi_env或napi_value引发多线程安全问题</a></p></li>      <li>       <p>最好不要缓存napi env，否则容易出现多线程安全问题和use-after-free问题</p>       <p>参考该文档的第八点【use-after-free】<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-coding-standard-api#section1219614634615" target="_blank">开发者使用napi接口时，跨线程使用napi_env或napi_value引发多线程安全问题</a></p></li>      <li><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-73" target="_blank">napi_env禁止缓存的原因是什么</a></li>     </ol>    </div>    <div class="tiledSection">     <h2 id="napi_call_threadsafe_function执行顺序不符合预期">napi_call_threadsafe_function执行顺序不符合预期<i class="anchor-icon anchor-icon-link" anchorid="napi_call_threadsafe_function执行顺序不符合预期" tips="复制节点链接"></i></h2>          <ul>      <li>       <p>问题描述：</p>       <p>napi_call_threadsafe_function执行顺序不符合预期</p>       <p>原本期望的执行顺序是 a -&gt; b -&gt; c</p>       <p>posttask(a);</p>       <p>posttask(b);</p>       <p>posttask(c);</p>       <p>但是实际的执行顺序是 b -&gt; a -&gt; c</p></li>      <li>       <p>排查方向：</p></li>     </ul>     <ol>      <li>       <p>是否使用的是同一个napi_threadsafe_function，若使用不同实例，则无法保障执行顺序一致；</p>       <p>注：对于同一个napi_threadsafe_function来说，napi_call_threadsafe_function是保序的，接口内维护了一个队列，先调用就会先执行。</p></li>      <li>是否能保证实际napi_threadsafe_function的调用顺序是a -&gt; b -&gt; c；</li>     </ol>    </div>    <div class="tiledSection">     <h2 id="arkts侧报错显示undefined">ArkTS侧报错显示undefined<i class="anchor-icon anchor-icon-link" anchorid="arkts侧报错显示undefined" tips="复制节点链接"></i></h2>          <p>具体问题：</p>     <p>ArkTS侧import xxx from libxxx.so后，使用xxx报错显示undefined/not callable或明确的Error message</p>     <ol>      <li>       <p>排查.cpp文件在注册模块时的模块名称与so的名称匹配一致。</p>       <p>如模块名为entry，则so的名字为libentry.so，napi_module中nm_modname字段应为entry，大小写与模块名保持一致。</p></li>      <li>       <p>排查so是否加载成功。</p>       <p>应用启动时过滤模块加载相关日志，重点搜索"dlopen"关键字，确认是否有相关报错信息；常见加载失败原因有权限不足、so文件不存在以及so已拉入黑名单等，可根据以下关键错误日志确认问题。其中，多线程场景（如worker、taskpool等）下优先检查模块实现中nm_modname是否与模块名一致，区分大小写。</p></li>      <li>       <p>排查依赖的so是否加载成功。</p>       <p>确定所依赖的其它so是否打包到应用中以及是否有权限打开。常见加载失败原因有权限不足、so文件不存在等。</p>       <div class="tablenoborder">        <div class="tbBox"><table class="layoutFixed idpTab">         <thead>          <tr>           <th align="left" class="cellrowborder" id="mcps1.3.12.4.3.3.1.3.1.1" valign="top" width="50%"><strong>已知关键错误日志</strong></th>           <th align="left" class="cellrowborder" id="mcps1.3.12.4.3.3.1.3.1.2" valign="top" width="50%"><strong>修改建议</strong></th>          </tr>         </thead>                   <tbody><tr>           <td class="cellrowborder" valign="top" width="50%">module $SO is not allowed to load in restricted runtime.</td>           <td class="cellrowborder" valign="top" width="50%">$SO表示模块名。该模块不在受限worker线程的so加载白名单，不允许加载，建议用户删除该模块。</td>          </tr>          <tr>           <td class="cellrowborder" valign="top" width="50%">module $SO is in blocklist, loading prohibited.</td>           <td class="cellrowborder" valign="top" width="50%">$SO表示模块名。受卡片或者Extension管控，该模块在黑名单内，不允许加载，建议用户删除该模块。</td>          </tr>          <tr>           <td class="cellrowborder" valign="top" width="50%">load module failed. $ERRMSG.</td>           <td class="cellrowborder" valign="top" width="50%">动态库加载失败。$ERRMSG表示加载失败原因，一般常见原因是so文件不存在、依赖的so文件不存在或者符号未定义，需根据加载失败原因具体分析。</td>          </tr>          <tr>           <td class="cellrowborder" valign="top" width="50%">try to load abc file from $FILEPATH failed.</td>           <td class="cellrowborder" valign="top" width="50%">通常加载动态库和abc文件为二选一：如果是要加载动态库并且加载失败，该告警可以忽略；如果是要加载abc文件，则该错误打印的原因是abc文件不存在，$FILEPATH表示模块路径。</td>          </tr>                 </tbody></table></div>       </div></li>      <li>       <p>如果有明确的Error message，可以通过Error message判断当前问题。</p>       <div class="tablenoborder">        <div class="tbBox"><table class="layoutFixed idpTab">         <thead>          <tr>           <th align="left" class="cellrowborder" id="mcps1.3.12.4.4.2.1.3.1.1" valign="top" width="50%"><strong>Error message</strong></th>           <th align="left" class="cellrowborder" id="mcps1.3.12.4.4.2.1.3.1.2" valign="top" width="50%"><strong>修改建议</strong></th>          </tr>         </thead>                   <tbody><tr>           <td class="cellrowborder" valign="top" width="50%">First attempt: $ERRMSG.</td>           <td class="cellrowborder" valign="top" width="50%">首先加载后缀不拼接'_napi'的模块名为'xxx'的so，如果加载失败会有该错误信息，$ERRMSG表示具体加载时的错误信息。</td>          </tr>          <tr>           <td class="cellrowborder" valign="top" width="50%">Second attempt: $ERRMSG.</td>           <td class="cellrowborder" valign="top" width="50%">第二次加载后缀拼接'_napi'的模块名为'xxx_napi'的so，如果加载失败会有该错误信息，$ERRMSG表示具体加载时的错误信息。</td>          </tr>          <tr>           <td class="cellrowborder" valign="top" width="50%">try to load abc file from xxx failed.</td>           <td class="cellrowborder" valign="top" width="50%">第三次加载名字为'xxx'的abc文件，如果加载失败会有该错误信息。</td>          </tr>          <tr>           <td class="cellrowborder" valign="top" width="50%">module xxx is not allowed to load in restricted runtime.</td>           <td class="cellrowborder" valign="top" width="50%">该模块不允许在受限运行时中使用，xxx表示模块名，建议用户删除该模块。</td>          </tr>          <tr>           <td class="cellrowborder" valign="top" width="50%">module xxx is in blocklist, loading prohibited.</td>           <td class="cellrowborder" valign="top" width="50%">该模块不允许在当前extension下使用，xxx表示模块名，建议用户删除该模块。</td>          </tr>                 </tbody></table></div>       </div></li>     </ol>    </div>    <div class="tiledSection">     <h2 id="接口执行结果非预期">接口执行结果非预期<i class="anchor-icon anchor-icon-link" anchorid="接口执行结果非预期" tips="复制节点链接"></i></h2>          <p>问题描述：接口执行结果非预期，日志显示occur exception need return。</p>     <p>部分Node-API接口在调用结束前会进行检查，检查虚拟机中是否存在ArkTS异常。如果存在异常，则会打印出occur exception need return日志，并打印出检查点所在的行号，以及对应的Node-API接口名称。</p>     <p>解决此类问题有以下两种思路：</p>     <ul>      <li>       <p>若该异常开发者不关心，可以选择直接清除。</p>       <p>可直接使用Node-API接口napi_get_and_clear_last_exception，清理异常。调用时机：在打印occur exception need return日志的接口之前调用。</p></li>      <li>       <p>将该异常继续向上抛到ArkTS层，在ArkTS层进行捕获。</p>       <p>发生异常时，可以选择走异常分支， 确保不再走多余的Native逻辑 ，直接返回到ArkTS层。</p></li>     </ul>    </div>    <div class="tiledSection">     <h2 id="napi_value和napi_ref的生命周期有何区别">napi_value和napi_ref的生命周期有何区别<i class="anchor-icon anchor-icon-link" anchorid="napi_value和napi_ref的生命周期有何区别" tips="复制节点链接"></i></h2>          <ul>      <li>       <p>napi_value由HandleScope管理，一般开发者不需要自己加HandleScope（uv_queue_work的complete callback除外）。</p></li>      <li>       <p>napi_ref由开发者自己管理，需要手动delete。</p></li>     </ul>    </div>    <div class="tiledSection">     <h2 id="node-api接口返回值不是napi_ok时如何排查定位">Node-API接口返回值不是napi_ok时如何排查定位<i class="anchor-icon anchor-icon-link" anchorid="node-api接口返回值不是napi_ok时如何排查定位" tips="复制节点链接"></i></h2>          <p>Node-API接口正常执行后，会返回一个napi_ok的状态枚举值，若Node-API接口返回值不为napi_ok，可先参考<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/napi_status_introduction">Node-API接口返回状态码介绍</a>。</p>     <p>以下是几个常见场景：</p>     <ul>      <li>       <p>Node-API接口执行前一般会进行入参校验，首先进行的是判空校验。在代码中体现为：</p>       <div _ngcontent-yey-c106="" class="highlight-div"><div _ngcontent-yey-c106="" class="highlight-div-header"><div _ngcontent-yey-c106="" class="highlight-div-header-left"><div _ngcontent-yey-c106="" class="handle-button expand-button"><div _ngcontent-yey-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-yey-c106="" class="highlight-div-header-right"><div _ngcontent-yey-c106="" class="handle-button ai-button"></div><div _ngcontent-yey-c106="" class="handle-button line-button"><div _ngcontent-yey-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-yey-c106="" class="handle-button theme-button"><div _ngcontent-yey-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-yey-c106="" class="handle-button copy-button"><div _ngcontent-yey-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-yey-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li>CHECK_ENV：env判空校验</li><li>CHECK_ARG：其它入参判空校验</li></ol></pre></div></div></li>      <li>       <p>某些Node-API接口还有入参类型校验。比如napi_get_value_double接口是获取ArkTS number对应的C double值，首先就要保证的是：ArkTS value类型为number，因此可以看到相关校验。</p>       <div _ngcontent-yey-c106="" class="highlight-div"><div _ngcontent-yey-c106="" class="highlight-div-header"><div _ngcontent-yey-c106="" class="highlight-div-header-left"><div _ngcontent-yey-c106="" class="handle-button expand-button"><div _ngcontent-yey-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-yey-c106="" class="highlight-div-header-right"><div _ngcontent-yey-c106="" class="handle-button ai-button"></div><div _ngcontent-yey-c106="" class="handle-button line-button"><div _ngcontent-yey-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-yey-c106="" class="handle-button theme-button"><div _ngcontent-yey-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-yey-c106="" class="handle-button copy-button"><div _ngcontent-yey-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-yey-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-built_in">RETURN_STATUS_IF_FALSE</span>(env, NativeValue-&gt;<span class="hljs-built_in">TypeOf</span>() == Native_NUMBER, napi_number_expected);</li></ol></pre></div></div></li>      <li>       <p>还有一些接口会对其执行结果进行校验。比如napi_call_function这个接口，其功能是执行一个ArkTS Function，当ArkTS Function中出现异常时，Node-API将会返回napi_pending_exception的状态值。</p>       <div _ngcontent-yey-c106="" class="highlight-div"><div _ngcontent-yey-c106="" class="highlight-div-header"><div _ngcontent-yey-c106="" class="highlight-div-header-left"><div _ngcontent-yey-c106="" class="handle-button expand-button"><div _ngcontent-yey-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-yey-c106="" class="highlight-div-header-right"><div _ngcontent-yey-c106="" class="handle-button ai-button"></div><div _ngcontent-yey-c106="" class="handle-button line-button"><div _ngcontent-yey-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-yey-c106="" class="handle-button theme-button"><div _ngcontent-yey-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-yey-c106="" class="handle-button copy-button"><div _ngcontent-yey-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-yey-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// 接口内部实现，经校验可返回状态值</span></li><li><span class="hljs-keyword">auto</span> resultValue = engine-&gt;<span class="hljs-built_in">CallFunction</span>(NativeRecv, NativeFunc, NativeArgv, argc);</li><li><span class="hljs-built_in">RETURN_STATUS_IF_FALSE</span>(env, resultValue != <span class="hljs-literal">nullptr</span>, napi_pending_exception)</li></ol></pre></div></div></li>      <li>       <p>还有一些状态值需要根据相应Node-API接口具体分析：确认具体的状态值，分析这个状态值在什么情况下会返回，再排查具体出错原因。</p></li>     </ul>    </div>    <div class="tiledSection">     <h2 id="napi_wrap如何保证被wrap的对象按期望顺序析构">napi_wrap如何保证被wrap的对象按期望顺序析构<i class="anchor-icon anchor-icon-link" anchorid="napi_wrap如何保证被wrap的对象按期望顺序析构" tips="复制节点链接"></i></h2>          <p>问题：在使用napi_wrap把两个 C++ 对象包装成两个 JavaScript 对象的场景中，由于这两个 C++ 对象存在依赖关系，要求其中一个C++对象必须在另一个C++对象之前析构。然而，JavaScript 垃圾回收（GC）的时机不确定，直接在napi_wrap的finalize_cb回调里销毁 C++ 对象，没办法保证析构顺序符合要求。该如何保证两个C++对象析构的前后顺序？</p>     <p>参考方案：</p>     <p>先标记可释放状态，当A和B都为可释放状态时同时释放C++对象</p>     <p>原理：将所有依赖对象的释放逻辑集中在最后一个被销毁的 ArkTS 对象的 finalize_cb 中处理。</p>     <p>实现步骤：</p>     <p>在 jsObjA 的 finalize_cb 中标记 cppObjA 为待销毁（不立即释放）。</p>     <p>在 jsObjB 的 finalize_cb 中标记 cppObjB 为待销毁（不立即释放）。</p>     <p>当 jsObjA 和 jsObjB 均处于待销毁状态时，按顺序销毁 cppObjA 和 cppObjB。</p>     <p>示例代码：</p>     <div _ngcontent-yey-c106="" class="highlight-div"><div _ngcontent-yey-c106="" class="highlight-div-header"><div _ngcontent-yey-c106="" class="highlight-div-header-left"><div _ngcontent-yey-c106="" class="handle-button expand-button"><div _ngcontent-yey-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-yey-c106="" class="highlight-div-header-right"><div _ngcontent-yey-c106="" class="handle-button ai-button"></div><div _ngcontent-yey-c106="" class="handle-button line-button"><div _ngcontent-yey-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-yey-c106="" class="handle-button theme-button"><div _ngcontent-yey-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-yey-c106="" class="handle-button copy-button"><div _ngcontent-yey-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-yey-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ObjectPair</span> {</li><li>    CppObjA* objA;</li><li>    CppObjB* objB;</li><li>    <span class="hljs-type">bool</span> objADestroyedA = <span class="hljs-literal">false</span>;</li><li>    <span class="hljs-type">bool</span> objADestroyedB = <span class="hljs-literal">false</span>;</li><li>};</li><li>
</li><li><span class="hljs-comment">// jsObjA 的 finalize 回调</span></li><li><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FinalizeA</span><span class="hljs-params">(napi_env env, <span class="hljs-type">void</span>* data, <span class="hljs-type">void</span>* hint)</span> </span>{</li><li>    ObjectPair* pair = <span class="hljs-built_in">static_cast</span>&lt;ObjectPair*&gt;(data);</li><li>    pair-&gt;objADestroyedA = <span class="hljs-literal">true</span>;</li><li>    <span class="hljs-keyword">if</span> (pair-&gt;objADestroyedA &amp;&amp; pair-&gt;objADestroyedB) {</li><li>        <span class="hljs-keyword">delete</span> pair-&gt;objA; <span class="hljs-comment">// 确保先销毁 A</span></li><li>        <span class="hljs-keyword">delete</span> pair-&gt;objB; <span class="hljs-comment">// 再销毁 B</span></li><li>        <span class="hljs-keyword">delete</span> pair;       <span class="hljs-comment">// 释放包装结构</span></li><li>    }</li><li>}</li><li>
</li><li><span class="hljs-comment">// jsObjB 的 finalize 回调</span></li><li><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FinalizeB</span><span class="hljs-params">(napi_env env, <span class="hljs-type">void</span>* data, <span class="hljs-type">void</span>* hint)</span> </span>{</li><li>    ObjectPair* pair = <span class="hljs-built_in">static_cast</span>&lt;ObjectPair*&gt;(data);</li><li>    pair-&gt;objADestroyedB = <span class="hljs-literal">true</span>;</li><li>    <span class="hljs-keyword">if</span> (pair-&gt;objADestroyedA &amp;&amp; pair-&gt;objADestroyedB) {</li><li>        <span class="hljs-keyword">delete</span> pair-&gt;objA; <span class="hljs-comment">// 确保先销毁 A</span></li><li>        <span class="hljs-keyword">delete</span> pair-&gt;objB; <span class="hljs-comment">// 再销毁 B</span></li><li>        <span class="hljs-keyword">delete</span> pair;       <span class="hljs-comment">// 释放包装结构</span></li><li>    }</li><li>}</li></ol></pre></div></div>    </div>    <div class="tiledSection">     <h2 id="napi_call_threadsafe_function回调任务不执行">napi_call_threadsafe_function回调任务不执行<i class="anchor-icon anchor-icon-link" anchorid="napi_call_threadsafe_function回调任务不执行" tips="复制节点链接"></i></h2>          <p>问题排查：</p>     <p>原因一：napi_call_threadsafe_function函数调用返回值不为napi_ok。请确认调用napi_call_threadsafe_function相关函数的返回值是否都是napi_ok，若不是，请根据<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/napi_status_introduction">Node-API接口返回状态码介绍</a>排查返回值非napi_ok的原因。</p>     <p>原因二：env所在的ArkTS线程被阻塞。napi_call_threadsafe_function函数的回调将执行在env所在的ArkTS线程上，若ArkTS线程被阻塞，则线程安全函数回调不会被执行。</p>     <p>原因三：线程安全函数被重复初始化的uv_async_t句柄影响，导致任务不执行。若某个uv_async_t句柄被重新初始化，第一次初始化和重复初始化范围内所创建所有uv_async_t句柄将无法被uv访问。线程安全函数是基于uv_async_t机制实现，在该特殊场景下创建线程安全函数将失效。</p>    </div>    <div class="tiledSection">     <h2 id="使用开发工具支撑cc代码快速进行node-api开发">使用开发工具支撑C/C++代码快速进行Node-API开发<i class="anchor-icon anchor-icon-link" anchorid="使用开发工具支撑cc代码快速进行node-api开发" tips="复制节点链接"></i></h2>          <p>HarmonyOS提供了丰富的Node-API接口示例。参考开发指南和示例工程，可以快速掌握Node-API模块开发流程。</p>     <p>可以使用<a href="https://gitcode.com/openharmony-sig/aki" target="_blank">AKI</a>或<a href="https://gitcode.com/openharmony/napi_generator" target="_blank">napi-generator</a>等开发工具，辅助Node-API开发，降低学习难度并提高开发效率。</p>    </div>   </div>   <div></div></div>