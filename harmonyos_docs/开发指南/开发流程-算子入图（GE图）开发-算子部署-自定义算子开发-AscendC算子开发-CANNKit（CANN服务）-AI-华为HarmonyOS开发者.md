<h1 _ngcontent-uxs-c119="" class="doc-title ng-star-inserted" title="开发流程"> 开发流程 </h1>

<div _ngcontent-uxs-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;"> <div><p>该开发流程以<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cannkit-overview-of-engineering-operator">工程化算子开发</a>为基础，除了需要提供<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cannkit-operator-prototype-definition">算子实现</a>中的算子实现文件外，还需要额外交付算子入图的代码文件。本节仅提供算子入图代码文件的开发指导。</p> <p>假设下图是我们需要使用的网络模型，开发者可能会想直接逐个算子调用，根据输入tensor得到输出tensor就可以完成网络的运行，但在图模式场景下，实际的网络模型生成过程中，会先进行tensor shape以及datatype的推导。这样可以让我们在图执行之前，就知道各tensor的数据类型和形状，提前校验其正确性；同时提前推理出算子的输出张量描述，包括张量的形状、数据类型及数据排布格式等信息，算子构图准备阶段就可以为所有的张量静态分配内存，避免动态内存分配带来的开销。</p> <p>下面的网络模型经过shape和datatype推导之后，可以得到灰色底纹框中的推导信息。</p> <div class="fignone"><span class="figcap"><b>图1 </b>shape与datatype推导示意图</span><br><span><img height="469.49" originheight="467" originwidth="530" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211114305.26324420922297016445506433652332:50001231000000:2800:89D2FDA180B2795B34336F46B6AA2EDCA1B7F2BF731515661FDA6E13F76E6CA9.png" title="点击放大" width="526.6800000000001"></span></div> <p>除了tiling实现外，算子入图时需要额外提供的实现代码有以下几种：</p> <ul><li>datatype推导：根据算子的输入datatype、算子逻辑及算子属性等信息，推理出算子的输出张量datatype。</li><li>shape推导：根据算子的输入shape、算子逻辑及算子属性等信息，推理出算子的输出张量shape。</li><li>声明数据依赖：部分算子在InferShape时，需要依赖某个输入的具体值才可以进行，这类算子被称为“数据依赖算子”，对应的输入被称为“数据依赖输入”。该类算子在注册时，需要声明其数据依赖输入。</li></ul> <p>下表列出了不同类型的算子对上述实现代码的要求。</p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><caption><b>表1 </b>不同的类型的算子对入图实现代码的要求</caption><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.8.2.3.1.1" valign="top" width="36%"><p>分类</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.8.2.3.1.2" valign="top" width="64%"><p>对入图实现代码的要求</p> </th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="36%"><p>根据输入shape可以推导出输出shape。</p> </td> <td class="cellrowborder" valign="top" width="64%"><ul><li>shape推导</li><li>datatype推导</li></ul> </td> </tr> <tr><td class="cellrowborder" valign="top" width="36%"><p>依赖输入的value才能推导出输出shape，即数据依赖算子。 如Reshape算子，依赖shape输入的value才能推导出输出shape。</p> </td> <td class="cellrowborder" valign="top" width="64%"><ul><li>shape推导</li><li>datatype推导</li><li>声明数据依赖</li></ul> </td> </tr>  </tbody></table></div> </div> <p>实际开发时通过固定的datatype和shape推导原型实现推导函数，然后再通过<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cannkit-setinfershape">SetInferShape</a>、<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cannkit-setinferdatatype">SetInferDataType</a>接口来关联对应的shape推导函数，样例如下。</p> <div _ngcontent-uxs-c106="" class="highlight-div"><div _ngcontent-uxs-c106="" class="highlight-div-header"><div _ngcontent-uxs-c106="" class="highlight-div-header-left"><div _ngcontent-uxs-c106="" class="handle-button expand-button"><div _ngcontent-uxs-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-uxs-c106="" class="highlight-div-header-right"><div _ngcontent-uxs-c106="" class="handle-button ai-button"></div><div _ngcontent-uxs-c106="" class="handle-button line-button"><div _ngcontent-uxs-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-uxs-c106="" class="handle-button theme-button"><div _ngcontent-uxs-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-uxs-c106="" class="handle-button copy-button"><div _ngcontent-uxs-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-uxs-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">namespace</span> ge { </li><li><span class="hljs-function"><span class="hljs-type">static</span> graphStatus <span class="hljs-title">InferShape</span><span class="hljs-params">(gert::InferShapeContext *context)</span> </span></li><li><span class="hljs-function"></span>{ </li><li>    <span class="hljs-comment">// ... </span></li><li>    <span class="hljs-keyword">return</span> GRAPH_SUCCESS; </li><li>} </li><li> </li><li><span class="hljs-function"><span class="hljs-type">static</span> graphStatus <span class="hljs-title">InferDataType</span><span class="hljs-params">(gert::InferDataTypeContext *context)</span> </span></li><li><span class="hljs-function"></span>{ </li><li>    <span class="hljs-comment">// ... </span></li><li>    <span class="hljs-keyword">return</span> ge::GRAPH_SUCCESS; </li><li>} </li><li>} <span class="hljs-comment">// namespace ge </span></li><li> </li><li> </li><li><span class="hljs-keyword">namespace</span> ops { </li><li><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddCustom</span> : <span class="hljs-keyword">public</span> OpDef { </li><li><span class="hljs-keyword">public</span>: </li><li>    <span class="hljs-built_in">AddCustom</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name) : <span class="hljs-built_in">OpDef</span>(name) </li><li>    { </li><li>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">Input</span>(<span class="hljs-string">"x"</span>) </li><li>            .<span class="hljs-built_in">ParamType</span>(REQUIRED) </li><li>            .<span class="hljs-built_in">DataType</span>({ge::DT_FLOAT16, ge::DT_FLOAT, ge::DT_INT32}) </li><li>            .<span class="hljs-built_in">Format</span>({ge::FORMAT_ND, ge::FORMAT_ND, ge::FORMAT_ND}); </li><li>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">Input</span>(<span class="hljs-string">"y"</span>) </li><li>            .<span class="hljs-built_in">ParamType</span>(REQUIRED) </li><li>            .<span class="hljs-built_in">DataType</span>({ge::DT_FLOAT16, ge::DT_FLOAT, ge::DT_INT32}) </li><li>            .<span class="hljs-built_in">Format</span>({ge::FORMAT_ND, ge::FORMAT_ND, ge::FORMAT_ND}); </li><li>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">Output</span>(<span class="hljs-string">"z"</span>) </li><li>            .<span class="hljs-built_in">ParamType</span>(REQUIRED) </li><li>            .<span class="hljs-built_in">DataType</span>({ge::DT_FLOAT16, ge::DT_FLOAT, ge::DT_INT32}) </li><li>            .<span class="hljs-built_in">Format</span>({ge::FORMAT_ND, ge::FORMAT_ND, ge::FORMAT_ND}); </li><li>        <span class="hljs-comment">// 根据开发者的算子调用方式决定需不需要注册 图模式调用方式下需要 </span></li><li>     <strong>   <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">SetInferShape</span>(ge::InferShape);</strong> </li><li><strong>       <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">SetInferDataType</span>(ge::InferDataType);  </strong> </li><li>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">AICore</span>() </li><li>            .<span class="hljs-built_in">SetTiling</span>(optiling::TilingFunc); </li><li>        <span class="hljs-comment">// 请替换为实际的Kirin AI处理器型号 </span></li><li>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">AICore</span>().<span class="hljs-built_in">AddConfig</span>(<span class="hljs-string">"ascendxxx"</span>); </li><li>    } </li><li>}; </li><li><span class="hljs-built_in">OP_ADD</span>(AddCustom); </li><li>} <span class="hljs-comment">// namespace ops</span></li></ol></pre></div></div> <div class="tiledSection"><h2 id="section5393mcpsimp">datatype推导<i class="anchor-icon anchor-icon-link" anchorid="section5393mcpsimp" tips="复制节点链接"></i></h2><p>以AddCustom算子为例，InferDataType的实现如下所示。该样例中输出tensor的数据类型与输入tensor的数据类型相同，所以直接将任意一个输入tensor的数据类型赋给输出tensor即可。</p> <div _ngcontent-uxs-c106="" class="highlight-div"><div _ngcontent-uxs-c106="" class="highlight-div-header"><div _ngcontent-uxs-c106="" class="highlight-div-header-left"><div _ngcontent-uxs-c106="" class="handle-button expand-button"><div _ngcontent-uxs-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-uxs-c106="" class="highlight-div-header-right"><div _ngcontent-uxs-c106="" class="handle-button ai-button"></div><div _ngcontent-uxs-c106="" class="handle-button line-button"><div _ngcontent-uxs-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-uxs-c106="" class="handle-button theme-button"><div _ngcontent-uxs-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-uxs-c106="" class="handle-button copy-button"><div _ngcontent-uxs-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-uxs-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">namespace</span> ge { </li><li><span class="hljs-function"><span class="hljs-type">static</span> graphStatus <span class="hljs-title">InferDataType</span><span class="hljs-params">(gert::InferDataTypeContext* context)</span> </span></li><li><span class="hljs-function"></span>{ </li><li>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> inputDataType = context-&gt;<span class="hljs-built_in">GetInputDataType</span>(<span class="hljs-number">0</span>); </li><li>    context-&gt;<span class="hljs-built_in">SetOutputDataType</span>(<span class="hljs-number">0</span>, inputDataType); </li><li>    <span class="hljs-keyword">return</span> ge::GRAPH_SUCCESS; </li><li>} </li><li>} <span class="hljs-comment">// namespace ge</span></li></ol></pre></div></div> <p>如下示例则给出了更灵活的datatype推导样例，当输入的数据类型为DT_INT4时，其输出的数据类型为DT_INT32。</p> <div _ngcontent-uxs-c106="" class="highlight-div"><div _ngcontent-uxs-c106="" class="highlight-div-header"><div _ngcontent-uxs-c106="" class="highlight-div-header-left"><div _ngcontent-uxs-c106="" class="handle-button expand-button"><div _ngcontent-uxs-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-uxs-c106="" class="highlight-div-header-right"><div _ngcontent-uxs-c106="" class="handle-button ai-button"></div><div _ngcontent-uxs-c106="" class="handle-button line-button"><div _ngcontent-uxs-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-uxs-c106="" class="handle-button theme-button"><div _ngcontent-uxs-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-uxs-c106="" class="handle-button copy-button"><div _ngcontent-uxs-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-uxs-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-function">ge::graphStatus <span class="hljs-title">InferDataTypeForFoo</span><span class="hljs-params">(gert::InferDataTypeContext* context)</span> </span>{ </li><li> </li><li>    <span class="hljs-keyword">if</span> (context-&gt;<span class="hljs-built_in">GetInputDataType</span>(<span class="hljs-number">0</span>) == DT_INT4) { </li><li>        context-&gt;<span class="hljs-built_in">SetOutputDataType</span>(<span class="hljs-number">0</span>, DT_INT32); </li><li>    } </li><li>}</li></ol></pre></div></div> </div> <div class="tiledSection"><h2 id="section5399mcpsimp">shape推导<i class="anchor-icon anchor-icon-link" anchorid="section5399mcpsimp" tips="复制节点链接"></i></h2><p>简单的shape推导逻辑可以使用<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cannkit-follow">Follow</a>接口来表达，比如输出shape和输入shape相同的情况。示例如下。</p> <p>输出“y1”Follow输入“x1”场景，指定Follow模式为SHAPE，此时“y1”的shape将会和“x1”保持一致。</p> <div _ngcontent-uxs-c106="" class="highlight-div"><div _ngcontent-uxs-c106="" class="highlight-div-header"><div _ngcontent-uxs-c106="" class="highlight-div-header-left"><div _ngcontent-uxs-c106="" class="handle-button expand-button"><div _ngcontent-uxs-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-uxs-c106="" class="highlight-div-header-right"><div _ngcontent-uxs-c106="" class="handle-button ai-button"></div><div _ngcontent-uxs-c106="" class="handle-button line-button"><div _ngcontent-uxs-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-uxs-c106="" class="handle-button theme-button"><div _ngcontent-uxs-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-uxs-c106="" class="handle-button copy-button"><div _ngcontent-uxs-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-uxs-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">Input</span>(<span class="hljs-string">"x1"</span>) </li><li>    .<span class="hljs-built_in">ParamType</span>(REQUIRED) </li><li>    .<span class="hljs-built_in">DataType</span>({ge::DT_FLOAT, ge::DT_FLOAT}) </li><li>    .<span class="hljs-built_in">Format</span>({ge::FORMAT_ND, ge::FORMAT_ND}); </li><li><span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">Input</span>(<span class="hljs-string">"x2"</span>) </li><li>    .<span class="hljs-built_in">ParamType</span>(REQUIRED) </li><li>    .<span class="hljs-built_in">DataType</span>({ge::DT_FLOAT, ge::DT_FLOAT}) </li><li>    .<span class="hljs-built_in">Format</span>({ge::FORMAT_ND, ge::FORMAT_ND}); </li><li><span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">Output</span>(<span class="hljs-string">"y1"</span>) </li><li>    .<span class="hljs-built_in">ParamType</span>(REQUIRED) </li><li>    .<span class="hljs-built_in">DataType</span>({ge::DT_FLOAT, ge::DT_FLOAT}) </li><li>    .<span class="hljs-built_in">Format</span>({ge::FORMAT_ND, ge::FORMAT_ND}) </li><li>    .<span class="hljs-built_in">Follow</span>(<span class="hljs-string">"x1"</span>, FollowType::SHAPE);</li></ol></pre></div></div> <p>无法在原型定义中通过Follow表达的情况需要开发者编写InferShape函数，其原型是确定的，接受一个<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cannkit-infershapecontext-getinputshape">InferShapeContext</a>作为输入，从此context上可以获取到输入、输出的shape指针等内容。输入shape为const类型，因此InferShape时，输入shape是只读、不允许修改的。InferShape成功后，返回ge::GRAPH_SUCCESS，其他返回值被认为推导失败。推导失败后，执行过程结束退出。</p> <p>以ReShape算子为例，InferShape的实现如下所示。根据第1个输入（shape输入）的值，Reshape算子将第0个输入（x输入）的shape做变换，并输出到其第0个输出（y输出）上。Reshape的InferShape实现为：</p> <div _ngcontent-uxs-c106="" class="highlight-div"><div _ngcontent-uxs-c106="" class="highlight-div-header"><div _ngcontent-uxs-c106="" class="highlight-div-header-left"><div _ngcontent-uxs-c106="" class="handle-button expand-button"><div _ngcontent-uxs-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-uxs-c106="" class="highlight-div-header-right"><div _ngcontent-uxs-c106="" class="handle-button ai-button"></div><div _ngcontent-uxs-c106="" class="handle-button line-button"><div _ngcontent-uxs-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-uxs-c106="" class="handle-button theme-button"><div _ngcontent-uxs-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-uxs-c106="" class="handle-button copy-button"><div _ngcontent-uxs-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-uxs-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-function">ge::graphStatus <span class="hljs-title">InferShapeForReshape</span><span class="hljs-params">(InferShapeContext *context)</span> </span>{ </li><li><span class="hljs-type">const</span> gert::Shape *x_shape = context-&gt;<span class="hljs-built_in">GetInputShape</span>(<span class="hljs-number">0</span>);        <span class="hljs-comment">// 获取第0个输入的shape </span></li><li><span class="hljs-type">const</span> gert::Tensor *shape_tensor = context-&gt;<span class="hljs-built_in">GetInputTensor</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 获取第1个输入的tensor </span></li><li>gert::Shape *output_shape = context-&gt;<span class="hljs-built_in">GetOutputShape</span>(<span class="hljs-number">0</span>); </li><li><span class="hljs-keyword">if</span> (x_shape == <span class="hljs-literal">nullptr</span> || shape_tensor == <span class="hljs-literal">nullptr</span> || output_shape == <span class="hljs-literal">nullptr</span>) { </li><li>    <span class="hljs-comment">// 防御式编程，不应该出现的场景，打印错误并返回失败 </span></li><li>    <span class="hljs-keyword">return</span> ge::GRAPH_FAILED; </li><li>} </li><li> </li><li><span class="hljs-keyword">auto</span> reshape_size = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int32_t</span>&gt;(shape_tensor-&gt;<span class="hljs-built_in">GetShapeSize</span>()); </li><li><span class="hljs-keyword">if</span> (reshape_size &lt; <span class="hljs-number">1</span>) { </li><li>    <span class="hljs-comment">// 防御式编程，不应该出现的场景，打印错误并返回失败 </span></li><li>    <span class="hljs-keyword">return</span> ge::GRAPH_FAILED; </li><li>} </li><li> </li><li><span class="hljs-comment">// 根据原型信息，Reshape的shape输入支持INT32与INT64两类，根据不同的类型进入对应的模板函数中做真正的shape变换操作 </span></li><li><span class="hljs-keyword">if</span> (shape_tensor-&gt;<span class="hljs-built_in">GetDataType</span>() == ge::DT_INT32) { </li><li>    <span class="hljs-type">int32_t</span> *reshape_data = shape_tensor-&gt;<span class="hljs-built_in">GetData</span>&lt;<span class="hljs-type">int32_t</span>&gt;(); </li><li>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ReshapeInferShapeImpl</span>&lt;<span class="hljs-type">int32_t</span>&gt;(reshape_data, *x_shape, *output_shape, reshape_size); </li><li>} <span class="hljs-keyword">else</span> { </li><li>    <span class="hljs-type">int64_t</span> *reshape_data = shape_tensor-&gt;<span class="hljs-built_in">GetData</span>&lt;<span class="hljs-type">int64_t</span>&gt;(); </li><li>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ReshapeInferShapeImpl</span>&lt;<span class="hljs-type">int64_t</span>&gt;(reshape_data, *x_shape, *output_shape, reshape_size); </li><li>} </li><li>}</li></ol></pre></div></div> <p><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cannkit-infershapecontext">InferShapeContext</a> public继承自<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cannkit-extendedkernelcontext">ExtendedKernelContext</a>，因此ExtendedKernelContext中提供的方法如获取算子type、name、属性等接口均可以在<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cannkit-infershapecontext">InferShapeContext</a>实例中调用。</p> <div><div class="hw-editor-tip warn"><div class="title">注意</div><div class="content"><ul><li>InferShape推导函数和使用Follow接口去Follow shape不能混用，即不支持部分输出采用InferShape推导、部分输出采用Follow推导的情况。若开发者同时使用了InferShape函数和Follow接口，以开发者的InferShape函数为准，需要保证在InferShape函数中能够推导出所有的输出shape。</li></ul> <ul><li>为了效率考虑，调用InferShape函数时，框架不会为输出shape做初始化，因此，在InferShape函数中，可以认为输出是<strong>未初始化</strong>的状态。如果在InferShape时，希望通过Append方式操作输出shape，需要先将输出shape的DimNum清零，以防止出现未定义行为。</li></ul> </div></div></div> </div> <div class="tiledSection"><h2 id="section5422mcpsimp">InferShape时获取属性、输入<i class="anchor-icon anchor-icon-link" anchorid="section5422mcpsimp" tips="复制节点链接"></i></h2><p>在InferShape、Tiling时，可以通过context实例获取算子IR属性值，所谓IR属性，是指在IR注册时定义的属性，以TransData算子为例：</p> <div _ngcontent-uxs-c106="" class="highlight-div"><div _ngcontent-uxs-c106="" class="highlight-div-header"><div _ngcontent-uxs-c106="" class="highlight-div-header-left"><div _ngcontent-uxs-c106="" class="handle-button expand-button"><div _ngcontent-uxs-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-uxs-c106="" class="highlight-div-header-right"><div _ngcontent-uxs-c106="" class="handle-button ai-button"></div><div _ngcontent-uxs-c106="" class="handle-button line-button"><div _ngcontent-uxs-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-uxs-c106="" class="handle-button theme-button"><div _ngcontent-uxs-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-uxs-c106="" class="handle-button copy-button"><div _ngcontent-uxs-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-uxs-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">namespace</span> ops { </li><li><span class="hljs-keyword">class</span> <span class="hljs-title class_">TransData</span> : <span class="hljs-keyword">public</span> OpDef { </li><li><span class="hljs-keyword">public</span>: </li><li>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">TransData</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span> : OpDef(name) </span></li><li><span class="hljs-function">    {</span> </li><li>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">Input</span>(<span class="hljs-string">"src"</span>) </li><li>             <span class="hljs-comment">// ... </span></li><li>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">Output</span>(<span class="hljs-string">"dst"</span>) </li><li>             <span class="hljs-comment">// ... </span></li><li>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">Attr</span>(<span class="hljs-string">"src_format"</span>) </li><li>            .<span class="hljs-built_in">AttrType</span>(REQUIRED) </li><li>            .<span class="hljs-built_in">String</span>(); </li><li>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">Attr</span>(<span class="hljs-string">"dst_format"</span>) </li><li>            .<span class="hljs-built_in">AttrType</span>(REQUIRED) </li><li>            .<span class="hljs-built_in">String</span>(); </li><li>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">Attr</span>(<span class="hljs-string">"group"</span>) </li><li>            .<span class="hljs-built_in">AttrType</span>(OPTIONAL)            </li><li>           .<span class="hljs-built_in">Int</span>(<span class="hljs-number">1</span>); </li><li>        <span class="hljs-comment">// ... </span></li><li>    } </li><li>}; </li><li><span class="hljs-built_in">OP_ADD</span>(TransData); </li><li>} <span class="hljs-comment">// namespace ops</span></li></ol></pre></div></div> <p>其原型定义中声明了src_format、dst_format、group三个属性，可以通过如下方式获取算子属性：</p> <div _ngcontent-uxs-c106="" class="highlight-div"><div _ngcontent-uxs-c106="" class="highlight-div-header"><div _ngcontent-uxs-c106="" class="highlight-div-header-left"><div _ngcontent-uxs-c106="" class="handle-button expand-button"><div _ngcontent-uxs-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-uxs-c106="" class="highlight-div-header-right"><div _ngcontent-uxs-c106="" class="handle-button ai-button"></div><div _ngcontent-uxs-c106="" class="handle-button line-button"><div _ngcontent-uxs-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-uxs-c106="" class="handle-button theme-button"><div _ngcontent-uxs-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-uxs-c106="" class="handle-button copy-button"><div _ngcontent-uxs-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-uxs-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-function">ge::graphStatus <span class="hljs-title">ExampleGetTransDataAttr</span><span class="hljs-params">(TilingContext *context)</span> </span>{ </li><li>  <span class="hljs-comment">// 获取所有属性 </span></li><li>  <span class="hljs-type">const</span> RuntimeAttrs *attrs = context-&gt;<span class="hljs-built_in">GetAttrs</span>(); </li><li>  <span class="hljs-built_in">ASSERT_NOT_NULL</span>(attrs); </li><li>   </li><li>  <span class="hljs-comment">// 按照在原型定义中的顺序，使用index获取属性，index从0开始计数 </span></li><li>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *src_format = attrs-&gt;<span class="hljs-built_in">GetAttrPointer</span>&lt;<span class="hljs-type">char</span>&gt;(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 获取src_format，src_format是第一个属性，因此index为0 </span></li><li>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *dst_format = attrs-&gt;<span class="hljs-built_in">GetAttrPointer</span>&lt;<span class="hljs-type">char</span>&gt;(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 获取dst_format，dst_format是第二个属性，因此index为1 </span></li><li>  <span class="hljs-type">const</span> <span class="hljs-type">int64_t</span> group = attrs-&gt;<span class="hljs-built_in">GetAttrPointer</span>&lt;<span class="hljs-type">int64_t</span>&gt;(<span class="hljs-number">2</span>);  <span class="hljs-comment">// 获取group，group是第三个属性，因此index为2 </span></li><li>   </li><li>  <span class="hljs-keyword">return</span> ge::GRAPH_SUCCESS; </li><li>}</li></ol></pre></div></div> </div> <div class="tiledSection"><h2 id="section5437mcpsimp">数据依赖<i class="anchor-icon anchor-icon-link" anchorid="section5437mcpsimp" tips="复制节点链接"></i></h2><p>一般来说，具备输入shape后，算子可以通过InferShape推导出输出shape。然而部分算子在InferShape时，需要依赖某个输入的具体值才可以进行，这类算子被称为“数据依赖算子”，对应的输入被称为“数据依赖输入”。以Reshape算子为例，其依据shape输入的描述，对输入的shape做调整，因此Reshape算子依赖shape输入的值。这类算子需要在原型定义时通过<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cannkit-valuedepend">ValueDepend</a>接口声明对应的输入为数据依赖输入项。</p> <div _ngcontent-uxs-c106="" class="highlight-div"><div _ngcontent-uxs-c106="" class="highlight-div-header"><div _ngcontent-uxs-c106="" class="highlight-div-header-left"><div _ngcontent-uxs-c106="" class="handle-button expand-button"><div _ngcontent-uxs-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-uxs-c106="" class="highlight-div-header-right"><div _ngcontent-uxs-c106="" class="handle-button ai-button"></div><div _ngcontent-uxs-c106="" class="handle-button line-button"><div _ngcontent-uxs-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-uxs-c106="" class="handle-button theme-button"><div _ngcontent-uxs-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-uxs-c106="" class="handle-button copy-button"><div _ngcontent-uxs-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-uxs-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">namespace</span> ops { </li><li><span class="hljs-keyword">class</span> <span class="hljs-title class_">Reshape</span> : <span class="hljs-keyword">public</span> OpDef { </li><li><span class="hljs-keyword">public</span>: </li><li>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Reshape</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span> : OpDef(name) </span></li><li><span class="hljs-function">    {</span> </li><li>        <span class="hljs-comment">// ... </span></li><li>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">Input</span>(<span class="hljs-string">"shape"</span>) </li><li>             .<span class="hljs-built_in">ParamType</span>(REQUIRED) </li><li>             <span class="hljs-comment">// ... </span></li><li>             .<span class="hljs-built_in">ValueDepend</span>(REQUIRED) <span class="hljs-comment">// 声明 ReShape算子的shape输入为数据依赖输入 </span></li><li>        <span class="hljs-comment">// ... </span></li><li>    } </li><li>}; </li><li><span class="hljs-built_in">OP_ADD</span>(Reshape); </li><li>} <span class="hljs-comment">// namespace ops</span></li></ol></pre></div></div> <p>根据第1个输入（shape输入）的值，Reshape算子将第0个输入（x输入）的shape做变换，并输出到其第0个输出（y输出）上。Reshape的InferShape实现为：</p> <div _ngcontent-uxs-c106="" class="highlight-div"><div _ngcontent-uxs-c106="" class="highlight-div-header"><div _ngcontent-uxs-c106="" class="highlight-div-header-left"><div _ngcontent-uxs-c106="" class="handle-button expand-button"><div _ngcontent-uxs-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-uxs-c106="" class="highlight-div-header-right"><div _ngcontent-uxs-c106="" class="handle-button ai-button"></div><div _ngcontent-uxs-c106="" class="handle-button line-button"><div _ngcontent-uxs-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-uxs-c106="" class="handle-button theme-button"><div _ngcontent-uxs-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-uxs-c106="" class="handle-button copy-button"><div _ngcontent-uxs-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-uxs-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-function">ge::graphStatus <span class="hljs-title">InferShapeForReshape</span><span class="hljs-params">(InferShapeContext *context)</span> </span>{ </li><li><span class="hljs-type">const</span> gert::Shape *x_shape = context-&gt;<span class="hljs-built_in">GetInputShape</span>(<span class="hljs-number">0</span>);        <span class="hljs-comment">// 获取第0个输入的shape </span></li><li><span class="hljs-type">const</span> gert::Tensor *shape_tensor = context-&gt;<span class="hljs-built_in">GetInputTensor</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 获取第1个输入的tensor </span></li><li>gert::Shape *output_shape = context-&gt;<span class="hljs-built_in">GetOutputShape</span>(<span class="hljs-number">0</span>); </li><li><span class="hljs-keyword">if</span> (x_shape == <span class="hljs-literal">nullptr</span> || shape_tensor == <span class="hljs-literal">nullptr</span> || output_shape == <span class="hljs-literal">nullptr</span>) { </li><li>    <span class="hljs-comment">// 防御式编程，不应该出现的场景，打印错误并返回失败 </span></li><li>    <span class="hljs-keyword">return</span> ge::GRAPH_FAILED; </li><li>} </li><li> </li><li><span class="hljs-keyword">auto</span> reshape_size = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int32_t</span>&gt;(shape_tensor-&gt;<span class="hljs-built_in">GetShapeSize</span>()); </li><li><span class="hljs-keyword">if</span> (reshape_size &lt; <span class="hljs-number">1</span>) { </li><li>    <span class="hljs-comment">// 防御式编程，不应该出现的场景，打印错误并返回失败 </span></li><li>    <span class="hljs-keyword">return</span> ge::GRAPH_FAILED; </li><li>} </li><li> </li><li><span class="hljs-comment">// 根据原型信息，Reshape的shape输入支持INT32与INT64两类，根据不同的类型进入对应的模板函数中做真正的shape变换操作 </span></li><li><span class="hljs-keyword">if</span> (shape_tensor-&gt;<span class="hljs-built_in">GetDataType</span>() == ge::DT_INT32) { </li><li>    <span class="hljs-type">int32_t</span> *reshape_data = shape_tensor-&gt;<span class="hljs-built_in">GetData</span>&lt;<span class="hljs-type">int32_t</span>&gt;(); </li><li>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ReshapeInferShapeImpl</span>&lt;<span class="hljs-type">int32_t</span>&gt;(reshape_data, *x_shape, *output_shape, reshape_size); </li><li>} <span class="hljs-keyword">else</span> { </li><li>    <span class="hljs-type">int64_t</span> *reshape_data = shape_tensor-&gt;<span class="hljs-built_in">GetData</span>&lt;<span class="hljs-type">int64_t</span>&gt;(); </li><li>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ReshapeInferShapeImpl</span>&lt;<span class="hljs-type">int64_t</span>&gt;(reshape_data, *x_shape, *output_shape, reshape_size); </li><li>} </li><li>}</li></ol></pre></div></div> <div><div class="hw-editor-tip warn"><div class="title">注意</div><div class="content"><ul><li>只有声明过数据依赖的输入，才可以在InferShape时调用GetInputTensor等获取tensor的接口获取其对应的tensor数据。若对一个未声明数据依赖的输入调用GetInputTensor等获取tensor的接口，只能在tensor中获取到正确的shape、format、datatype信息，无法获取到真实的tensor数据地址（获取到的地址为nullptr）。</li></ul> <ul><li>从tensor中获取tensor_data时(GetData&lt;int32_t&gt;或GetData&lt;int64_t&gt;)，使用者需要保证获取的数据类型是正确的，否则行为是未定义的。</li></ul> </div></div></div> </div> </div> <div></div></div>