<h1 _ngcontent-bph-c119="" class="doc-title ng-star-inserted" title="时域可分层视频编码"> 时域可分层视频编码 </h1>

<div _ngcontent-bph-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;"> <div> <div class="tiledSection"><h2 id="基础概念">基础概念<i class="anchor-icon anchor-icon-link" anchorid="基础概念" tips="复制节点链接"></i></h2></div>  <div class="tiledSection"><h3 id="时域可分层视频编码介绍" class="firsth2">时域可分层视频编码介绍<i class="anchor-icon anchor-icon-link" anchorid="时域可分层视频编码介绍" tips="复制节点链接"></i></h3><p><strong>可分层视频编码</strong>，又叫可分级视频编码、可伸缩视频编码，是视频编码的扩展标准，目前广泛使用的包含SVC（H.264编码标准采用的可伸缩扩展）和SHVC（H.265编码标准采用的可扩展标准）。</p> <p>其特点是能一次编码出时域分层、空域分层、质量域分层的码流结构，满足因网络、终端能力和用户需求不同带来的差异化需求。</p> <p><strong>时域可分层视频编码</strong>，是指能编码出时域分层码流的视频编码，下图展示了通过参考关系构建的4层时域分层码流结构。</p> <p><span><img originheight="189" originwidth="634" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211114434.08909438671937393699573212803854:50001231000000:2800:46C8DAE9104FBE6698426CF3CBBA0BC35B441921F85D6A0D1774CAB61461DAD2.png" width="634" height="189"></span></p> <p>从高到低逐层丢弃部分层级的码流（丢弃顺序L3-&gt;L2-&gt;L1），能实现不同程度的帧率伸缩，以满足传输和解码能力的变化需求。</p> <p>如下图所示，这是上述4层时域分层码流结构丢弃L3后组成的新的码流结构，能在解码正常的情况下实现帧率减半的效果。其他层的丢弃同理。</p> <p><span><img originheight="178" originwidth="635" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211114434.23720665908907238573037534705665:50001231000000:2800:84B3FFFBD003713D722A2B1BCE2B3C0365C440EB230D3741C678544AB2206798.png" width="635" height="178"></span></p> </div>  <div class="tiledSection"><h3 id="时域分层码流结构介绍">时域分层码流结构介绍<i class="anchor-icon anchor-icon-link" anchorid="时域分层码流结构介绍" tips="复制节点链接"></i></h3><p>基础码流是由一个或多个独立图像组（Group Of Pictures，简称GOP）组合而成的视频码流。GOP是在编码中一组从I帧开始到I帧结束的连续的可独立解码的图像组。</p> <p>时域分层码流可以在GOP内继续细分为独立的一个或多个时域图像组（Temporal Group Of Pictures，简称TGOP），每一个TGOP由一个基本层和后续的一个或多个增强层组合而成，如上述4层时域分层码流结构中的帧0到帧7是一个TGOP。</p> <ul><li><p><strong>基本层（Base Layer，简称BL）：</strong> 是GOP中的最底层（L0）。在时域分层中，该层用最低帧率进行编码。</p>  </li><li><p><strong>增强层（Enhance Layer，简称EL）：</strong> 是BL之上的层级，由低到高可以分为多层（L1、L2、L3）。在时域分层中，最低层的EL参考BL，进一步编码帧率更高的层级，更高层的EL会参考BL或低层EL，来编码比低层更高帧率的视频。</p>  </li></ul> </div>  <div class="tiledSection"><h3 id="如何实现时域分层码流结构">如何实现时域分层码流结构<i class="anchor-icon anchor-icon-link" anchorid="如何实现时域分层码流结构" tips="复制节点链接"></i></h3><p>时域分层码流结构的实现依赖于逐帧指定的参考关系，参考帧根据在解码图像缓存区（Decoded Picture Buffer，简称DPB）驻留的时长分为短期参考帧和长期参考帧。</p> <ul><li><p><strong>短期参考帧（Short-Term Reference，简称STR）：</strong> 是不能长期驻留在DPB中的参考帧，更新方式是先进先出，如果DPB满，旧的短期参考帧会被移出DPB。</p>  </li><li><p><strong>长期参考帧（Long-Term Reference，简称LTR）：</strong> 是能长期驻留在DPB中的参考帧，通过标记替换的方式更新，不主动标记替换就不会更新。</p>  </li></ul> <p>虽然STR个数大于1时，也能实现一定的跨帧参考结构，但受限于存在时效过短，时域分层结构支持的跨度有限。LTR则不存在上述问题，也能覆盖短期参考帧跨帧场景。优选使用LTR实现时域分层码流结构。</p> </div>  <div class="tiledSection"><h2 id="适用场景">适用场景<i class="anchor-icon anchor-icon-link" anchorid="适用场景" tips="复制节点链接"></i></h2><p>基于上述描述的时域分层编码特点，推荐以下场景使用：</p> <ul><li><p>场景1：播放侧无缓存或低缓存的实时编码传输场景，例如视频会议、视频直播、协同办公等。</p>  </li><li><p>场景2：有视频预览播放或倍速播放需求的视频编码录制场景。</p>  </li></ul> <p>若应用场景不涉及动态调整时域参考结构，且分层结构简单，则推荐使用<a href="/consumer/cn/doc/harmonyos-guides/video-encoding-temporal-scalability#全局时域可分层特性feature_temporal_scalability">全局时域可分层特性</a>，否则使能<a href="/consumer/cn/doc/harmonyos-guides/video-encoding-temporal-scalability#长期参考帧特性feature_long-term_reference">长期参考帧特性</a>。</p> </div>  <div class="tiledSection"><h2 id="约束和限制">约束和限制<i class="anchor-icon anchor-icon-link" anchorid="约束和限制" tips="复制节点链接"></i></h2><ul><li><p>不可以混用全局时域可分层特性和长期参考帧特性。</p>  <p>由于底层实现归一，全局时域可分层特性和长期参考帧特性不能同时开启。</p>  </li><li><p>叠加强制IDR配置时，请使用随帧通路配置。</p>  <p>参考帧仅在GOP内有效，刷新I帧后，DPB随之清空，参考帧也会被清空，因此参考关系的指定受I帧刷新位置影响很大。</p>  <p>使能时域分层能力后，若需要通过OH_MD_KEY_REQUEST_I_FRAME临时请求I帧，应使用生效时机确定的随帧通路配置方式准确告知系统I帧刷新位置以避免参考关系错乱，参考随帧通路配置相关指导，避免使用生效时机不确定的OH_VideoEncoder_SetParameter方式。详情请参考<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/video-encoding#surface模式">视频编码Surface模式</a>"步骤-4"。</p>  </li><li><p>支持OH_AVBuffer回调通路，不支持OH_AVMemory回调通路。</p>  <p> 新特性依赖随帧特性，应避免使用OH_AVMemory回调OH_AVCodecAsyncCallback，应使用OH_AVBuffer回调OH_AVCodecCallback。</p>  </li><li><p>支持时域P分层，不支持时域B分层。</p>  <p>时域可分层编码按分层帧类型分为基于P帧的时域分层和基于B帧的时域编码，当前支持分层P编码，不支持分层B编码。</p>  </li><li><p>均匀分层模式当前只支持TGOP为2或4。</p>  </li></ul> </div>  <div class="tiledSection"><h2 id="全局时域可分层特性feature_temporal_scalability">全局时域可分层特性（Feature_Temporal_Scalability）<i class="anchor-icon anchor-icon-link" anchorid="全局时域可分层特性feature_temporal_scalability" tips="复制节点链接"></i></h2></div>  <div class="tiledSection"><h3 id="接口介绍" class="firsth2">接口介绍<i class="anchor-icon anchor-icon-link" anchorid="接口介绍" tips="复制节点链接"></i></h3><p>全局时域可分层特性，适用于编码稳定和简单的时域分层结构，初始配置全局生效，不支持动态修改。开发配置参数如下。</p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.8.3.1.3.1.1" valign="top" width="50%">配置参数</th> <th align="left" class="cellrowborder" id="mcps1.3.8.3.1.3.1.2" valign="top" width="50%">语义</th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="50%">OH_MD_KEY_VIDEO_ENCODER_ENABLE_TEMPORAL_SCALABILITY</td> <td class="cellrowborder" valign="top" width="50%">全局时域可分层编码使能参数。</td> </tr> <tr><td class="cellrowborder" valign="top" width="50%">OH_MD_KEY_VIDEO_ENCODER_TEMPORAL_GOP_SIZE</td> <td class="cellrowborder" valign="top" width="50%">全局时域可分层编码TGOP大小参数。</td> </tr> <tr><td class="cellrowborder" valign="top" width="50%">OH_MD_KEY_VIDEO_ENCODER_TEMPORAL_GOP_REFERENCE_MODE</td> <td class="cellrowborder" valign="top" width="50%">全局时域可分层编码TGOP参考模式。</td> </tr>  </tbody></table></div> </div> <ul><li><p><strong>全局时域可分层编码使能参数：</strong> 在配置阶段配置，仅特性支持才会真正使能成功。</p>  </li><li><p><strong>全局时域可分层编码TGOP大小参数：</strong> 可选配置，影响时域关键帧之间的间隔，用户需要基于自身业务场景下抽帧需求自定义关键帧密度，可在[2, GopSize)范围内配置，若不配置则使用默认值。</p>  </li><li><p><strong>全局时域可分层编码TGOP参考模式参数：</strong> 可选配置，影响非关键帧参考模式。包括相邻参考ADJACENT_REFERENCE、跨帧参考JUMP_REFERENCE和均匀分层UNIFORMLY_SCALED_REFERENCE。相邻参考相对跨帧参考拥有更好的压缩性能，跨帧参考相对相邻参考拥有更好的丢帧自由度，均匀分层模式丢帧后的码流分布更均匀，如不配置则使用默认值。</p>  <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"> <p>均匀分层模式当前只支持TGOP为2或4。</p>  </div></div></div>  </li></ul> <p>使用举例1：TGOP=4时的相邻参考模式。</p> <p><span><img originheight="182" originwidth="632" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211114434.79120125286133431698719756112647:50001231000000:2800:F1544351816048B9F2378C0972A115CF69B7AA9E2B43FACAA637415329FCF1CB.png" width="632" height="182"></span></p> <p>使用举例2：TGOP=4时的跨帧参考模式。</p> <p><span><img originheight="167" originwidth="614" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211114434.93868435748569777744133541237961:50001231000000:2800:F7B0088E998A85F43CD790F7A629B126C9D9B0D4DB42DBD1AC9E3F9EDDA5E1A2.png" width="614" height="167"></span></p> <p>使用举例3：TGOP=4时的均匀分层模式。</p> <p><span><img originheight="167" originwidth="614" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211114434.26664877225315526564661248145709:50001231000000:2800:69342C2A1AB033BF36B08C2E55941CF9E2FF1CE41189867D10AA22D6611E6E24.png" width="614" height="167"></span></p> </div>  <div class="tiledSection"><h3 id="开发指导">开发指导<i class="anchor-icon anchor-icon-link" anchorid="开发指导" tips="复制节点链接"></i></h3><p>基础编码流程请参考<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/video-encoding">视频编码开发指导</a>。下面将重点说明与基础视频编码流程中的不同之处。</p> <ol><li><p>在初始阶段创建编码实例时，校验视频编码器是否支持全局时域可分层特性。</p>  <div _ngcontent-bph-c106="" class="highlight-div"><div _ngcontent-bph-c106="" class="highlight-div-header"><div _ngcontent-bph-c106="" class="highlight-div-header-left"><div _ngcontent-bph-c106="" class="handle-button expand-button"><div _ngcontent-bph-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-bph-c106="" class="highlight-div-header-right"><div _ngcontent-bph-c106="" class="handle-button ai-button"></div><div _ngcontent-bph-c106="" class="handle-button line-button"><div _ngcontent-bph-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-bph-c106="" class="handle-button theme-button"><div _ngcontent-bph-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-bph-c106="" class="handle-button copy-button"><div _ngcontent-bph-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-bph-c106="" class="highlight-scroll-div"><pre class="prettyprint linenums hljs language-go" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// 1.1 获取对应视频编码器能力实例，此处以H.264为例。</span></li><li>OH_AVCapability *<span class="hljs-built_in">cap</span> = OH_AVCodec_GetCapability(OH_AVCODEC_MIMETYPE_VIDEO_AVC, <span class="hljs-literal">true</span>);</li><li><span class="hljs-comment">// 1.2 通过特性能力查询接口校验是否支持全局时域可分层特性。</span></li><li><span class="hljs-type">bool</span> isSupported = OH_AVCapability_IsFeatureSupported(<span class="hljs-built_in">cap</span>, VIDEO_ENCODER_TEMPORAL_SCALABILITY);</li></ol></pre></div></div>  <p> 如果支持，则可以使能全局时域可分层特性。</p>  <div _ngcontent-bph-c106="" class="highlight-div"><div _ngcontent-bph-c106="" class="highlight-div-header"><div _ngcontent-bph-c106="" class="highlight-div-header-left"><div _ngcontent-bph-c106="" class="handle-button expand-button"><div _ngcontent-bph-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-bph-c106="" class="highlight-div-header-right"><div _ngcontent-bph-c106="" class="handle-button ai-button"></div><div _ngcontent-bph-c106="" class="handle-button line-button"><div _ngcontent-bph-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-bph-c106="" class="handle-button theme-button"><div _ngcontent-bph-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-bph-c106="" class="handle-button copy-button"><div _ngcontent-bph-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-bph-c106="" class="highlight-scroll-div"><pre class="prettyprint linenums hljs language-cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// 创建硬件编码器实例。</span></li><li>OH_AVCodec *videoEnc = <span class="hljs-built_in">OH_VideoEncoder_CreateByMime</span>(OH_AVCODEC_MIMETYPE_VIDEO_AVC);</li></ol></pre></div></div>  </li><li><p>在配置阶段，设置全局时域可分层编码特性参数。</p>  <div _ngcontent-bph-c106="" class="highlight-div"><div _ngcontent-bph-c106="" class="highlight-div-header"><div _ngcontent-bph-c106="" class="highlight-div-header-left"><div _ngcontent-bph-c106="" class="handle-button expand-button"><div _ngcontent-bph-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-bph-c106="" class="highlight-div-header-right"><div _ngcontent-bph-c106="" class="handle-button ai-button"></div><div _ngcontent-bph-c106="" class="handle-button line-button"><div _ngcontent-bph-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-bph-c106="" class="handle-button theme-button"><div _ngcontent-bph-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-bph-c106="" class="handle-button copy-button"><div _ngcontent-bph-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-bph-c106="" class="highlight-scroll-div"><pre class="prettyprint linenums hljs language-cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int32_t</span> TGOP_SIZE = <span class="hljs-number">3</span>;</li><li><span class="hljs-comment">// 2.1 创建配置用临时AVFormat。</span></li><li><span class="hljs-keyword">auto</span> format = std::<span class="hljs-built_in">shared_ptr</span>&lt;OH_AVFormat&gt;(<span class="hljs-built_in">OH_AVFormat_Create</span>(), OH_AVFormat_Destroy);</li><li><span class="hljs-keyword">if</span> (format == <span class="hljs-literal">nullptr</span>) {</li><li>    <span class="hljs-comment">// 异常处理。</span></li><li>}</li><li><span class="hljs-comment">// 2.2 填充使能参数键值对。</span></li><li><span class="hljs-built_in">OH_AVFormat_SetIntValue</span>(format.<span class="hljs-built_in">get</span>(), OH_MD_KEY_VIDEO_ENCODER_ENABLE_TEMPORAL_SCALABILITY, <span class="hljs-number">1</span>);</li><li><span class="hljs-comment">// 2.3 (可选)填充TGOP大小和TGOP内参考模式键值对。</span></li><li><span class="hljs-built_in">OH_AVFormat_SetIntValue</span>(format.<span class="hljs-built_in">get</span>(), OH_MD_KEY_VIDEO_ENCODER_TEMPORAL_GOP_SIZE, TGOP_SIZE);</li><li><span class="hljs-built_in">OH_AVFormat_SetIntValue</span>(format.<span class="hljs-built_in">get</span>(), OH_MD_KEY_VIDEO_ENCODER_TEMPORAL_GOP_REFERENCE_MODE, ADJACENT_REFERENCE);</li><li><span class="hljs-comment">// 2.4 参数配置。</span></li><li><span class="hljs-type">int32_t</span> ret = <span class="hljs-built_in">OH_VideoEncoder_Configure</span>(videoEnc, format.<span class="hljs-built_in">get</span>());</li><li><span class="hljs-keyword">if</span> (ret != AV_ERR_OK) {</li><li>    <span class="hljs-comment">// 异常处理。</span></li><li>}</li></ol></pre></div></div>  </li><li><p>（可选）在输出轮转中，可以获取码流对应时域层级信息。</p>  <p> 开发者可利用已配置的TGOP参数和编码出帧数目获取时域层级信息。</p>  <p> 示例代码如下：</p>  <div _ngcontent-bph-c106="" class="highlight-div"><div _ngcontent-bph-c106="" class="highlight-div-header"><div _ngcontent-bph-c106="" class="highlight-div-header-left"><div _ngcontent-bph-c106="" class="handle-button expand-button"><div _ngcontent-bph-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-bph-c106="" class="highlight-div-header-right"><div _ngcontent-bph-c106="" class="handle-button ai-button"></div><div _ngcontent-bph-c106="" class="handle-button line-button"><div _ngcontent-bph-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-bph-c106="" class="handle-button theme-button"><div _ngcontent-bph-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-bph-c106="" class="handle-button copy-button"><div _ngcontent-bph-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-bph-c106="" class="highlight-scroll-div"><pre class="prettyprint linenums hljs language-cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int32_t</span> TGOP_SIZE = <span class="hljs-number">3</span>;</li><li><span class="hljs-type">uint32_t</span> outPoc = <span class="hljs-number">0</span>;</li><li><span class="hljs-comment">// 通过输出回调中有效帧数，获取TGOP内相对位置，对照配置确认层级。</span></li><li><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">OnNewOutputBuffer</span><span class="hljs-params">(OH_AVCodec *codec, <span class="hljs-type">uint32_t</span> index, OH_AVBuffer *buffer, <span class="hljs-type">void</span> *userData)</span></span></li><li><span class="hljs-function"></span>{</li><li>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">OH_AVCodecBufferAttr</span> attr;</li><li>    OH_AVErrCode ret = <span class="hljs-built_in">OH_AVBuffer_GetBufferAttr</span>(buffer, &amp;attr);</li><li>    <span class="hljs-keyword">if</span> (ret != AV_ERR_OK) {</li><li>        <span class="hljs-comment">// 异常处理。</span></li><li>    }</li><li>    <span class="hljs-comment">// 刷新I帧后POC归零。</span></li><li>    <span class="hljs-keyword">if</span> (attr.flags &amp; AVCODEC_BUFFER_FLAGS_SYNC_FRAME) {</li><li>        outPoc = <span class="hljs-number">0</span>;</li><li>    }</li><li>    <span class="hljs-comment">// 只有XPS的输出需要跳过。</span></li><li>    <span class="hljs-keyword">if</span> (attr.flags != AVCODEC_BUFFER_FLAGS_CODEC_DATA) {</li><li>        <span class="hljs-type">int32_t</span> tGopInner = outPoc % TGOP_SIZE;</li><li>        <span class="hljs-keyword">if</span> (tGopInner == <span class="hljs-number">0</span>) {</li><li>            <span class="hljs-comment">// 时域关键帧，后续传输、解码流程不可丢弃。</span></li><li>        } <span class="hljs-keyword">else</span> {</li><li>            <span class="hljs-comment">// 时域非关键帧，后续传输、解码流程可以丢弃。</span></li><li>        }</li><li>        outPoc++;</li><li>    }</li><li>}</li></ol></pre></div></div>  </li><li><p>（可选）在输出轮转中，使用步骤3获取的时域层级信息，自适应传输或自适应解码。</p>  <p> 根据获取的时域可分层码流和对应的层级信息，开发者可选择需要的层级进行传输，或携带至对端自适应选帧解码。</p>  </li></ol> </div>  <div class="tiledSection"><h2 id="长期参考帧特性feature_long-term_reference">长期参考帧特性（Feature_Long-Term_Reference）<i class="anchor-icon anchor-icon-link" anchorid="长期参考帧特性feature_long-term_reference" tips="复制节点链接"></i></h2></div>  <div class="tiledSection"><h3 id="接口介绍-1" class="firsth2">接口介绍<i class="anchor-icon anchor-icon-link" anchorid="接口介绍-1" tips="复制节点链接"></i></h3><p>长期参考帧特性提供帧级参考关系配置。适用于灵活和复杂的时域分层结构。</p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.11.3.1.3.1.1" valign="top" width="50%">配置参数</th> <th align="left" class="cellrowborder" id="mcps1.3.11.3.1.3.1.2" valign="top" width="50%">语义</th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="50%">OH_MD_KEY_VIDEO_ENCODER_LTR_FRAME_COUNT</td> <td class="cellrowborder" valign="top" width="50%">长期参考帧个数参数。</td> </tr> <tr><td class="cellrowborder" valign="top" width="50%">OH_MD_KEY_VIDEO_ENCODER_PER_FRAME_MARK_LTR</td> <td class="cellrowborder" valign="top" width="50%">当前帧标记为LTR帧。</td> </tr> <tr><td class="cellrowborder" valign="top" width="50%">OH_MD_KEY_VIDEO_ENCODER_PER_FRAME_USE_LTR</td> <td class="cellrowborder" valign="top" width="50%">当前帧参考的LTR帧的POC号。</td> </tr>  </tbody></table></div> </div> <ul><li><strong>长期参考帧个数参数：</strong> 在配置阶段进行设置，应不大于实际查询到的最大支持数目。具体查询方法请参见下文开发指导的“步骤-3”。</li><li><strong>当前帧标记为LTR帧：</strong> BL层和被跳跃参考的EL层均标记为LTR。</li><li><strong>当前帧参考的LTR帧的POC号：</strong> 如当前帧需要跳跃参考前面已被标记为LTR帧的POC号。</li></ul> <p>使用举例，实现<a href="/consumer/cn/doc/harmonyos-guides/video-encoding-temporal-scalability#时域可分层视频编码介绍">时域可分层视频编码介绍</a>中的4层时域分层结构的配置如下。</p> <ol><li><p>在配置阶段，将OH_MD_KEY_VIDEO_ENCODER_LTR_FRAME_COUNT 配置为5。</p>  </li><li><p>在运行阶段输入轮转中，按如下表所示随帧配置LTR相关参数，下表中\表示不做配置。</p>   <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.11.6.2.2.1.19.1.1" valign="top" width="5.555555555555555%">配置\POC</th> <th align="left" class="cellrowborder" id="mcps1.3.11.6.2.2.1.19.1.2" valign="top" width="5.555555555555555%">0</th> <th align="left" class="cellrowborder" id="mcps1.3.11.6.2.2.1.19.1.3" valign="top" width="5.555555555555555%">1</th> <th align="left" class="cellrowborder" id="mcps1.3.11.6.2.2.1.19.1.4" valign="top" width="5.555555555555555%">2</th> <th align="left" class="cellrowborder" id="mcps1.3.11.6.2.2.1.19.1.5" valign="top" width="5.555555555555555%">3</th> <th align="left" class="cellrowborder" id="mcps1.3.11.6.2.2.1.19.1.6" valign="top" width="5.555555555555555%">4</th> <th align="left" class="cellrowborder" id="mcps1.3.11.6.2.2.1.19.1.7" valign="top" width="5.555555555555555%">5</th> <th align="left" class="cellrowborder" id="mcps1.3.11.6.2.2.1.19.1.8" valign="top" width="5.555555555555555%">6</th> <th align="left" class="cellrowborder" id="mcps1.3.11.6.2.2.1.19.1.9" valign="top" width="5.555555555555555%">7</th> <th align="left" class="cellrowborder" id="mcps1.3.11.6.2.2.1.19.1.10" valign="top" width="5.555555555555555%">8</th> <th align="left" class="cellrowborder" id="mcps1.3.11.6.2.2.1.19.1.11" valign="top" width="5.555555555555555%">9</th> <th align="left" class="cellrowborder" id="mcps1.3.11.6.2.2.1.19.1.12" valign="top" width="5.555555555555555%">10</th> <th align="left" class="cellrowborder" id="mcps1.3.11.6.2.2.1.19.1.13" valign="top" width="5.555555555555555%">11</th> <th align="left" class="cellrowborder" id="mcps1.3.11.6.2.2.1.19.1.14" valign="top" width="5.555555555555555%">12</th> <th align="left" class="cellrowborder" id="mcps1.3.11.6.2.2.1.19.1.15" valign="top" width="5.555555555555555%">13</th> <th align="left" class="cellrowborder" id="mcps1.3.11.6.2.2.1.19.1.16" valign="top" width="5.555555555555555%">14</th> <th align="left" class="cellrowborder" id="mcps1.3.11.6.2.2.1.19.1.17" valign="top" width="5.555555555555555%">15</th> <th align="left" class="cellrowborder" id="mcps1.3.11.6.2.2.1.19.1.18" valign="top" width="5.555555555555555%">16</th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="5.555555555555555%">MARK_LTR</td> <td class="cellrowborder" valign="top" width="5.555555555555555%">1</td> <td class="cellrowborder" valign="top" width="5.555555555555555%">0</td> <td class="cellrowborder" valign="top" width="5.555555555555555%">0</td> <td class="cellrowborder" valign="top" width="5.555555555555555%">0</td> <td class="cellrowborder" valign="top" width="5.555555555555555%">1</td> <td class="cellrowborder" valign="top" width="5.555555555555555%">0</td> <td class="cellrowborder" valign="top" width="5.555555555555555%">0</td> <td class="cellrowborder" valign="top" width="5.555555555555555%">0</td> <td class="cellrowborder" valign="top" width="5.555555555555555%">1</td> <td class="cellrowborder" valign="top" width="5.555555555555555%">0</td> <td class="cellrowborder" valign="top" width="5.555555555555555%">0</td> <td class="cellrowborder" valign="top" width="5.555555555555555%">0</td> <td class="cellrowborder" valign="top" width="5.555555555555555%">1</td> <td class="cellrowborder" valign="top" width="5.555555555555555%">0</td> <td class="cellrowborder" valign="top" width="5.555555555555555%">0</td> <td class="cellrowborder" valign="top" width="5.555555555555555%">0</td> <td class="cellrowborder" valign="top" width="5.555555555555555%">1</td> </tr> <tr><td class="cellrowborder" valign="top" width="5.555555555555555%">USE_LTR</td> <td class="cellrowborder" valign="top" width="5.555555555555555%">\</td> <td class="cellrowborder" valign="top" width="5.555555555555555%">\</td> <td class="cellrowborder" valign="top" width="5.555555555555555%">0</td> <td class="cellrowborder" valign="top" width="5.555555555555555%">\</td> <td class="cellrowborder" valign="top" width="5.555555555555555%">0</td> <td class="cellrowborder" valign="top" width="5.555555555555555%">\</td> <td class="cellrowborder" valign="top" width="5.555555555555555%">4</td> <td class="cellrowborder" valign="top" width="5.555555555555555%">\</td> <td class="cellrowborder" valign="top" width="5.555555555555555%">0</td> <td class="cellrowborder" valign="top" width="5.555555555555555%">\</td> <td class="cellrowborder" valign="top" width="5.555555555555555%">8</td> <td class="cellrowborder" valign="top" width="5.555555555555555%">\</td> <td class="cellrowborder" valign="top" width="5.555555555555555%">8</td> <td class="cellrowborder" valign="top" width="5.555555555555555%">\</td> <td class="cellrowborder" valign="top" width="5.555555555555555%">12</td> <td class="cellrowborder" valign="top" width="5.555555555555555%">\</td> <td class="cellrowborder" valign="top" width="5.555555555555555%">8</td> </tr>  </tbody></table></div> </div>  </li></ol> </div>  <div class="tiledSection"><h3 id="开发指导-1">开发指导<i class="anchor-icon anchor-icon-link" anchorid="开发指导-1" tips="复制节点链接"></i></h3><p>基础编码流程请参考<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/video-encoding">视频编码开发指导</a>，下面仅针对与基础视频编码过程中存在的区别做具体说明。</p> <ol><li><p>在初始阶段创建编码实例时，校验当前视频编码器是否支持LTR特性。</p>  <div _ngcontent-bph-c106="" class="highlight-div"><div _ngcontent-bph-c106="" class="highlight-div-header"><div _ngcontent-bph-c106="" class="highlight-div-header-left"><div _ngcontent-bph-c106="" class="handle-button expand-button"><div _ngcontent-bph-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-bph-c106="" class="highlight-div-header-right"><div _ngcontent-bph-c106="" class="handle-button ai-button"></div><div _ngcontent-bph-c106="" class="handle-button line-button"><div _ngcontent-bph-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-bph-c106="" class="handle-button theme-button"><div _ngcontent-bph-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-bph-c106="" class="handle-button copy-button"><div _ngcontent-bph-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-bph-c106="" class="highlight-scroll-div"><pre class="prettyprint linenums hljs language-cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int32_t</span> NEEDED_LTR_COUNT = <span class="hljs-number">5</span>;</li><li><span class="hljs-type">bool</span> isSupported = <span class="hljs-literal">false</span>;</li><li><span class="hljs-type">int32_t</span> supportedLTRCount = <span class="hljs-number">0</span>;</li><li><span class="hljs-comment">// 1.1 获取对应编码器能力实例，此处以H.264为例。</span></li><li>OH_AVCapability *cap = <span class="hljs-built_in">OH_AVCodec_GetCapability</span>(OH_AVCODEC_MIMETYPE_VIDEO_AVC, <span class="hljs-literal">true</span>);</li><li><span class="hljs-comment">// 1.2 通过特性能力查询接口校验是否支持LTR特性。</span></li><li>isSupported = <span class="hljs-built_in">OH_AVCapability_IsFeatureSupported</span>(cap, VIDEO_ENCODER_LONG_TERM_REFERENCE);</li><li><span class="hljs-comment">// 1.3 确定支持的LTR数目。</span></li><li><span class="hljs-keyword">if</span> (isSupported) {</li><li>    OH_AVFormat *properties = <span class="hljs-built_in">OH_AVCapability_GetFeatureProperties</span>(cap, VIDEO_ENCODER_LONG_TERM_REFERENCE);</li><li>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">OH_AVFormat_GetIntValue</span>(properties, OH_FEATURE_PROPERTY_KEY_VIDEO_ENCODER_MAX_LTR_FRAME_COUNT, &amp;supportedLTRCount)) {</li><li>        <span class="hljs-comment">// 异常处理。</span></li><li>    }</li><li>    <span class="hljs-built_in">OH_AVFormat_Destroy</span>(properties);</li><li>    <span class="hljs-comment">// 1.4 判断LTR是否满足结构需求。</span></li><li>    isSupported = supportedLTRCount &gt;= NEEDED_LTR_COUNT;</li><li>}</li></ol></pre></div></div>  <p> 若支持且LTR数目满足自身码流结构需求，则可以使能LTR特性。</p>  </li><li><p>在配置之前注册回调时，注册随帧通路回调。</p>  <p> Buffer输入模式示例：</p>  <div _ngcontent-bph-c106="" class="highlight-div"><div _ngcontent-bph-c106="" class="highlight-div-header"><div _ngcontent-bph-c106="" class="highlight-div-header-left"><div _ngcontent-bph-c106="" class="handle-button expand-button"><div _ngcontent-bph-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-bph-c106="" class="highlight-div-header-right"><div _ngcontent-bph-c106="" class="handle-button ai-button"></div><div _ngcontent-bph-c106="" class="handle-button line-button"><div _ngcontent-bph-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-bph-c106="" class="handle-button theme-button"><div _ngcontent-bph-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-bph-c106="" class="handle-button copy-button"><div _ngcontent-bph-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-bph-c106="" class="highlight-scroll-div"><pre class="prettyprint linenums hljs language-cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// 2.1 编码输入回调OH_AVCodecOnNeedInputBuffer实现。</span></li><li><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">OnNeedInputBuffer</span><span class="hljs-params">(OH_AVCodec *codec, <span class="hljs-type">uint32_t</span> index, OH_AVBuffer *buffer, <span class="hljs-type">void</span> *userData)</span></span></li><li><span class="hljs-function"></span>{</li><li>    <span class="hljs-comment">// 输入帧buffer对应的index，送入InIndexQueue队列。</span></li><li>    <span class="hljs-comment">// 输入帧的数据buffer送入InBufferQueue队列。</span></li><li>    <span class="hljs-comment">// 数据处理，请参考：</span></li><li>    <span class="hljs-comment">// - 写入编码码流。</span></li><li>    <span class="hljs-comment">// - 通知编码器码流结束。</span></li><li>    <span class="hljs-comment">// - 随帧参数写入。</span></li><li>    <span class="hljs-keyword">auto</span> format = std::<span class="hljs-built_in">shared_ptr</span>&lt;OH_AVFormat&gt;(<span class="hljs-built_in">OH_AVBuffer_GetParameter</span>(buffer), OH_AVFormat_Destroy);</li><li>    <span class="hljs-keyword">if</span> (format == <span class="hljs-literal">nullptr</span>) {</li><li>        <span class="hljs-comment">// 异常处理。</span></li><li>    }</li><li>    <span class="hljs-built_in">OH_AVFormat_SetIntValue</span>(format.<span class="hljs-built_in">get</span>(), OH_MD_KEY_VIDEO_ENCODER_PER_FRAME_MARK_LTR, <span class="hljs-number">1</span>);</li><li>    <span class="hljs-built_in">OH_AVFormat_SetIntValue</span>(format.<span class="hljs-built_in">get</span>(), OH_MD_KEY_VIDEO_ENCODER_PER_FRAME_USE_LTR, <span class="hljs-number">4</span>);</li><li>    <span class="hljs-built_in">OH_AVBuffer_SetParameter</span>(buffer, format.<span class="hljs-built_in">get</span>());</li><li>    <span class="hljs-comment">// 通知编码器buffer输入完成。</span></li><li>    <span class="hljs-built_in">OH_VideoEncoder_PushInputBuffer</span>(codec, index);</li><li>}</li><li>
</li><li><span class="hljs-comment">// 2.2 编码输出回调OH_AVCodecOnNewOutputBuffer实现。</span></li><li><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">OnNewOutputBuffer</span><span class="hljs-params">(OH_AVCodec *codec, <span class="hljs-type">uint32_t</span> index, OH_AVBuffer *buffer, <span class="hljs-type">void</span> *userData)</span></span></li><li><span class="hljs-function"></span>{</li><li>    <span class="hljs-comment">// 完成帧buffer对应的index，送入outIndexQueue队列。</span></li><li>    <span class="hljs-comment">// 完成帧的数据buffer送入outBufferQueue队列。</span></li><li>    <span class="hljs-comment">// 数据处理，请参考：</span></li><li>    <span class="hljs-comment">// - 释放编码帧。</span></li><li>    <span class="hljs-comment">// - 记录POC和LTR生效情况。</span></li><li>}</li><li>
</li><li><span class="hljs-comment">// 2.3 注册数据回调。</span></li><li>OH_AVCodecCallback cb;</li><li>cb.onNeedInputBuffer = OnNeedInputBuffer;</li><li>cb.onNewOutputBuffer = OnNewOutputBuffer;</li><li><span class="hljs-built_in">OH_VideoEncoder_RegisterCallback</span>(videoEnc, cb, <span class="hljs-literal">nullptr</span>);</li></ol></pre></div></div>  <p> Surface输入模式示例：</p>  <div _ngcontent-bph-c106="" class="highlight-div"><div _ngcontent-bph-c106="" class="highlight-div-header"><div _ngcontent-bph-c106="" class="highlight-div-header-left"><div _ngcontent-bph-c106="" class="handle-button expand-button"><div _ngcontent-bph-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-bph-c106="" class="highlight-div-header-right"><div _ngcontent-bph-c106="" class="handle-button ai-button"></div><div _ngcontent-bph-c106="" class="handle-button line-button"><div _ngcontent-bph-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-bph-c106="" class="handle-button theme-button"><div _ngcontent-bph-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-bph-c106="" class="handle-button copy-button"><div _ngcontent-bph-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-bph-c106="" class="highlight-scroll-div"><pre class="prettyprint linenums hljs language-cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// 2.1 编码输入参数回调OH_VideoEncoder_OnNeedInputParameter实现。</span></li><li><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">OnNeedInputParameter</span><span class="hljs-params">(OH_AVCodec *codec, <span class="hljs-type">uint32_t</span> index, OH_AVFormat *parameter, <span class="hljs-type">void</span> *userData)</span></span></li><li><span class="hljs-function"></span>{</li><li>    <span class="hljs-comment">// 输入帧buffer对应的index，送入InIndexQueue队列。</span></li><li>    <span class="hljs-comment">// 输入帧的数据avformat送入InFormatQueue队列。</span></li><li>    <span class="hljs-comment">// 数据处理，请参考：</span></li><li>    <span class="hljs-comment">// - 写入编码码流。</span></li><li>    <span class="hljs-comment">// - 通知编码器码流结束。</span></li><li>    <span class="hljs-comment">// - 随帧参数写入。</span></li><li>    <span class="hljs-built_in">OH_AVFormat_SetIntValue</span>(parameter, OH_MD_KEY_VIDEO_ENCODER_PER_FRAME_MARK_LTR, <span class="hljs-number">1</span>);</li><li>    <span class="hljs-built_in">OH_AVFormat_SetIntValue</span>(parameter, OH_MD_KEY_VIDEO_ENCODER_PER_FRAME_USE_LTR, <span class="hljs-number">4</span>);</li><li>    <span class="hljs-comment">// 通知编码器随帧参数配置输入完成。</span></li><li>    <span class="hljs-built_in">OH_VideoEncoder_PushInputParameter</span>(codec, index);</li><li>}</li><li>
</li><li><span class="hljs-comment">// 2.2 编码输出回调OH_AVCodecOnNewOutputBuffer实现。</span></li><li><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">OnNewOutputBuffer</span><span class="hljs-params">(OH_AVCodec *codec, <span class="hljs-type">uint32_t</span> index, OH_AVBuffer *buffer, <span class="hljs-type">void</span> *userData)</span></span></li><li><span class="hljs-function"></span>{</li><li>    <span class="hljs-comment">// 完成帧buffer对应的index，送入outIndexQueue队列。</span></li><li>    <span class="hljs-comment">// 完成帧的数据buffer送入outBufferQueue队列。</span></li><li>    <span class="hljs-comment">// 数据处理，请参考：</span></li><li>    <span class="hljs-comment">// - 释放编码帧。</span></li><li>    <span class="hljs-comment">// - 记录POC和LTR生效情况。</span></li><li>}</li><li>
</li><li><span class="hljs-comment">// 2.3 注册数据回调。</span></li><li>OH_AVCodecCallback cb;</li><li>cb.onNewOutputBuffer = OnNewOutputBuffer;</li><li><span class="hljs-built_in">OH_VideoEncoder_RegisterCallback</span>(videoEnc, cb, <span class="hljs-literal">nullptr</span>);</li><li><span class="hljs-comment">// 2.4 注册随帧参数回调。</span></li><li>OH_VideoEncoder_OnNeedInputParameter inParaCb = OnNeedInputParameter;</li><li><span class="hljs-built_in">OH_VideoEncoder_RegisterParameterCallback</span>(videoEnc, inParaCb, <span class="hljs-literal">nullptr</span>);</li></ol></pre></div></div>  </li><li><p>在配置阶段，设置最大LTR数目。</p>  <div _ngcontent-bph-c106="" class="highlight-div"><div _ngcontent-bph-c106="" class="highlight-div-header"><div _ngcontent-bph-c106="" class="highlight-div-header-left"><div _ngcontent-bph-c106="" class="handle-button expand-button"><div _ngcontent-bph-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-bph-c106="" class="highlight-div-header-right"><div _ngcontent-bph-c106="" class="handle-button ai-button"></div><div _ngcontent-bph-c106="" class="handle-button line-button"><div _ngcontent-bph-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-bph-c106="" class="handle-button theme-button"><div _ngcontent-bph-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-bph-c106="" class="handle-button copy-button"><div _ngcontent-bph-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-bph-c106="" class="highlight-scroll-div"><pre class="prettyprint linenums hljs language-cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int32_t</span> NEEDED_LTR_COUNT = <span class="hljs-number">5</span>;</li><li><span class="hljs-comment">// 3.1 创建配置用临时AVFormat。</span></li><li><span class="hljs-keyword">auto</span> format = std::<span class="hljs-built_in">shared_ptr</span>&lt;OH_AVFormat&gt;(<span class="hljs-built_in">OH_AVFormat_Create</span>(), OH_AVFormat_Destroy);</li><li><span class="hljs-keyword">if</span> (format == <span class="hljs-literal">nullptr</span>) {</li><li>    <span class="hljs-comment">// 异常处理。</span></li><li>}</li><li><span class="hljs-comment">// 3.2 填充使能LTR个数键值对。</span></li><li><span class="hljs-built_in">OH_AVFormat_SetIntValue</span>(format.<span class="hljs-built_in">get</span>(), OH_MD_KEY_VIDEO_ENCODER_LTR_FRAME_COUNT, NEEDED_LTR_COUNT);</li><li><span class="hljs-comment">// 3.3 参数配置。</span></li><li><span class="hljs-type">int32_t</span> ret = <span class="hljs-built_in">OH_VideoEncoder_Configure</span>(videoEnc, format.<span class="hljs-built_in">get</span>());</li><li><span class="hljs-keyword">if</span> (ret != AV_ERR_OK) {</li><li>    <span class="hljs-comment">// 异常处理。</span></li><li>}</li></ol></pre></div></div>  </li><li><p>（可选）在输出轮转中，可以获取码流的时域层级信息。</p>  <p> 同全局时域可分层特性。</p>  <p> 由于在输入轮转过程中配置了LTR参数，也可以在输入轮转中记录这些参数，并在输出轮转中找到对应的输入参数。</p>  </li><li><p>（可选）在输出轮转中，使用步骤4获取的时域层级信息，进行自适应传输或自适应解码。</p>  <p> 同全局时域可分层特性。</p>  </li></ol> </div> </div> <div></div></div>