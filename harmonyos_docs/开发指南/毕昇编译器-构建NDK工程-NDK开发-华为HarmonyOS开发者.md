<h1 _ngcontent-lfm-c119="" class="doc-title ng-star-inserted" title="毕昇编译器"> 毕昇编译器 </h1>

<div _ngcontent-lfm-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;"> <div><div class="tiledSection"><h2 id="section9398118131718">毕昇编译器简介<i class="anchor-icon anchor-icon-link" anchorid="section9398118131718" tips="复制节点链接"></i></h2><p>毕昇编译器是基于LLVM开源软件开发的一款用于C/C++等语言的native编译器，能将C/C++代码工程编译链接成可以在设备上运行的二进制。在无需改动用户代码的条件下，相比业界主流的开源LLVM或GCC编译器，毕昇编译器能提供更强大的优化能力，使编译链接出来的二进制的运行时长更短、指令数更少，帮助提升应用在设备上的运行流畅度。</p> </div> <div class="tiledSection"><h2 id="section16877114219172">能力范围<i class="anchor-icon anchor-icon-link" anchorid="section16877114219172" tips="复制节点链接"></i></h2><p>毕昇编译器提供将C/C++代码工程编译链接成可以在设备上运行的二进制的基本能力，主要包括以下三方面：</p> <ul><li>编译能力：将C/C++源码文件编译成汇编文件，汇编文件是指使用汇编语言编写的文件。</li><li>汇编能力：将汇编文件汇编成可重定向文件，可重定向文件是ELF格式的二进制文件，但不能直接放在设备上运行。</li><li>链接能力：将一个或多个可重定向文件一起链接成一个可执行的二进制文件。</li></ul> </div> <div class="tiledSection"><h2 id="section17255219186">亮点特征示例<i class="anchor-icon anchor-icon-link" anchorid="section17255219186" tips="复制节点链接"></i></h2><p>毕昇编译器相对于LLVM/GCC编译器有以下特点。</p> <ul><li><strong>毕昇编译器Loop Distribution优化增强示例</strong></li></ul> <p>针对循环相关的编译优化，毕昇编译器在场景识别、结构变换等方面做了改进和增强。例如在社区LLVM已有的Loop Distribution优化上，毕昇编译器相比开源LLVM编译器，能额外识别出循环内不同代码块间数据依赖关系、以及不同代码块运行的迭代次数差别，从而能对更多的循环进行loop distribution优化。</p> <p><span><img height="383.232451" originheight="602" originwidth="1241" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211114334.11951612275299711358448338431726:50001231000000:2800:7EF967E67B2450C9B65589AF264AAE007D987CAE8C1BC2E32AF7C9A91DA4C933.png" title="点击放大" width="790.0200000000001"></span></p> <p></p> <ul><li><strong>毕昇编译器矢量化优化增强示例</strong></li></ul> <p>毕昇编译器在矢量化优化方面，相比开源LLVM编译器，不仅能将更多的循环做矢量化转换，还在矢量化指令选择上更高效。例如下面示例中，开源LLVM编译器虽然做了矢量化，但使用了5条矢量指令；而毕昇编译器只需要使用2条矢量指令，最终产生的二进制效率更优。</p> <p><span><img originheight="535" originwidth="786" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211114334.28216077810921211703484663947715:50001231000000:2800:9CA1BF846D1C3C315BFE101AAC7FC9FB66EB5914A446DDD7A6813F57EBE3622F.png" width="786" height="535"></span></p> </div> <div class="tiledSection"><h2 id="section1450716302183">毕昇编译器使用指导<i class="anchor-icon anchor-icon-link" anchorid="section1450716302183" tips="复制节点链接"></i></h2><p><strong>在DevEco Studio 中使用毕昇编译器：</strong></p> <ul><li>开发者获取DevEco Studio 5.1.1 release及之后的版本，新建C/C++工程默认使用毕昇编译器，打开C/C++老工程有弹窗提示，点击<strong>Try Now</strong>可以切换使用毕昇编译器，构建HarmonyOS工程的C/C++代码。</li></ul> <p><span><img height="298.53073600000005" originheight="422" originwidth="987" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211114334.55526000661541862960010218523159:50001231000000:2800:E88C3B40D215E94A54C29CB3464DB7290C0E9DD117BE82DB7BE39DE6526BA360.png" title="点击放大" width="698.25"></span></p> <ul><li>开发者获取DevEco Studio 5.1.1 beta及之前的版本，需要在HarmonyOS应用的工程级build-profile.json5中简单配置即可使用毕昇编译器：在runtimeOS为HarmonyOS的时候，设置nativeCompiler为BiSheng，即可使用毕昇编译器构建HarmonyOS工程的C/C++代码。</li></ul> <p><span><img originheight="269" originwidth="703" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211114334.75199838093499392370127238978311:50001231000000:2800:6DDD370849761F496E22F19A27886244D301D2755C9F5F70F3CFF162C596516B.png" width="703" height="269"></span></p> <p>此外当开发者自己单独配置流水线切换毕昇编译器时可能会遇到找不到头文件错误，此时添加sysroot路径选项即可解决（xxx为sdk的路径）：</p> <p>--sysroot=xxx/sdk/default/openharmony/native/sysroot</p> </div> <div class="tiledSection"><h2 id="section8221174018112">主要编译优化特性<i class="anchor-icon anchor-icon-link" anchorid="section8221174018112" tips="复制节点链接"></i></h2><ul><li><strong>IClang</strong></li></ul> <p>IClang是一种增量编译优化手段。该特性在增量编译的基础上，进一步实现函数级别的编译复用，利用上一次的编译结果，显著提升编译速度。</p> <p><strong>1. 启用指导</strong></p> <p>编译时，需要增加-iclang选项。以CMake构建系统为例，可在 CMakeLists.txt 中配置：add_compile_options(-iclang)</p> <p><strong>2. IClang维护的数据</strong></p> <p>IClang 会在目标文件所在目录下自动生成一个 .iclang 子目录，用于存储其运行所需的数据。例如，编译 test.o 时，会创建 test.o.iclang 目录。</p> <p><strong>3. IClang的编译模式</strong></p> <p>由于用户通常仅修改部分源文件而非整个项目，故IClang仅会为需要频繁修改的源文件生成可复用的缓存。具体而言，IClang的编译可以分为以下三种模式：</p> <p>（1）初始模式：在首次编译-iclang时，仅维护一些非常轻量的元数据，从而避免对用户的全量编译性能造成影响。</p> <p>（2）预热模式：当用户首次对某个文件进行修改并重新编译时，IClang会认定其为高频修改目标，并执行一些必要的分析与缓存构建。该模式可能会略微影响用户的首次增量编译性能，相关产物存储在.iclang中。</p> <p>（3）增量编译模式：完成预热后的文件，用户后续对其修改之后的增量编译都可以得到加速，非常适用于频繁修改某个源文件的场景。</p> <p><strong>4. 缓存失效的情况</strong></p> <p>（1）上次编译生成的二进制产物被删除。此时IClang将无法实现二进制函数复用，因此回退到初始模式。</p> <p>（2）头文件内容或配置发生变化。此时IClang将无法判断哪些函数可以被安全复用，因此回退到初始模式。</p> <p>（3）编译命令发生变化。此时构建系统会重新编译整个项目，IClang保持与构建系统的行为一致，回退到初始模式。</p> <p>当IClang发生内部错误时，会在相关产物下生成.iclangtmp目录，检测到该目录存在后IClang将进入恢复模式，完全退回到Clang，确保用户可以正常编译。同时，应将这一行为报告给IClang开发者进行确认和修复。如有需要，用户也可以尝试自行删除.iclangtmp目录，此时IClang将会重新回到初始模式。</p> <p><strong>5. 编译选项限制</strong></p> <p>（1）IClang仅会作用于-c编译，且命令只有一个输入文件和一个输出文件，常见的构建系统（如CMake）都可以满足这个条件。</p> <p>（2）IClang目前仅支持-O0优化选项，用户需要注意仅在debug模式的开发环境下使用。如果检测到其他优化选项，IClang将回退到Clang并提示：[IClang Warning] Please ensure that IClang is only enabled under -O0</p> <p>（3）为了确保二进制复用的正确进行，IClang会添加-ffunction-sections与-fdata-sections两个编译选项，按符号划分二进制文件的代码段和数据段。</p> <p><strong>6. 编译前端限制</strong></p> <p>IClang在优化过程中，出于正确性考虑会选择不对包含某些语法的函数进行优化，包括：数组实例化类型、函数指针实例化类型、虚函数、UniqueExternalLinkage。</p> <p><strong>7. 编译后端限制</strong></p> <p>IClang生成的二进制产物遵循X86-64 ELF规范，在此基础上额外提出以下限制：仅支持64位小端序；二进制文件中仅包含Rela重定位表，不支持Rel重定位表；链接器采用lld，不支持gnu ld。</p> <p></p> <ul><li><strong>PGO（Profile Guided Optimization）</strong></li></ul> <p>PGO是一种自适应优化手段。它通过收集代码在实际运行过程中的性能数据，来准确得知例如哪些函数是真正被频繁执行的、哪些分支是真正频繁进入的等信息，从而指导编译器做出相应优化。相较于传统的PGO，毕昇PGO具有更强的准确性和优化性。</p> <p>毕昇编译器通过信号量触发文件写入操作：Dso在接受到特定信号量时将采样信息写入文件中，并清空相应计数器。 其主要流程如下图所示：<span><img height="323.04742400000003" originheight="479" originwidth="764" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211114335.13915183493879486503448662494716:50001231000000:2800:29B4CF3C7FEE01030926C0D73AD0DAE1C44DE54BA5F9A8347990C415179FDEB1.png" title="点击放大" width="515.25663"></span></p> <p>这种方案能够精准的控制采样范围，解决了传统PGO依赖业务中存在的统一入口和出口，无法对某一段范围进行精准采样的痛点。</p> <p>毕昇PGO使用和开源LLVM一样，优化流程分为插桩阶段、采集阶段和优化阶段。</p> <p><strong>1. 插桩阶段</strong></p> <p>编译时，需要增加选项：-fprofile-generate=/data/storage/el2/base/files，该路径为沙箱路径，会在其映射路径下产生对应的文件，映射路径为：/data/app/el2/100/base/应用名/files。</p> <p>可以通过检查编译后文件是否有llvm_prf字段或反汇编指令序列来判断是否插装成功。</p> <div _ngcontent-lfm-c106="" class="highlight-div"><div _ngcontent-lfm-c106="" class="highlight-div-header"><div _ngcontent-lfm-c106="" class="highlight-div-header-left"><div _ngcontent-lfm-c106="" class="handle-button expand-button"><div _ngcontent-lfm-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-lfm-c106="" class="highlight-div-header-right"><div _ngcontent-lfm-c106="" class="handle-button ai-button"></div><div _ngcontent-lfm-c106="" class="handle-button line-button"><div _ngcontent-lfm-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-lfm-c106="" class="handle-button theme-button"><div _ngcontent-lfm-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-lfm-c106="" class="handle-button copy-button"><div _ngcontent-lfm-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-lfm-c106="" class="highlight-scroll-div"><pre class="ts prettyprint linenums hljs language-typescript" hw-language="ts" data-highlighted="yes"><ol class="linenums"><li>llvm<span class="">-</span>objdump <span class="">-</span>h xx.<span class="hljs-property">so</span> #检查是否有llvm_prf字段</li><li>llvm<span class="">-</span>objdump <span class="">-</span>d xx.<span class="hljs-property">so</span>  # 看反汇编是否有ldr add store代码序列</li></ol></pre></div></div> <p><strong>2. 采集阶段</strong></p> <p>通过lldb方式进行profile数据采集。</p> <p>编译完成后，在Deveco中用debug模式推送APP包：</p> <p><span><img height="104.59492399999999" originheight="236" originwidth="1149" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211114335.95351734871983387503821917277699:50001231000000:2800:6A6D5E4AEE7BDA2C53D4B038B0820EB2264A6EEB408CDA5C4A3905DD41A71D53.png" title="点击放大" width="509.23478900000003"></span></p> <p>启动后会出现debug窗口，确保是Native的debug模式，未出现则需要修改Deveco的debug Type配置为Native。</p> <p><span><img height="95.852036" originheight="164" originwidth="867" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211114335.40563422823049698278237499284862:50001231000000:2800:B71AD7C5F4C17C540006EBDD56B46DA75DEDFE2565648FAB701CA62A6AB05D45.png" title="点击放大" width="506.73"></span></p> <p><span><img height="170.25622600000003" originheight="295" originwidth="878" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211114335.84614829424315677093512354904992:50001231000000:2800:C7E35F4F86BEBB05937343ED815A224EE5F7FD7F0634AF540CD542367BFEE688.png" title="点击放大" width="506.73"></span></p> <p>启动完成后，找到native debug的lldb位置，需要在lldb中设置参数，保证业务正常运行，不会在debug模式下被一些信号影响（信号一般是程序本身发送）影响数据采集，设置方法为：</p> <p><span><img height="99.089522" originheight="202" originwidth="1033" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211114335.92247716937055793525385357796041:50001231000000:2800:663D1ECB31C0B8C569F91BD51992BDE9EFCA331483647F25A587CAE3867C4C25.png" title="点击放大" width="506.73"></span></p> <p>由于程序没有设置断点，导致程序暂停的原因是信号量，可以屏蔽信号量暂停机制：</p> <p>查看有哪些信号量：</p> <p>(lldb) process handle</p> <p>屏蔽所有信号量暂停效果：</p> <p>(lldb) process handle SIG<span style="color: rgb(154,110,58);">*</span> <span style="color: rgb(154,110,58);">-</span>s false</p> <p>SIG<span style="color: rgb(154,110,58);">*</span>为信号量name, 若要一次性屏蔽所有信号量，则无需指定信号量名。</p> <p>做完上述动作，直接发送信号量：</p> <p>(lldb) process signal SIGUSR2</p> <p>可以在对应的目录(/data/app/el2/100/base/应用进程名/files)找到default*_profile文件，每发送一次信号会产生一次文件。第一次发送采集到的数据为：应用启动到发送信号时间点的数据；第二次发送为：第一次发送信号量到第二次发送信号量期间的数据；以此类推。可以控制发送信号量时间，来采集我们需要场景的数据。 生成的文件没有权限删除，一次应用启动采集到的数据，是同名的，多次生成文件会覆盖，也可以保证采集的数据是目标场景的数据。</p> <p><span><img height="168.57750000000001" originheight="193" originwidth="865" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211114335.15178823970966447674423305149216:50001231000000:2800:C4ABF3425C425DDD1962C5CB32F63649BFD93408CFDA5D921CF43DB1C150D7D5.png" title="点击放大" width="755.541346"></span></p> <p>用hdc将该文件从手机拷贝到电脑上，使用与clang同级目录下的llvm-profdata.exe工具，执行 llvm<span style="color: rgb(154,110,58);">-</span>profdata merge <span style="color: rgb(154,110,58);">--</span>output<span style="color: rgb(154,110,58);">=</span>lib.profdata default_<span style="color: rgb(154,110,58);">*</span>.profraw 得到lib.profdata。</p> <p><strong>3. 优化阶段</strong></p> <p>重新编译，增加编译选项-fprofile-use=lib.profdata, lib.profdata为合并后的配置文件。</p> <p></p> <ul><li><strong>LTO（Link Time Optimization）</strong></li></ul> <p>LTO是一种在链接阶段跨编译单元进行优化的编译器优化手段，旨在提升程序性能。毕昇LTO使用和开源LLVM一样，但是相比开源LLVM在指令预取、inline算法、thin lto funciton import 算法、plt-inline优化等做了增强优化，进一步提升了生成代码的执行效率。</p> <p><strong>1. 优化指导</strong></p> <p>为启用LTO，需在编译阶段添加 -flto 选项。以CMake构建系统为例，可在 CMakeLists.txt 中配置：add_compile_options(-flto)</p> <p><strong>2. 注意事项</strong></p> <p>-flto：默认为full模式，会显著增加编译时长，但性能会更优</p> <p>-flto=thin：可修改为 thin lto 降低编译时长，但性能不及full lto，两者相对平衡</p> <p>若构建时间还显著增加，指定并行任务数加速构建，-flto-jobs=xxx,  xxx根据电脑核数设置</p> <p></p> <ul><li><strong>fp优化</strong></li></ul> <p>fp优化是一组控制浮点运算语义和行为的编译器选项，它用于控制浮点表达式中的运算顺序是否可以被重排或合并，从而达到更高的性能或更强的可预测性。毕昇编译器默认关闭该优化，如果浮点计算场景较多，可以打开该优化</p> <p><strong>1. 优化指导</strong></p> <p>在编译阶段加入 -ffp-contract=on 选项。以CMake构建系统为例，在 CMakeLists.txt 中配置：add_compile_options( -ffp-contract=on)</p> <p></p> </div> </div> <div></div></div>