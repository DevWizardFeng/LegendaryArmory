<h1 _ngcontent-kww-c119="" class="doc-title ng-star-inserted" title="矢量编程"> 矢量编程 </h1>

<div _ngcontent-kww-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;"> <div><div class="tiledSection"><h2 id="section11347102811216">算子实现流程概述<i class="anchor-icon anchor-icon-link" anchorid="section11347102811216" tips="复制节点链接"></i></h2><p>基于AscendC方式实现矢量算子的流程如图1所示。</p> </div> <div class="fignone"><span class="figcap"><b>图1 </b>矢量算子实现流程</span><br><span><img height="219.45000000000002" originheight="217" originwidth="525" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211114257.19637077052786832948546940548032:50001231000000:2800:5363A928C681BE10DFE6E472D9A7846A41569D919D80A5D07DF2F3728E961F08.png" title="点击放大" width="526.6800000000001"></span></div> <ul><li>算子分析：分析算子的数学表达式、输入、输出以及计算逻辑的实现，明确需要调用的AscendC接口。</li><li>核函数定义：定义AscendC算子入口函数。</li><li>根据矢量编程范式实现算子类：完成核函数的内部实现。</li></ul> <p>下文以ElemWise(Add)算子为例，对上述步骤进行详细介绍。本样例中介绍的算子完整代码参见<a href="https://gitcode.com/HarmonyOS_Samples/cannkit_samplecode_add_custom_cpp/blob/master/FrameworkLaunch/AddCustom/op_kernel/add_custom.cpp" target="_blank">add_custom.cpp</a>。</p> <div class="tiledSection"><h3 id="section415174815220" class="firsth2">算子分析<i class="anchor-icon anchor-icon-link" anchorid="section415174815220" tips="复制节点链接"></i></h3><p>在开发算子代码之前需要分析算子的数学表达式、输入、输出以及计算逻辑的实现，明确需要调用的AscendC接口。</p> <ol><li><span>明确算子的数学表达式及计算逻辑。</span><p></p><p>Add算子的数学表达式为：</p> <div _ngcontent-kww-c106="" class="highlight-div"><div _ngcontent-kww-c106="" class="highlight-div-header"><div _ngcontent-kww-c106="" class="highlight-div-header-left"><div _ngcontent-kww-c106="" class="handle-button expand-button"><div _ngcontent-kww-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-kww-c106="" class="highlight-div-header-right"><div _ngcontent-kww-c106="" class="handle-button ai-button"></div><div _ngcontent-kww-c106="" class="handle-button line-button"><div _ngcontent-kww-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-kww-c106="" class="handle-button theme-button"><div _ngcontent-kww-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-kww-c106="" class="handle-button copy-button"><div _ngcontent-kww-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-kww-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li>z = x + y</li></ol></pre></div></div> <p>计算逻辑是：AscendC提供的<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cannkit-vector-calculation-exp">矢量计算</a>接口的操作元素都为LocalTensor，输入数据需要先搬运进片上存储，然后使用计算接口完成两个输入参数相加，得到最终结果，再搬出到外部存储上。AscendC Add算子的计算逻辑如下图所示。</p> <div class="fignone"><span class="figcap"><b>图2 </b>算子计算逻辑</span><br><span><img height="277.97" originheight="274" originwidth="228" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211114257.26863398518245873949352415430194:50001231000000:2800:841E4D0C63D0D457E7F48EAFA75D07D758A8E03A5DE67122F4E3F7E1173AF6F0.png" width="228.76000000000002" class="notEnlarge"></span></div> <p></p></li><li><span>明确输入和输出。</span><p></p><ul><li>Add算子有两个输入：x与y，输出为z。</li><li>本样例中算子的输入支持的数据类型为half(float16)，算子输出的数据类型与输入数据类型相同。</li><li>算子输入支持shape(8，2048)，输出shape与输入shape相同。</li><li>算子输入支持的format为：ND。</li></ul> <p></p></li><li><span>确定核函数名称和参数。</span><p></p><ul><li>开发者可以自定义核函数名称，本样例中核函数命名为add_custom。</li><li>根据对算子输入输出的分析，确定核函数有3个参数x，y，z；x，y为输入在Global Memory上的内存地址，z为输出在Global Memory上的内存地址。</li></ul> <p></p></li><li><span>确定算子实现所需接口。</span><p></p><ul><li>实现涉及外部存储和内部存储间的数据搬运，查看AscendC API参考中的数据搬移接口，需要使用<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cannkit-datacopy">DataCopy</a>来实现数据搬移。</li><li>本样例只涉及矢量计算的加法操作，通过查看AscendC API参考中的<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cannkit-vector-calculation-exp">矢量计算</a>接口定义，初步分析可使用双目指令<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cannkit-add">Add</a>接口实现x+y。</li><li>计算中使用到的Tensor数据结构，使用Queue队列进行管理，会使用到<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cannkit-tque-enque">EnQue</a>、<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cannkit-tque-deque">DeQue</a>等接口。</li></ul> <p>通过以上分析，得到AscendC Add算子的设计规格如下。</p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><caption><b>表1 </b>AscendC Add算子设计规格</caption><tbody><tr><th class="firstcol" id="mcps1.3.5.3.4.2.3.2.6.1.1" valign="top"><p>算子类型（OpType）</p> </th> <td class="cellrowborder" colspan="4" valign="top"><p>Add</p> </td> </tr> <tr><th class="firstcol" id="mcps1.3.5.3.4.2.3.2.6.2.1" rowspan="4" valign="top" width="20%"><p>算子输入输出</p> </th> <td class="cellrowborder" valign="top" width="19.97%"><p><strong>name</strong></p> </td> <td class="cellrowborder" valign="top" width="20.03%"><p><strong>shape</strong></p> </td> <td class="cellrowborder" valign="top" width="20%"><p><strong>data type</strong></p> </td> <td class="cellrowborder" valign="top" width="20%"><p><strong>format</strong></p> </td> </tr> <tr><td class="cellrowborder" valign="top"><p>x（输入）</p> </td> <td class="cellrowborder" valign="top"><p>(8, 2048)</p> </td> <td class="cellrowborder" valign="top"><p>half</p> </td> <td class="cellrowborder" valign="top"><p>ND</p> </td> </tr> <tr><td class="cellrowborder" valign="top"><p>y（输入）</p> </td> <td class="cellrowborder" valign="top"><p>(8, 2048)</p> </td> <td class="cellrowborder" valign="top"><p>half</p> </td> <td class="cellrowborder" valign="top"><p>ND</p> </td> </tr> <tr><td class="cellrowborder" valign="top"><p>z（输出）</p> </td> <td class="cellrowborder" valign="top"><p>(8, 2048)</p> </td> <td class="cellrowborder" valign="top"><p>half</p> </td> <td class="cellrowborder" valign="top"><p>ND</p> </td> </tr> <tr><th class="firstcol" id="mcps1.3.5.3.4.2.3.2.6.6.1" valign="top"><p>核函数名称</p> </th> <td class="cellrowborder" colspan="4" valign="top"><p>add_custom</p> </td> </tr> <tr><th class="firstcol" id="mcps1.3.5.3.4.2.3.2.6.7.1" rowspan="3" valign="top"><p>使用的主要接口</p> </th> <td class="cellrowborder" colspan="4" valign="top"><p>DataCopy：数据搬移接口。</p> </td> </tr> <tr><td class="cellrowborder" colspan="4" valign="top"><p>Add：矢量双目指令接口。</p> </td> </tr> <tr><td class="cellrowborder" colspan="4" valign="top"><p>EnQue、DeQue等接口：Queue队列管理接口。</p> </td> </tr> <tr><th class="firstcol" id="mcps1.3.5.3.4.2.3.2.6.10.1" valign="top"><p>算子实现文件名称</p> </th> <td class="cellrowborder" colspan="4" valign="top"><p>add_custom.cpp</p> </td> </tr>  </tbody></table></div> </div> <p></p></li></ol> </div> <div class="tiledSection"><h3 id="section1716448525">核函数定义<i class="anchor-icon anchor-icon-link" anchorid="section1716448525" tips="复制节点链接"></i></h3><p>根据<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cannkit-kernel-function#section552mcpsimp">核函数定义</a>中介绍的规则进行核函数的定义。</p> <ol><li><span>函数原型定义</span><p></p><p>本样例中，函数名为add_custom（核函数名称可自定义），根据<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cannkit-vector-programming#section415174815220">算子分析</a>中对算子输入输出的分析，确定有3个参数x，y，z，其中x，y为输入内存，z为输出内存。根据<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cannkit-kernel-function#section552mcpsimp">核函数定义</a>核函数的规则介绍，函数原型定义如下所示：使用__global__函数类型限定符来标识它是一个核函数；使用__aicore__函数类型限定符来标识该核函数在设备端aicore上执行；为方便起见，统一使用GM_ADDR宏修饰入参，GM_ADDR宏定义请参考<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cannkit-kernel-function">核函数</a>。</p> <div _ngcontent-kww-c106="" class="highlight-div"><div _ngcontent-kww-c106="" class="highlight-div-header"><div _ngcontent-kww-c106="" class="highlight-div-header-left"><div _ngcontent-kww-c106="" class="handle-button expand-button"><div _ngcontent-kww-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-kww-c106="" class="highlight-div-header-right"><div _ngcontent-kww-c106="" class="handle-button ai-button"></div><div _ngcontent-kww-c106="" class="handle-button line-button"><div _ngcontent-kww-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-kww-c106="" class="handle-button theme-button"><div _ngcontent-kww-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-kww-c106="" class="handle-button copy-button"><div _ngcontent-kww-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-kww-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> <span class="hljs-function">__global__ __aicore__ <span class="hljs-type">void</span> <span class="hljs-title">add_custom</span><span class="hljs-params">(GM_ADDR x, GM_ADDR y, GM_ADDR z)</span> </span></li><li><span class="hljs-function"></span>{ </li><li>}</li></ol></pre></div></div> <p></p></li><li><span>调用算子类的Init和Process函数。</span><p></p><p>算子类的Init函数，完成内存初始化相关工作，Process函数完成算子实现的核心逻辑，具体介绍参见<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cannkit-vector-programming#section1618448324">算子类实现</a>。</p> <div _ngcontent-kww-c106="" class="highlight-div"><div _ngcontent-kww-c106="" class="highlight-div-header"><div _ngcontent-kww-c106="" class="highlight-div-header-left"><div _ngcontent-kww-c106="" class="handle-button expand-button"><div _ngcontent-kww-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-kww-c106="" class="highlight-div-header-right"><div _ngcontent-kww-c106="" class="handle-button ai-button"></div><div _ngcontent-kww-c106="" class="handle-button line-button"><div _ngcontent-kww-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-kww-c106="" class="handle-button theme-button"><div _ngcontent-kww-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-kww-c106="" class="handle-button copy-button"><div _ngcontent-kww-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-kww-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> <span class="hljs-function">__global__ __aicore__ <span class="hljs-type">void</span> <span class="hljs-title">add_custom</span><span class="hljs-params">(GM_ADDR x, GM_ADDR y, GM_ADDR z)</span> </span></li><li><span class="hljs-function"></span>{ </li><li>    KernelAdd op; </li><li>    op.<span class="hljs-built_in">Init</span>(x, y, z); </li><li>    op.<span class="hljs-built_in">Process</span>(); </li><li>}</li></ol></pre></div></div> <p></p></li></ol> </div> <div class="tiledSection"><h3 id="section1618448324">算子类实现<i class="anchor-icon anchor-icon-link" anchorid="section1618448324" tips="复制节点链接"></i></h3><p>根据上一节介绍，核函数中会调用算子类的Init和Process函数，本节具体讲解如何基于编程范式实现算子类。</p> <p>根据矢量编程范式对Add算子的实现流程进行设计的思路如下，矢量编程范式请参考<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cannkit-programming-paradigm#section715mcpsimp">Vector编程范式</a>，设计完成后得到的Add算子实现流程图参见图3：</p> <ul><li>Add算子的实现流程分为3个基本任务：CopyIn，Compute，CopyOut。CopyIn任务负责将Global Memory上的输入Tensor xGm和yGm搬运至Local Memory，分别存储在xLocal，yLocal，Compute任务负责对xLocal，yLocal执行加法操作，计算结果存储在zLocal中，CopyOut任务负责将输出数据从zLocal搬运至Global Memory上的输出Tensor zGm中。</li><li>CopyIn，Compute任务间通过VECIN队列inQueueX，inQueueY进行通信和同步，Compute，CopyOut任务间通过VECOUT队列outQueueZ进行通信和同步。</li><li>任务间交互使用到的内存、临时变量使用到的内存统一使用pipe内存管理对象进行管理。</li></ul> <div class="fignone"><span class="figcap"><b>图3 </b>Add算子实现流程</span><br><span><img height="228.76000000000002" originheight="390" originwidth="907" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211114257.30154526676797513796682315566624:50001231000000:2800:5FF08FFCC739D3DB15DE9631D52D72A926F1045651AA0DFBAF0E4642EE0DDECA.png" title="点击放大" width="526.6800000000001"></span></div> <p>算子类中主要实现上述流程，包含对外开放的初始化Init函数和核心处理函数Process，Process函数中会对上图中的三个基本任务进行调用；同时包括一些算子实现中会用到的私有成员，比如上图中的Global Tensor和VECIN、VECOUT队列等。KernelAdd算子类具体成员如下。</p> <div _ngcontent-kww-c106="" class="highlight-div"><div _ngcontent-kww-c106="" class="highlight-div-header"><div _ngcontent-kww-c106="" class="highlight-div-header-left"><div _ngcontent-kww-c106="" class="handle-button expand-button"><div _ngcontent-kww-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-kww-c106="" class="highlight-div-header-right"><div _ngcontent-kww-c106="" class="handle-button ai-button"></div><div _ngcontent-kww-c106="" class="handle-button line-button"><div _ngcontent-kww-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-kww-c106="" class="handle-button theme-button"><div _ngcontent-kww-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-kww-c106="" class="handle-button copy-button"><div _ngcontent-kww-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-kww-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">class</span> <span class="hljs-title class_">KernelAdd</span> { </li><li><span class="hljs-keyword">public</span>: </li><li>    <span class="hljs-function">__aicore__ <span class="hljs-keyword">inline</span> <span class="hljs-title">KernelAdd</span><span class="hljs-params">()</span> </span>{} </li><li>    <span class="hljs-comment">// Initialization function, which initializes the memory</span></li><li>    <span class="hljs-function">__aicore__ <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Init</span><span class="hljs-params">(GM_ADDR x, GM_ADDR y, GM_ADDR z)</span></span>{} </li><li>    <span class="hljs-comment">// Core processing function, which implements the operator logic and calls the private member functions </span></li><li>    <span class="hljs-comment">// </span><strong><span class="hljs-comment">CopyIn</span></strong><span class="hljs-comment">, </span><strong><span class="hljs-comment">Compute</span></strong><span class="hljs-comment">, and </span><strong><span class="hljs-comment">CopyOut</span></strong><span class="hljs-comment"> to complete the three-stage pipelined execution of the vector operator</span></li><li>    <span class="hljs-function">__aicore__ <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Process</span><span class="hljs-params">()</span></span>{} </li><li> </li><li><span class="hljs-keyword">private</span>: </li><li>    <span class="hljs-comment">// </span><strong><span class="hljs-comment">CopyIn</span></strong><span class="hljs-comment"> function, which completes the processing in the CopyIn phase and is called by the Process function </span></li><li>    <span class="hljs-function">__aicore__ <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">CopyIn</span><span class="hljs-params">(<span class="hljs-type">int32_t</span> progress)</span></span>{} </li><li>    <span class="hljs-comment">// </span><strong><span class="hljs-comment">Compute</span></strong><span class="hljs-comment"> function, which completes the processing in the Compute phase and is called by Process function </span></li><li>    <span class="hljs-function">__aicore__ <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Compute</span><span class="hljs-params">(<span class="hljs-type">int32_t</span> progress)</span></span>{} </li><li>    <span class="hljs-comment">// </span><strong><span class="hljs-comment">CopyOut</span></strong><span class="hljs-comment"> function, which completes the processing in the CopyOut phase and is called by the Process function </span></li><li>    <span class="hljs-function">__aicore__ <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">CopyOut</span><span class="hljs-params">(<span class="hljs-type">int32_t</span> progress)</span></span>{} </li><li> </li><li><span class="hljs-keyword">private</span>: </li><li>    AscendC::TPipe pipe;  <span class="hljs-comment">// Pipe memory management object. </span></li><li>    AscendC::TQue&lt;AscendC::QuePosition::VECIN, <span class="hljs-number">1</span>&gt; inQueueX, inQueueY;  <span class="hljs-comment">// Input data queue management object. QuePosition is VECIN.</span></li><li>    AscendC::TQue&lt;AscendC::QuePosition::VECOUT, <span class="hljs-number">1</span>&gt; outQueueZ;  <span class="hljs-comment">// Output data queue management object. QuePosition is VECOUT. </span></li><li>    AscendC::GlobalTensor&lt;half&gt; xGm;  <span class="hljs-comment">// Object for managing the input and output global memory addresses. xGm and yGm are inputs, and zGm is the output. </span></li><li>    AscendC::GlobalTensor&lt;half&gt; yGm; </li><li>    AscendC::GlobalTensor&lt;half&gt; zGm; </li><li>};</li></ol></pre></div></div> <p>初始化函数主要完成以下内容：</p> <ul><li>设置输入输出Global Tensor的Global Memory内存地址。<p>本样例中使用多核并行计算，即把数据进行分片，分配到多个核上进行处理。AscendC核函数是在一个核上的处理函数，所以只处理部分数据，需要在初始化函数中获取该核函数需要处理的输入输出在Global Memory上的内存偏移地址，并将该偏移地址设置在Global Tensor中。</p> <p>以获取输入x在Global Memory上的内存偏移地址为例：</p> <div _ngcontent-kww-c106="" class="highlight-div"><div _ngcontent-kww-c106="" class="highlight-div-header"><div _ngcontent-kww-c106="" class="highlight-div-header-left"><div _ngcontent-kww-c106="" class="handle-button expand-button"><div _ngcontent-kww-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-kww-c106="" class="highlight-div-header-right"><div _ngcontent-kww-c106="" class="handle-button ai-button"></div><div _ngcontent-kww-c106="" class="handle-button line-button"><div _ngcontent-kww-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-kww-c106="" class="handle-button theme-button"><div _ngcontent-kww-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-kww-c106="" class="handle-button copy-button"><div _ngcontent-kww-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-kww-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li>xGm.<span class="hljs-built_in">SetGlobalBuffer</span>((__gm__ half*)x + BLOCK_LENGTH * <span class="hljs-built_in">GetBlockIdx</span>(), BLOCK_LENGTH);</li></ol></pre></div></div> <p>本样例中的分配方案是：数据整体长度TOTAL_LENGTH为8 * 2048，平均分配到8个核上运行，每个核上处理的数据大小BLOCK_LENGTH为2048字节。x + BLOCK_LENGTH * GetBlockIdx()即为单核处理程序中x在Global Memory上的内存偏移地址，获取偏移地址后，使用<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cannkit-globaltensor">GlobalTensor</a>类的接口设定该核上Global Memory的起始地址以及长度。具体示意图请参考图4。</p> <div class="fignone"><span class="figcap"><b>图4 </b>多核并行处理示意图</span><br><span><img height="133" originheight="246" originwidth="975" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211114257.73696663044675133197004465981771:50001231000000:2800:0A09F19AFCF2B64A1CD530E5AB29D90AA688A27B64B9A1F8E1995B777FD8E017.png" title="点击放大" width="526.6800000000001"></span></div> </li><li>通过Pipe内存管理对象为输入输出Queue分配内存。<p>比如，为输入x的Queue分配内存，可以通过如下代码段实现：</p> <div _ngcontent-kww-c106="" class="highlight-div"><div _ngcontent-kww-c106="" class="highlight-div-header"><div _ngcontent-kww-c106="" class="highlight-div-header-left"><div _ngcontent-kww-c106="" class="handle-button expand-button"><div _ngcontent-kww-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-kww-c106="" class="highlight-div-header-right"><div _ngcontent-kww-c106="" class="handle-button ai-button"></div><div _ngcontent-kww-c106="" class="handle-button line-button"><div _ngcontent-kww-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-kww-c106="" class="handle-button theme-button"><div _ngcontent-kww-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-kww-c106="" class="handle-button copy-button"><div _ngcontent-kww-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-kww-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li>pipe.<span class="hljs-built_in">InitBuffer</span>(inQueueX, BUFFER_NUM, TILE_LENGTH * <span class="hljs-built_in">sizeof</span>(half))</li></ol></pre></div></div> <p>对于单核上的处理数据，可以进行数据切块(Tiling)，在本示例中，将数据切分成8块（并不意味着8块就是性能最优）仅作为参考。切分后的每个数据块再次切分成2块，即可开启double buffer，实现流水线之间的并行。</p> <p>这样单核上的数据（2048个数）被切分成16块，每块TILE_LENGTH(128)个数据。上文代码表示Pipe为inQueueX分配了两块大小为TILE_LENGTH * sizeof(half)个字节的内存块，每个内存块能容纳TILE_LENGTH(128)个half类型数据。数据切分示意图如图5所示。</p> <div class="fignone"><span class="figcap"><b>图5 </b>单核数据切分示意图</span><br><span><img height="182.21" originheight="338" originwidth="963" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211114257.82044028473421153120178245952120:50001231000000:2800:D56EAAFC43CE6BF91749425F4D52CF7AE20BAEB8D954C7F5F59CE169EE961E80.png" title="点击放大" width="526.6800000000001"></span></div> </li></ul> <p>Kirin9020/KirinX90系列处理器支持的核数为1，具体的初始化函数代码如下。</p> <div _ngcontent-kww-c106="" class="highlight-div"><div _ngcontent-kww-c106="" class="highlight-div-header"><div _ngcontent-kww-c106="" class="highlight-div-header-left"><div _ngcontent-kww-c106="" class="handle-button expand-button"><div _ngcontent-kww-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-kww-c106="" class="highlight-div-header-right"><div _ngcontent-kww-c106="" class="handle-button ai-button"></div><div _ngcontent-kww-c106="" class="handle-button line-button"><div _ngcontent-kww-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-kww-c106="" class="handle-button theme-button"><div _ngcontent-kww-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-kww-c106="" class="handle-button copy-button"><div _ngcontent-kww-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-kww-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><strong><span class="hljs-keyword">constexpr</span></strong> <strong><span class="hljs-type">int32_t</span></strong> TOTAL_LENGTH = <span class="hljs-number">8</span> * <span class="hljs-number">2048</span>;                            <span class="hljs-comment">// total length of data </span></li><li><strong><span class="hljs-keyword">constexpr</span></strong> <strong><span class="hljs-type">int32_t</span></strong> USE_CORE_NUM = <span class="hljs-number">1</span>;                                   <span class="hljs-comment">// num of core used </span></li><li><strong><span class="hljs-keyword">constexpr</span></strong> <strong><span class="hljs-type">int32_t</span></strong> BLOCK_LENGTH = TOTAL_LENGTH / USE_CORE_NUM;         <span class="hljs-comment">// length computed of each core </span></li><li><strong><span class="hljs-keyword">constexpr</span></strong> <strong><span class="hljs-type">int32_t</span></strong> TILE_NUM = <span class="hljs-number">8</span>;                                       <span class="hljs-comment">// split data into 8 tiles for each core </span></li><li><strong><span class="hljs-keyword">constexpr</span></strong> <strong><span class="hljs-type">int32_t</span></strong> BUFFER_NUM = <span class="hljs-number">2</span>;                                     <span class="hljs-comment">// tensor num for each queue </span></li><li><strong><span class="hljs-keyword">constexpr</span></strong> <strong><span class="hljs-type">int32_t</span></strong> TILE_LENGTH = BLOCK_LENGTH / TILE_NUM / BUFFER_NUM; <span class="hljs-comment">// separate to 2 parts, due to double buffer </span></li><li><span class="hljs-function">__aicore__ <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Init</span><span class="hljs-params">(GM_ADDR x, GM_ADDR y, GM_ADDR z)</span> </span></li><li><span class="hljs-function"></span>{ </li><li>    <span class="hljs-comment">// get start index for current core, core parallel </span></li><li>    xGm.<span class="hljs-built_in">SetGlobalBuffer</span>((__gm__ half*)x + BLOCK_LENGTH * AscendC::<span class="hljs-built_in">GetBlockIdx</span>(), BLOCK_LENGTH); </li><li>    yGm.<span class="hljs-built_in">SetGlobalBuffer</span>((__gm__ half*)y + BLOCK_LENGTH * AscendC::<span class="hljs-built_in">GetBlockIdx</span>(), BLOCK_LENGTH); </li><li>    zGm.<span class="hljs-built_in">SetGlobalBuffer</span>((__gm__ half*)z + BLOCK_LENGTH * AscendC::<span class="hljs-built_in">GetBlockIdx</span>(), BLOCK_LENGTH); </li><li>    <span class="hljs-comment">// pipe alloc memory to queue, the unit is Bytes </span></li><li>    pipe.<span class="hljs-built_in">InitBuffer</span>(inQueueX, BUFFER_NUM, TILE_LENGTH * <span class="hljs-built_in">sizeof</span>(half)); </li><li>    pipe.<span class="hljs-built_in">InitBuffer</span>(inQueueY, BUFFER_NUM, TILE_LENGTH * <span class="hljs-built_in">sizeof</span>(half)); </li><li>    pipe.<span class="hljs-built_in">InitBuffer</span>(outQueueZ, BUFFER_NUM, TILE_LENGTH * <span class="hljs-built_in">sizeof</span>(half)); </li><li>}</li></ol></pre></div></div> <p>基于矢量编程范式，将核函数的实现分为3个基本任务：CopyIn，Compute，CopyOut。Process函数中通过如下方式调用这三个函数。</p> <div _ngcontent-kww-c106="" class="highlight-div"><div _ngcontent-kww-c106="" class="highlight-div-header"><div _ngcontent-kww-c106="" class="highlight-div-header-left"><div _ngcontent-kww-c106="" class="handle-button expand-button"><div _ngcontent-kww-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-kww-c106="" class="highlight-div-header-right"><div _ngcontent-kww-c106="" class="handle-button ai-button"></div><div _ngcontent-kww-c106="" class="handle-button line-button"><div _ngcontent-kww-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-kww-c106="" class="handle-button theme-button"><div _ngcontent-kww-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-kww-c106="" class="handle-button copy-button"><div _ngcontent-kww-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-kww-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li>    <span class="hljs-function">__aicore__ </span><strong><span class="hljs-function"><span class="hljs-keyword">inline</span></span></strong><span class="hljs-function"> </span><strong><span class="hljs-function"><span class="hljs-type">void</span></span></strong><span class="hljs-function"> <span class="hljs-title">Process</span><span class="hljs-params">()</span> </span></li><li><span class="hljs-function">    </span>{ </li><li>        <span class="hljs-comment">// loop count need to be doubled, due to double buffer </span></li><li>        <strong><span class="hljs-keyword">constexpr</span></strong> <strong><span class="hljs-type">int32_t</span></strong> loopCount = TILE_NUM * BUFFER_NUM; </li><li>        <span class="hljs-comment">// tiling strategy, pipeline parallel </span></li><li>        <strong><span class="hljs-keyword">for</span></strong> (<strong><span class="hljs-type">int32_t</span></strong> i = <span class="hljs-number">0</span>; i &lt; loopCount; i++) { </li><li>            <span class="hljs-built_in">CopyIn</span>(i); </li><li>            <span class="hljs-built_in">Compute</span>(i); </li><li>            <span class="hljs-built_in">CopyOut</span>(i); </li><li>        } </li><li>    }</li></ol></pre></div></div> <p>根据编程范式上面的算法分析，将整个计算拆分成三个Stage，开发者单独编写每个Stage的代码，三阶段流程示意图参见图3，具体流程如下。</p> <ol><li><span>CopyIn函数实现。</span><p></p><ol><li>使用<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cannkit-datacopy">DataCopy</a>接口将GlobalTensor数据拷贝到LocalTensor。</li><li>使用<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cannkit-tque-enque">EnQue</a>将LocalTensor放入VecIn的Queue中。</li></ol> <div _ngcontent-kww-c106="" class="highlight-div"><div _ngcontent-kww-c106="" class="highlight-div-header"><div _ngcontent-kww-c106="" class="highlight-div-header-left"><div _ngcontent-kww-c106="" class="handle-button expand-button"><div _ngcontent-kww-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-kww-c106="" class="highlight-div-header-right"><div _ngcontent-kww-c106="" class="handle-button ai-button"></div><div _ngcontent-kww-c106="" class="handle-button line-button"><div _ngcontent-kww-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-kww-c106="" class="handle-button theme-button"><div _ngcontent-kww-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-kww-c106="" class="handle-button copy-button"><div _ngcontent-kww-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-kww-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-function">__aicore__ </span><strong><span class="hljs-function"><span class="hljs-keyword">inline</span></span></strong><span class="hljs-function"> </span><strong><span class="hljs-function"><span class="hljs-type">void</span></span></strong><span class="hljs-function"> <span class="hljs-title">CopyIn</span><span class="hljs-params">(</span></span><strong><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">int32_t</span></span></span></strong><span class="hljs-function"><span class="hljs-params"> progress)</span> </span></li><li><span class="hljs-function">    </span>{ </li><li>        <span class="hljs-comment">// alloc tensor from queue memory </span></li><li>        AscendC::LocalTensor&lt;half&gt; xLocal = inQueueX.<span class="hljs-built_in">AllocTensor</span>&lt;half&gt;(); </li><li>        AscendC::LocalTensor&lt;half&gt; yLocal = inQueueY.<span class="hljs-built_in">AllocTensor</span>&lt;half&gt;(); </li><li>        <span class="hljs-comment">// copy progress_th tile from global tensor to local tensor </span></li><li>        AscendC::<span class="hljs-built_in">DataCopy</span>(xLocal, xGm[progress * TILE_LENGTH], TILE_LENGTH); </li><li>        AscendC::<span class="hljs-built_in">DataCopy</span>(yLocal, yGm[progress * TILE_LENGTH], TILE_LENGTH); </li><li>        <span class="hljs-comment">// enque input tensors to VECIN queue </span></li><li>        inQueueX.<span class="hljs-built_in">EnQue</span>(xLocal); </li><li>        inQueueY.<span class="hljs-built_in">EnQue</span>(yLocal); </li><li>    }</li></ol></pre></div></div> <p></p></li><li><span>Compute函数实现。</span><p></p><ol><li>使用<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cannkit-tque-deque">DeQue</a>从VecIn中取出LocalTensor。</li><li>使用<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cannkit-add">Add</a>接口完成矢量计算。</li><li>使用<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cannkit-tque-enque">EnQue</a>将计算结果LocalTensor放入到VecOut的Queue中。</li><li>使用<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cannkit-tque-freetensor">FreeTensor</a>释放不再使用的LocalTensor。</li></ol> <div _ngcontent-kww-c106="" class="highlight-div"><div _ngcontent-kww-c106="" class="highlight-div-header"><div _ngcontent-kww-c106="" class="highlight-div-header-left"><div _ngcontent-kww-c106="" class="handle-button expand-button"><div _ngcontent-kww-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-kww-c106="" class="highlight-div-header-right"><div _ngcontent-kww-c106="" class="handle-button ai-button"></div><div _ngcontent-kww-c106="" class="handle-button line-button"><div _ngcontent-kww-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-kww-c106="" class="handle-button theme-button"><div _ngcontent-kww-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-kww-c106="" class="handle-button copy-button"><div _ngcontent-kww-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-kww-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-function">__aicore__ <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Compute</span><span class="hljs-params">(<span class="hljs-type">int32_t</span> progress)</span> </span></li><li><span class="hljs-function"></span>{ </li><li>    <span class="hljs-comment">// deque input tensors from VECIN queue </span></li><li>    AscendC::LocalTensor&lt;half&gt; xLocal = inQueueX.<span class="hljs-built_in">DeQue</span>&lt;half&gt;(); </li><li>    AscendC::LocalTensor&lt;half&gt; yLocal = inQueueY.<span class="hljs-built_in">DeQue</span>&lt;half&gt;(); </li><li>    AscendC::LocalTensor&lt;half&gt; zLocal = outQueueZ.<span class="hljs-built_in">AllocTensor</span>&lt;half&gt;(); </li><li>    <span class="hljs-comment">// call Add instr for computation </span></li><li>    AscendC::<span class="hljs-built_in">Add</span>(zLocal, xLocal, yLocal, TILE_LENGTH); </li><li>    <span class="hljs-comment">// enque the output tensor to VECOUT queue </span></li><li>    outQueueZ.<span class="hljs-built_in">EnQue</span>&lt;half&gt;(zLocal); </li><li>    <span class="hljs-comment">// free input tensors for reuse </span></li><li>    inQueueX.<span class="hljs-built_in">FreeTensor</span>(xLocal); </li><li>    inQueueY.<span class="hljs-built_in">FreeTensor</span>(yLocal); </li><li>}</li></ol></pre></div></div> <p></p></li><li><span>CopyOut函数实现。</span><p></p><ol><li>使用<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cannkit-tque-deque">DeQue</a>接口从VecOut的Queue中取出LocalTensor。</li><li>使用<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cannkit-datacopy">DataCopy</a>接口将LocalTensor拷贝到GlobalTensor上。</li><li>使用<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/cannkit-tque-freetensor">FreeTensor</a>将不再使用的LocalTensor进行回收。</li></ol> <div _ngcontent-kww-c106="" class="highlight-div"><div _ngcontent-kww-c106="" class="highlight-div-header"><div _ngcontent-kww-c106="" class="highlight-div-header-left"><div _ngcontent-kww-c106="" class="handle-button expand-button"><div _ngcontent-kww-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-kww-c106="" class="highlight-div-header-right"><div _ngcontent-kww-c106="" class="handle-button ai-button"></div><div _ngcontent-kww-c106="" class="handle-button line-button"><div _ngcontent-kww-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-kww-c106="" class="handle-button theme-button"><div _ngcontent-kww-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-kww-c106="" class="handle-button copy-button"><div _ngcontent-kww-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-kww-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li> <span class="hljs-function">__aicore__ <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">CopyOut</span><span class="hljs-params">(<span class="hljs-type">int32_t</span> progress)</span> </span></li><li><span class="hljs-function"></span>{ </li><li>    <span class="hljs-comment">// deque output tensor from VECOUT queue </span></li><li>    AscendC::LocalTensor&lt;half&gt; zLocal = outQueueZ.<span class="hljs-built_in">DeQue</span>&lt;half&gt;(); </li><li>    <span class="hljs-comment">// copy progress_th tile from local tensor to global tensor </span></li><li>    AscendC::<span class="hljs-built_in">DataCopy</span>(zGm[progress * TILE_LENGTH], zLocal, TILE_LENGTH); </li><li>    <span class="hljs-comment">// free output tensor for reuse </span></li><li>    outQueueZ.<span class="hljs-built_in">FreeTensor</span>(zLocal); </li><li>}</li></ol></pre></div></div> <p></p></li></ol> </div> <div class="tiledSection"><h3 id="section1487mcpsimp">运行验证<i class="anchor-icon anchor-icon-link" anchorid="section1487mcpsimp" tips="复制节点链接"></i></h3><p>核函数即算子kernel程序开发完成后，即可编写host侧的核函数调用程序，实现从host侧的APP程序调用算子，进行运行验证。</p> </div> </div> <div></div></div>