<h1 _ngcontent-odm-c119="" class="doc-title ng-star-inserted" title="稳定性相关问题汇总"> 稳定性相关问题汇总 </h1>

<div _ngcontent-odm-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;"> <div> <div class="tiledSection"><h2 id="应用运行过程中出现高概率闪退怎么进行定位解决">应用运行过程中出现高概率闪退怎么进行定位解决<i class="anchor-icon anchor-icon-link" anchorid="应用运行过程中出现高概率闪退怎么进行定位解决" tips="复制节点链接"></i></h2><ul><li><p>具体问题：在使用Node-API开发过程中，应用运行过程中出现高概率闪退，出现cppcrash栈，栈顶为系统库libark_jsruntime.so，崩溃栈前几帧也有libace_napi.z.so，怎么进行定位解决？</p> <p>复现概率高，每次崩溃栈略有区别，但是共性都是：崩溃栈顶是系统库的libark_jsruntime.so或者libace_napi.z.so</p> </li><li>崩溃信息如下：</li></ul> <div _ngcontent-odm-c106="" class="highlight-div"><div _ngcontent-odm-c106="" class="highlight-div-header"><div _ngcontent-odm-c106="" class="highlight-div-header-left"><div _ngcontent-odm-c106="" class="handle-button expand-button"><div _ngcontent-odm-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-odm-c106="" class="highlight-div-header-right"><div _ngcontent-odm-c106="" class="handle-button ai-button"></div><div _ngcontent-odm-c106="" class="handle-button line-button"><div _ngcontent-odm-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-odm-c106="" class="handle-button theme-button"><div _ngcontent-odm-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-odm-c106="" class="handle-button copy-button"><div _ngcontent-odm-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-odm-c106="" class="highlight-scroll-div"><pre class="sh prettyprint linenums hljs language-bash" hw-language="sh" data-highlighted="yes"><ol class="linenums"><li>Reason:Signal:SIGSEGV(SEGV_MAPERR)@0x00000136 probably caus</li><li>Fault thread info:</li><li>Tid:15894, Name:e.myapplication</li><li><span class="hljs-comment">#00 pc 002b8dd4 /system/lib/platformsdk/libark_jsruntime.so</span></li><li><span class="hljs-comment">#01 pc 0024d3e1 /system/lib/platformsdk/libark_jsruntime.so</span></li><li><span class="hljs-comment">#02 pc 0024d0d9 /system/lib/platformsdk/libark_jsruntime.so</span></li><li><span class="hljs-comment">#03 pc 002eac5d /system/lib/platformsdk/libark_jsruntime.so</span></li><li><span class="hljs-comment">#04 pc 00428d0f /system/lib/platformsdk/libark_jsruntime.so</span></li></ol></pre></div></div> <ul><li><p>定位问题：</p> <p>使用Node-API时如果出现高概率闪退，崩溃栈顶在系统库libark_jsruntime.so，一般是开发者Node-API接口使用不当导致。</p> </li><li>以下定位问题的思路，可作为参考：</li></ul> <ol><li><p>排查是否存在多线程安全问题（概率较大）。</p> <p>DevEco Studio中提供了相关开关，开启开关后，重新编译打包并运行，看看崩溃栈是不是符合下面这个文档的描述，如果是，那就是在使用Node-API时，存在多线程安全问题。</p> <p><a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-ark-runtime-detection#section19357830121120" target="_blank">常见多线程安全问题</a></p> <p>DevEco Studio开关：</p> <p><span><img originheight="257" originwidth="689" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211114338.57088532079040189482346547072814:50001231000000:2800:DD2609311FD2EF520D71F1D37E68278310870CACDDC23D054C274AF9C46A8D9E.png" width="689" height="257"></span></p> </li><li>使用Node-API接口时入参非法导致。</li></ol> <ul><li><p>这种情况一般是崩溃栈上的so会很浅，so调用了某个具体的Node-API接口，比如调用了napi_call_function之类的接口，然后Node-API又调到了libark_jsruntime的so，然后直接崩溃在libark_jsruntime里面。</p> <p>示例栈结构如下。</p> </li></ul> <div _ngcontent-odm-c106="" class="highlight-div"><div _ngcontent-odm-c106="" class="highlight-div-header"><div _ngcontent-odm-c106="" class="highlight-div-header-left"><div _ngcontent-odm-c106="" class="handle-button expand-button"><div _ngcontent-odm-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-odm-c106="" class="highlight-div-header-right"><div _ngcontent-odm-c106="" class="handle-button ai-button"></div><div _ngcontent-odm-c106="" class="handle-button line-button"><div _ngcontent-odm-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-odm-c106="" class="handle-button theme-button"><div _ngcontent-odm-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-odm-c106="" class="handle-button copy-button"><div _ngcontent-odm-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-odm-c106="" class="highlight-scroll-div"><pre class="sh prettyprint linenums hljs language-bash" hw-language="sh" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">#01 /system/lib/platformsdk/libark_jsruntime.so</span></li><li><span class="hljs-comment">#02 /system/lib/platformsdk/libark_jsruntime.so</span></li><li><span class="hljs-comment">#03 /system/lib/platformsdk/libace_napi.z.so(napi_set_named_property+170) -- Node-API的so，该位置显示具体调用报错的接口</span></li><li><span class="hljs-comment">#04 /data/storage/el1/bundle/libs/arm/libentry.so -- 你的so</span></li></ol></pre></div></div> <ul><li><p>如果是入参问题，一般so在崩溃栈上的位置比较浅（不会跑到#10这种离栈顶很远的位置），不过也可以按照这个思路进行排查。</p>  </li><li><p>排查思路参考：</p> <p>a. 排查有没有napi_value未初始化，还没赋值成功，直接作为非法入参传递给接口了。</p> <p>b. 排查有没有在这个易错API列表里面找到相应的篇章。</p>  <p>可参考文档：</p> <p><a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-coding-standard-api#section1219614634615" target="_blank">方舟运行时API</a></p>  </li></ul> </div>  <div class="tiledSection"><h2 id="线程池中并发调用arkts方法如何处理线程安全问题">线程池中并发调用ArkTS方法如何处理线程安全问题<i class="anchor-icon anchor-icon-link" anchorid="线程池中并发调用arkts方法如何处理线程安全问题" tips="复制节点链接"></i></h2><ul><li>现有个场景，ArkTS中有个类方法，对这个方法创建了napi_ref引用，现想在C++线程池中并发的调用ArkTS方法，有以下几个问题：</li></ul> <ol><li>可以在C++创建的线程池中调用napi_ref缓存的ArkTS类方法吗？</li><li>回调到ArkTS要怎么确保线程安全？</li></ol> <p>对于问题一：</p> <p>只能在C++线程中将ArkTS任务抛回ArkTS线程，这时候并不是同步调用，而是一个抛任务的动作。</p> <p>需要注意的是，这个ArkTS方法真正的执行动作只能在ArkTS线程中完成，即，只能方法运行在对应的ArkTS线程上。</p> <p>对于问题二：</p> <p>上面提到，C++线程都是抛任务到ArkTS线程，进而执行ArkTS方法。关于线程安全，可参考<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/use-napi-thread-safety">使用Node-API接口进行线程安全开发</a>。</p> <p>另外，开发过程中也可以打开<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-ark-runtime-detection#section75786272088" target="_blank">方舟多线程检测</a>开关，这个开关可以拦截多线程安全问题。</p> </div>  <div class="tiledSection"><h2 id="napi_value内容产生变化">napi_value内容产生变化<i class="anchor-icon anchor-icon-link" anchorid="napi_value内容产生变化" tips="复制节点链接"></i></h2><ul><li><p>具体描述：在一个程序初始化的时候，保存了env和一个method（napi_value），这个method在刚刚创建的时候有进行check，napi_typeof的结果是napi_function，符合预期。程序运行一段时间后，使用保存的env和method再去调用，发现method check不过了，此时不是一个napi_function了，保存与使用时均处于同一主线程，要如何解决？</p>  </li><li><p>排查建议：</p>  </li></ul> <ol><li><p>确认是否napi_value出了scope还在使用，导致use-after-scope问题。</p> <p>可参考文档：</p> <p><a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-coding-standard-api#section1219614634615" target="_blank">方舟运行时API</a></p> </li><li>保存时建议使用napi_ref，而不是直接保存napi_value。</li></ol> </div>  <div class="tiledSection"><h2 id="是否存在获取最新napi_env的方法">是否存在获取最新napi_env的方法<i class="anchor-icon anchor-icon-link" anchorid="是否存在获取最新napi_env的方法" tips="复制节点链接"></i></h2><ul><li>具体描述：Native 层在较深的调用层级中需调用 ArkTS 方法，无法逐层传递 napi_env，直接缓存会导致崩溃。</li></ul> <div _ngcontent-odm-c106="" class="highlight-div"><div _ngcontent-odm-c106="" class="highlight-div-header"><div _ngcontent-odm-c106="" class="highlight-div-header-left"><div _ngcontent-odm-c106="" class="handle-button expand-button"><div _ngcontent-odm-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-odm-c106="" class="highlight-div-header-right"><div _ngcontent-odm-c106="" class="handle-button ai-button"></div><div _ngcontent-odm-c106="" class="handle-button line-button"><div _ngcontent-odm-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-odm-c106="" class="handle-button theme-button"><div _ngcontent-odm-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-odm-c106="" class="handle-button copy-button"><div _ngcontent-odm-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-odm-c106="" class="highlight-scroll-div"><pre class="sh prettyprint linenums hljs language-bash" hw-language="sh" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">#00 /system/lib/platformsdk/libark_jsruntime.so(panda::JSValueRef::IsFunction)</span></li><li><span class="hljs-comment">#01 /system/lib/platformsdk/libace_napi.z.so(napi_call_function)</span></li><li><span class="hljs-comment">#02 /data/storage/el1/bundle/libs/arm/libentry.so</span></li><li>...</li></ol></pre></div></div> <ul><li>参考方案：</li></ul> <ol><li><p>关于保存napi_env：</p> <p>Node-API没有提供直接获取napi_env的能力，只能通过逐层函数调用传递。一般不推荐保存napi_env，有两个原因：</p> <p>其一，napi_env退出时候如果没有被使用方感知到，很容易出现use-after-free问题；</p> <p>其二，napi_env和ArkTS线程是强绑定的，如果napi_env放在其它ArkTS线程使用，就会有多线程安全问题。</p> <p>可参考文档：</p> <p><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-73" target="_blank">napi_env禁止缓存的原因是什么</a></p>  </li><li><p>该问题的关键在于：</p> <p>如果要强行保存env，必须感知env是否退出，可以使用napi_add_env_cleanup_hook的回调进行感知。同时，在开发过程中打开多线程检测开关，避免出现多线程安全问题。</p> <p>可参考<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-ark-runtime-detection#section19357830121120" target="_blank">常见多线程安全问题</a></p>  </li><li><p>对于崩溃问题本身，该崩溃可能发生在调用napi_call_function时，入参 func 有问题，即非法入参，开发者可排查napi_value是否被缓存。这种情况可能是napi_value被缓存后，napi_value超出napi_handle_scope作用域导致失效。</p> <p>如果有类似逻辑，需使用napi_ref进行存储，napi_ref可以延长生命周期。</p>  </li></ol> <ul><li><p>可参考文档：</p> <p><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/use-napi-life-cycle">napi_create_reference、napi_delete_reference</a></p> <p><a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-coding-standard-api#section1219614634615" target="_blank">方舟运行时API</a></p> </li></ul> </div>  <div class="tiledSection"><h2 id="napi_add_env_cleanup_hook调用报错该如何处理">napi_add_env_cleanup_hook调用报错该如何处理<i class="anchor-icon anchor-icon-link" anchorid="napi_add_env_cleanup_hook调用报错该如何处理" tips="复制节点链接"></i></h2><ul><li><p>具体问题：napi_add_env_cleanup_hook/napi_remove_env_cleanup_hook调用报错，该如何处理？</p> <p>napi_add_env_cleanup_hook 和 napi_remove_env_cleanup_hook 调用报错，常见原因和特征日志如下，均为接口使用不当导致。</p> </li></ul> <ol><li>在env所在的ArkTS线程外使用上述两个接口，导致多线程安全问题。特征报错日志current napi interface cannot run in multi-thread。</li><li>调用napi_add_env_cleanup_hook时，重复使用同一个args注册不同的回调函数，导致后续注册失败问题。该接口第三个入参args是作为接口内部map的key值，当重复注册同一个args的回调时，后续注册动作将会失败，仅第一次注册才会成功。注册失败可能导致后续业务功能异常或崩溃。特征报错日志AddCleanupHook Failed。</li><li>调用napi_remove_env_cleanup_hook时，尝试通过一个不存在（或已被删除）的args删除回调函数，该接口调用失败，出现特征报错日志RemoveCleanupHook Failed。</li></ol> <p>常见错误场景示例如下：</p> <div _ngcontent-odm-c106="" class="highlight-div"><div _ngcontent-odm-c106="" class="highlight-div-header"><div _ngcontent-odm-c106="" class="highlight-div-header-left"><div _ngcontent-odm-c106="" class="handle-button expand-button"><div _ngcontent-odm-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-odm-c106="" class="highlight-div-header-right"><div _ngcontent-odm-c106="" class="handle-button ai-button"></div><div _ngcontent-odm-c106="" class="handle-button line-button"><div _ngcontent-odm-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-odm-c106="" class="handle-button theme-button"><div _ngcontent-odm-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-odm-c106="" class="handle-button copy-button"><div _ngcontent-odm-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-odm-c106="" class="highlight-scroll-div"><pre class="prettyprint linenums hljs language-scss" data-highlighted="yes"><ol class="linenums"><li>void <span class="hljs-built_in">AddEnvCleanupHook</span>(napi_env env)</li><li>{</li><li>    <span class="hljs-built_in">napi_add_env_cleanup_hook</span>(env, [](void* args) -&gt; void {</li><li>        <span class="hljs-comment">// cleanup function回调</span></li><li>    }, env); <span class="hljs-comment">// env是个通用的数据，即使此处没有重复注册，可能会被其它地方所提前注册，导致该处注册失败。</span></li><li>}</li><li>
</li><li>static napi_value <span class="hljs-built_in">Test</span>(napi_env env, napi_callback_info info)</li><li>{</li><li>    <span class="hljs-comment">//第一次注册</span></li><li>    <span class="hljs-built_in">AddEnvCleanupHook</span>(env);</li><li>    <span class="hljs-comment">//第二次重复注册</span></li><li>    <span class="hljs-built_in">AddEnvCleanupHook</span>(env);</li><li>    return nullptr;</li><li>}</li></ol></pre></div></div> <ul><li>修复建议：</li></ul> <ol><li>对于多线程安全问题，需确保调用接口的线程在env所在的ArkTS线程上。</li><li>对于注册失败的问题，需由使用者明确待注册的函数。需要保证key值（也就是napi_add_env_cleanup_hook的第三个入参）是唯一的即可。</li><li>对于删除失败的问题，需要使用者确保args已注册过且未被删除。</li></ol> <p>相关参考资料链接：</p> <p><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/use-napi-about-cleanuphook">使用Node-API接口注册和使用环境清理钩子</a></p> <p><a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-coding-standard-api#section1219614634615" target="_blank">方舟运行时API</a></p> </div>  <div class="tiledSection"><h2 id="napi_open_handle_scope与napi_close_handle_scope进行生命周期相关开发典型错误场景">napi_open_handle_scope与napi_close_handle_scope进行生命周期相关开发典型错误场景<i class="anchor-icon anchor-icon-link" anchorid="napi_open_handle_scope与napi_close_handle_scope进行生命周期相关开发典型错误场景" tips="复制节点链接"></i></h2><ul><li><p>具体问题：使用napi_open_handle_scope与napi_close_handle_scope接口管理ArkTS对象时出现稳定性问题，该如何处理？</p> <p>napi_open_handle_scope 和 napi_close_handle_scope 调用出现稳定性问题，常见原因如下，均为接口使用不当导致。</p> </li></ul> <ol><li>未配对使用napi_open_handle_scope 和 napi_close_handle_scope，只打开了一个scope而没有关闭，会导致内存泄漏，且可能触发程序崩溃。</li><li>未按照与打开scope顺序相反的顺序关闭scope，可能引发踩内存问题。在例如open_scope1，open_scope2，close_scope1，close_scope2这种场景下，close_scope1之后指针返回，极有可能覆写scope2中的内存造成踩内存问题。</li><li>在native方法中创建的scope未在该方法返回之前被关闭，导致函数重入时scope配对混乱，发生稳定性问题。</li></ol> <p>常见错误场景示例如下：</p> <div _ngcontent-odm-c106="" class="highlight-div"><div _ngcontent-odm-c106="" class="highlight-div-header"><div _ngcontent-odm-c106="" class="highlight-div-header-left"><div _ngcontent-odm-c106="" class="handle-button expand-button"><div _ngcontent-odm-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-odm-c106="" class="highlight-div-header-right"><div _ngcontent-odm-c106="" class="handle-button ai-button"></div><div _ngcontent-odm-c106="" class="handle-button line-button"><div _ngcontent-odm-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-odm-c106="" class="handle-button theme-button"><div _ngcontent-odm-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-odm-c106="" class="handle-button copy-button"><div _ngcontent-odm-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-odm-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"napi/native_api.h"</span></span></li><li><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hilog/log.h&gt;</span></span></li><li>
</li><li><span class="hljs-comment">// 1. 全局Scope</span></li><li><span class="hljs-type">static</span> napi_handle_scope g_globalScope = <span class="hljs-literal">nullptr</span>;</li><li>
</li><li><span class="hljs-function"><span class="hljs-type">static</span> napi_value <span class="hljs-title">CallFunction</span><span class="hljs-params">(napi_env env, napi_callback_info info)</span> </span>{</li><li>    <span class="hljs-type">size_t</span> argc = <span class="hljs-number">1</span>;</li><li>    napi_value argv[<span class="hljs-number">1</span>] = {<span class="hljs-literal">nullptr</span>};</li><li>    <span class="hljs-built_in">napi_get_cb_info</span>(env, info, &amp;argc, argv, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);</li><li>    </li><li>    napi_valuetype type = napi_undefined;</li><li>    <span class="hljs-keyword">if</span> (argv[<span class="hljs-number">0</span>] == <span class="hljs-literal">nullptr</span> || <span class="hljs-built_in">napi_typeof</span>(env, argv[<span class="hljs-number">0</span>], &amp;type) != napi_ok || type != napi_function) {</li><li>        <span class="hljs-built_in">OH_LOG_INFO</span>(LOG_APP, <span class="hljs-string">"JS函数参数非法"</span>);</li><li>        napi_value errRet = <span class="hljs-literal">nullptr</span>;</li><li>        <span class="hljs-built_in">napi_create_int32</span>(env, <span class="hljs-number">-1</span>, &amp;errRet);</li><li>        <span class="hljs-keyword">return</span> errRet;</li><li>    }</li><li>
</li><li>    <span class="hljs-keyword">if</span> (!g_globalScope) {</li><li>        <span class="hljs-built_in">OH_LOG_INFO</span>(LOG_APP, <span class="hljs-string">"【首次调用】全局Scope为空，执行open"</span>);</li><li>        <span class="hljs-built_in">napi_open_handle_scope</span>(env, &amp;g_globalScope);</li><li>        <span class="hljs-comment">// 首次调用：执行JS函数</span></li><li>        napi_value global = <span class="hljs-literal">nullptr</span>;</li><li>        <span class="hljs-built_in">napi_get_global</span>(env, &amp;global);</li><li>        napi_value result = <span class="hljs-literal">nullptr</span>;</li><li>        <span class="hljs-built_in">napi_call_function</span>(env, global, argv[<span class="hljs-number">0</span>], argc, argv, &amp;result);</li><li>        <span class="hljs-keyword">return</span> result; <span class="hljs-comment">// 首次调用直接返回，不执行后续close逻辑</span></li><li>    } <span class="hljs-keyword">else</span> {</li><li>        <span class="hljs-comment">// 重入调用：直接返回固定值 + 关闭Scope</span></li><li>        napi_value result = <span class="hljs-literal">nullptr</span>;</li><li>        <span class="hljs-built_in">napi_create_int32</span>(env, <span class="hljs-number">10</span>, &amp;result);</li><li>        <span class="hljs-built_in">OH_LOG_INFO</span>(LOG_APP, <span class="hljs-string">"【重入调用】全局Scope非空，执行close"</span>);</li><li>        <span class="hljs-built_in">napi_close_handle_scope</span>(env, g_globalScope);</li><li>        g_globalScope = <span class="hljs-literal">nullptr</span>;</li><li>        <span class="hljs-keyword">return</span> result;</li><li>    }</li><li>}</li></ol></pre></div></div> <p>接口声明</p> <div _ngcontent-odm-c106="" class="highlight-div"><div _ngcontent-odm-c106="" class="highlight-div-header"><div _ngcontent-odm-c106="" class="highlight-div-header-left"><div _ngcontent-odm-c106="" class="handle-button expand-button"><div _ngcontent-odm-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-odm-c106="" class="highlight-div-header-right"><div _ngcontent-odm-c106="" class="handle-button ai-button"></div><div _ngcontent-odm-c106="" class="handle-button line-button"><div _ngcontent-odm-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-odm-c106="" class="handle-button theme-button"><div _ngcontent-odm-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-odm-c106="" class="handle-button copy-button"><div _ngcontent-odm-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-odm-c106="" class="highlight-scroll-div"><pre class="ts prettyprint linenums hljs language-typescript" hw-language="ts" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// index.d.ts</span></li><li><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> callFunction : <span class="hljs-function">(<span class="hljs-params">func : <span class="hljs-built_in">Function</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;</li></ol></pre></div></div> <p>ArkTS侧示例代码</p> <div _ngcontent-odm-c106="" class="highlight-div"><div _ngcontent-odm-c106="" class="highlight-div-header"><div _ngcontent-odm-c106="" class="highlight-div-header-left"><div _ngcontent-odm-c106="" class="handle-button expand-button"><div _ngcontent-odm-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-odm-c106="" class="highlight-div-header-right"><div _ngcontent-odm-c106="" class="handle-button ai-button"></div><div _ngcontent-odm-c106="" class="handle-button line-button"><div _ngcontent-odm-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-odm-c106="" class="handle-button theme-button"><div _ngcontent-odm-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-odm-c106="" class="handle-button copy-button"><div _ngcontent-odm-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-odm-c106="" class="highlight-scroll-div"><pre class="ts prettyprint linenums hljs language-typescript" hw-language="ts" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">import</span> { hilog } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.PerformanceAnalysisKit'</span>;</li><li><span class="hljs-keyword">import</span> testNapi <span class="hljs-keyword">from</span> <span class="hljs-string">'libentry.so'</span>;</li><li>
</li><li><span class="hljs-keyword">function</span> <span class="hljs-title function_">reenterFunc</span>(<span class="hljs-params">count = <span class="hljs-number">1</span></span>) : <span class="hljs-built_in">void</span>{</li><li>  hilog.<span class="hljs-title function_">info</span>(<span class="hljs-number">0x0000</span>, <span class="hljs-string">'testTag'</span>, <span class="hljs-string">`【JS侧】递归`</span>);</li><li>  <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>) {</li><li>    <span class="hljs-keyword">return</span>;</li><li>  }</li><li>  testNapi.<span class="hljs-title function_">callFunction</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">reenterFunc</span>(count - <span class="hljs-number">1</span>));</li><li>  hilog.<span class="hljs-title function_">info</span>(<span class="hljs-number">0x0000</span>, <span class="hljs-string">'testTag'</span>, <span class="hljs-string">`【JS侧】重入调用`</span>);</li><li>  <span class="hljs-keyword">return</span>;</li><li>}</li><li>
</li><li><span class="hljs-keyword">try</span> {</li><li>  testNapi.<span class="hljs-title function_">callFunction</span>(reenterFunc);</li><li>  hilog.<span class="hljs-title function_">info</span>(<span class="hljs-number">0x0000</span>, <span class="hljs-string">'testTag'</span>, <span class="hljs-string">'【执行完成】'</span>);</li><li>} <span class="hljs-keyword">catch</span> (error) {</li><li>  hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x0000</span>, <span class="hljs-string">'testTag'</span>, <span class="hljs-string">`调用错误：<span class="hljs-subst">${error.message}</span>`</span>);</li><li>}</li></ol></pre></div></div> <p>CMakeLists.txt</p> <div _ngcontent-odm-c106="" class="highlight-div"><div _ngcontent-odm-c106="" class="highlight-div-header"><div _ngcontent-odm-c106="" class="highlight-div-header-left"><div _ngcontent-odm-c106="" class="handle-button expand-button"><div _ngcontent-odm-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-odm-c106="" class="highlight-div-header-right"><div _ngcontent-odm-c106="" class="handle-button ai-button"></div><div _ngcontent-odm-c106="" class="handle-button line-button"><div _ngcontent-odm-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-odm-c106="" class="handle-button theme-button"><div _ngcontent-odm-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-odm-c106="" class="handle-button copy-button"><div _ngcontent-odm-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-odm-c106="" class="highlight-scroll-div"><pre class="text prettyprint linenums hljs language-plaintext" hw-language="text" data-highlighted="yes"><ol class="linenums"><li>cmake_minimum_required(VERSION 3.5.0)</li><li>project(Test)</li><li>
</li><li>set(NATIVERENDER_ROOT_PATH ${CMAKE_CURRENT_SOURCE_DIR})</li><li>
</li><li>if(DEFINED PACKAGE_FIND_FILE)</li><li>    include(${PACKAGE_FIND_FILE})</li><li>endif()</li><li>
</li><li>include_directories(${NATIVERENDER_ROOT_PATH}</li><li>                    ${NATIVERENDER_ROOT_PATH}/include)</li><li>
</li><li>add_library(entry SHARED napi_init.cpp)</li><li>add_definitions( "-DLOG_DOMAIN=0xd0d0" )</li><li>add_definitions( "-DLOG_TAG=\"testTag\"" )</li><li>target_link_libraries(entry PUBLIC libace_napi.z.so libhilog_ndk.z.so)</li></ol></pre></div></div> <ul><li>修复建议：</li></ul> <ol><li>napi_open_handle_scope和napi_close_handle_scope必须配对使用，开发者应当自查。</li><li>所有的scope必须按照与打开顺序相反的顺序关闭。</li><li>在native方法中创建的所有scope必须在该方法返回之前被关闭。</li></ol> <p>相关参考资料链接：</p> <p><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/use-napi-life-cycle#napi_open_handle_scopenapi_close_handle_scope" target="_blank">使用Node-API接口进行生命周期相关开发</a></p> </div> </div> <div></div></div>