<h1 _ngcontent-cln-c119="" class="doc-title ng-star-inserted" title="线性容器"> 线性容器 </h1>

<div _ngcontent-cln-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;">   <div>    <p>线性容器实现能按顺序访问的数据结构，其底层主要通过数组实现，包括ArrayList、Vector、List、LinkedList、Deque、Queue和Stack。</p>    <p>线性容器优化了数据访问速度，运行时（Runtime）通过一条字节码指令即可完成增、删、改、查等操作。</p>    <div class="tiledSection">     <h2 id="各线性容器类型特征对比">各线性容器类型特征对比<i class="anchor-icon anchor-icon-link" anchorid="各线性容器类型特征对比" tips="复制节点链接"></i></h2>          <div class="tablenoborder">      <div class="tbBox"><table class="layoutFixed idpTab">       <thead>        <tr>         <th align="left" class="cellrowborder" id="mcps1.3.3.2.1.3.1.1" valign="top" width="50%">类名</th>         <th align="left" class="cellrowborder" id="mcps1.3.3.2.1.3.1.2" valign="top" width="50%">特征及建议使用场景</th>        </tr>       </thead>               <tbody><tr>         <td class="cellrowborder" valign="top" width="50%">ArrayList</td>         <td class="cellrowborder" valign="top" width="50%">动态数组，占用一片连续的内存空间。需要频繁读取元素时推荐使用。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="50%">List</td>         <td class="cellrowborder" valign="top" width="50%">单向链表，占用的空间可以不连续。推荐在需要频繁插入和删除元素，且需要使用单向链表时使用。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="50%">LinkedList</td>         <td class="cellrowborder" valign="top" width="50%">双向链表，占用的空间可以不连续。推荐在需要频繁插入和删除元素，且需要使用双向链表时使用。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="50%">Deque</td>         <td class="cellrowborder" valign="top" width="50%">双端队列，支持从头尾两端进行元素的插入和删除操作，占用连续的内存空间。推荐在需要频繁访问和操作头尾元素时使用。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="50%">Queue</td>         <td class="cellrowborder" valign="top" width="50%">队列，是一种从尾部插入元素、从头部移除元素的数据结构，占用连续的内存空间，适用于先进先出的场景。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="50%">Stack</td>         <td class="cellrowborder" valign="top" width="50%">栈，只能从一端进行插入和删除操作，占用连续的内存空间。适用于先进后出的场景。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="50%">Vector</td>         <td class="cellrowborder" valign="top" width="50%">动态数组，占用连续的内存空间。已不再维护，推荐使用ArrayList。</td>        </tr>             </tbody></table></div>     </div>    </div>    <div class="tiledSection">     <h2 id="arraylist">ArrayList<i class="anchor-icon anchor-icon-link" anchorid="arraylist" tips="复制节点链接"></i></h2>          <p><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arraylist" target="_blank">ArrayList</a>即动态数组，可用来构造全局的数组对象。需要频繁读取集合元素时，推荐使用ArrayList。</p>     <p>ArrayList依据泛型定义，存储位置为连续的内存空间，初始容量为10，支持动态扩容，每次扩容为原始容量的1.5倍。</p>     <p>ArrayList支持增、删、改、查操作，常用API如下：</p>     <div class="tablenoborder">      <div class="tbBox"><table class="layoutFixed idpTab">       <thead>        <tr>         <th align="left" class="cellrowborder" id="mcps1.3.4.5.1.4.1.1" valign="top" width="33.33333333333333%">操作</th>         <th align="left" class="cellrowborder" id="mcps1.3.4.5.1.4.1.2" valign="top" width="33.33333333333333%">方法</th>         <th align="left" class="cellrowborder" id="mcps1.3.4.5.1.4.1.3" valign="top" width="33.33333333333333%">描述</th>        </tr>       </thead>               <tbody><tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">增加元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">add(element: T)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">在数组尾部增加一个元素。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">增加元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">insert(element: T, index: number)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">在指定位置插入一个元素。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">arr[index: number]</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">获取指定index对应的value值。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">forEach(callbackFn: (value: T, index?: number, arrlist?: ArrayList&lt;T&gt;) =&gt; void, thisArg?: Object)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问整个ArrayList容器的元素，其中callbackFn是forEach方法中用于处理每个元素的回调函数，它接收当前元素、索引和原列表作为参数。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">[Symbol.iterator]():IterableIterator&lt;T&gt;</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">创建迭代器以进行数据访问。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">修改元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">arr[index] = xxx</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">修改指定index位置对应的value值。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">删除元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">remove(element: T)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">删除第一个匹配到的元素。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">删除元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">removeByRange(fromIndex: number, toIndex:number)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">删除指定范围内的元素。</td>        </tr>             </tbody></table></div>     </div>    </div>    <div class="tiledSection">     <h2 id="list">List<i class="anchor-icon anchor-icon-link" anchorid="list" tips="复制节点链接"></i></h2>          <p><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-list" target="_blank">List</a>可用来构造一个单向链表对象，若需要查找List中某一个元素，只能从头结点开始遍历。List依据泛型定义，存储的元素在内存中的存储位置可以不连续。</p>     <p>List和<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-linkedlist" target="_blank">LinkedList</a>相比，LinkedList是双向链表，支持在头部和尾部快速增删操作。List则是单向链表，不支持双向操作。</p>     <p>当需要频繁插入和删除元素，并且使用单向链表时，推荐使用List进行高效操作。</p>     <p>可以通过get/set等接口修改存储的元素，List支持增、删、改、查操作，常用API如下：</p>     <div class="tablenoborder">      <div class="tbBox"><table class="layoutFixed idpTab">       <thead>        <tr>         <th align="left" class="cellrowborder" id="mcps1.3.5.6.1.4.1.1" valign="top" width="33.33333333333333%">操作</th>         <th align="left" class="cellrowborder" id="mcps1.3.5.6.1.4.1.2" valign="top" width="33.33333333333333%">方法</th>         <th align="left" class="cellrowborder" id="mcps1.3.5.6.1.4.1.3" valign="top" width="33.33333333333333%">描述</th>        </tr>       </thead>               <tbody><tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">增加元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">add(element: T)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">在数组尾部增加一个元素。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">增加元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">insert(element: T, index: number)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">在指定位置增加一个元素。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">get(index: number)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">获取指定index位置对应的元素。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">list[index: number]</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">获取指定索引位置的元素。若索引超出数组范围（index &lt; 0 或 index &gt;= list.length），或者数组是稀疏数组（存在未赋值的索引），则返回undefined。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">getFirst()</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">获取第一个元素。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">getLast()</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">获取最后一个元素。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">getIndexOf(element: T)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">获取第一个匹配指定元素的位置。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">getLastIndexOf(element: T)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">获取最后一个匹配指定元素的位置。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">forEach(callbackfn: (value:T, index?: number, list?: List&lt;T&gt;)=&gt; void,thisArg?: Object)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">遍历访问整个List容器中的每个元素，并执行指定的回调函数。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">[Symbol.iterator]():IterableIterator&lt;T&gt;</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">创建迭代器以进行数据访问。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">修改元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">set(index:number, element: T)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">修改指定index位置的元素值为element。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">修改元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">list[index] = element</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">修改指定index位置的元素值为element时，不会对链表中的实际节点进行任何更改，仅会在对象上添加一个属性，这将导致程序状态与链表实际内容不一致，从而产生未定义行为。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">修改元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">replaceAllElements(callbackFn:(value: T,index?: number,list?: List&lt;T&gt;)=&gt;T,thisArg?: Object)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">对List内元素进行逐个替换。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">删除元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">remove(element: T)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">通过 === 运算符逐个比对链表中的元素，删除第一个匹配成功的节点。对于对象类型，只有当传入的对象与链表中某节点的引用完全一致时才会被删除。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">删除元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">removeByIndex(index:number)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">删除index位置对应的元素，如果index超出范围，则会报out of range错误。</td>        </tr>             </tbody></table></div>     </div>    </div>    <div class="tiledSection">     <h2 id="linkedlist">LinkedList<i class="anchor-icon anchor-icon-link" anchorid="linkedlist" tips="复制节点链接"></i></h2>          <p><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-linkedlist" target="_blank">LinkedList</a>可用于构造双向链表对象，支持在任意节点向前或向后遍历LinkedList。LinkedList依据泛型定义，其元素在内存中的存储位置可以不连续。</p>     <p>LinkedList和<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-list" target="_blank">List</a>相比，LinkedList是双向链表，支持快速的头尾增删操作。List是单向链表，不支持双向操作。</p>     <p>LinkedList和<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arraylist" target="_blank">ArrayList</a>相比，LinkedList插入数据的效率高于ArrayList，ArrayList查询效率高于LinkedList。</p>     <p>需要频繁插入删除元素且使用双向链表时，推荐使用LinkedList。</p>     <p>可以通过get/set等接口修改存储的元素。LinkedList支持增、删、改、查操作，常用API如下：</p>     <div class="tablenoborder">      <div class="tbBox"><table class="layoutFixed idpTab">       <thead>        <tr>         <th align="left" class="cellrowborder" id="mcps1.3.6.7.1.4.1.1" valign="top" width="33.33333333333333%">操作</th>         <th align="left" class="cellrowborder" id="mcps1.3.6.7.1.4.1.2" valign="top" width="33.33333333333333%">方法</th>         <th align="left" class="cellrowborder" id="mcps1.3.6.7.1.4.1.3" valign="top" width="33.33333333333333%">描述</th>        </tr>       </thead>               <tbody><tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">增加元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">add(element: T)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">在数组尾部增加一个元素。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">增加元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">insert(element: T, index: number)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">在指定位置插入一个元素。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">get(index: number)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">获取指定index位置对应的元素。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">list[index: number]</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">获取指定index位置对应的元素，若索引超出数组范围（index &lt; 0 或 index &gt;= list.length），或者数组是稀疏数组（存在未赋值的索引），则返回undefined。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">getFirst()</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">获取第一个元素。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">getLast()</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">获取最后一个元素。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">getIndexOf(element: T)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">获取第一个匹配指定元素的位置。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">getLastIndexOf(element: T)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">获取最后一个匹配指定元素的位置。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">forEach(callbackFn: (value: T, index?: number, list?: LinkedList&lt;T&gt;) =&gt; void, thisArg?: Object)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">遍历访问整个LinkedList容器的每个元素，并执行指定的回调函数。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">[Symbol.iterator]():IterableIterator&lt;T&gt;</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">创建迭代器以进行数据访问。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">修改元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">set(index:number, element: T)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">修改指定index位置的元素值为element。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">修改元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">list[index] = element</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">修改指定index位置的元素值为element，若索引超出数组范围（index &lt; 0 或 index &gt;= list.length），或者数组是稀疏数组（存在未赋值的索引），则可能导致未定义行为。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">删除元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">remove(element: T)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">删除第一个匹配到的元素。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">删除元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">removeByIndex(index:number)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">删除index位置对应的元素。</td>        </tr>             </tbody></table></div>     </div>    </div>    <div class="tiledSection">     <h2 id="deque">Deque<i class="anchor-icon anchor-icon-link" anchorid="deque" tips="复制节点链接"></i></h2>          <p><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-deque" target="_blank">Deque</a>可用来构造双端队列对象，存储元素遵循先进先出以及先进后出的规则，双端队列可以分别从队头或者队尾进行访问。</p>     <p>Deque依据泛型定义，要求存储位置为连续的内存空间，初始容量为8，支持动态扩容，每次扩容为原容量的2倍。Deque底层采用循环队列实现，入队和出队操作效率高。</p>     <p>Deque和<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-queue" target="_blank">Queue</a>相比，Deque支持在两端进行元素的增删操作，而Queue仅支持在头部删除元素，尾部增加元素。</p>     <p>Deque和<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-vector" target="_blank">Vector</a>相比，都支持在两端增删元素，但Deque不支持中间插入。Deque在头部插入和删除元素的效率高于Vector，而Vector访问元素的效率高于Deque。</p>     <p>需要频繁在两端增删元素时，推荐使用Deque。</p>     <p>Deque支持增、删、改、查操作。常用API如下：</p>     <div class="tablenoborder">      <div class="tbBox"><table class="layoutFixed idpTab">       <thead>        <tr>         <th align="left" class="cellrowborder" id="mcps1.3.7.8.1.4.1.1" valign="top" width="33.33333333333333%">操作</th>         <th align="left" class="cellrowborder" id="mcps1.3.7.8.1.4.1.2" valign="top" width="33.33333333333333%">方法</th>         <th align="left" class="cellrowborder" id="mcps1.3.7.8.1.4.1.3" valign="top" width="33.33333333333333%">描述</th>        </tr>       </thead>               <tbody><tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">增加元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">insertFront(element: T)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">在头部增加一个元素。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">增加元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">insertEnd(element: T)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">在尾部增加一个元素。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">getFirst()</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">获取第一个元素，不进行出队操作。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">getLast()</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">获取最后一个元素，不进行出队操作。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">forEach(callbackFn:(value: T, index?: number, deque?: Deque&lt;T&gt;) =&gt; void, thisArg?: Object)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">遍历访问整个Deque容器的每个元素，并执行指定的回调函数。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">[Symbol.iterator]():IterableIterator&lt;T&gt;</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">创建迭代器以进行数据访问。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">删除元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">popFirst()</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">将队首元素作为返回值进行返回，并将其出队，如果队列为空，则返回undefined。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">删除元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">popLast()</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">将队尾元素作为返回值进行返回，并将其出队，如果队列为空，则返回undefined。</td>        </tr>             </tbody></table></div>     </div>    </div>    <div class="tiledSection">     <h2 id="queue">Queue<i class="anchor-icon anchor-icon-link" anchorid="queue" tips="复制节点链接"></i></h2>          <p><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-queue" target="_blank">Queue</a>可用来构造队列对象，存储元素遵循先进先出的规则。</p>     <p>Queue基于泛型定义，存储位置为连续的内存空间，初始容量为8，支持动态扩容，每次扩容容量翻倍。</p>     <p>Queue底层采用循环队列实现，入队和出队操作效率高。</p>     <p>Queue和<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-deque" target="_blank">Deque</a>相比，Queue仅支持在头部删除元素，尾部增加元素，而Deque支持在两端进行元素的增删操作。</p>     <p>符合先进先出的场景可以使用Queue。</p>     <p>Queue支持增、删、改、查操作，常用API如下：</p>     <div class="tablenoborder">      <div class="tbBox"><table class="layoutFixed idpTab">       <thead>        <tr>         <th align="left" class="cellrowborder" id="mcps1.3.8.8.1.4.1.1" valign="top" width="33.33333333333333%">操作</th>         <th align="left" class="cellrowborder" id="mcps1.3.8.8.1.4.1.2" valign="top" width="33.33333333333333%">方法</th>         <th align="left" class="cellrowborder" id="mcps1.3.8.8.1.4.1.3" valign="top" width="33.33333333333333%">描述</th>        </tr>       </thead>               <tbody><tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">增加元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">add(element: T)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">在尾部增加一个元素。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">getFirst()</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">获取队首元素，不进行出队操作。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">forEach(callbackFn: (value: T, index?: number, queue?: Queue&lt;T&gt;) =&gt; void,thisArg?: Object)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">遍历访问整个Queue容器的每个元素，并执行指定的回调函数。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">[Symbol.iterator]():IterableIterator&lt;T&gt;</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">创建迭代器以进行数据访问。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">删除元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">pop()</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">将队首元素作为返回值进行返回，并将其移除。</td>        </tr>             </tbody></table></div>     </div>    </div>    <div class="tiledSection">     <h2 id="stack">Stack<i class="anchor-icon anchor-icon-link" anchorid="stack" tips="复制节点链接"></i></h2>          <p><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-stack" target="_blank">Stack</a>可用来构造栈对象，存储元素遵循先进后出的规则。</p>     <p>Stack基于泛型定义，要求使用连续的内存空间存储元素，初始容量为8，并支持动态扩容，每次扩容为原容量的1.5倍。Stack底层使用数组实现，入栈和出栈操作均在数组的一端进行。</p>     <p>Stack和<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-queue" target="_blank">Queue</a>相比，Queue基于循环队列实现，仅支持在头部删除元素，尾部增加元素，而Stack都在一端进行操作。</p>     <p>符合先进后出的场景可以使用Stack。</p>     <p>Stack支持增、删、改、查操作，常用API如下：</p>     <div class="tablenoborder">      <div class="tbBox"><table class="layoutFixed idpTab">       <thead>        <tr>         <th align="left" class="cellrowborder" id="mcps1.3.9.7.1.4.1.1" valign="top" width="33.33333333333333%">操作</th>         <th align="left" class="cellrowborder" id="mcps1.3.9.7.1.4.1.2" valign="top" width="33.33333333333333%">方法</th>         <th align="left" class="cellrowborder" id="mcps1.3.9.7.1.4.1.3" valign="top" width="33.33333333333333%">描述</th>        </tr>       </thead>               <tbody><tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">增加元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">push(item: T)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">在栈顶增加一个元素。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">peek()</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">获取栈顶元素，不进行出队操作。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">locate(element: T)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">获取元素对应的位置。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">forEach(callbackFn: (value: T, index?: number, stack?: Stack&lt;T&gt;) =&gt; void, thisArg?: Object)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">遍历访问整个Stack容器的每个元素，并执行指定的回调函数。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">[Symbol.iterator]():IterableIterator&lt;T&gt;</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">创建迭代器以进行数据访问。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">删除元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">pop()</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">将栈顶元素作为返回值进行返回，并将其移除。</td>        </tr>             </tbody></table></div>     </div>    </div>    <div class="tiledSection">     <h2 id="vector">Vector<i class="anchor-icon anchor-icon-link" anchorid="vector" tips="复制节点链接"></i></h2>          <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content">       <p>API version 9开始，该接口不再维护，推荐使用<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arraylist" target="_blank">ArrayList</a>。</p>      </div></div></div>     <p><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-vector" target="_blank">Vector</a>是一种连续存储结构，用于创建全局数组对象。它基于泛型定义，要求存储在连续的内存空间中。Vector的初始容量为10，支持动态扩容，每次扩容时容量增加为原来的两倍。</p>     <p>Vector和<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arraylist" target="_blank">ArrayList</a>相似，都基于数组实现，但Vector提供了更多操作数组的接口，支持操作符访问，增加get/set接口，提供更完善的校验和容错机制，满足不同的场景需求。</p>     <p>Vector支持增、删、改、查操作，常用API如下：</p>     <div class="tablenoborder">      <div class="tbBox"><table class="layoutFixed idpTab">       <thead>        <tr>         <th align="left" class="cellrowborder" id="mcps1.3.10.6.1.4.1.1" valign="top" width="33.33333333333333%">操作</th>         <th align="left" class="cellrowborder" id="mcps1.3.10.6.1.4.1.2" valign="top" width="33.33333333333333%">方法</th>         <th align="left" class="cellrowborder" id="mcps1.3.10.6.1.4.1.3" valign="top" width="33.33333333333333%">描述</th>        </tr>       </thead>               <tbody><tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">增加元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">add(element: T)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">在数组尾部增加一个元素。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">增加元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">insert(element: T, index: number)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">在指定位置插入一个元素。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">get(index: number)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">获取指定index位置对应的元素。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">vec[index: number]</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">获取指定index位置对应的元素，通过指令获取保证访问速度。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">getFirst()</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">获取第一个元素。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">getLastElement()</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">获取最后一个元素。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">getIndexOf(element: T)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">获取第一个匹配指定元素的位置。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">getLastIndexOf(element: T)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">获取最后一个匹配指定元素的位置。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">forEach(callbackFn: (value: T, index?: number, Vector?: Vector&lt;T&gt;) =&gt; void, thisArg?: Object)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">遍历访问整个Vector容器的每个元素，并执行指定的回调函数。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">[Symbol.iterator]():IterableIterator&lt;T&gt;</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">创建迭代器以进行数据访问。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">修改元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">set(index:number, element: T)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">修改指定index位置的元素值为element。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">修改元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">vec[index] = element</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">修改指定index位置的元素值为element。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">修改元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">replaceAllElements(callbackFn: (value: T, index?: number, vector?: Vector&lt;T&gt;) =&gt; T, thisArg?: Object)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">逐个替换Vector内的元素。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">修改元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">setLength(newSize:number)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">设置Vector的长度大小。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">删除元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">remove(element: T)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">删除第一个匹配到的元素。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">删除元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">removeByIndex(index:number)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">删除index位置对应的元素。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">删除元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">removeByRange(fromIndex:number,toIndex:number)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">删除指定范围内的元素。</td>        </tr>             </tbody></table></div>     </div>    </div>    <div class="tiledSection">     <h2 id="线性容器的使用">线性容器的使用<i class="anchor-icon anchor-icon-link" anchorid="线性容器的使用" tips="复制节点链接"></i></h2>          <p>此处列举常用的线性容器ArrayList、Deque、Stack、List的使用示例，包括导入模块、添加元素、访问元素及修改等操作。示例代码如下所示：</p>     <div _ngcontent-cln-c106="" class="highlight-div"><div _ngcontent-cln-c106="" class="highlight-div-header"><div _ngcontent-cln-c106="" class="highlight-div-header-left"><div _ngcontent-cln-c106="" class="handle-button expand-button"><div _ngcontent-cln-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-cln-c106="" class="highlight-div-header-right"><div _ngcontent-cln-c106="" class="handle-button ai-button"></div><div _ngcontent-cln-c106="" class="handle-button line-button"><div _ngcontent-cln-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-cln-c106="" class="handle-button theme-button"><div _ngcontent-cln-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-cln-c106="" class="handle-button copy-button"><div _ngcontent-cln-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-cln-c106="" class="highlight-scroll-div"><pre class="ts prettyprint linenums hljs language-typescript" hw-language="ts" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// ArrayList</span></li><li><span class="hljs-keyword">import</span> { <span class="hljs-title class_">ArrayList</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.ArkTS'</span>; <span class="hljs-comment">// 导入ArrayList模块</span></li><li>
</li><li><span class="hljs-keyword">let</span> <span class="hljs-attr">arrayList1</span>: <span class="hljs-title class_">ArrayList</span>&lt;<span class="hljs-built_in">string</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();</li><li>arrayList1.<span class="hljs-title function_">add</span>(<span class="hljs-string">'a'</span>); <span class="hljs-comment">// 增加一个值为'a'的元素</span></li><li><span class="hljs-keyword">let</span> <span class="hljs-attr">arrayList2</span>: <span class="hljs-title class_">ArrayList</span>&lt;<span class="hljs-built_in">number</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();</li><li>arrayList2.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 增加一个值为1的元素</span></li><li><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">`result: <span class="hljs-subst">${arrayList2[<span class="hljs-number">0</span>]}</span>`</span>); <span class="hljs-comment">// 访问索引为0的元素。输出：result: 1</span></li><li>arrayList1[<span class="hljs-number">0</span>] = <span class="hljs-string">'one'</span>; <span class="hljs-comment">// 修改索引为0的元素</span></li><li><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">`result: <span class="hljs-subst">${arrayList1[<span class="hljs-number">0</span>]}</span>`</span>); <span class="hljs-comment">// 输出：result: one</span></li><li>
</li><li><span class="hljs-comment">// Deque</span></li><li><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Deque</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.ArkTS'</span>; <span class="hljs-comment">// 导入Deque模块</span></li><li>
</li><li><span class="hljs-keyword">let</span> <span class="hljs-attr">deque1</span>: <span class="hljs-title class_">Deque</span>&lt;<span class="hljs-built_in">string</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Deque</span>();</li><li>deque1.<span class="hljs-title function_">insertFront</span>(<span class="hljs-string">'a'</span>); <span class="hljs-comment">// 头部增加一个值为'a'的元素</span></li><li><span class="hljs-keyword">let</span> <span class="hljs-attr">deque2</span>: <span class="hljs-title class_">Deque</span>&lt;<span class="hljs-built_in">number</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Deque</span>();</li><li>deque2.<span class="hljs-title function_">insertFront</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 头部增加一个值为1的元素</span></li><li><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">`result: <span class="hljs-subst">${deque2.getFirst()}</span>`</span>); <span class="hljs-comment">// 访问队列首部的元素。输出：result: 1</span></li><li>deque1.<span class="hljs-title function_">insertEnd</span>(<span class="hljs-string">'one'</span>); <span class="hljs-comment">// 尾部增加一个值为'one'的元素</span></li><li><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">`result: <span class="hljs-subst">${deque1.getLast()}</span>`</span>); <span class="hljs-comment">// 访问队列尾部的元素。输出：result: one</span></li><li>
</li><li><span class="hljs-comment">// Stack</span></li><li><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Stack</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.ArkTS'</span>; <span class="hljs-comment">// 导入Stack模块</span></li><li>
</li><li><span class="hljs-keyword">let</span> <span class="hljs-attr">stack1</span>: <span class="hljs-title class_">Stack</span>&lt;<span class="hljs-built_in">string</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>();</li><li>stack1.<span class="hljs-title function_">push</span>(<span class="hljs-string">'a'</span>); <span class="hljs-comment">// 向栈里增加一个值为'a'的元素</span></li><li><span class="hljs-keyword">let</span> <span class="hljs-attr">stack2</span>: <span class="hljs-title class_">Stack</span>&lt;<span class="hljs-built_in">number</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>();</li><li>stack2.<span class="hljs-title function_">push</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 向栈里增加一个值为1的元素</span></li><li><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">`result: <span class="hljs-subst">${stack1.peek()}</span>`</span>); <span class="hljs-comment">// 访问栈顶元素。输出：result: a</span></li><li><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">`result: <span class="hljs-subst">${stack2.pop()}</span>`</span>); <span class="hljs-comment">// 删除栈顶元素并返回该删除元素。输出：result: 1</span></li><li><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">`result: <span class="hljs-subst">${stack2.length}</span>`</span>); <span class="hljs-comment">// 输出：result: 0</span></li><li>
</li><li><span class="hljs-comment">// List</span></li><li><span class="hljs-keyword">import</span> { <span class="hljs-title class_">List</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.ArkTS'</span>; <span class="hljs-comment">// 导入List模块</span></li><li>
</li><li><span class="hljs-keyword">let</span> <span class="hljs-attr">list1</span>: <span class="hljs-title class_">List</span>&lt;<span class="hljs-built_in">string</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>();</li><li>list1.<span class="hljs-title function_">add</span>(<span class="hljs-string">'a'</span>); <span class="hljs-comment">// 增加一个值为'a'的元素</span></li><li><span class="hljs-keyword">let</span> <span class="hljs-attr">list2</span>: <span class="hljs-title class_">List</span>&lt;<span class="hljs-built_in">number</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>();</li><li>list2.<span class="hljs-title function_">insert</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// 在0号位置插入（增加）一个值为0的元素</span></li><li><span class="hljs-keyword">let</span> <span class="hljs-attr">list3</span>: <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">number</span>&gt;&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>();</li><li><span class="hljs-keyword">let</span> b2 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];</li><li>list3.<span class="hljs-title function_">add</span>(b2); <span class="hljs-comment">// 增加一个Array类型的元素</span></li><li><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">`result: <span class="hljs-subst">${list1[<span class="hljs-number">0</span>]}</span>`</span>); <span class="hljs-comment">// 访问索引为0的元素。输出：result: a</span></li><li><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">`result: <span class="hljs-subst">${list3.get(<span class="hljs-number">0</span>)}</span>`</span>); <span class="hljs-comment">// 访问索引为0的元素。输出：result: 1,2,3</span></li></ol></pre></div></div>    </div>   </div>   <div></div></div>