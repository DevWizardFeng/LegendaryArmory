<h1 _ngcontent-crp-c119="" class="doc-title ng-star-inserted" title="非线性容器"> 非线性容器 </h1>

<div _ngcontent-crp-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;">   <div>    <p>非线性容器实现能快速查找的数据结构，其底层通过hash或者红黑树实现，包括HashMap、HashSet、TreeMap、TreeSet、LightWeightMap、LightWeightSet、PlainArray七种。非线性容器中的key及value的类型均满足ECMA标准。</p>    <div class="tiledSection">     <h2 id="各非线性容器类型特征对比">各非线性容器类型特征对比<i class="anchor-icon anchor-icon-link" anchorid="各非线性容器类型特征对比" tips="复制节点链接"></i></h2>          <div class="tablenoborder">      <div class="tbBox"><table class="layoutFixed idpTab">       <thead>        <tr>         <th align="left" class="cellrowborder" id="mcps1.3.2.2.1.3.1.1" valign="top" width="50%">类名</th>         <th align="left" class="cellrowborder" id="mcps1.3.2.2.1.3.1.2" valign="top" width="50%">特征及建议使用场景</th>        </tr>       </thead>               <tbody><tr>         <td class="cellrowborder" valign="top" width="50%">HashMap</td>         <td class="cellrowborder" valign="top" width="50%">存储具有关联关系的键值对集合。键唯一，依据键的hash值确定存储位置。访问速度快，但不能自定义排序。推荐用于需要快速存取、插入删除键值对数据时使用。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="50%">HashSet</td>         <td class="cellrowborder" valign="top" width="50%">存储一系列值的集合。值唯一，依据值的hash确定存储位置。允许放入null值，但不能自定义排序。适用于不重复的集合或去重某个集合。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="50%">TreeMap</td>         <td class="cellrowborder" valign="top" width="50%">存储具有关联关系的键值对集合。键唯一，允许用户自定义排序方法。适用于按序存储键值对的场景。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="50%">TreeSet</td>         <td class="cellrowborder" valign="top" width="50%">存储一系列值的集合。值唯一，允许用户自定义排序方法，但不建议放入null值。适用于按序存储集合的场景。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="50%">LightWeightMap</td>         <td class="cellrowborder" valign="top" width="50%">存储具有关联关系的键值对集合。键唯一，底层采用轻量级结构，空间占用小。推荐用于存取键值对数据且内存不充足时。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="50%">LightWeightSet</td>         <td class="cellrowborder" valign="top" width="50%">存储一系列值的集合。值唯一，底层采用轻量级结构，空间占用小。适用于不重复的集合或去重某个集合。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="50%">PlainArray</td>         <td class="cellrowborder" valign="top" width="50%">存储具有关联关系的键值对集合。键唯一，底层与LightWeightMap一样采用轻量级结构，键固定为number类型。适用于存储键为number类型键值对的场景。</td>        </tr>             </tbody></table></div>     </div>    </div>    <div class="tiledSection">     <h2 id="hashmap">HashMap<i class="anchor-icon anchor-icon-link" anchorid="hashmap" tips="复制节点链接"></i></h2>          <p><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-hashmap" target="_blank">HashMap</a>可用来存储具有关联关系的key-value键值对集合，存储元素中key是唯一的，每个key会对应一个value值。</p>     <p>HashMap通过泛型定义，利用键的哈希值确定存储位置，实现快速查找。初始容量为16，支持动态扩容，每次扩容为原容量的两倍。底层基于哈希表实现，冲突处理采用链地址法。</p>     <p>HashMap和<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-treemap" target="_blank">TreeMap</a>相比，HashMap依据键的hashCode存取数据，访问速度较快。TreeMap则按顺序存取，效率较低。</p>     <p><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-hashset" target="_blank">HashSet</a>基于HashMap实现。HashMap的输入参数由key、value两个值组成。在HashSet中，只处理value对象。</p>     <p>需要快速存取、删除以及插入键值对数据时，推荐使用HashMap。</p>     <p>HashMap支持增、删、改、查操作，常用API如下：</p>     <div class="tablenoborder">      <div class="tbBox"><table class="layoutFixed idpTab">       <thead>        <tr>         <th align="left" class="cellrowborder" id="mcps1.3.3.8.1.4.1.1" valign="top" width="33.33333333333333%">操作</th>         <th align="left" class="cellrowborder" id="mcps1.3.3.8.1.4.1.2" valign="top" width="33.33333333333333%">方法</th>         <th align="left" class="cellrowborder" id="mcps1.3.3.8.1.4.1.3" valign="top" width="33.33333333333333%">描述</th>        </tr>       </thead>               <tbody><tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">增加元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">set(key: K, value: V)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">增加一个键值对。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">get(key: K)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">获取key对应的value值。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">keys()</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">返回一个迭代器对象，包含map中的所有key值。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">values()</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">返回一个迭代器对象，包含map中的所有value值。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">entries()</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">返回一个迭代器对象，包含map中的所有键值对。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">forEach(callbackFn: (value?: V, key?: K, map?: HashMap&lt;K, V&gt;) =&gt; void, thisArg?: Object)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">遍历访问整个map的元素。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">[Symbol.iterator]():IterableIterator&lt;[K,V]&gt;</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">创建迭代器以访问数据。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">修改元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">replace(key: K, newValue: V)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">修改指定key对应的value值。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">修改元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">forEach(callbackFn: (value?: V, key?: K, map?: HashMap&lt;K, V&gt;) =&gt; void, thisArg?: Object)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">遍历并修改整个map的元素。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">删除元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">remove(key: K)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">删除map中匹配到的键值对。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">删除元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">clear()</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">清空整个map。</td>        </tr>             </tbody></table></div>     </div>    </div>    <div class="tiledSection">     <h2 id="hashset">HashSet<i class="anchor-icon anchor-icon-link" anchorid="hashset" tips="复制节点链接"></i></h2>          <p><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-hashset" target="_blank">HashSet</a>可用来存储一系列值的集合，存储元素中value是唯一的。</p>     <p>HashSet基于泛型定义，集合中通过value的hash值确定存储位置，从而快速找到该值。初始容量为16，支持动态扩容，每次扩容为原始容量的2倍。value的类型需满足ECMA标准。HashSet基于<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-hashmap" target="_blank">HashMap</a>实现，只处理value对象，底层数据结构与HashMap一致。</p>     <p>HashSet和<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-treeset" target="_blank">TreeSet</a>相比，HashSet中的数据无序存放，不支持用户指定排序方式，而TreeSet中的数据有序存放，支持用户通过排序函数对元素进行排序。它们集合中的元素都不允许重复，HashSet允许放入null值，但TreeSet不建议存放null值，可能会对排序结果产生影响。</p>     <p>可以利用HashSet的不重复特性，在需要去重或确保集合元素唯一性时使用。</p>     <p>HashSet支持增、删、改、查操作，常用API如下：</p>     <div class="tablenoborder">      <div class="tbBox"><table class="layoutFixed idpTab">       <thead>        <tr>         <th align="left" class="cellrowborder" id="mcps1.3.4.7.1.4.1.1" valign="top" width="33.33333333333333%">操作</th>         <th align="left" class="cellrowborder" id="mcps1.3.4.7.1.4.1.2" valign="top" width="33.33333333333333%">方法</th>         <th align="left" class="cellrowborder" id="mcps1.3.4.7.1.4.1.3" valign="top" width="33.33333333333333%">描述</th>        </tr>       </thead>               <tbody><tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">增加元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">add(value: T)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">增加一个值。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">values()</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">返回一个迭代器对象，包含set中的所有value。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">entries()</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">返回一个迭代器对象，包含类似键值对的数组，键值都是value。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">forEach(callbackFn: (value?: T, key?: T, set?: HashSet&lt;T&gt;) =&gt; void, thisArg?: Object)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">遍历访问整个set的元素。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">[Symbol.iterator]():IterableIterator&lt;T&gt;</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">创建迭代器以进行数据访问。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">修改元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">forEach(callbackFn: (value?: T, key?: T, set?: HashSet&lt;T&gt;) =&gt; void, thisArg?: Object)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">通过遍历对set中的元素进行操作，可能包括但不限于修改元素。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">删除元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">remove(value: T)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">删除指定的元素。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">删除元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">clear()</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">清空整个set。</td>        </tr>             </tbody></table></div>     </div>    </div>    <div class="tiledSection">     <h2 id="treemap">TreeMap<i class="anchor-icon anchor-icon-link" anchorid="treemap" tips="复制节点链接"></i></h2>          <p><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-treemap" target="_blank">TreeMap</a>用于存储具有关联关系的key-value键值对集合，存储元素中key是唯一的，每个key对应一个value值。</p>     <p>TreeMap的key按照泛型定义有序存储，基于红黑树实现，支持快速插入和删除，key的类型需满足ECMA标准。</p>     <p>TreeMap和<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-hashmap" target="_blank">HashMap</a>相比，HashMap依据键的hashCode存取数据，访问速度较快。而TreeMap是有序存取，效率较低。</p>     <p>一般需要存储有序键值对的场景，可以使用TreeMap。</p>     <p>TreeMap支持增、删、改、查操作，常用 API 如下：</p>     <div class="tablenoborder">      <div class="tbBox"><table class="layoutFixed idpTab">       <thead>        <tr>         <th align="left" class="cellrowborder" id="mcps1.3.5.7.1.4.1.1" valign="top" width="33.33333333333333%">操作</th>         <th align="left" class="cellrowborder" id="mcps1.3.5.7.1.4.1.2" valign="top" width="33.33333333333333%">方法</th>         <th align="left" class="cellrowborder" id="mcps1.3.5.7.1.4.1.3" valign="top" width="33.33333333333333%">描述</th>        </tr>       </thead>               <tbody><tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">增加元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">set(key: K, value: V)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">增加一个键值对。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">get(key: K)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">获取key对应的value值。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">getFirstKey()</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">获取map中排在首位的key值。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">getLastKey()</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">获取map中排在末位的key值。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">keys()</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">返回一个迭代器对象，包含map中的所有key值。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">values()</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">返回一个迭代器对象，包含map中的所有value值。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">entries()</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">返回一个迭代器对象，包含map中的所有键值对。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">forEach(callbackFn: (value?: V, key?: K, map?: TreeMap&lt;K, V&gt;) =&gt; void, thisArg?: Object)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">遍历访问整个map的元素。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">[Symbol.iterator]():IterableIterator&lt;[K,V]&gt;</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">创建迭代器以进行数据访问。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">修改元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">replace(key: K, newValue: V)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">修改指定key对应的value值。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">修改元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">forEach(callbackFn: (value?: V, key?: K, map?: TreeMap&lt;K, V&gt;) =&gt; void, thisArg?: Object)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">通过遍历对map中的元素进行操作，可能包括但不限于修改元素。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">删除元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">remove(key: K)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">删除map中匹配到的键值对。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">删除元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">clear()</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">清空整个map。</td>        </tr>             </tbody></table></div>     </div>    </div>    <div class="tiledSection">     <h2 id="treeset">TreeSet<i class="anchor-icon anchor-icon-link" anchorid="treeset" tips="复制节点链接"></i></h2>          <p><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-treeset" target="_blank">TreeSet</a>可用来存储一系列值的集合，存储元素中value是唯一的。</p>     <p>TreeSet根据泛型定义有序存储值，底层实现基于红黑树，支持快速插入和删除。value的类型符合ECMA标准。</p>     <p>TreeSet基于<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-treemap" target="_blank">TreeMap</a>实现，仅处理value对象，用于存储值的集合，元素中value唯一，并支持按用户定义的排序函数排序。</p>     <p>TreeSet和<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-hashset" target="_blank">HashSet</a>相比，HashSet无序存放数据，TreeSet有序存放数据。两者元素均不允许重复，HashSet允许null值，但TreeSet不建议存放null值，可能影响排序。</p>     <p>在需要存储有序集合的场景中，可以使用TreeSet。</p>     <p>TreeSet支持增、删、改、查操作，常用API如下：</p>     <div class="tablenoborder">      <div class="tbBox"><table class="layoutFixed idpTab">       <thead>        <tr>         <th align="left" class="cellrowborder" id="mcps1.3.6.8.1.4.1.1" valign="top" width="33.33333333333333%">操作</th>         <th align="left" class="cellrowborder" id="mcps1.3.6.8.1.4.1.2" valign="top" width="33.33333333333333%">方法</th>         <th align="left" class="cellrowborder" id="mcps1.3.6.8.1.4.1.3" valign="top" width="33.33333333333333%">描述</th>        </tr>       </thead>               <tbody><tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">增加元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">add(value: T)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">增加一个值。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">values()</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">返回一个迭代器对象，包含set中的所有value值。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">entries()</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">返回一个迭代器对象，包含类似键值对的数组，键值都是value。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">getFirstValue()</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">获取set中排在首位的value值。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">getLastValue()</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">获取set中排在末位的value值。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">forEach(callbackFn: (value?: T, key?: T, set?: TreeSet&lt;T&gt;) =&gt; void, thisArg?: Object)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">遍历访问整个set的元素。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">[Symbol.iterator]():IterableIterator&lt;T&gt;</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">创建迭代器以进行数据访问。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">修改元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">forEach(callbackFn: (value?: T, key?: T, set?: TreeSet&lt;T&gt;) =&gt; void, thisArg?: Object)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">通过遍历对set中的元素进行操作，可能包括但不限于修改元素。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">删除元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">remove(value: T)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">删除指定的元素。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">删除元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">clear()</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">清空整个set。</td>        </tr>             </tbody></table></div>     </div>    </div>    <div class="tiledSection">     <h2 id="lightweightmap">LightWeightMap<i class="anchor-icon anchor-icon-link" anchorid="lightweightmap" tips="复制节点链接"></i></h2>          <p><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-lightweightmap" target="_blank">LightWeightMap</a>用于存储具有唯一键的键值对集合，存储元素中key是唯一的，每个key会对应一个value值。LightWeightMap依据泛型定义，采用轻量级结构，底层通过hash实现唯一key，冲突策略为线性探测。集合中的key值的查找依赖于hash值以及二分查找算法，通过一个数组存储hash值，然后映射到其他数组中的key值以及value值，key的类型满足ECMA标准。</p>     <p>初始默认容量为8，每次扩容为原容量的2倍。</p>     <p>LightWeightMap和<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-hashmap" target="_blank">HashMap</a>都是用来存储具有关联关系的key-value键值对集合，但LightWeightMap占用内存更小。</p>     <p>当需要存储具有关联关系的key-value键值对集合时，推荐使用占用内存更小的LightWeightMap。</p>     <p>LightWeightMap支持增、删、改、查操作，常用API如下：</p>     <div class="tablenoborder">      <div class="tbBox"><table class="layoutFixed idpTab">       <thead>        <tr>         <th align="left" class="cellrowborder" id="mcps1.3.7.7.1.4.1.1" valign="top" width="33.33333333333333%">操作</th>         <th align="left" class="cellrowborder" id="mcps1.3.7.7.1.4.1.2" valign="top" width="33.33333333333333%">方法</th>         <th align="left" class="cellrowborder" id="mcps1.3.7.7.1.4.1.3" valign="top" width="33.33333333333333%">描述</th>        </tr>       </thead>               <tbody><tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">增加元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">set(key: K, value: V)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">增加一个键值对。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">get(key: K)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">获取key对应的value值。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">getIndexOfKey(key: K)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">获取map中指定key的index。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">getIndexOfValue(value: V)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">获取map中指定value出现的第一个的index。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">keys()</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">返回一个迭代器对象，包含map中的所有key值。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">values()</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">返回一个迭代器对象，包含map中的所有value值。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">entries()</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">返回一个迭代器对象，包含map中的所有键值对。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">getKeyAt(index: number)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">获取指定index对应的key值。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">getValueAt(index: number)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">获取指定index对应的value值。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">forEach(callbackFn: (value?: V, key?: K, map?: LightWeightMap&lt;K, V&gt;) =&gt; void, thisArg?: Object)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">遍历访问整个map的元素。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">[Symbol.iterator]():IterableIterator&lt;[K,V]&gt;</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">创建迭代器以进行数据访问。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">修改元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">setValueAt(index: number, newValue: V)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">修改指定index对应的value值。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">修改元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">forEach(callbackFn: (value?: V, key?: K, map?: LightWeightMap&lt;K, V&gt;) =&gt; void, thisArg?: Object)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">通过遍历对map中的元素进行操作，可能包括但不限于修改元素。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">删除元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">remove(key: K)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">删除map中指定key匹配到的键值对。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">删除元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">removeAt(index: number)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">删除map中指定index对应的键值对。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">删除元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">clear()</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">清空整个map。</td>        </tr>             </tbody></table></div>     </div>    </div>    <div class="tiledSection">     <h2 id="lightweightset">LightWeightSet<i class="anchor-icon anchor-icon-link" anchorid="lightweightset" tips="复制节点链接"></i></h2>          <p><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-lightweightset" target="_blank">LightWeightSet</a>可用来存储一系列值的集合，存储元素中value是唯一的。</p>     <p>LightWeightSet依据泛型定义，采用更加轻量级的结构，初始默认容量为8，每次扩容为原始容量的2倍。集合中的value值的查找依赖于hash值以及二分查找算法，通过一个数组存储hash值，然后映射到其他数组中的value值，value的类型满足ECMA标准。</p>     <p>LightWeightSet底层通过hash表结构实现value的唯一性，冲突策略采用线性探测法，查找策略基于二分查找法。</p>     <p>LightWeightSet和<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-hashset" target="_blank">HashSet</a>都是用来存储键值的集合，但LightWeightSet的占用内存更小。</p>     <p>当需要存取某个集合或是对某个集合去重时，推荐使用占用内存更小的LightWeightSet。</p>     <p>LightWeightSet支持增、删、改、查操作。常用API如下：</p>     <div class="tablenoborder">      <div class="tbBox"><table class="layoutFixed idpTab">       <thead>        <tr>         <th align="left" class="cellrowborder" id="mcps1.3.8.8.1.4.1.1" valign="top" width="33.33333333333333%">操作</th>         <th align="left" class="cellrowborder" id="mcps1.3.8.8.1.4.1.2" valign="top" width="33.33333333333333%">方法</th>         <th align="left" class="cellrowborder" id="mcps1.3.8.8.1.4.1.3" valign="top" width="33.33333333333333%">描述</th>        </tr>       </thead>               <tbody><tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">增加元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">add(obj: T)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">增加一个值。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">getIndexOf(key: T)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">获取对应的index值。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">getValueAt(index: number)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">获取指定index对应的value值。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">values()</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">返回一个迭代器对象，包含set中的所有value值。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">entries()</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">返回一个迭代器对象，包含类似键值对的数组，键值都是value。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">forEach(callbackFn: (value?: T, key?: T, set?: LightWeightSet&lt;T&gt;) =&gt; void, thisArg?: Object)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">遍历访问整个set的元素。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">[Symbol.iterator]():IterableIterator&lt;T&gt;</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">创建迭代器以进行数据访问。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">修改元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">forEach(callbackFn: (value?: T, key?: T, set?: LightWeightSet&lt;T&gt;) =&gt; void, thisArg?: Object)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">通过遍历对set中的元素进行操作，可能包括但不限于修改元素。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">删除元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">remove(key: K)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">删除指定的元素。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">删除元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">removeAt(index: number)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">删除set中指定index对应的值。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">删除元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">clear()</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">清空整个set。</td>        </tr>             </tbody></table></div>     </div>    </div>    <div class="tiledSection">     <h2 id="plainarray">PlainArray<i class="anchor-icon anchor-icon-link" anchorid="plainarray" tips="复制节点链接"></i></h2>          <p><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-plainarray" target="_blank">PlainArray</a>可用来存储具有关联关系的键值对集合，存储元素中key是唯一的，并且对于PlainArray来说，其key的类型为number类型。每个key会对应一个value值，类型依据泛型的定义，PlainArray采用轻量级的结构，集合中的key值的查找依赖于二分查找算法，然后映射到其他数组中的value值。</p>     <p>初始默认容量为16，每次扩容为原始容量的2倍。</p>     <p>PlainArray和<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-lightweightmap" target="_blank">LightWeightMap</a>都用于存储键值对，且采用轻量级结构。不过，PlainArray的键值类型仅限于number。</p>     <p>当需要存储键为number类型的键值对时，可以使用PlainArray。</p>     <p>PlainArray支持增、删、改、查操作。常用API如下：</p>     <div class="tablenoborder">      <div class="tbBox"><table class="layoutFixed idpTab">       <thead>        <tr>         <th align="left" class="cellrowborder" id="mcps1.3.9.7.1.4.1.1" valign="top" width="33.33333333333333%">操作</th>         <th align="left" class="cellrowborder" id="mcps1.3.9.7.1.4.1.2" valign="top" width="33.33333333333333%">方法</th>         <th align="left" class="cellrowborder" id="mcps1.3.9.7.1.4.1.3" valign="top" width="33.33333333333333%">描述</th>        </tr>       </thead>               <tbody><tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">增加元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">add(key: number,value: T)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">增加一个键值对。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">get(key: number)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">获取key对应的value值。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">getIndexOfKey(key: number)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">获取PlainArray中指定key的index。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">getIndexOfValue(value: T)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">获取PlainArray中指定value出现的第一个的index。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">getKeyAt(index: number)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">获取指定index对应的key值。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">getValueAt(index: number)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">获取指定index对应的value值。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">forEach(callbackFn: (value: T, index?: number, PlainArray?: PlainArray&lt;T&gt;) =&gt; void, thisArg?: Object)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">遍历访问整个PlainArray的元素。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">访问元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">[Symbol.iterator]():IterableIterator&lt;[number, T]&gt;</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">创建迭代器以进行数据访问。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">修改元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">setValueAt(index:number, value: T)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">修改指定index对应的value值。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">修改元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">forEach(callbackFn: (value: T, index?: number, PlainArray?: PlainArray&lt;T&gt;) =&gt; void, thisArg?: Object)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">通过遍历对PlainArray中的元素进行操作，可能包括但不限于修改元素。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">删除元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">remove(key: number)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">删除PlainArray中指定key匹配到的键值对。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">删除元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">removeAt(index: number)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">删除PlainArray中指定index对应的键值对。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">删除元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">removeRangeFrom(index: number, size: number)</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">删除PlainArray中指定范围内的元素。</td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">删除元素</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">clear()</td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">清空整个PlainArray。</td>        </tr>             </tbody></table></div>     </div>    </div>    <div class="tiledSection">     <h2 id="非线性容器的使用">非线性容器的使用<i class="anchor-icon anchor-icon-link" anchorid="非线性容器的使用" tips="复制节点链接"></i></h2>          <p>此处列举常用的非线性容器HashMap、TreeMap、LightWeightMap、PlainArray的使用示例，包括导入模块、增加元素、访问元素及修改等操作，示例代码如下所示：</p>     <div _ngcontent-crp-c106="" class="highlight-div"><div _ngcontent-crp-c106="" class="highlight-div-header"><div _ngcontent-crp-c106="" class="highlight-div-header-left"><div _ngcontent-crp-c106="" class="handle-button expand-button"><div _ngcontent-crp-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-crp-c106="" class="highlight-div-header-right"><div _ngcontent-crp-c106="" class="handle-button ai-button"></div><div _ngcontent-crp-c106="" class="handle-button line-button"><div _ngcontent-crp-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-crp-c106="" class="handle-button theme-button"><div _ngcontent-crp-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-crp-c106="" class="handle-button copy-button"><div _ngcontent-crp-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-crp-c106="" class="highlight-scroll-div"><pre class="ts prettyprint linenums hljs language-typescript" hw-language="ts" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// HashMap</span></li><li><span class="hljs-keyword">import</span> { <span class="hljs-title class_">HashMap</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.ArkTS'</span>; <span class="hljs-comment">// 导入HashMap模块</span></li><li>
</li><li><span class="hljs-keyword">let</span> <span class="hljs-attr">hashMap1</span>: <span class="hljs-title class_">HashMap</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();</li><li>hashMap1.<span class="hljs-title function_">set</span>(<span class="hljs-string">'a'</span>, <span class="hljs-number">123</span>); <span class="hljs-comment">// 增加一个键为'a'，值为123的元素</span></li><li><span class="hljs-keyword">let</span> <span class="hljs-attr">hashMap2</span>: <span class="hljs-title class_">HashMap</span>&lt;<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();</li><li>hashMap2.<span class="hljs-title function_">set</span>(<span class="hljs-number">4</span>, <span class="hljs-number">123</span>); <span class="hljs-comment">// 增加一个键为4，值为123的元素</span></li><li><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">`result: <span class="hljs-subst">${hashMap2.hasKey(<span class="hljs-number">4</span>)}</span>`</span>); <span class="hljs-comment">// 判断是否含有键为4的元素。输出：result: true</span></li><li><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">`result: <span class="hljs-subst">${hashMap1.get(<span class="hljs-string">'a'</span>)}</span>`</span>); <span class="hljs-comment">// 访问键为'a'的元素。输出：result: 123</span></li><li>
</li><li><span class="hljs-comment">// TreeMap</span></li><li><span class="hljs-keyword">import</span> { <span class="hljs-title class_">TreeMap</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.ArkTS'</span>; <span class="hljs-comment">// 导入TreeMap模块</span></li><li>
</li><li><span class="hljs-keyword">let</span> <span class="hljs-attr">treeMap</span>: <span class="hljs-title class_">TreeMap</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>();</li><li>treeMap.<span class="hljs-title function_">set</span>(<span class="hljs-string">'a'</span>, <span class="hljs-number">123</span>); <span class="hljs-comment">// 增加一个键为'a'，值为123的元素</span></li><li>treeMap.<span class="hljs-title function_">set</span>(<span class="hljs-string">'6'</span>, <span class="hljs-number">356</span>); <span class="hljs-comment">// 增加一个键为'6'，值为356的元素</span></li><li><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">`result: <span class="hljs-subst">${treeMap.get(<span class="hljs-string">'a'</span>)}</span>`</span>); <span class="hljs-comment">// 访问键为'a'的元素。输出：result: 123</span></li><li><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">`result: <span class="hljs-subst">${treeMap.getFirstKey()}</span>`</span>); <span class="hljs-comment">// 访问首元素。输出：result: 6</span></li><li><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">`result: <span class="hljs-subst">${treeMap.getLastKey()}</span>`</span>); <span class="hljs-comment">// 访问尾元素。输出：result: a</span></li><li>
</li><li><span class="hljs-comment">// LightWeightMap</span></li><li><span class="hljs-keyword">import</span> { <span class="hljs-title class_">LightWeightMap</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.ArkTS'</span>; <span class="hljs-comment">// 导入LightWeightMap模块</span></li><li>
</li><li><span class="hljs-keyword">let</span> <span class="hljs-attr">lightWeightMap</span>: <span class="hljs-title class_">LightWeightMap</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LightWeightMap</span>();</li><li>lightWeightMap.<span class="hljs-title function_">set</span>(<span class="hljs-string">'x'</span>, <span class="hljs-number">123</span>); <span class="hljs-comment">// 增加一个键为'x'，值为123的元素</span></li><li>lightWeightMap.<span class="hljs-title function_">set</span>(<span class="hljs-string">'8'</span>, <span class="hljs-number">356</span>); <span class="hljs-comment">// 增加一个键为'8'，值为356的元素</span></li><li><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">`result: <span class="hljs-subst">${lightWeightMap.get(<span class="hljs-string">'a'</span>)}</span>`</span>); <span class="hljs-comment">// 访问键为'a'的元素。输出：result: undefined</span></li><li><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">`result: <span class="hljs-subst">${lightWeightMap.get(<span class="hljs-string">'x'</span>)}</span>`</span>); <span class="hljs-comment">// 访问键为'x'的元素，获取其值。输出：result: 123</span></li><li><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">`result: <span class="hljs-subst">${lightWeightMap.getIndexOfKey(<span class="hljs-string">'8'</span>)}</span>`</span>); <span class="hljs-comment">// 访问键为'8'的元素，获取其索引。输出：result: 0</span></li><li>
</li><li><span class="hljs-comment">// PlainArray</span></li><li><span class="hljs-keyword">import</span> { <span class="hljs-title class_">PlainArray</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.ArkTS'</span>; <span class="hljs-comment">// 导入PlainArray模块</span></li><li>
</li><li><span class="hljs-keyword">let</span> <span class="hljs-attr">plainArray</span>: <span class="hljs-title class_">PlainArray</span>&lt;<span class="hljs-built_in">string</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PlainArray</span>();</li><li>plainArray.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-string">'sdd'</span>); <span class="hljs-comment">// 增加一个键为1，值为'sdd'的元素</span></li><li>plainArray.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>, <span class="hljs-string">'sff'</span>); <span class="hljs-comment">// 增加一个键为2，值为'sff'的元素</span></li><li><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">`result: <span class="hljs-subst">${plainArray.get(<span class="hljs-number">1</span>)}</span>`</span>); <span class="hljs-comment">// 访问键为1的元素，获取值。输出：result: sdd</span></li><li><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">`result: <span class="hljs-subst">${plainArray.getKeyAt(<span class="hljs-number">1</span>)}</span>`</span>); <span class="hljs-comment">// 访问索引为1的元素，获取键。输出：result: 2</span></li></ol></pre></div></div>    </div>   </div>   <div></div></div>