<h1 _ngcontent-gqe-c119="" class="doc-title ng-star-inserted" title="Buffer低功耗优化"> Buffer低功耗优化 </h1>

<div _ngcontent-gqe-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;"> <div><div class="tiledSection"><h2 id="section2074965114216">概述<i class="anchor-icon anchor-icon-link" anchorid="section2074965114216" tips="复制节点链接"></i></h2><p>在HarmonyOS中，Buffer是承载自绘制内容循环渲染的主要载体，有别于Vsync统一执行的思想，自绘制内容的生产不依赖于系统事件，而是由三方主导控制。Buffer在渲染过程中通过BufferQueue来进行轮转，采用了生产者与消费者的设计思想，应用将作为生产者将生产好的渲染内容准备好后，从BufferQueue中获取并Flush Buffer，而RS则作为消费者可以通过AcquireBuffer接口获取Buffer，让该Buffer作为自绘制Surface中的一帧在屏幕上显示，并将使用后的Buffer调用ReleaseBuffer释放进入轮转池。相关的流转逻辑可以参考下图：</p> <p><span><img originheight="516" originwidth="1006" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163438.72983320680055528595705242415094:50001231000000:2800:7B93EDF5AD506117BCCDFEEF282A451CDC3F3C97283E55D03E4429076CB56AD2.png" width="920" height="471.8886679920477"></span></p> <p>开发者可以通过Profiler的Trace工具分析Buffer的流转过程，可按照下图所示的顺序将相关进程置顶排列。其中OS_IPC中包含了render_service的跨进程通信信息，开发者可参考下图虚线所示，根据binder找到对应的生产者进程，详细的Trace点含义如下：</p> <ol><li>“H:RequestBuffer name: xxx queueId: 6631429506443 queueSize: 5 reserveSlotNum: 0”：位于OS_IPC线程泳道，表明Producer申请使用了一帧Buffer，通过binder与生产者的对应进程连接，由生产者执行后续业务。</li><li>“H:FlushBuffer name: xxx queueId: 6631429506443 sequence: 97784886”：位于OS_IPC线程泳道，表明名称为xxx的Surface的Buffer在此时完成内容生产，已通过BufferQueue交给了消费者侧。其中queueId是Buffer序列的独立id，sequence是每个Buffer的独立id。与此同时，OS_IPC中还可以搜到H:rs_RequestNextVSync，表明下一帧Vsync中，rs会被拉起执行后续业务。</li><li>“H:AcquireBuffer with PresentTimestamp name: xxx queueId: 6631429506443”：位于render_service线程泳道，表明名为xxx的Surface此时在rs收集该帧的绘制诉求时，rs作为消费者请求了这个Buffer，用于后续的帧绘制。如果成功获取到了该Buffer，会在子Trace中额外打印“H:acquire buffer sequence: 97784886”。</li><li>“H:ReleaseBuffer name: xxx queueId: 6631429506443 seq: 97784892”：位于RSHardware或RSUniRenderThrea线程泳道，该信息通常出现在RSHardwareThrea一帧中的最末尾，表明消费者已成功使用该Buffer，并释放该Buffer块，交还给BufferQueue。反之，如果ReleaseBuffer在RSUniRender中出现，则表明此时Buffer无需渲染在屏幕上，属于Buffer空跑问题。</li></ol> <p><span><img height="274.9496087425796" originheight="601" originwidth="2011" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163438.65244327737949730416739024744468:50001231000000:2800:0FEC9F4A43C8BFC21FD71BF3F34CF0EE698E5EDD0249F5FB3ABD4447C01B8F44.png" title="点击放大" width="920"></span></p> </div> <div class="tiledSection"><h2 id="section912089185910">分析思路<i class="anchor-icon anchor-icon-link" anchorid="section912089185910" tips="复制节点链接"></i></h2><p>在定位问题时，开发者可以按照以下步骤来确定Buffer使用是否无误：</p> <ul><li>在RSHardwareThread泳道中搜索“H:ReleaseBuffer”：如图所示，在选定的时间段内RosenWeb和DisplayNode均释放了一定次数，开发者可以根据右侧的Occurrence统计其出现次数。由于BufferQueue具有循环复用的机制，同一seq会多次复用，如图中RosenWeb由5个Buffer循环复用而成。DisplayNode是应用进程下发绘制指令并经渲染后得到的统一绘制图层，大部分ArkUI组件的刷新也在DisplayNode中体现。<p><span><img height="181.40320543496168" originheight="433" originwidth="2196" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163438.84155590072440169506281547329553:50001231000000:2800:5EE7C0C32B04CEC58884EA32B3334FBE8D7C22ADAF946CE42D708D348062F322.png" title="点击放大" width="920"></span></p> </li></ul> <ul><li>在RSUniRenderThre中搜索“H:ReleaseBuffer”：RSUniRenderThre中也会出现Buffer释放的流程，如下图所示，有一块RosenWeb的BufferQueue在框选时间内循环了174次，该Buffer并未实际造成显示效果，造成了Buffer空跑问题。<p><span><img height="162.8284458398744" originheight="386" originwidth="2181" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163439.25358088082253317958080913914486:50001231000000:2800:D3708DAA7578AC938E8D5704CA744CB45F2118C363226D9A5913C15816E95278.png" title="点击放大" width="920"></span></p> </li></ul> <ul><li>在render_service泳道中搜索“seq =  [空跑Buffer id]”：发现一个空跑的BufferQueue时，可以从中找到一个Buffer id，例如100151309，并在render_service中进行搜索。搜索结果如下，在“H:RsDebug surfaceHandler(id:xxx)”中，开发者可以确认到该Buffer所对应的RS树node id 。<p><span><img height="160.3700705882353" originheight="380" originwidth="2180" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163439.59546791841418956795246722484155:50001231000000:2800:D31A58ED6FD91F638FF9BBC5ECA91F687630648DF53539D6685E271AD54CDEBF.png" title="点击放大" width="920"></span></p> </li></ul> <p>开发者可使用HiSmartPerf工具，在“整机测试-RS树可视化展示”处展开RS树，通过id查找的方式找到此BufferQueue对应的rs节点位置，定位到导致空跑问题的自绘制内容。如下图，开发者在TabIndex为0的home页面抓取Trace发现了Buffer空跑问题，通过RsDebug找到问题node id后通过id搜索，在切换至yellow页面时，发现是此处的web buffer预渲染导致的空跑问题。</p> <div><div class="hw-editor-tip warn"><div class="title">注意</div><div class="content"><p>能够造成空跑问题的Buffer通常并不会在屏幕上显示，所以往往并不会在当前页面被发现，开发者在使用该工具时可以结合页面逻辑，上下滚动、左右切换，以及根据问题复现的步骤依次回溯路径页面来寻找有问题的RS node。</p> </div></div></div> <p><span><img height="668.6704927536231" originheight="1011" originwidth="1391" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163439.10487138845200900137727680286580:50001231000000:2800:F2D99766361428C31FB84C702848E9206234AB91C7D6FC8ACB9776A31AC8FE66.png" title="点击放大" width="920"></span></p> <p></p> </div> <div class="tiledSection"><h2 id="section18338414175">Web预渲染优化案例<i class="anchor-icon anchor-icon-link" anchorid="section18338414175" tips="复制节点链接"></i></h2></div> <div class="tiledSection"><h3 id="section6429190132111" class="firsth2">问题现象<i class="anchor-icon anchor-icon-link" anchorid="section6429190132111" tips="复制节点链接"></i></h3><p><a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-web-develop-optimization#section172031338172719" target="_blank">Web的预渲染</a>是一种广泛使用的性能优化手段，让Web组件在挂载之前完成渲染可以有效减少Web初次加载时的时延表现，但处理不当也同样可能引起Buffer类空跑问题。在Web类应用中，对于预加载的离线Web节点，开发者需要确保这些后台的Web处于冻结状态，不会产生持续性的冗余Buffer影响正常场景的功能。下图展示了一个在非Web首页通过Tab预加载两个Web页面的Trace，分析Buffer的Release情况，发现Trace中RSUniRenderThre的帧率表现高于实际的显示帧率，表明空跑问题存在。进一步观察发现，RSUni中有两处ReleaseBuffer，来自两个不同的queueId，由此可以推断该页面可能存在两个离线的Web组件正在后台渲染，带来冗余负载。</p> <p><span><img height="744.9501565607832" originheight="932" originwidth="1151" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163439.56061228466187243338731858238419:50001231000000:2800:94295D6F4BEA177E06445EC4EA27EE272D90A3E61898FEEA702DA079BE8671A6.png" title="点击放大" width="920"></span></p> <p>开发者可以通过HiSmartPerf的RS树工具定位Buffer位置，除此之外，推荐开发者充分利用Web DevTools工具，参考<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/web-debugging-with-devtools" target="_blank">使用DevTools工具调试前端页面</a>，开发者可以通过端口投射的方式展示当前页面中所有的Web页面加载情况。如下图所示，端口投射成功后“1”处填写投射端口，“2”处将显示所有创建成功的web对象，点击其中的两个网页可查看其当前活跃状态，如“3”“4”则分别对应了处于冻结状态和活跃状态的页面，点击inspect观察表现情况。这种活跃/冻结状态可以调用webcontroller.onActive/onInactive来控制，原则上，并非在屏幕显示范围内的Web不应处于活跃状态，避免带来Buffer空跑问题。</p> <p><span><img height="512.668051" originheight="1255" originwidth="1915" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163439.67457402728165609802070814286996:50001231000000:2800:452F960F82880317591E2C5EBC95761CD056B4417255833E4AF8CADAFB9FE75D.png" title="点击放大" width="782.288444"></span></p> </div> <div class="tiledSection"><h3 id="section1318144183010">优化思路<i class="anchor-icon anchor-icon-link" anchorid="section1318144183010" tips="复制节点链接"></i></h3><div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"><p>当前系统对Web组件接入了<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-component-visible-area-change-event#onvisibleareaapproximatechange17" target="_blank">可见性回调</a>来方便开发者规避大部分Web空跑问题，该接口可以保证当Web挂载到ArkUI树上之后，跟随Web组件的可见性来控制Controller，当组件不可见时设置Web为冻结，可见时设置为活跃。但可见性接口对于离线组件不会返回结果，依赖三方开发者进行控制。</p> </div></div></div> <p>开发者可通过<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/arkts-apis-webview-webviewcontroller" target="_blank">WebviewController</a>的onActive()和onInactive()来控制Web的活跃与冻结，冻结态的Web处于后台不会生产Buffer，可保证功耗收益。当开发者<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/web-offline-mode#预渲染web页面" target="_blank">使用离线Web组件</a>或主动调用了preloaditems()等方法时，建议在Web容器中添加onFirstMeaningfulPaint()回调，确保Web离线加载时，在完成第一次页面渲染之后进入冻结状态，既能保证进入预渲染Web时能够快速打开第一帧内容，也能保证其后台不产生冗余Buffer。</p> <div class="screenLinkPre"><div _ngcontent-gqe-c106="" class="highlight-div"><div _ngcontent-gqe-c106="" class="highlight-div-header"><div _ngcontent-gqe-c106="" class="highlight-div-header-left"><div _ngcontent-gqe-c106="" class="handle-button expand-button"><div _ngcontent-gqe-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-gqe-c106="" class="highlight-div-header-right"><div _ngcontent-gqe-c106="" class="handle-button ai-button"></div><div _ngcontent-gqe-c106="" class="handle-button line-button"><div _ngcontent-gqe-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-gqe-c106="" class="handle-button theme-button"><div _ngcontent-gqe-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-gqe-c106="" class="handle-button copy-button"><div _ngcontent-gqe-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-gqe-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-kotlin" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/PowerAnalysis/LowerPowerSample/entry/src/main/ets/pages/buffer_power_example.ets#L24-L45" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-meta">@Component</span></li><li>struct MyWebComponent {</li><li>  <span class="hljs-keyword">private</span> src: string = <span class="hljs-string">""</span></li><li>  <span class="hljs-keyword">private</span> controller1: webview.WebviewController = new webview.WebviewController();</li><li>  shouldDraw: boolean = <span class="hljs-literal">true</span>;</li><li>  build() {</li><li>    Web({ src: <span class="hljs-keyword">this</span>.src, controller: <span class="hljs-keyword">this</span>.controller1 })</li><li>      .onPageBegin(() =&gt; {</li><li>        console.log(<span class="hljs-keyword">this</span>.src, <span class="hljs-string">"webpage is onActive"</span>)</li><li>        <span class="hljs-keyword">this</span>.controller1.onActive();</li><li>      })</li><li>
</li><li>      .onFirstMeaningfulPaint(() =&gt; {</li><li>        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.shouldDraw) {</li><li>          <span class="hljs-keyword">return</span>;</li><li>        }</li><li>        console.log(<span class="hljs-keyword">this</span>.src, <span class="hljs-string">"webpage is onInactive"</span>)</li><li>        <span class="hljs-keyword">this</span>.controller1.onInactive()</li><li>        <span class="hljs-keyword">this</span>.shouldDraw = <span class="hljs-literal">false</span></li><li>      })</li><li>  }</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/PowerAnalysis/LowerPowerSample/entry/src/main/ets/pages/buffer_power_example.ets#L24-L45" target="_blank">buffer_power_example.ets</a></div></div></div></div> <div><div class="hw-editor-tip warn"><div class="title">注意</div><div class="content"><p>Tab是一种较为特殊的加载结构，Tab默认的切换动效会将路径中的TabContent进行构建，此时位于路径TabContent中的Web组件，会由于隐式动效的特性无法响应可见性回调。对于使用了Tab+Web的开发者，推荐在接入onFirstMeaningFulPaint()首帧冻结的基础上，主动调用<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-tabs#preloaditems12" target="_blank">preloadItems</a>()方法对Tabs进行预加载。若不进行预加载，需确保onPageBegin()中，不将controller设置为活跃状态。</p> </div></div></div> </div> <div class="tiledSection"><h2 id="section448211416537">自绘制组件空跑优化案例<i class="anchor-icon anchor-icon-link" anchorid="section448211416537" tips="复制节点链接"></i></h2></div> <div class="tiledSection"><h3 id="section1758252915556" class="firsth2">问题现象<i class="anchor-icon anchor-icon-link" anchorid="section1758252915556" tips="复制节点链接"></i></h3><p><span><img height="315.7649833020416" originheight="671" originwidth="1955" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163439.18114465285941799615959073678466:50001231000000:2800:530C73E882EBE893A06EBBA84A152E7DDC0AB329F87772880C7FB4F93DD03871.png" title="点击放大" width="920"></span></p> <p>上图展示了一个位于可滑动列表中的Video组件从屏幕外滑动至屏幕内的应用场景。其中“1”处的信息代表页面滑动的时机，“2”处的信息表明，视频的硬解码进程一直持续着产生。观察“3”“4”两处的差异可以发现，当Video组件位于屏幕外时，由于Buffer的持续生产造成了RSUni持续ReleaseBuffer，引发空跑问题。原则上，开发者所使用的自绘制图层需要对其ArkUI载体（如Video、XComponent等）添加充分的事件监听，确保其不再需要显示时，从Buffer生产的源头上停止。</p> </div> <div class="tiledSection"><h3 id="section12421164312516">优化思路<i class="anchor-icon anchor-icon-link" anchorid="section12421164312516" tips="复制节点链接"></i></h3><div class="screenLinkPre"><div _ngcontent-gqe-c106="" class="highlight-div"><div _ngcontent-gqe-c106="" class="highlight-div-header"><div _ngcontent-gqe-c106="" class="highlight-div-header-left"><div _ngcontent-gqe-c106="" class="handle-button expand-button"><div _ngcontent-gqe-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-gqe-c106="" class="highlight-div-header-right"><div _ngcontent-gqe-c106="" class="handle-button ai-button"></div><div _ngcontent-gqe-c106="" class="handle-button line-button"><div _ngcontent-gqe-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-gqe-c106="" class="handle-button theme-button"><div _ngcontent-gqe-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-gqe-c106="" class="handle-button copy-button"><div _ngcontent-gqe-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-gqe-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-typescript" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/PowerAnalysis/LowerPowerSample/entry/src/main/ets/pages/buffer_power_example.ets#L49-L84" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-meta">@Component</span></li><li><span class="hljs-keyword">export</span> struct <span class="hljs-title class_">MyVideoComponent</span> {</li><li>  <span class="hljs-meta">@State</span> <span class="hljs-attr">videoSrc</span>: <span class="hljs-title class_">Resource</span> | <span class="hljs-built_in">string</span> = $r(<span class="hljs-string">'app.media.test_video'</span>);</li><li>  <span class="hljs-keyword">private</span> <span class="hljs-attr">controller</span>: <span class="hljs-title class_">VideoController</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VideoController</span>();</li><li>
</li><li>
</li><li>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) {</li><li>    <span class="hljs-title class_">Column</span>() {</li><li>      <span class="hljs-title class_">Video</span>({</li><li>        <span class="hljs-attr">src</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">videoSrc</span>,</li><li>        <span class="hljs-attr">controller</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">controller</span>,</li><li>
</li><li>      })</li><li>        .<span class="hljs-title function_">width</span>(<span class="hljs-number">300</span>)</li><li>        .<span class="hljs-title function_">height</span>(<span class="hljs-number">200</span>)</li><li>        .<span class="hljs-title function_">onPrepared</span>(<span class="hljs-function">() =&gt;</span> {</li><li>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">controller</span>.<span class="hljs-title function_">start</span>();</li><li>        })</li><li>        <span class="hljs-comment">// 确保视频组件完全可见时播放，完全不可见时停止</span></li><li>        .<span class="hljs-title function_">onVisibleAreaChange</span>([<span class="hljs-number">0.0</span>], <span class="hljs-function">(<span class="hljs-params">isExpanding: <span class="hljs-built_in">boolean</span>, currentRatio: <span class="hljs-built_in">number</span></span>) =&gt;</span> {</li><li>          <span class="hljs-keyword">if</span> (isExpanding &amp;&amp; currentRatio &gt;= <span class="hljs-number">1.0</span>) {</li><li>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">'Component is completely visiable.'</span>);</li><li>            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">controller</span>) {</li><li>              <span class="hljs-variable language_">this</span>.<span class="hljs-property">controller</span>.<span class="hljs-title function_">start</span>();</li><li>            }</li><li>          }</li><li>          <span class="hljs-keyword">if</span> (!isExpanding &amp;&amp; currentRatio &lt;= <span class="hljs-number">0.0</span>) {</li><li>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">'Component is completely invisible.'</span>);</li><li>            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">controller</span>) {</li><li>              <span class="hljs-variable language_">this</span>.<span class="hljs-property">controller</span>.<span class="hljs-title function_">pause</span>();</li><li>            }</li><li>          }</li><li>        })</li><li>    }</li><li>  }</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/PowerAnalysis/LowerPowerSample/entry/src/main/ets/pages/buffer_power_example.ets#L49-L84" target="_blank">buffer_power_example.ets</a></div></div></div></div> <p>如上代码所示，开发者可利用可见性监听，判断当前呈现自绘制内容的ArkUI组件是否位于显示范围，通过控制Video.controller，控制视频在可见时播放，不可见时停止。</p> </div> <div class="tiledSection"><h2 id="section14283355111612">自绘制图层GPU重绘问题低功耗建议<i class="anchor-icon anchor-icon-link" anchorid="section14283355111612" tips="复制节点链接"></i></h2></div> <div class="tiledSection"><h3 id="section1880814012109" class="firsth2">问题现象<i class="anchor-icon anchor-icon-link" anchorid="section1880814012109" tips="复制节点链接"></i></h3></div> <p><span><img height="299.442451" originheight="1242" originwidth="2503" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163439.62426853904695689808036539982466:50001231000000:2800:6D362F3807CB41E2BDCEB412F1353603ACFA7B72A65006D22AA3FB3AB7E76FCD.png" title="点击放大" width="603.4875000000001"></span></p> <p>对于使用了自绘制图层的应用页面而言，开发者还需要考虑该自绘制图层与当前页面中已有的图层如DisplayNode之间的交叠关系。理想情况下，自绘制图层完成生产后，如果无需与其他图层产生更多叠加计算时，无需交由RSUniRender线程重新处理，可直接交由RSHardware显示，这种显示方式可称之为“直通”。反之，如果开发者对承载自绘制组件的容器设定了一些图形绘制效果，例如模糊、透明、提亮等，那么RSUniRender需要将已经渲染好的Buffer，与作为背景的DisplayNode进行交叠计算。在这种情况下，自绘制图层不得不在RSUniRender中提前释放Buffer，将自绘制图层的内容由GPU进行重绘，并重新作为DisplayNode的一部分，再交由RSHardware进行显示，这种现象可称之为“GPU重绘”问题。</p> <div><div class="hw-editor-tip err"><div class="title">警告</div><div class="content"><p>GPU重绘问题对功耗的影响巨大，且多数情况下，开发者所设置的背景色、透明度等属性实际带来的显示效果在自绘制图层的覆盖下，效果并不明显。由于自绘制图层的生产本身也会消耗较多CPU和GPU的计算资源，持续性的GPU重绘将会占据更高的计算资源，引起明显发热。特别地，对于Web、XComponent等容器，不建议开发者主动设置背景色与透明度。</p> </div></div></div> <p>以下是一些常见的“GPU重绘”问题的根因。</p> <ul><li>filter效果：自绘制图层本身或与之相交叠的组件具有filter效果，包括模糊、提亮、blendMode等效果，导致图层需要重新GPU计算</li><li>背景颜色：图层背景颜色带透明度，导致合成时不得不与其他图层做叠加计算</li><li>图层格式：当前系统的直通绘制，不支持非HEBC格式且旋转的buffer直接在线合成，对于视频播放、通话、会议场景，建议开发者<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkgraphics-2d-14" target="_blank">主动关闭CPU访问窗口缓冲区</a>（适配HEBC格式）。HEBC格式的图层本身在绘制时对CPU更加友好，可以带来更好的功耗表现，减少发热风险。</li></ul> <div class="tiledSection"><h3 id="section184194138919">问题定位<i class="anchor-icon anchor-icon-link" anchorid="section184194138919" tips="复制节点链接"></i></h3><p><span><img height="353.3583873811907" originheight="502" originwidth="1307" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163439.22274047523363340171838063797665:50001231000000:2800:D7FB7BF1EB341BFF64678A8964167B11C5636159D9B874E36D7909007293E8A1.png" title="点击放大" width="920"></span></p> <p>开发者可以搜索“DrawImage”判断有无GPU重绘问题产生，如上图，给一个纯净的适配播放图层设置了一个透明度，进而引发GPU重绘问题发生，开发者可根据以下几个Trace点定位问题：</p> <ol><li>H:AcquireBuffer name: Surface queueId: 6605659702100：对应自绘制图层Buffer获取时机</li><li>H:RSBaseRenderEngine::DrawImage(GPU) targetColorGamut=4：“DrawImage(GPU)”表明存在GPU重绘现象，targetColorGamut=4表明该Surface在合成时，有四个buffer的内容，其中固定存在的三个Buffer分别是Display和两个固定圆角图层，当该值大于3时，表明有其他来源的Buffer进行了重绘进入了DisplayNode</li><li>H:ReleaseBuffer name: Surface queueId: 6605659702100 seq: 100801225：Buffer在RSUni中释放，此时Buffer的内容已经在DisplayNode中，Buffer重新流入BufferQueue</li><li>H:ReleaseBuffer name: DisplayNode queueId: 6605659701285 seq: 100798111：DisplayNode在RSHardware中释放</li></ol> <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"><p>在上图所示的案例中，观察发现render_service里既没有ProcessCommandUni、也没有Animate的有效信息，表明此时DisplayNode并无实际刷新任务执行。但由于GPU重绘问题的存在，DisplayNode也会全程参与Buffer轮转过程，并产生图层计算功耗。</p> </div></div></div> </div> <div class="tiledSection"><h3 id="section4124202216014">优化思路<i class="anchor-icon anchor-icon-link" anchorid="section4124202216014" tips="复制节点链接"></i></h3><p><span><img height="562.599975" originheight="1152" originwidth="1538" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163439.60722680478991242367893313421449:50001231000000:2800:B7B8BDF90E8BAE10F89AD9A2132F55AA6EB40DBD45A523617563562D78333977.png" title="点击放大" width="751.1175000000001"></span></p> <p>如上图，开发者可以使用HiSmartPerf的RS树工具查看可疑节点，在OtherModifier位置可以查看到来自pid进程58867，为该节点添加了一个0.4的Alpha透明度，结合该信息可进一步定位到对应的代码片段，如下图代码，注释掉透明度效果后问题不复现。</p> <div class="screenLinkPre"><div _ngcontent-gqe-c106="" class="highlight-div"><div _ngcontent-gqe-c106="" class="highlight-div-header"><div _ngcontent-gqe-c106="" class="highlight-div-header-left"><div _ngcontent-gqe-c106="" class="handle-button expand-button"><div _ngcontent-gqe-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-gqe-c106="" class="highlight-div-header-right"><div _ngcontent-gqe-c106="" class="handle-button ai-button"></div><div _ngcontent-gqe-c106="" class="handle-button line-button"><div _ngcontent-gqe-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-gqe-c106="" class="handle-button theme-button"><div _ngcontent-gqe-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-gqe-c106="" class="handle-button copy-button"><div _ngcontent-gqe-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-gqe-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-cangjie" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/PowerAnalysis/LowerPowerSample/entry/src/main/ets/pages/buffer_power_example.ets#L89-L110" data-highlighted="yes"><ol class="linenums"><li>@<span class="hljs-title function_">Component</span></li><li><span class="hljs-variable">export</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyVideoComponent_opacity</span> {</li><li>  @<span class="hljs-title function_">State</span> <span class="hljs-variable">videoSrc</span>: <span class="hljs-title class_">Resource</span> | <span class="hljs-title class_">string</span> = $<span class="hljs-title function_">r</span>(<span class="hljs-string">'app.media.test_video'</span>);</li><li>  <span class="hljs-keyword">private</span> <span class="hljs-variable">controller</span>: <span class="hljs-title class_">VideoController</span> = <span class="hljs-variable">new</span> <span class="hljs-title function_">VideoController</span>();</li><li>
</li><li>
</li><li>  <span class="hljs-title function_">build</span>() {</li><li>    <span class="hljs-title function_">Column</span>() {</li><li>      <span class="hljs-title function_">Video</span>({</li><li>        <span class="hljs-variable">src</span>: <span class="hljs-keyword">this</span>.<span class="hljs-title class_">videoSrc</span>,</li><li>        <span class="hljs-variable">controller</span>: <span class="hljs-keyword">this</span>.<span class="hljs-title class_">controller</span>,</li><li>
</li><li>      })</li><li>        .<span class="hljs-title function_">width</span>(<span class="hljs-number">300</span>)</li><li>        .<span class="hljs-title function_">height</span>(<span class="hljs-number">200</span>)</li><li>        <span class="hljs-comment">// .opacity(0.4) 注释掉此段代码，可规避GPU重绘</span></li><li>        .<span class="hljs-title function_">onPrepared</span>(() =&gt; {</li><li>          <span class="hljs-keyword">this</span>.<span class="hljs-variable">controller</span>.<span class="hljs-title function_">start</span>();</li><li>        })</li><li>    }</li><li>  }</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/PowerAnalysis/LowerPowerSample/entry/src/main/ets/pages/buffer_power_example.ets#L89-L110" target="_blank">buffer_power_example.ets</a></div></div></div></div> <p>修改好的Trace表现如下图所示，在直通情况下，自绘制图层在图中“1”处获取Buffer，“2”处释放Buffer，无需交由RSUniRender进行重绘计算，也没有DisplayNode的刷新显示，达到预期的低功耗效果。</p> <p><span><img height="372.78463600000003" originheight="512" originwidth="996" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163439.54287100993449233804798845013119:50001231000000:2800:0F449BB7A6781351D1FB7DF2F2EA6C5CCE770ED1D95E24B7D4E1F13D5999E6DE.png" title="点击放大" width="725.1825"></span></p> <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"><p>以下效果会导致自绘制图层GPU重绘，非必要显示效果，不建议开发者接入：</p> <ul><li>使用<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-opacity#opacity18" target="_blank">opacity</a>属性，给自绘制组件设置透明度</li><li>使用<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-foreground-effect#foregroundeffect" target="_blank">foregroundEffect</a>实现前景模糊，<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-image-effect#blur" target="_blank">blur</a>实现背景模糊</li><li>使用<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-image-effect#grayscale" target="_blank">grayscale</a>，实现灰阶效果</li><li>使用<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-image-effect#lightupeffect12" target="_blank">lightUpEffect</a>，强行对图层进行压暗提亮</li><li>特别地，对于Web、XComponent组件，建议设置背景色为黑色不透明，或不主动设置<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-background#backgroundcolor" target="_blank">backgroundColor</a>属性</li></ul> </div></div></div> </div> </div> <div></div></div>