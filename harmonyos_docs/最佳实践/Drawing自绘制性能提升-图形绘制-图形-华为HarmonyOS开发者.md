<h1 _ngcontent-lhi-c119="" class="doc-title ng-star-inserted" title="Drawing自绘制性能提升"> Drawing自绘制性能提升 </h1>

<div _ngcontent-lhi-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;"> <div><div class="tiledSection"><h2 id="section8763719198">概述<i class="anchor-icon anchor-icon-link" anchorid="section8763719198" tips="复制节点链接"></i></h2><p><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-components-canvas-canvas" target="_blank">Canvas</a>画布组件是用来显示自绘内容的组件，它具有保留历史绘制内容、增量绘制的特点。Canvas有<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-canvasrenderingcontext2d" target="_blank">CanvasRenderingContext2D</a>/<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-offscreencanvasrenderingcontext2d" target="_blank">OffscreenCanvasRenderingContext2D</a>和<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-drawingrenderingcontext" target="_blank">DrawingRenderingContext</a>两套API，应用使用两套绘制API绘制的内容都可以在绑定的Canvas组件上显示。其中CanvasRenderingContext2D按照W3C标准封装了Native Drawing接口，可以方便快速复用Web应用的绘制逻辑，因此非常适用于Web应用和游戏、快速原型设计、数据可视化、在线绘图板、教学工具或创意应用等场景。</p> <p>为了遵循W3C标准，实现过程中进行了多层的封装，涉及一些数据结构的转换，不如原生API那样接近硬件，因此对于性能要求比较高、绘制比较复杂，或者硬件依赖性比较强的场景（如高性能游戏开发、专业图形处理软件、桌面或移动应用等），使用Canvas CanvasRenderingContext2D绘制会存在一定的卡顿、掉帧等性能问题，此时可以直接使用Native Drawing接口自绘制替代Canvas CanvasRenderingContext2D绘制来提升绘制性能。</p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><tbody><tr><td class="cellrowborder" valign="top" width="33.333333333333336%"><p>方案</p> </td> <td class="cellrowborder" valign="top" width="33.333333333333336%"><p>适用场景</p> </td> <td class="cellrowborder" valign="top" width="33.333333333333336%"><p>特点</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="33.333333333333336%"><p>使用Canvas CanvasRenderingContext2D</p> </td> <td class="cellrowborder" valign="top" width="33.333333333333336%"><p>Web应用和游戏、快速原型设计、数据可视化、在线绘图板、教学工具、创意应用</p> </td> <td class="cellrowborder" valign="top" width="33.333333333333336%"><p>场景简单、跨平台、快捷灵活、兼容性强、开发维护成本低、性能要求低。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="33.333333333333336%"><p>使用Native Drawing</p> </td> <td class="cellrowborder" valign="top" width="33.333333333333336%"><p>高性能游戏开发、专业图形处理软件、桌面或移动应用开发</p> </td> <td class="cellrowborder" valign="top" width="33.333333333333336%"><p>场景复杂、资源管理精细、硬件依赖强、与平台深度集成、定制化、性能要求高。</p> </td> </tr>  </tbody></table></div> </div> </div> <div class="tiledSection"><h2 id="section239651941911">原理机制<i class="anchor-icon anchor-icon-link" anchorid="section239651941911" tips="复制节点链接"></i></h2><p>由于Canvas CanvasRenderingContext2D绘制本质上是对Native Drawing接口的封装，相对于直接使用Native Drawing接口，Canvas CanvasRenderingContext2D在实现过程中进行了多层的封装，涉及一些数据结构的转换。如果图片绘制比较复杂，执行的绘制指令可能会成倍数的增长，进而绘制性能下降的更加严重，导致卡顿、掉帧等问题。下面以实现在背景图上绘制1000个透明空心圆的玻璃效果来对比两者的性能差异。</p> </div> <div class="tiledSection"><h2 id="section910774131915">场景示例<i class="anchor-icon anchor-icon-link" anchorid="section910774131915" tips="复制节点链接"></i></h2><p>下图是一个绘制1000个透明空心圆与背景图融合的绘制场景，下面分别使用Canvas CanvasRenderingContext2D和Native侧的Drawing来实现该场景，并分析两者的性能差异。</p> <p><span><img height="545.5261" originheight="720" originwidth="348" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163048.65669317227277458543517272919565:50001231000000:2800:B53FD26C0FE32925E79DA3FBE009E19CE1667FF759D86C42E3BF9B746AED3699.gif" title="点击放大" width="266"></span></p> </div> <div class="tiledSection"><h3 id="section13561332202019" class="firsth2">使用Canvas CanvasRenderingContext2D绘制<i class="anchor-icon anchor-icon-link" anchorid="section13561332202019" tips="复制节点链接"></i></h3></div> <p>Canvas CanvasRenderingContext2D使用<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-canvasrenderingcontext2d#globalcompositeoperation" target="_blank">globalCompositeOperation</a>属性来实现各种图层混合模式，此处将该属性的值设置为destination-out来实现透明空心圆。具体实现步骤如下：</p> <ol><li>使用自定义组件GlassCoverView来实现透明圆圈。在首页点击"Begin Draw"按钮，随机生成1000个0-1的位置列表。<div class="screenLinkPre"><div _ngcontent-lhi-c106="" class="highlight-div"><div _ngcontent-lhi-c106="" class="highlight-div-header"><div _ngcontent-lhi-c106="" class="highlight-div-header-left"><div _ngcontent-lhi-c106="" class="handle-button expand-button"><div _ngcontent-lhi-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-lhi-c106="" class="highlight-div-header-right"><div _ngcontent-lhi-c106="" class="handle-button ai-button"></div><div _ngcontent-lhi-c106="" class="handle-button line-button"><div _ngcontent-lhi-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-lhi-c106="" class="handle-button theme-button"><div _ngcontent-lhi-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-lhi-c106="" class="handle-button copy-button"><div _ngcontent-lhi-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-lhi-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-cangjie" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/NdkDrawing/entry/src/main/ets/view/Index.ets#L17-L61" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">import</span> <span class="hljs-package">GlassCoverView</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./GlassCoverView'</span>;</li><li>
</li><li>@<span class="hljs-title function_">Entry</span></li><li>@<span class="hljs-title function_">Component</span></li><li><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Index</span> {</li><li>  @<span class="hljs-title function_">State</span> <span class="hljs-variable">pointsToDraw</span>: <span class="hljs-title class_">number</span>[][] = [];</li><li>
</li><li>  <span class="hljs-comment">/**</span></li><li><span class="hljs-comment">   * Make a list of 1000 0-1 positions and draw circles at the corresponding positions</span></li><li><span class="hljs-comment">   */</span></li><li>  <span class="hljs-title function_">startDraw</span>(): <span class="hljs-title class_">void</span> {</li><li>    <span class="hljs-keyword">this</span>.<span class="hljs-variable">pointsToDraw</span> = [];</li><li>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> <span class="hljs-variable">index</span> = <span class="hljs-number">0</span>; <span class="hljs-variable">index</span> &lt; <span class="hljs-number">1000</span>; <span class="hljs-title class_">index</span>++) {</li><li>      <span class="hljs-keyword">this</span>.<span class="hljs-variable">pointsToDraw</span>.<span class="hljs-title function_">push</span>([<span class="hljs-variable">Math</span>.<span class="hljs-title function_">random</span>(), <span class="hljs-variable">Math</span>.<span class="hljs-title function_">random</span>()]);</li><li>    }</li><li>  }</li><li>
</li><li>  <span class="hljs-title function_">build</span>() {</li><li>    <span class="hljs-title function_">Stack</span>() {</li><li>      <span class="hljs-title function_">Image</span>($<span class="hljs-title function_">r</span>(<span class="hljs-string">'app.media.layered_image'</span>))</li><li>        .<span class="hljs-title function_">width</span>(<span class="hljs-string">'100%'</span>)</li><li>        .<span class="hljs-title function_">height</span>(<span class="hljs-string">'100%'</span>)</li><li>      <span class="hljs-comment">// Transparent circle custom component, in which 1000 transparent circles are drawn</span></li><li>      <span class="hljs-title function_">GlassCoverView</span>({ <span class="hljs-variable">pointsToDraw</span>: <span class="hljs-keyword">this</span>.<span class="hljs-title class_">pointsToDraw</span> })</li><li>        .<span class="hljs-title function_">width</span>(<span class="hljs-string">'100%'</span>)</li><li>        .<span class="hljs-title function_">height</span>(<span class="hljs-string">'100%'</span>)</li><li>      <span class="hljs-title function_">Row</span>() {</li><li>        <span class="hljs-title function_">Button</span>(<span class="hljs-string">'Begin Draw'</span>)</li><li>          .<span class="hljs-title function_">width</span>(<span class="hljs-string">'100%'</span>)</li><li>          .<span class="hljs-title function_">height</span>(<span class="hljs-number">40</span>)</li><li>      }</li><li>      .<span class="hljs-title function_">padding</span>({</li><li>        <span class="hljs-variable">right</span>: <span class="hljs-number">16</span>,</li><li>        <span class="hljs-variable">bottom</span>: <span class="hljs-number">16</span>,</li><li>        <span class="hljs-variable">left</span>: <span class="hljs-number">16</span></li><li>      })</li><li>      .<span class="hljs-title function_">onClick</span>(() =&gt; {</li><li>        <span class="hljs-keyword">this</span>.<span class="hljs-title function_">startDraw</span>();</li><li>      })</li><li>    }</li><li>    .<span class="hljs-title function_">alignContent</span>(<span class="hljs-variable">Alignment</span>.<span class="hljs-variable">Bottom</span>)</li><li>    .<span class="hljs-title function_">width</span>(<span class="hljs-string">'100%'</span>)</li><li>    .<span class="hljs-title function_">height</span>(<span class="hljs-string">'100%'</span>)</li><li>  }</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/NdkDrawing/entry/src/main/ets/view/Index.ets#L17-L61" target="_blank">Index.ets</a></div></div></div></div> </li><li>GlassCoverView子页面使用@Watch装饰器，监控到首页位置列表数据pointsToDraw更新后，在页面上绘制1000个透明空心圆圈（具体参见 onDraw()方法）。<div class="screenLinkPre"><div _ngcontent-lhi-c106="" class="highlight-div"><div _ngcontent-lhi-c106="" class="highlight-div-header"><div _ngcontent-lhi-c106="" class="highlight-div-header-left"><div _ngcontent-lhi-c106="" class="handle-button expand-button"><div _ngcontent-lhi-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-lhi-c106="" class="highlight-div-header-right"><div _ngcontent-lhi-c106="" class="handle-button ai-button"></div><div _ngcontent-lhi-c106="" class="handle-button line-button"><div _ngcontent-lhi-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-lhi-c106="" class="handle-button theme-button"><div _ngcontent-lhi-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-lhi-c106="" class="handle-button copy-button"><div _ngcontent-lhi-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-lhi-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-kotlin" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/NdkDrawing/entry/src/main/ets/view/GlassCoverView.ets#L17-L91" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">import</span> { hilog, hiTraceMeter } from <span class="hljs-string">'@kit.PerformanceAnalysisKit'</span>;</li><li>
</li><li><span class="hljs-keyword">const</span> DOMAIN = <span class="hljs-number">0x0000</span>;</li><li><span class="hljs-keyword">const</span> TAG = <span class="hljs-string">'GlassCoverView'</span>;</li><li><span class="hljs-keyword">const</span> FORMAT = <span class="hljs-string">'%{public}s'</span>;</li><li>
</li><li><span class="hljs-comment">/**</span></li><li><span class="hljs-comment"> * Glass cladding effect</span></li><li><span class="hljs-comment"> */</span></li><li><span class="hljs-meta">@Preview</span></li><li><span class="hljs-meta">@Component</span></li><li>export default struct GlassCoverView {</li><li>  <span class="hljs-meta">@Prop</span> <span class="hljs-meta">@Watch(<span class="hljs-string">'onDraw'</span>)</span> pointsToDraw: number[][] = [];</li><li>  <span class="hljs-keyword">private</span> settings = new RenderingContextSettings(<span class="hljs-literal">true</span>);</li><li>  <span class="hljs-keyword">private</span> renderContext = new CanvasRenderingContext2D(<span class="hljs-keyword">this</span>.settings);</li><li>  <span class="hljs-keyword">private</span> viewWidth: number = <span class="hljs-number">0</span>;</li><li>  <span class="hljs-keyword">private</span> viewHeight: number = <span class="hljs-number">0</span>;</li><li>
</li><li>  build() {</li><li>    Stack() {</li><li>      Canvas(<span class="hljs-keyword">this</span>.renderContext)</li><li>        .width(<span class="hljs-string">'100%'</span>)</li><li>        .height(<span class="hljs-string">'100%'</span>)</li><li>        .onAreaChange((_: Area, newValue: Area) =&gt; {</li><li>          <span class="hljs-keyword">this</span>.handleAreaChange(newValue);</li><li>        })</li><li>    }</li><li>    .height(<span class="hljs-string">'100%'</span>)</li><li>    .width(<span class="hljs-string">'100%'</span>)</li><li>  }</li><li>
</li><li>  <span class="hljs-keyword">private</span> handleAreaChange(area: Area): void {</li><li>    <span class="hljs-keyword">this</span>.viewWidth = parseInt(area.width.toString());</li><li>    <span class="hljs-keyword">this</span>.viewHeight = parseInt(area.height.toString());</li><li>    <span class="hljs-keyword">this</span>.onDraw();</li><li>  }</li><li>
</li><li>  <span class="hljs-keyword">private</span> onDraw(): void {</li><li>    <span class="hljs-keyword">const</span> canvas = <span class="hljs-keyword">this</span>.renderContext;</li><li>    canvas.reset();</li><li>    <span class="hljs-keyword">if</span> (canvas === undefined) {</li><li>      <span class="hljs-keyword">return</span>;</li><li>    }</li><li>    <span class="hljs-comment">// Hollow transparent circle</span></li><li>    hiTraceMeter.startTrace(<span class="hljs-string">'slow'</span>, <span class="hljs-number">1</span>);</li><li>    hilog.info(DOMAIN, TAG, FORMAT, <span class="hljs-string">'debug: slow start'</span>);</li><li>    <span class="hljs-comment">// Save drawing context</span></li><li>    canvas.save();</li><li>    <span class="hljs-comment">// Clears the specified pixel within the given rectangle</span></li><li>    canvas.clearRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>.viewWidth, <span class="hljs-keyword">this</span>.viewHeight);</li><li>    <span class="hljs-comment">// Specifies the fill color of the drawing</span></li><li>    canvas.fillStyle = <span class="hljs-string">'#77CCCCCC'</span>;</li><li>    <span class="hljs-comment">// Fill a rectangle</span></li><li>    canvas.fillRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>.viewWidth, <span class="hljs-keyword">this</span>.viewHeight);</li><li>    <span class="hljs-comment">// Draw a hollow circle</span></li><li>    canvas.globalCompositeOperation = <span class="hljs-string">'destination-out'</span>;</li><li>    canvas.fillStyle = <span class="hljs-string">'#CCCCCC'</span>;</li><li>    <span class="hljs-keyword">this</span>.pointsToDraw.forEach((xy: number[]) =&gt; {</li><li>      <span class="hljs-keyword">this</span>.drawOneCell(canvas, xy[<span class="hljs-number">0</span>] * <span class="hljs-keyword">this</span>.viewWidth, xy[<span class="hljs-number">1</span>] * <span class="hljs-keyword">this</span>.viewHeight, <span class="hljs-keyword">this</span>.getUIContext().px2vp(<span class="hljs-number">15</span>));</li><li>    })</li><li>    canvas.fill();</li><li>    <span class="hljs-comment">// Restore the saved drawing context</span></li><li>    canvas.restore();</li><li>    hilog.info(DOMAIN, TAG, FORMAT, <span class="hljs-string">'debug: slow end'</span>);</li><li>    hiTraceMeter.finishTrace(<span class="hljs-string">'slow'</span>, <span class="hljs-number">1</span>);</li><li>  }</li><li>
</li><li>  <span class="hljs-comment">/**</span></li><li><span class="hljs-comment">   * Draw a circle according to the specified position and width</span></li><li><span class="hljs-comment">   */</span></li><li>  <span class="hljs-keyword">private</span> drawOneCell(canvas: CanvasRenderer, x: number, y: number, width: number): void {</li><li>    canvas.moveTo(x + width, y);</li><li>    canvas.arc(x, y, width, <span class="hljs-number">0</span>, Math.PI * <span class="hljs-number">2</span>);</li><li>  }</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/NdkDrawing/entry/src/main/ets/view/GlassCoverView.ets#L17-L91" target="_blank">GlassCoverView.ets</a></div></div></div></div> <p>使用Canvas CanvasRenderingContext2D绘制的trace图，可以看到绘制1000个圆圈耗时14.9毫秒。</p> <p><span><img originheight="559" originwidth="1188" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163048.61795866323990378324839841926553:50001231000000:2800:FDA120E2977B16160CEF98B02D54A3B9FD497CD835D297FCE8AE914D98B13117.png" width="920" height="432.8956228956229"></span></p> <p></p> </li></ol> <div class="tiledSection"><h3 id="section0256183611257">使用Native侧Drawing绘制<i class="anchor-icon anchor-icon-link" anchorid="section0256183611257" tips="复制节点链接"></i></h3><p>Native Drawing主要使用分层接口<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-drawing-canvas-h#oh_drawing_canvassavelayer" target="_blank">OH_Drawing_CanvasSaveLayer</a>和融合接口<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-drawing-brush-h#oh_drawing_brushsetblendmode" target="_blank">OH_Drawing_BrushSetBlendMode</a>来实现多图融合效果。通过在前端创建一个自绘制节点<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arkui-rendernode" target="_blank">RenderNode</a>，并将图形绘制上下文及背景图参数通过Native侧暴露的接口传入，由Native使用相应Drawing接口进行绘制。具体实现步骤如下：</p> </div> <ol><li>前端定义一个<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arkui-rendernode" target="_blank">RenderNode</a>自绘制渲染节点，将背景图this.pMap及图形绘制上下文context传入Native，调用Native侧的nativeOnDraw接口进行绘制。<div class="screenLinkPre"><div _ngcontent-lhi-c106="" class="highlight-div"><div _ngcontent-lhi-c106="" class="highlight-div-header"><div _ngcontent-lhi-c106="" class="highlight-div-header-left"><div _ngcontent-lhi-c106="" class="handle-button expand-button"><div _ngcontent-lhi-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-lhi-c106="" class="highlight-div-header-right"><div _ngcontent-lhi-c106="" class="handle-button ai-button"></div><div _ngcontent-lhi-c106="" class="handle-button line-button"><div _ngcontent-lhi-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-lhi-c106="" class="handle-button theme-button"><div _ngcontent-lhi-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-lhi-c106="" class="handle-button copy-button"><div _ngcontent-lhi-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-lhi-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-cangjie" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/NdkDrawing/entry/src/main/ets/pages/Index.ets#L36-L57" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// entry\src\main\ets\pages\Index.ets</span></li><li><span class="hljs-comment">// Define a RenderNode self-drawing RenderNode MyRenderNode, so as to draw with the interface of Native</span></li><li><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRenderNode</span> <span class="hljs-variable">extends</span> <span class="hljs-variable">RenderNode</span> {</li><li>  <span class="hljs-keyword">private</span> <span class="hljs-variable">drawType</span>: <span class="hljs-title class_">DrawType</span> = <span class="hljs-variable">DrawType</span>.<span class="hljs-variable">NONE</span>;</li><li>  <span class="hljs-keyword">private</span> <span class="hljs-variable">pMap</span>: <span class="hljs-title class_">image</span>.<span class="hljs-title class_">PixelMap</span> | <span class="hljs-title class_">undefined</span> = <span class="hljs-variable">undefined</span>; <span class="hljs-comment">// background image</span></li><li>
</li><li>  <span class="hljs-title function_">draw</span>(<span class="hljs-variable">context</span>: <span class="hljs-title class_">DrawContext</span>): <span class="hljs-title class_">void</span> {</li><li>    <span class="hljs-comment">// Call the Native onDraw interface on the native side to draw, and pass in the background image this.pMap and the graphic drawing context as parameters</span></li><li>    <span class="hljs-variable">testNapi</span>.<span class="hljs-title function_">nativeOnDraw</span>(<span class="hljs-number">666</span>, <span class="hljs-variable">context</span>, <span class="hljs-variable">uiContext</span>?.<span class="hljs-title function_">vp2px</span>(<span class="hljs-keyword">this</span>.<span class="hljs-variable">size</span>.<span class="hljs-variable">width</span>), <span class="hljs-variable">uiContext</span>?.<span class="hljs-title function_">vp2px</span>(<span class="hljs-keyword">this</span>.<span class="hljs-variable">size</span>.<span class="hljs-variable">height</span>),</li><li>      <span class="hljs-keyword">this</span>.<span class="hljs-variable">drawType</span>, <span class="hljs-keyword">this</span>.<span class="hljs-variable">pMap</span>);</li><li>  }</li><li>
</li><li>  <span class="hljs-comment">// Set the drawing type</span></li><li>  <span class="hljs-title function_">resetType</span>(<span class="hljs-keyword">type</span>: <span class="hljs-title class_">DrawType</span>): <span class="hljs-title class_">void</span> {</li><li>    <span class="hljs-keyword">this</span>.<span class="hljs-variable">drawType</span> = <span class="hljs-keyword">type</span>;</li><li>  }</li><li>
</li><li>  <span class="hljs-comment">// Set the background picture</span></li><li>  <span class="hljs-title function_">setPixelMap</span>(<span class="hljs-variable">p</span>: <span class="hljs-title class_">PixelMap</span>): <span class="hljs-title class_">void</span> {</li><li>    <span class="hljs-keyword">this</span>.<span class="hljs-variable">pMap</span> = <span class="hljs-variable">p</span>;</li><li>  }</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/NdkDrawing/entry/src/main/ets/pages/Index.ets#L36-L57" target="_blank">Index.ets</a></div></div></div></div> <p>新建一个自绘制渲染节点，并定义一个<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arkui-nodecontroller" target="_blank">NodeController</a>，对该节点进行管理。</p> <div class="screenLinkPre"><div _ngcontent-lhi-c106="" class="highlight-div"><div _ngcontent-lhi-c106="" class="highlight-div-header"><div _ngcontent-lhi-c106="" class="highlight-div-header-left"><div _ngcontent-lhi-c106="" class="handle-button expand-button"><div _ngcontent-lhi-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-lhi-c106="" class="highlight-div-header-right"><div _ngcontent-lhi-c106="" class="handle-button ai-button"></div><div _ngcontent-lhi-c106="" class="handle-button line-button"><div _ngcontent-lhi-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-lhi-c106="" class="handle-button theme-button"><div _ngcontent-lhi-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-lhi-c106="" class="handle-button copy-button"><div _ngcontent-lhi-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-lhi-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-kotlin" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/NdkDrawing/entry/src/main/ets/pages/Index.ets#L61-L87" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// entry\src\main\ets\pages\Index.ets</span></li><li><span class="hljs-comment">// Create a MyRenderNode object</span></li><li><span class="hljs-keyword">const</span> newNode = new MyRenderNode();</li><li><span class="hljs-comment">// Defines the size and location of the newNode</span></li><li>newNode.frame = {</li><li>  x: <span class="hljs-number">0</span>,</li><li>  y: <span class="hljs-number">0</span>,</li><li>  width: <span class="hljs-number">980</span>,</li><li>  height: <span class="hljs-number">1280</span></li><li>};</li><li>
</li><li><span class="hljs-comment">// Mount the MyRenderNode object node on the NodeContainer</span></li><li><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyNodeController</span> <span class="hljs-title">extends</span> <span class="hljs-title">NodeController</span> {</li><li>  <span class="hljs-keyword">private</span> rootNode: FrameNode | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;</li><li>
</li><li>  makeNode(uiContext: UIContext): FrameNode | <span class="hljs-literal">null</span> {</li><li>    <span class="hljs-keyword">this</span>.rootNode = new FrameNode(uiContext);</li><li>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.rootNode === <span class="hljs-literal">null</span>) {</li><li>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;</li><li>    }</li><li>    <span class="hljs-keyword">const</span> renderNode = <span class="hljs-keyword">this</span>.rootNode.getRenderNode();</li><li>    <span class="hljs-keyword">if</span> (renderNode !== <span class="hljs-literal">null</span>) {</li><li>      renderNode.appendChild(newNode);</li><li>    }</li><li>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.rootNode;</li><li>  }</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/NdkDrawing/entry/src/main/ets/pages/Index.ets#L61-L87" target="_blank">Index.ets</a></div></div></div></div> </li><li>在页面中将自绘制节点挂载到<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arkui-nodecontroller" target="_blank">NodeContainer</a>上。<div class="screenLinkPre"><div _ngcontent-lhi-c106="" class="highlight-div"><div _ngcontent-lhi-c106="" class="highlight-div-header"><div _ngcontent-lhi-c106="" class="highlight-div-header-left"><div _ngcontent-lhi-c106="" class="handle-button expand-button"><div _ngcontent-lhi-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-lhi-c106="" class="highlight-div-header-right"><div _ngcontent-lhi-c106="" class="handle-button ai-button"></div><div _ngcontent-lhi-c106="" class="handle-button line-button"><div _ngcontent-lhi-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-lhi-c106="" class="handle-button theme-button"><div _ngcontent-lhi-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-lhi-c106="" class="handle-button copy-button"><div _ngcontent-lhi-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-lhi-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-cangjie" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/NdkDrawing/entry/src/main/ets/pages/Index.ets#L91-L143" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// entry\src\main\ets\pages\Index.ets</span></li><li>@<span class="hljs-title function_">Entry</span></li><li>@<span class="hljs-title function_">Component</span></li><li><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Index</span> {</li><li>  <span class="hljs-keyword">private</span> <span class="hljs-variable">myNodeController</span>: <span class="hljs-title class_">MyNodeController</span> = <span class="hljs-variable">new</span> <span class="hljs-title function_">MyNodeController</span>();</li><li>
</li><li>  <span class="hljs-title function_">aboutToAppear</span>(): <span class="hljs-title class_">void</span> {</li><li>    <span class="hljs-keyword">const</span> <span class="hljs-variable">context</span>: <span class="hljs-title class_">Context</span> = <span class="hljs-keyword">this</span>.<span class="hljs-title function_">getUIContext</span>().<span class="hljs-title function_">getHostContext</span>()!;</li><li>    <span class="hljs-keyword">const</span> <span class="hljs-variable">resourceMgr</span>: <span class="hljs-title class_">resourceManager</span>.<span class="hljs-title class_">ResourceManager</span> = <span class="hljs-variable">context</span>.<span class="hljs-variable">resourceManager</span>;</li><li>    <span class="hljs-variable">resourceMgr</span>.<span class="hljs-title function_">getRawFileContent</span>(<span class="hljs-string">'drawImage.jpg'</span>).<span class="hljs-title function_">then</span>((<span class="hljs-variable">fileData</span>: <span class="hljs-title class_">Uint8Array</span>) =&gt; {</li><li>      <span class="hljs-variable">hilog</span>.<span class="hljs-title function_">info</span>(<span class="hljs-variable">DOMAIN</span>, <span class="hljs-variable">TAG</span>, <span class="hljs-variable">FORMAT</span>, `<span class="hljs-variable">success</span> <span class="hljs-keyword">in</span> <span class="hljs-variable">getRawFileContent</span>`);</li><li>      <span class="hljs-keyword">const</span> <span class="hljs-variable">buffer</span> = <span class="hljs-variable">fileData</span>.<span class="hljs-variable">buffer</span>.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>);</li><li>      <span class="hljs-keyword">const</span> <span class="hljs-variable">imageSource</span>: <span class="hljs-title class_">image</span>.<span class="hljs-title class_">ImageSource</span> = <span class="hljs-variable">image</span>.<span class="hljs-title function_">createImageSource</span>(<span class="hljs-variable">buffer</span>);</li><li>      <span class="hljs-variable">imageSource</span>.<span class="hljs-title function_">createPixelMap</span>().<span class="hljs-title function_">then</span>((<span class="hljs-variable">pMap</span>: <span class="hljs-title class_">image</span>.<span class="hljs-title class_">PixelMap</span>) =&gt; {</li><li>        <span class="hljs-comment">// Self-drawing rendering node background map</span></li><li>        <span class="hljs-variable">newNode</span>.<span class="hljs-title function_">setPixelMap</span>(<span class="hljs-variable">pMap</span>);</li><li>      }).<span class="hljs-keyword">catch</span>((<span class="hljs-variable">err</span>: <span class="hljs-title class_">BusinessError</span>) =&gt; {</li><li>        <span class="hljs-variable">hilog</span>.<span class="hljs-title function_">error</span>(<span class="hljs-variable">DOMAIN</span>, <span class="hljs-variable">TAG</span>, <span class="hljs-variable">FORMAT</span>, `<span class="hljs-variable">fail</span> <span class="hljs-variable">to</span> <span class="hljs-variable">create</span> <span class="hljs-variable">PixelMap</span>, <span class="hljs-variable">error</span> <span class="hljs-variable">code</span>: ${<span class="hljs-variable">err</span>.<span class="hljs-variable">code</span>}, <span class="hljs-variable">message</span>: ${<span class="hljs-variable">err</span>.<span class="hljs-variable">message</span>}.`);</li><li>      }).<span class="hljs-keyword">catch</span>((<span class="hljs-variable">err</span>: <span class="hljs-title class_">BusinessError</span>) =&gt; {</li><li>        <span class="hljs-variable">hilog</span>.<span class="hljs-title function_">error</span>(<span class="hljs-variable">DOMAIN</span>, <span class="hljs-variable">TAG</span>, <span class="hljs-variable">FORMAT</span>,</li><li>          `<span class="hljs-variable">fail</span> <span class="hljs-variable">to</span> <span class="hljs-variable">getRawFileContent</span>, <span class="hljs-variable">error</span> <span class="hljs-variable">code</span>: ${<span class="hljs-variable">err</span>.<span class="hljs-variable">code</span>}, <span class="hljs-variable">message</span>: ${<span class="hljs-variable">err</span>.<span class="hljs-variable">message</span>}.`);</li><li>      });</li><li>    }).<span class="hljs-keyword">catch</span>((<span class="hljs-variable">err</span>: <span class="hljs-title class_">BusinessError</span>) =&gt; {</li><li>      <span class="hljs-variable">hilog</span>.<span class="hljs-title function_">error</span>(<span class="hljs-variable">DOMAIN</span>, <span class="hljs-variable">TAG</span>, <span class="hljs-variable">FORMAT</span>,</li><li>        `<span class="hljs-variable">callback</span> <span class="hljs-variable">getRawFileContent</span> <span class="hljs-variable">failed</span>, <span class="hljs-variable">error</span> <span class="hljs-variable">code</span>: ${<span class="hljs-variable">err</span>.<span class="hljs-variable">code</span>}, <span class="hljs-variable">message</span>: ${<span class="hljs-variable">err</span>.<span class="hljs-variable">message</span>}.`);</li><li>    });</li><li>  }</li><li>
</li><li>  <span class="hljs-title function_">build</span>() {</li><li>    <span class="hljs-title function_">Stack</span>() {</li><li>      <span class="hljs-comment">// Mount the self-drawn rendering node to NodeContainer</span></li><li>      <span class="hljs-title function_">NodeContainer</span>(<span class="hljs-keyword">this</span>.<span class="hljs-variable">myNodeController</span>)</li><li>        .<span class="hljs-title function_">height</span>(<span class="hljs-string">'100%'</span>)</li><li>      <span class="hljs-title function_">Row</span>() {</li><li>        <span class="hljs-title function_">Button</span>(<span class="hljs-string">'Begin Draw'</span>)</li><li>          .<span class="hljs-title function_">width</span>(<span class="hljs-string">'100%'</span>)</li><li>          .<span class="hljs-title function_">height</span>(<span class="hljs-number">40</span>)</li><li>          .<span class="hljs-title function_">onClick</span>(() =&gt; {</li><li>            <span class="hljs-variable">newNode</span>.<span class="hljs-title function_">resetType</span>(<span class="hljs-variable">DrawType</span>.<span class="hljs-variable">IMAGE</span>);</li><li>            <span class="hljs-variable">newNode</span>.<span class="hljs-title function_">invalidate</span>();</li><li>          })</li><li>      }</li><li>      .<span class="hljs-title function_">padding</span>({</li><li>        <span class="hljs-variable">right</span>: <span class="hljs-number">16</span>,</li><li>        <span class="hljs-variable">bottom</span>: <span class="hljs-number">16</span>,</li><li>        <span class="hljs-variable">left</span>: <span class="hljs-number">16</span></li><li>      })</li><li>    }</li><li>    .<span class="hljs-title function_">alignContent</span>(<span class="hljs-variable">Alignment</span>.<span class="hljs-variable">Bottom</span>)</li><li>    .<span class="hljs-title function_">width</span>(<span class="hljs-string">'100%'</span>)</li><li>    .<span class="hljs-title function_">height</span>(<span class="hljs-string">'100%'</span>)</li><li>  }</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/NdkDrawing/entry/src/main/ets/pages/Index.ets#L91-L143" target="_blank">Index.ets</a></div></div></div></div> </li><li>Native侧暴露绘制接口nativeOnDraw供前端调用，该接口绑定Native侧的OnDraw函数，ArkTS传入的参数在该函数中处理。<div class="screenLinkPre"><div _ngcontent-lhi-c106="" class="highlight-div"><div _ngcontent-lhi-c106="" class="highlight-div-header"><div _ngcontent-lhi-c106="" class="highlight-div-header-left"><div _ngcontent-lhi-c106="" class="handle-button expand-button"><div _ngcontent-lhi-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-lhi-c106="" class="highlight-div-header-right"><div _ngcontent-lhi-c106="" class="handle-button ai-button"></div><div _ngcontent-lhi-c106="" class="handle-button line-button"><div _ngcontent-lhi-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-lhi-c106="" class="handle-button theme-button"><div _ngcontent-lhi-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-lhi-c106="" class="handle-button copy-button"><div _ngcontent-lhi-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-lhi-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-cpp" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/NdkDrawing/entry/src/main/cpp/native_bridge.cpp#L172-L181" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// entry\src\main\cpp\native_bridge.cpp</span></li><li><span class="hljs-function">EXTERN_C_START</span></li><li><span class="hljs-function"><span class="hljs-type">static</span> napi_value <span class="hljs-title">Init</span><span class="hljs-params">(napi_env env, napi_value exports)</span> </span>{</li><li>    napi_property_descriptor desc[] = {</li><li>        <span class="hljs-comment">// Expose the NativeOnDraw interface for the front-end to call and bind the native OnDraw function</span></li><li>        {<span class="hljs-string">"nativeOnDraw"</span>, <span class="hljs-literal">nullptr</span>, OnDraw, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, napi_default, <span class="hljs-literal">nullptr</span>}};</li><li>    <span class="hljs-built_in">napi_define_properties</span>(env, exports, <span class="hljs-built_in">sizeof</span>(desc) / <span class="hljs-built_in">sizeof</span>(desc[<span class="hljs-number">0</span>]), desc);</li><li>    <span class="hljs-keyword">return</span> exports;</li><li>}</li><li>EXTERN_C_END</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/NdkDrawing/entry/src/main/cpp/native_bridge.cpp#L172-L181" target="_blank">native_bridge.cpp</a></div></div></div></div> </li><li>在OnDraw函数中接收前端传入的参数，主要是图形绘制上下文与背景图。<div class="screenLinkPre"><div _ngcontent-lhi-c106="" class="highlight-div"><div _ngcontent-lhi-c106="" class="highlight-div-header"><div _ngcontent-lhi-c106="" class="highlight-div-header-left"><div _ngcontent-lhi-c106="" class="handle-button expand-button"><div _ngcontent-lhi-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-lhi-c106="" class="highlight-div-header-right"><div _ngcontent-lhi-c106="" class="handle-button ai-button"></div><div _ngcontent-lhi-c106="" class="handle-button line-button"><div _ngcontent-lhi-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-lhi-c106="" class="handle-button theme-button"><div _ngcontent-lhi-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-lhi-c106="" class="handle-button copy-button"><div _ngcontent-lhi-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-lhi-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-cpp" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/NdkDrawing/entry/src/main/cpp/native_bridge.cpp#L137-L168" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// entry\src\main\cpp\native_bridge.cpp</span></li><li><span class="hljs-function"><span class="hljs-type">static</span> napi_value <span class="hljs-title">OnDraw</span><span class="hljs-params">(napi_env env, napi_callback_info info)</span> </span>{</li><li>    <span class="hljs-type">size_t</span> argc = <span class="hljs-number">6</span>;</li><li>    napi_value args[<span class="hljs-number">6</span>] = {<span class="hljs-literal">nullptr</span>};</li><li>
</li><li>    <span class="hljs-built_in">napi_get_cb_info</span>(env, info, &amp;argc, args, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);</li><li>
</li><li>    <span class="hljs-type">int32_t</span> id;</li><li>    <span class="hljs-built_in">napi_get_value_int32</span>(env, args[<span class="hljs-number">0</span>], &amp;id);</li><li>
</li><li>    <span class="hljs-comment">// Graphic drawing context parameters</span></li><li>    <span class="hljs-type">void</span> *temp = <span class="hljs-literal">nullptr</span>;</li><li>    <span class="hljs-built_in">napi_unwrap</span>(env, args[<span class="hljs-number">1</span>], &amp;temp);</li><li>    OH_Drawing_Canvas *canvas = <span class="hljs-built_in">reinterpret_cast</span>&lt;OH_Drawing_Canvas *&gt;(temp);</li><li>
</li><li>    <span class="hljs-type">int32_t</span> width;</li><li>    <span class="hljs-built_in">napi_get_value_int32</span>(env, args[<span class="hljs-number">2</span>], &amp;width);</li><li>
</li><li>    <span class="hljs-type">int32_t</span> height;</li><li>    <span class="hljs-built_in">napi_get_value_int32</span>(env, args[<span class="hljs-number">3</span>], &amp;height);</li><li>
</li><li>    <span class="hljs-built_in">DRAWING_LOGI</span>(<span class="hljs-string">"OnDraw, width:%{public}d, height:%{public}d"</span>, width, height);</li><li>    <span class="hljs-type">int32_t</span> drawOption;</li><li>    <span class="hljs-built_in">napi_get_value_int32</span>(env, args[<span class="hljs-number">4</span>], &amp;drawOption);</li><li>    <span class="hljs-comment">// Background image parameters</span></li><li>    NativePixelMap *nativePixelMap = <span class="hljs-built_in">OH_PixelMap_InitNativePixelMap</span>(env, args[<span class="hljs-number">5</span>]);</li><li>    <span class="hljs-keyword">if</span> (drawOption == IMAGE) {</li><li>        <span class="hljs-comment">// Call the fusion drawing interface to draw</span></li><li>        <span class="hljs-built_in">NativeOnDrawPixelMap</span>(canvas, nativePixelMap);</li><li>    }</li><li>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/NdkDrawing/entry/src/main/cpp/native_bridge.cpp#L137-L168" target="_blank">native_bridge.cpp</a></div></div></div></div> </li><li>在NativeOnDrawPixelMap函数中实现透明圆圈绘制（主要使用<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-drawing-canvas-h#oh_drawing_canvassavelayer" target="_blank">OH_Drawing_CanvasSaveLayer</a>分层接口及 <a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-drawing-brush-h#oh_drawing_brushsetblendmode" target="_blank">OH_Drawing_BrushSetBlendMode</a>融合接口得到图形融合效果）。<div class="screenLinkPre"><div _ngcontent-lhi-c106="" class="highlight-div"><div _ngcontent-lhi-c106="" class="highlight-div-header"><div _ngcontent-lhi-c106="" class="highlight-div-header-left"><div _ngcontent-lhi-c106="" class="handle-button expand-button"><div _ngcontent-lhi-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-lhi-c106="" class="highlight-div-header-right"><div _ngcontent-lhi-c106="" class="handle-button ai-button"></div><div _ngcontent-lhi-c106="" class="handle-button line-button"><div _ngcontent-lhi-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-lhi-c106="" class="handle-button theme-button"><div _ngcontent-lhi-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-lhi-c106="" class="handle-button copy-button"><div _ngcontent-lhi-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-lhi-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-cpp" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/NdkDrawing/entry/src/main/cpp/native_bridge.cpp#L52-L133" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// entry\src\main\cpp\native_bridge.cpp</span></li><li><span class="hljs-keyword">enum</span> <span class="hljs-title class_">DrawType</span> { NONE, PATH, TEXT, IMAGE };</li><li><span class="hljs-meta">#<span class="hljs-keyword">define</span> DRAW_MAX_NUM 1000 <span class="hljs-comment">// Maximum number of drawn circles</span></span></li><li>
</li><li><span class="hljs-comment">// Generate random coordinates</span></li><li><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">RangedRand</span><span class="hljs-params">(<span class="hljs-type">int</span> range_min, <span class="hljs-type">int</span> range_max)</span> </span>{</li><li>    <span class="hljs-type">int</span> r = ((<span class="hljs-type">double</span>)<span class="hljs-built_in">rand</span>() / RAND_MAX) * (range_max - range_min) + range_min;</li><li>    <span class="hljs-keyword">return</span> r;</li><li>}</li><li>
</li><li><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DrawCircle</span><span class="hljs-params">(OH_Drawing_Path *path, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> width)</span> </span>{</li><li>    <span class="hljs-built_in">OH_Drawing_PathMoveTo</span>(path, x + width, y);</li><li>    OH_Drawing_Rect *rect = <span class="hljs-built_in">OH_Drawing_RectCreate</span>(x - width, y - width, x + width, y + width);</li><li>    <span class="hljs-built_in">OH_Drawing_PathAddArc</span>(path, rect, <span class="hljs-number">0</span>, <span class="hljs-number">360</span>);</li><li>}</li><li>
</li><li><span class="hljs-comment">// Scene draw by fusion of hollow circle and background image</span></li><li><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">NativeOnDrawPixelMap</span><span class="hljs-params">(OH_Drawing_Canvas *canvas, NativePixelMap *nativeMap)</span> </span>{</li><li>    <span class="hljs-comment">// Draw a background picture</span></li><li>    <span class="hljs-built_in">OH_Drawing_CanvasSave</span>(canvas);</li><li>    OH_Drawing_PixelMap *pixelMap = <span class="hljs-built_in">OH_Drawing_PixelMapGetFromNativePixelMap</span>(nativeMap);</li><li>    <span class="hljs-comment">// Create a sampling option object</span></li><li>    OH_Drawing_SamplingOptions *sampling = <span class="hljs-built_in">OH_Drawing_SamplingOptionsCreate</span>(FILTER_MODE_NEAREST, MIPMAP_MODE_NONE);</li><li>    <span class="hljs-comment">// Acquiring a background image drawing area</span></li><li>    OH_Drawing_Rect *src = <span class="hljs-built_in">OH_Drawing_RectCreate</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">360</span>, <span class="hljs-number">693</span>);</li><li>    <span class="hljs-comment">// Create a render area</span></li><li>    OH_Drawing_Rect *dst = <span class="hljs-built_in">OH_Drawing_RectCreate</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1300</span>, <span class="hljs-number">2800</span>);</li><li>    <span class="hljs-comment">// Create a brush</span></li><li>    OH_Drawing_Brush *brush = <span class="hljs-built_in">OH_Drawing_BrushCreate</span>();</li><li>    <span class="hljs-built_in">OH_Drawing_CanvasAttachBrush</span>(canvas, brush);</li><li>    <span class="hljs-comment">// Render the background image to the designated area of the canvas.</span></li><li>    <span class="hljs-built_in">OH_Drawing_CanvasDrawPixelMapRect</span>(canvas, pixelMap, src, dst, sampling);</li><li>    <span class="hljs-built_in">OH_Drawing_CanvasDetachBrush</span>(canvas);</li><li>
</li><li>    <span class="hljs-comment">// Call hierarchical interface</span></li><li>    <span class="hljs-built_in">OH_Drawing_CanvasSaveLayer</span>(canvas, dst, brush);</li><li>
</li><li>    <span class="hljs-comment">// Painting mask layer</span></li><li>    OH_Drawing_Rect *rect2 = <span class="hljs-built_in">OH_Drawing_RectCreate</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1300</span>, <span class="hljs-number">2800</span>);</li><li>    OH_Drawing_Brush *brush2 = <span class="hljs-built_in">OH_Drawing_BrushCreate</span>();</li><li>    <span class="hljs-comment">// Set the brush color</span></li><li>    <span class="hljs-built_in">OH_Drawing_BrushSetColor</span>(brush2, <span class="hljs-built_in">OH_Drawing_ColorSetArgb</span>(<span class="hljs-number">0x77</span>, <span class="hljs-number">0xCC</span>, <span class="hljs-number">0xCC</span>, <span class="hljs-number">0xCC</span>));</li><li>    <span class="hljs-built_in">OH_Drawing_CanvasAttachBrush</span>(canvas, brush2);</li><li>    <span class="hljs-built_in">OH_Drawing_CanvasDrawRect</span>(canvas, rect2);</li><li>    <span class="hljs-built_in">OH_Drawing_CanvasDetachBrush</span>(canvas);</li><li>
</li><li>    OH_Drawing_Point *pointArray[DRAW_MAX_NUM];</li><li>    <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;</li><li>    <span class="hljs-type">int</span> y = <span class="hljs-number">0</span>;</li><li>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; DRAW_MAX_NUM; i++) {</li><li>        <span class="hljs-comment">// Generate random coordinates</span></li><li>        x = <span class="hljs-built_in">RangedRand</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1300</span>);</li><li>        y = <span class="hljs-built_in">RangedRand</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2800</span>);</li><li>        pointArray[i] = <span class="hljs-built_in">OH_Drawing_PointCreate</span>(x, y);</li><li>    }</li><li>
</li><li>    OH_Drawing_Point *point = <span class="hljs-built_in">OH_Drawing_PointCreate</span>(<span class="hljs-number">800</span>, <span class="hljs-number">1750</span>);</li><li>    OH_Drawing_Brush *brush3 = <span class="hljs-built_in">OH_Drawing_BrushCreate</span>();</li><li>    <span class="hljs-comment">// Set the brush and blending mode of the circle.</span></li><li>    <span class="hljs-built_in">OH_Drawing_BrushSetBlendMode</span>(brush3, BLEND_MODE_DST_OUT);</li><li>    <span class="hljs-built_in">OH_Drawing_CanvasAttachBrush</span>(canvas, brush3);</li><li>    <span class="hljs-comment">// Circle</span></li><li>    OH_Drawing_Path *path = <span class="hljs-built_in">OH_Drawing_PathCreate</span>();</li><li>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; DRAW_MAX_NUM; i++) {</li><li>        x = <span class="hljs-built_in">RangedRand</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1300</span>);</li><li>        y = <span class="hljs-built_in">RangedRand</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2800</span>);</li><li>        <span class="hljs-built_in">DrawCircle</span>(path, x, y, <span class="hljs-number">15</span>);</li><li>    }</li><li>    <span class="hljs-built_in">OH_Drawing_CanvasDrawPath</span>(canvas, path);</li><li>
</li><li>    <span class="hljs-comment">// Destroy the object</span></li><li>    <span class="hljs-built_in">OH_Drawing_CanvasDetachBrush</span>(canvas);</li><li>    <span class="hljs-built_in">OH_Drawing_RectDestroy</span>(rect2);</li><li>    <span class="hljs-built_in">OH_Drawing_BrushDestroy</span>(brush2);</li><li>    <span class="hljs-built_in">OH_Drawing_BrushDestroy</span>(brush3);</li><li>    <span class="hljs-built_in">OH_Drawing_PointDestroy</span>(point);</li><li>    <span class="hljs-built_in">OH_Drawing_BrushDestroy</span>(brush);</li><li>    <span class="hljs-built_in">OH_Drawing_CanvasRestore</span>(canvas);</li><li>    <span class="hljs-built_in">OH_Drawing_SamplingOptionsDestroy</span>(sampling);</li><li>    <span class="hljs-built_in">OH_Drawing_RectDestroy</span>(src);</li><li>    <span class="hljs-built_in">OH_Drawing_RectDestroy</span>(dst);</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/NdkDrawing/entry/src/main/cpp/native_bridge.cpp#L52-L133" target="_blank">native_bridge.cpp</a></div></div></div></div> <p>使用Native侧Drawing绘制trace图，可以看到绘制1000个圆圈耗时2.4毫秒，相较于Canvas CanvasRenderingContext2D绘制有较大的性能提升。</p> <p><span><img originheight="457" originwidth="841" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163048.78739620063259627182694849957562:50001231000000:2800:1C74FCCC3A76DD218D7FB5112B521167FE5E1E5D414F7FAC5F813A08A8AE4BA9.png" width="841" height="457"></span></p> </li></ol> <div class="tiledSection"><h2 id="section1173820802818">效果对比<i class="anchor-icon anchor-icon-link" anchorid="section1173820802818" tips="复制节点链接"></i></h2> <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><tbody><tr><td class="cellrowborder" valign="top" width="33.333333333333336%"><p><strong>方案</strong></p> </td> <td class="cellrowborder" valign="top" width="33.333333333333336%"><p><strong>圆圈数量</strong></p> </td> <td class="cellrowborder" valign="top" width="33.333333333333336%"><p><strong>耗时</strong></p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="33.333333333333336%"><p>Canvas CanvasRenderingContext2D 画透明圈</p> </td> <td class="cellrowborder" valign="top" width="33.333333333333336%"><p>1000</p> </td> <td class="cellrowborder" valign="top" width="33.333333333333336%"><p>14.9毫秒</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="33.333333333333336%"><p>Native Drawing画透明圈</p> </td> <td class="cellrowborder" valign="top" width="33.333333333333336%"><p>1000</p> </td> <td class="cellrowborder" valign="top" width="33.333333333333336%"><p>2.4毫秒</p> </td> </tr>  </tbody></table></div> </div> <p>通过上述对比可以发现，在实现较大数量透明空心圆这样的复杂的绘制场景，相比于Canvas CanvasRenderingContext2D，使用Native <a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-drawing-canvas-h" target="_blank">Drawing</a>可以得到明显的性能提升。以上只是实现透明空心圆融合场景，针对实心圆及其他融合场景（如<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-canvasrenderingcontext2d#globalcompositeoperation" target="_blank">globalCompositeOperation</a>属性的其他值），由于实现机制的不同，绘制指令数量也存在差异，从而性能数据会存在一些差异。实际应用中，可以根据实际情况，在对性能要求不高的情况采用Canvas CanvasRenderingContext2D，如果对性能要求比较高，建议使用Native <a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-drawing-canvas-h" target="_blank">Drawing</a>进行绘制。</p> </div> <div class="tiledSection"><h2 id="section1078520389541">示例代码<i class="anchor-icon anchor-icon-link" anchorid="section1078520389541" tips="复制节点链接"></i></h2><ul><li><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/tree/master/NdkDrawing" target="_blank">Drawing自绘制性能提升</a></li></ul> </div> </div> <div></div></div>