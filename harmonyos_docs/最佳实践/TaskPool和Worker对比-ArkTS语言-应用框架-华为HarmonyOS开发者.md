<h1 _ngcontent-olo-c119="" class="doc-title ng-star-inserted" title="TaskPool和Worker对比"> TaskPool和Worker对比 </h1>

<div _ngcontent-olo-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;"> <div><div class="tiledSection"><h2 id="section733733912367">概述<i class="anchor-icon anchor-icon-link" anchorid="section733733912367" tips="复制节点链接"></i></h2><p>ArkTS提供了TaskPool与Worker两种多线程并发方案，下面我们将从其工作原理、使用效果对比两种方案的差异，进而选择适用于ArkTS图片编辑场景的并发方案。</p> </div> <div class="tiledSection"><h2 id="section17797125417368">TaskPool和Worker工作原理<i class="anchor-icon anchor-icon-link" anchorid="section17797125417368" tips="复制节点链接"></i></h2><p>TaskPool与Worker两种多线程并发能力均是基于Actor并发模型实现的。Worker主、子线程通过收发消息进行通信；TaskPool基于Worker做了更多场景化的功能封装，例如支持任务执行、任务Task或任务组TaskGroup的创建、任务优先级设置、取消任务等功能，且可以根据任务数量进行自动的扩容与缩容，还可以根据任务优先级进行任务调度。</p> </div> <div class="tiledSection"><h3 id="section1578381613716" class="firsth2">Worker工作原理<i class="anchor-icon anchor-icon-link" anchorid="section1578381613716" tips="复制节点链接"></i></h3><p>Worker拥有独立的运行环境，每个Worker线程和主线程一样拥有自己的内存空间、消息队列（MessageQueue）、事件轮询机制（EventLoop）、调用栈（CallStack）等。线程之间通过Message进行交互，如下图所示：</p> <div class="fignone"><span class="figcap"><b>图1 </b>Worker工作原理</span></div> <p><span><img height="133.58520000000001" originheight="294" originwidth="1428" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163015.84837453331151160469151078980616:50001231000000:2800:DCCA3E7E8E3B2ADD518B7C8C179BA01CDA00635C1DE66300D8EF71DF00E2302B.png" title="点击放大" width="649.3725000000001"></span></p> <p>在多核的情况下（下图中的CPU 1和CPU 2能同时工作），多个Worker线程（下图中的Worker thread1和Worker thread2）可以同时执行，因此Worker线程做到了真正的并发，如下图所示：</p> <div class="fignone"><span class="figcap"><b>图2 </b>多核CPU下Worker并发原理图</span></div> <p><span><img height="228.4275" originheight="284" originwidth="650" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163015.28837236105144807247654777246558:50001231000000:2800:1472404388630CA2D31E89511A7D503055D735373618443BA35698F629E51904.png" title="点击放大" width="523.6875"></span></p> </div> <div class="tiledSection"><h3 id="section10249134413719">TaskPool工作原理<i class="anchor-icon anchor-icon-link" anchorid="section10249134413719" tips="复制节点链接"></i></h3><p><span style="color: rgb(36,41,46);">TaskPool</span><span style="color: rgb(36,41,46);">在Worker之上实现了调度器和Worker线程池，无需管理生命周期。在主线程（ArkTS Main Thread）</span>中调用execute接口会将待执行的任务方法及参数信息，根据设置的任务优先级放入任务队列（TaskQueue）中等待调度执行。<span style="color: rgb(36,41,46);">调度器会依据调度算法（优先级，防饥饿），从优先级队列中取出任务进行序列化，放入TaskPool中的Worker线程池，</span>工作线程（ArkTS Worker Thread）根据调度器的安排执行任务方法，并将任务处理结果进行反序列化，最终以Promise-Then的方式返回给主线程。TaskPool的工作线程池会根据待执行的任务数量，任务的执行时间进行相应的扩容与缩容。<span style="color: rgb(36,41,46);">原理图如下所示：</span></p> <div class="fignone"><span class="figcap"><b>图3 </b>TaskPool工作原理图</span></div> <p><span><img height="357.1316" originheight="840" originwidth="1605" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163015.46841639791967804912463881209859:50001231000000:2800:3A5B01BE128A43C8D6B054EE9CA35F6EE15EB1BC10F7D8A9CB8CC56B61B3A267.png" title="点击放大" width="684.2850000000001"></span></p> </div> <div class="tiledSection"><h2 id="section350011253816">TaskPool与Worker并发方案对比<i class="anchor-icon anchor-icon-link" anchorid="section350011253816" tips="复制节点链接"></i></h2></div> <div class="tiledSection"><h3 id="section1187159133815" class="firsth2">使用场景<i class="anchor-icon anchor-icon-link" anchorid="section1187159133815" tips="复制节点链接"></i></h3><p>本章节主要介绍Worker与TaskPool并发方案在ArkTS图片编辑场景下的使用及性能差异。分别从编码效率、线程创建耗时、数据传输、任务执行耗时、应用运行内存占用几个维度进行分析，对比不同方案各自的优缺点，以供开发者在遇到不同场景时参考。</p> <div class="fignone"><span class="figcap"><b>图4 </b>ArkTS图片编辑效果</span></div> <p><span><img height="546.0847" originheight="1080" originwidth="523" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163015.20667184783928378546452361294315:50001231000000:2800:4010620DF505C52A7403AF1BA4B3F06C0B106C6643D6CF6A519CB1D576BEB925.gif" title="点击放大" width="266"></span></p> <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"><ul><li>本文中对TaskPool的实验均是在配置了高优先级（taskpool.Priority.HIGH）模式下进行的。</li><li>本实验中手机均为8核，应用运行实验环境有中载、重载两种，中载CPU资源占用率为50%~60%，重载CPU占用率为90%以上。</li><li>测试数据仅限于示例程序，不同的应用程序及待编辑图片差异都会引起实验数据的变化。</li><li>长时任务指耗时大于3分钟的任务。</li></ul> </div></div></div> </div> <div class="tiledSection"><h3 id="section19819143153810">编码效率对比<i class="anchor-icon anchor-icon-link" anchorid="section19819143153810" tips="复制节点链接"></i></h3><p><strong>使用Worker处理图片</strong></p> <p>使用Worker并发处理图片时需要开发者根据任务量的多少，控制Worker实例运行的数量，最多可以同时运行64个实例。为了避免产生大量的线程创建开销，需要开发者尽量复用已创建线程处理耗时任务，任务执行完成时需要及时销毁Worker，以免线程资源长期被占用影响其他任务的执行。具体请参见<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/worker-introduction#worker注意事项" target="_blank">Worker注意事项</a>。</p> <p>使用Worker进行图片处理分以下步骤：</p> <ol><li><span>根据任务数创建Worker实例，由于Worker最多同时运行的子线程数量为64个（API12新增支持，旧版本为8个），所以当任务数超过64时需要做相应限制，示例代码如下。</span><p></p><div class="screenLinkPre"><div _ngcontent-olo-c106="" class="highlight-div"><div _ngcontent-olo-c106="" class="highlight-div-header"><div _ngcontent-olo-c106="" class="highlight-div-header-left"><div _ngcontent-olo-c106="" class="handle-button expand-button"><div _ngcontent-olo-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-olo-c106="" class="highlight-div-header-right"><div _ngcontent-olo-c106="" class="handle-button ai-button"></div><div _ngcontent-olo-c106="" class="handle-button line-button"><div _ngcontent-olo-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-olo-c106="" class="handle-button theme-button"><div _ngcontent-olo-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-olo-c106="" class="handle-button copy-button"><div _ngcontent-olo-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-olo-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-cangjie" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/ImageEditTaskPool/entry/src/main/ets/view/AdjustContentView.ets#L429-L435" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">let</span> <span class="hljs-variable">taskNum</span>: <span class="hljs-title class_">number</span> = <span class="hljs-number">14</span>; <span class="hljs-comment">// The number of concurrent tasks is controlled, which can be adjusted according to the demand.</span></li><li><span class="hljs-keyword">let</span> <span class="hljs-variable">curTaskNum</span>: <span class="hljs-title class_">number</span> = <span class="hljs-variable">taskNum</span> &lt;= <span class="hljs-number">64</span> ? <span class="hljs-title class_">taskNum</span> : <span class="hljs-number">64</span>; <span class="hljs-comment">// Control allows up to 64 Worker instances to run at the same time.</span></li><li><span class="hljs-keyword">let</span> <span class="hljs-variable">Workers</span>: <span class="hljs-title class_">worker</span>.<span class="hljs-title class_">ThreadWorker</span>[] = [];</li><li><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> <span class="hljs-variable">i</span> = <span class="hljs-number">0</span>; <span class="hljs-variable">i</span> &lt; <span class="hljs-title class_">curTaskNum</span>; <span class="hljs-title class_">i</span>++) { <span class="hljs-comment">// Control the number of instantiations of the Worker according to the limit.</span></li><li>  <span class="hljs-keyword">let</span> <span class="hljs-variable">WorkerInstance</span> = <span class="hljs-variable">new</span> <span class="hljs-variable">worker</span>.<span class="hljs-title function_">ThreadWorker</span>(<span class="hljs-variable">WorkerName</span>);</li><li>  <span class="hljs-variable">Workers</span>.<span class="hljs-title function_">push</span>(<span class="hljs-variable">WorkerInstance</span>);</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/ImageEditTaskPool/entry/src/main/ets/view/AdjustContentView.ets#L429-L435" target="_blank">AdjustContentView.ets</a></div></div></div></div> <p></p></li><li><span>根据任务数将图片像素字节数进行拆分，并分配给已创建的Worker实例进行计算处理。</span><p></p><div class="screenLinkPre"><div _ngcontent-olo-c106="" class="highlight-div"><div _ngcontent-olo-c106="" class="highlight-div-header"><div _ngcontent-olo-c106="" class="highlight-div-header-left"><div _ngcontent-olo-c106="" class="handle-button expand-button"><div _ngcontent-olo-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-olo-c106="" class="highlight-div-header-right"><div _ngcontent-olo-c106="" class="handle-button ai-button"></div><div _ngcontent-olo-c106="" class="handle-button line-button"><div _ngcontent-olo-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-olo-c106="" class="handle-button theme-button"><div _ngcontent-olo-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-olo-c106="" class="handle-button copy-button"><div _ngcontent-olo-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-olo-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-cangjie" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/ImageEditTaskPool/entry/src/main/ets/view/AdjustContentView.ets#L368-L402" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">//Split the picture pixel data ArrayBuffer according to the number of tasks N.</span></li><li><span class="hljs-variable">function</span> <span class="hljs-title function_">splitArrayBuffer</span>(<span class="hljs-variable">buffer</span>: <span class="hljs-title class_">ArrayBuffer</span>, <span class="hljs-variable">taskCount</span>: <span class="hljs-title class_">number</span>): <span class="hljs-title class_">ArrayBuffer</span>[] {</li><li>  <span class="hljs-keyword">const</span> <span class="hljs-variable">BYTES_PER_PIXEL</span> = <span class="hljs-number">4</span>; <span class="hljs-comment">// RGBA</span></li><li>  <span class="hljs-keyword">const</span> <span class="hljs-variable">bytesPerTask</span> = <span class="hljs-variable">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-variable">buffer</span>.<span class="hljs-variable">byteLength</span> / <span class="hljs-variable">taskCount</span> / <span class="hljs-variable">BYTES_PER_PIXEL</span>) * <span class="hljs-variable">BYTES_PER_PIXEL</span>;</li><li>  </li><li>  <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span>: <span class="hljs-title class_">ArrayBuffer</span>[] = [];</li><li>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> <span class="hljs-variable">i</span> = <span class="hljs-number">0</span>; <span class="hljs-variable">i</span> &lt; <span class="hljs-title class_">taskCount</span>; <span class="hljs-title class_">i</span>++) {</li><li>    <span class="hljs-keyword">if</span> (<span class="hljs-variable">i</span> === <span class="hljs-variable">taskCount</span> - <span class="hljs-number">1</span>) {</li><li>      <span class="hljs-comment">// The final block contains all the remaining data</span></li><li>      <span class="hljs-variable">result</span>[<span class="hljs-variable">i</span>] = <span class="hljs-variable">buffer</span>.<span class="hljs-title function_">slice</span>(<span class="hljs-variable">i</span> * <span class="hljs-variable">bytesPerTask</span>);</li><li>    } <span class="hljs-keyword">else</span> {</li><li>      <span class="hljs-variable">result</span>[<span class="hljs-variable">i</span>] = <span class="hljs-variable">buffer</span>.<span class="hljs-title function_">slice</span>(<span class="hljs-variable">i</span> * <span class="hljs-variable">bytesPerTask</span>, (<span class="hljs-variable">i</span> + <span class="hljs-number">1</span>) * <span class="hljs-variable">bytesPerTask</span>);</li><li>    }</li><li>  }</li><li>  <span class="hljs-keyword">return</span> <span class="hljs-variable">result</span>;</li><li>}</li><li>
</li><li><span class="hljs-comment">// ...</span></li><li>  <span class="hljs-comment">// Assign the split pixels to the Worker instance.</span></li><li>  <span class="hljs-keyword">const</span> <span class="hljs-variable">buffers</span>: <span class="hljs-title class_">ArrayBuffer</span>[] = <span class="hljs-title function_">splitArrayBuffer</span>(<span class="hljs-variable">bufferArray</span>, <span class="hljs-variable">taskNum</span>);</li><li>  <span class="hljs-keyword">let</span> <span class="hljs-variable">messages</span>: <span class="hljs-title class_">MessageItem</span>[] = [];</li><li>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> <span class="hljs-variable">i</span> = <span class="hljs-number">0</span>; <span class="hljs-variable">i</span> &lt; <span class="hljs-title class_">taskNum</span>; <span class="hljs-title class_">i</span>++) { <span class="hljs-comment">// Encapsulating corresponding task data according to the number of tasks.</span></li><li>    <span class="hljs-keyword">let</span> <span class="hljs-variable">message</span> = <span class="hljs-variable">new</span> <span class="hljs-title function_">MessageItem</span>(<span class="hljs-variable">buffers</span>[<span class="hljs-variable">i</span>], <span class="hljs-variable">sliderValue</span>, <span class="hljs-variable">value</span>); <span class="hljs-comment">//Construct task message</span></li><li>    <span class="hljs-variable">messages</span>.<span class="hljs-title function_">push</span>(<span class="hljs-variable">message</span>);</li><li>  }</li><li>  <span class="hljs-keyword">let</span> <span class="hljs-variable">n</span>: <span class="hljs-title class_">number</span> = <span class="hljs-number">0</span>;</li><li>  <span class="hljs-keyword">let</span> <span class="hljs-variable">allocation</span>: <span class="hljs-title class_">number</span> = <span class="hljs-variable">taskNum</span>; <span class="hljs-comment">// Number of tasks to be assigned</span></li><li>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> <span class="hljs-variable">index</span> = <span class="hljs-number">0</span>; <span class="hljs-variable">index</span> &lt; <span class="hljs-title class_">taskNum</span>; <span class="hljs-title class_">index</span>++) {</li><li>    <span class="hljs-variable">Workers</span>[<span class="hljs-variable">index</span>].<span class="hljs-title function_">postMessage</span>(<span class="hljs-variable">messages</span>[<span class="hljs-variable">n</span>]); <span class="hljs-comment">// Distribute the task to the corresponding Worker child thread instance.</span></li><li>    <span class="hljs-variable">allocation</span> = <span class="hljs-variable">allocation</span> - <span class="hljs-number">1</span>; <span class="hljs-comment">// Number of remaining tasks to be assigned</span></li><li>    <span class="hljs-variable">n</span> += <span class="hljs-number">1</span>;</li><li>  }</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/ImageEditTaskPool/entry/src/main/ets/view/AdjustContentView.ets#L368-L402" target="_blank">AdjustContentView.ets</a></div></div></div></div> <p></p></li><li><span>接收到任务的Worker子线程会进行像素计算，并将计算结果返回给主线程。</span><p></p><div class="screenLinkPre"><div _ngcontent-olo-c106="" class="highlight-div"><div _ngcontent-olo-c106="" class="highlight-div-header"><div _ngcontent-olo-c106="" class="highlight-div-header-left"><div _ngcontent-olo-c106="" class="handle-button expand-button"><div _ngcontent-olo-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-olo-c106="" class="highlight-div-header-right"><div _ngcontent-olo-c106="" class="handle-button ai-button"></div><div _ngcontent-olo-c106="" class="handle-button line-button"><div _ngcontent-olo-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-olo-c106="" class="handle-button theme-button"><div _ngcontent-olo-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-olo-c106="" class="handle-button copy-button"><div _ngcontent-olo-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-olo-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-cangjie" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/ImageEditTaskPool/entry/src/main/ets/view/WorkerPort.ets#L8-L40" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// The child thread receives the task and calculates it.</span></li><li><span class="hljs-variable">WorkerPort</span>.<span class="hljs-variable">onmessage</span> = (<span class="hljs-variable">event</span>: <span class="hljs-title class_">MessageEvents</span>) =&gt; {</li><li>  <span class="hljs-keyword">let</span> <span class="hljs-variable">bufferArray</span>: <span class="hljs-title class_">ArrayBuffer</span> = <span class="hljs-variable">event</span>.<span class="hljs-variable">data</span>.<span class="hljs-variable">buf</span>;</li><li>  <span class="hljs-keyword">let</span> <span class="hljs-variable">last</span>: <span class="hljs-title class_">number</span> = <span class="hljs-variable">event</span>.<span class="hljs-variable">data</span>.<span class="hljs-variable">last</span>;</li><li>  <span class="hljs-keyword">let</span> <span class="hljs-variable">cur</span>: <span class="hljs-title class_">number</span> = <span class="hljs-variable">event</span>.<span class="hljs-variable">data</span>.<span class="hljs-variable">cur</span>;</li><li>  <span class="hljs-keyword">let</span> <span class="hljs-variable">index</span>: <span class="hljs-title class_">number</span> = <span class="hljs-variable">event</span>.<span class="hljs-variable">data</span>.<span class="hljs-variable">index</span>;</li><li>  <span class="hljs-keyword">let</span> <span class="hljs-variable">buffer</span> = <span class="hljs-title function_">adjustImageValue</span>(<span class="hljs-variable">bufferArray</span>, <span class="hljs-variable">last</span>, <span class="hljs-variable">cur</span>); <span class="hljs-comment">// Pixel calculation execution</span></li><li>  <span class="hljs-keyword">let</span> <span class="hljs-variable">output</span>: <span class="hljs-title class_">ESObject</span> = <span class="hljs-variable">new</span> <span class="hljs-title function_">WorkerBuffer</span>(<span class="hljs-variable">buffer</span>, <span class="hljs-variable">index</span>);</li><li>  <span class="hljs-variable">WorkerPort</span>.<span class="hljs-title function_">postMessage</span>(<span class="hljs-variable">output</span>); <span class="hljs-comment">// Send the calculation result to the main thread.</span></li><li>}</li><li>
</li><li>
</li><li><span class="hljs-variable">function</span> <span class="hljs-title function_">adjustImageValue</span>(<span class="hljs-variable">bufferArray</span>: <span class="hljs-title class_">ArrayBuffer</span>, <span class="hljs-variable">last</span>: <span class="hljs-title class_">number</span>, <span class="hljs-variable">cur</span>: <span class="hljs-title class_">number</span>, <span class="hljs-variable">hsvIndex</span>?: <span class="hljs-title class_">number</span>): <span class="hljs-title class_">ArrayBuffer</span> {</li><li>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">execColorInfo</span>(<span class="hljs-variable">bufferArray</span>, <span class="hljs-variable">last</span>, <span class="hljs-variable">cur</span>, <span class="hljs-variable">HSVIndex</span>.<span class="hljs-variable">VALUE</span>);</li><li>}</li><li>
</li><li><span class="hljs-comment">// Picture pixel calculation</span></li><li><span class="hljs-variable">function</span> <span class="hljs-title function_">execColorInfo</span>(<span class="hljs-variable">bufferArray</span>: <span class="hljs-title class_">ArrayBuffer</span>, <span class="hljs-variable">last</span>: <span class="hljs-title class_">number</span>, <span class="hljs-variable">cur</span>: <span class="hljs-title class_">number</span>, <span class="hljs-variable">hsvIndex</span>: <span class="hljs-title class_">number</span>) {</li><li>  <span class="hljs-comment">// ...</span></li><li>  <span class="hljs-keyword">const</span> <span class="hljs-variable">newBufferArr</span> = <span class="hljs-variable">bufferArray</span>;</li><li>  <span class="hljs-keyword">let</span> <span class="hljs-variable">colorInfo</span> = <span class="hljs-variable">new</span> <span class="hljs-title function_">Uint8Array</span>(<span class="hljs-variable">newBufferArr</span>);</li><li>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> <span class="hljs-variable">i</span> = <span class="hljs-number">0</span>; <span class="hljs-variable">i</span> &lt; <span class="hljs-title class_">colorInfo</span>?.<span class="hljs-title class_">length</span>; <span class="hljs-title class_">i</span> += <span class="hljs-title class_">CommonConstants</span>.<span class="hljs-title class_">PIXEL_STEP</span>) {</li><li>    <span class="hljs-keyword">const</span> <span class="hljs-variable">hsv</span> = <span class="hljs-title function_">rgb2hsv</span>(<span class="hljs-variable">colorInfo</span>[<span class="hljs-variable">i</span> + <span class="hljs-variable">RGBIndex</span>.<span class="hljs-variable">RED</span>], <span class="hljs-variable">colorInfo</span>[<span class="hljs-variable">i</span> + <span class="hljs-variable">RGBIndex</span>.<span class="hljs-variable">GREEN</span>], <span class="hljs-variable">colorInfo</span>[<span class="hljs-variable">i</span> + <span class="hljs-variable">RGBIndex</span>.<span class="hljs-variable">BLUE</span>]);</li><li>    <span class="hljs-keyword">let</span> <span class="hljs-variable">rate</span> = <span class="hljs-variable">cur</span> / <span class="hljs-variable">last</span>;</li><li>    <span class="hljs-variable">hsv</span>[<span class="hljs-variable">hsvIndex</span>] *= <span class="hljs-variable">rate</span>;</li><li>    <span class="hljs-keyword">const</span> <span class="hljs-variable">rgb</span>: <span class="hljs-title class_">ESObject</span> = <span class="hljs-title function_">hsv2rgb</span>(<span class="hljs-variable">hsv</span>[<span class="hljs-variable">HSVIndex</span>.<span class="hljs-variable">HUE</span>], <span class="hljs-variable">hsv</span>[<span class="hljs-variable">HSVIndex</span>.<span class="hljs-variable">SATURATION</span>], <span class="hljs-variable">hsv</span>[<span class="hljs-variable">HSVIndex</span>.<span class="hljs-variable">VALUE</span>]);</li><li>    <span class="hljs-variable">colorInfo</span>[<span class="hljs-variable">i</span> + <span class="hljs-variable">RGBIndex</span>.<span class="hljs-variable">RED</span>] = <span class="hljs-variable">rgb</span>[<span class="hljs-variable">RGBIndex</span>.<span class="hljs-variable">RED</span>];</li><li>    <span class="hljs-variable">colorInfo</span>[<span class="hljs-variable">i</span> + <span class="hljs-variable">RGBIndex</span>.<span class="hljs-variable">GREEN</span>] = <span class="hljs-variable">rgb</span>[<span class="hljs-variable">RGBIndex</span>.<span class="hljs-variable">GREEN</span>];</li><li>    <span class="hljs-variable">colorInfo</span>[<span class="hljs-variable">i</span> + <span class="hljs-variable">RGBIndex</span>.<span class="hljs-variable">BLUE</span>] = <span class="hljs-variable">rgb</span>[<span class="hljs-variable">RGBIndex</span>.<span class="hljs-variable">BLUE</span>];</li><li>  }</li><li>  <span class="hljs-keyword">return</span> <span class="hljs-variable">newBufferArr</span>;</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/ImageEditTaskPool/entry/src/main/ets/view/WorkerPort.ets#L8-L40" target="_blank">WorkerPort.ets</a></div></div></div></div> <p></p></li><li><span>当主线程接收到子线程的计算结果时，如果还有剩余任务没有处理，就会复用该子Worker线程继续处理剩余任务；当所有任务都处理完成时，销毁所有子线程，并将所有任务处理结果进行合并进而更新UI。</span><p></p><div class="screenLinkPre"><div _ngcontent-olo-c106="" class="highlight-div"><div _ngcontent-olo-c106="" class="highlight-div-header"><div _ngcontent-olo-c106="" class="highlight-div-header-left"><div _ngcontent-olo-c106="" class="handle-button expand-button"><div _ngcontent-olo-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-olo-c106="" class="highlight-div-header-right"><div _ngcontent-olo-c106="" class="handle-button ai-button"></div><div _ngcontent-olo-c106="" class="handle-button line-button"><div _ngcontent-olo-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-olo-c106="" class="handle-button theme-button"><div _ngcontent-olo-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-olo-c106="" class="handle-button copy-button"><div _ngcontent-olo-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-olo-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-javascript" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/ImageEditTaskPool/entry/src/main/ets/view/newBuffer1.ets#L12-L56" data-highlighted="yes"><ol class="linenums"><li>  <span class="hljs-keyword">let</span> num = <span class="hljs-number">0</span>; <span class="hljs-comment">// Number of tasks processed</span></li><li>  <span class="hljs-keyword">let</span> <span class="hljs-attr">newBuffers</span>: <span class="hljs-title class_">ArrayBuffer</span>[] = [];</li><li>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; taskNum; i++) {</li><li>    newBuffers[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// Initialize calculation result data of each task</span></li><li>  }</li><li>  <span class="hljs-title class_">Workers</span>[index].<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">e: ESObject</span>) =&gt;</span> {</li><li>    newBuffers[e.<span class="hljs-property">data</span>.<span class="hljs-property">index</span>] = e.<span class="hljs-property">data</span>.<span class="hljs-property">buffer</span>; <span class="hljs-comment">// The main thread receives the calculation result.</span></li><li>    num = num + <span class="hljs-number">1</span>; <span class="hljs-comment">// Number of tasks completed +1</span></li><li>    <span class="hljs-keyword">if</span> (allocation !== <span class="hljs-number">0</span>) { <span class="hljs-comment">// If the total task has not been processed, reuse the sub-thread to continue processing the remaining tasks.</span></li><li>      <span class="hljs-title class_">Workers</span>[index].<span class="hljs-title function_">postMessage</span>(messages[n]);</li><li>      n += <span class="hljs-number">1</span>;</li><li>      allocation = allocation - <span class="hljs-number">1</span>;</li><li>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num === taskNum) {</li><li>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; curTaskNum; i++) {</li><li>        <span class="hljs-title class_">Workers</span>[i].<span class="hljs-title function_">terminate</span>(); <span class="hljs-comment">// When all tasks are processed, the child thread is destroyed.</span></li><li>      }</li><li>      <span class="hljs-keyword">const</span> entireArrayBuffer = <span class="hljs-title function_">mergeArrayBuffers</span>(newBuffers); <span class="hljs-comment">// Merge all task calculation results</span></li><li>      that.<span class="hljs-title function_">updatePixelMap</span>(entireArrayBuffer); <span class="hljs-comment">// Refresh the UI according to the calculation result.</span></li><li>    }</li><li>  }</li><li><span class="hljs-comment">// Merge the calculation results of all tasks.</span></li><li><span class="hljs-keyword">function</span> <span class="hljs-title function_">mergeArrayBuffers</span>(<span class="hljs-params">buffers: <span class="hljs-built_in">ArrayBuffer</span>[]</span>) {</li><li>  <span class="hljs-comment">// Calculate the combined total length.</span></li><li>  <span class="hljs-keyword">let</span> totalLength = buffers.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">length, buffer</span>) =&gt;</span> {</li><li>    length += buffer.<span class="hljs-property">byteLength</span>;</li><li>    <span class="hljs-keyword">return</span> length;</li><li>  }, <span class="hljs-number">0</span>);</li><li>  <span class="hljs-comment">// Create a new ArrayBuffer.</span></li><li>  <span class="hljs-keyword">let</span> mergedBuffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(totalLength);</li><li>  <span class="hljs-comment">// Create a Uint8Array to operate the new ArrayBuffer.</span></li><li>  <span class="hljs-keyword">let</span> mergedArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(mergedBuffer);</li><li>  <span class="hljs-comment">// Copy the contents of each ArrayBuffer to the new ArrayBuffer in turn.</span></li><li>  <span class="hljs-keyword">let</span> offset = <span class="hljs-number">0</span>;</li><li>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> buffer <span class="hljs-keyword">of</span> buffers) {</li><li>    <span class="hljs-keyword">let</span> array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(buffer);</li><li>    mergedArray.<span class="hljs-title function_">set</span>(array, offset);</li><li>    offset += array.<span class="hljs-property">length</span>;</li><li>  }</li><li>  <span class="hljs-keyword">return</span> mergedBuffer;</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/ImageEditTaskPool/entry/src/main/ets/view/newBuffer1.ets#L12-L56" target="_blank">newBuffer1.ets</a></div></div></div></div> <p></p></li></ol> <p>基于以上示例代码，可以发现使用Worker需要关注任务池个数上限，并管理Worker线程的生命周期，当任务数较多时难免会增加代码的复杂度。</p> <p></p> <p><strong>使用TaskPool处理图片</strong></p> <p>TaskPool提供了比较简洁的API接口，开发者只需把任务方法、参数传入execute()接口，等待任务执行完成返回结果就行了，无需关注线程的创建，系统会自动根据任务量多少进行扩容及缩容。TaskPool还提供了一些常用功能，支持任务执行，任务Task或任务组TaskGroup的创建、配置任务优先级、任务取消等功能，以满足开发者更多的开发场景。本实践利用TaskGroup任务组的能力，将一个大的任务拆分成多个小的任务放进一个任务组中等待调度执行。</p> <p>使用TaskPool进行图片处理步骤如下，其中根据图片编辑类型分别对图片进行处理，针对图片亮度和饱和度根据任务数对图片数据进行拆分、图片像素点的计算，以及任务结果的合并与Worker的处理逻辑一致，在此不再赘述。</p> <ol><li><span>根据图片编辑类型分别处理。</span><p></p><div class="screenLinkPre"><div _ngcontent-olo-c106="" class="highlight-div"><div _ngcontent-olo-c106="" class="highlight-div-header"><div _ngcontent-olo-c106="" class="highlight-div-header-left"><div _ngcontent-olo-c106="" class="handle-button expand-button"><div _ngcontent-olo-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-olo-c106="" class="highlight-div-header-right"><div _ngcontent-olo-c106="" class="handle-button ai-button"></div><div _ngcontent-olo-c106="" class="handle-button line-button"><div _ngcontent-olo-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-olo-c106="" class="handle-button theme-button"><div _ngcontent-olo-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-olo-c106="" class="handle-button copy-button"><div _ngcontent-olo-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-olo-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-typescript" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/ImageEditTaskPool/entry/src/main/ets/view/AdjustContentView.ets#L175-L224" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// ImageEditTaskPool/entry/src/main/ets/view/AdjustContentView.ets</span></li><li><span class="hljs-keyword">async</span> <span class="hljs-title function_">sliderChange</span>(<span class="hljs-params">value: <span class="hljs-built_in">number</span>, mode: SliderChangeMode</span>) {</li><li>  <span class="hljs-comment">// ...</span></li><li>    <span class="hljs-keyword">const</span> needBrightness = <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentAdjustData</span>[<span class="hljs-title class_">AdjustId</span>.<span class="hljs-property">BRIGHTNESS</span>] !== <span class="hljs-title class_">CommonConstants</span>.<span class="hljs-property">SLIDER_MAX</span>;</li><li>    <span class="hljs-keyword">const</span> needSaturation = <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentAdjustData</span>[<span class="hljs-title class_">AdjustId</span>.<span class="hljs-property">SATURATION</span>] !== <span class="hljs-title class_">CommonConstants</span>.<span class="hljs-property">SLIDER_MAX</span>;</li><li>    <span class="hljs-keyword">if</span> (needBrightness || needSaturation) {</li><li>      <span class="hljs-keyword">try</span> {</li><li>        <span class="hljs-keyword">if</span> (needBrightness) {</li><li>          buffer = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">execImageProcessing</span>(buffer, <span class="hljs-title class_">AdjustId</span>.<span class="hljs-property">BRIGHTNESS</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentAdjustData</span>[<span class="hljs-title class_">AdjustId</span>.<span class="hljs-property">BRIGHTNESS</span>]);</li><li>        }</li><li>        <span class="hljs-keyword">if</span> (needSaturation) {</li><li>          buffer = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">execImageProcessing</span>(buffer, <span class="hljs-title class_">AdjustId</span>.<span class="hljs-property">SATURATION</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentAdjustData</span>[<span class="hljs-title class_">AdjustId</span>.<span class="hljs-property">SATURATION</span>]);</li><li>        }</li><li>        px.<span class="hljs-title function_">writeBufferToPixelsSync</span>(buffer);</li><li>      } <span class="hljs-keyword">catch</span> (err) {</li><li>        <span class="hljs-keyword">let</span> error = err <span class="hljs-keyword">as</span> <span class="hljs-title class_">BusinessError</span>;</li><li>        hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x0000</span>, <span class="hljs-variable constant_">TAG</span>, <span class="hljs-string">`<span class="hljs-subst">${error.code}</span>, <span class="hljs-subst">${error.message}</span>`</span>);</li><li>      }</li><li>    }</li><li>
</li><li>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">currentAdjustData</span>[<span class="hljs-title class_">AdjustId</span>.<span class="hljs-property">TRANSPARENCY</span>] !== <span class="hljs-title class_">CommonConstants</span>.<span class="hljs-property">SLIDER_MAX</span>) {</li><li>      <span class="hljs-keyword">const</span> opacity = <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentAdjustData</span>[<span class="hljs-title class_">AdjustId</span>.<span class="hljs-property">TRANSPARENCY</span>] / <span class="hljs-title class_">CommonConstants</span>.<span class="hljs-property">SLIDER_MAX</span>;</li><li>      <span class="hljs-keyword">try</span> {</li><li>        px.<span class="hljs-title function_">opacitySync</span>(opacity);</li><li>      } <span class="hljs-keyword">catch</span> (err) {</li><li>        <span class="hljs-keyword">let</span> error = err <span class="hljs-keyword">as</span> <span class="hljs-title class_">BusinessError</span>;</li><li>        hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x0000</span>, <span class="hljs-variable constant_">TAG</span>, <span class="hljs-string">`<span class="hljs-subst">${error.code}</span>, <span class="hljs-subst">${error.message}</span>`</span>);</li><li>      }</li><li>    }</li><li>    <span class="hljs-comment">// ...</span></li><li>  }</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/ImageEditTaskPool/entry/src/main/ets/view/AdjustContentView.ets#L175-L224" target="_blank">AdjustContentView.ets</a></div></div></div></div> <p></p></li><li><span>根据任务数拆分任务，并把任务放进任务组里面，调用TaskPool的execute()接口将TaskGroup任务组中的每个任务放入线程池中，系统会根据第二个参数任务优先级进行调度执行。TaskGroup任务组内的每个任务的执行顺序会与执行结果数组中的顺序保持一致。将任务组的执行结果（数组内多个任务的处理结果）合并并返回给主线程。</span><p></p><div class="screenLinkPre"><div _ngcontent-olo-c106="" class="highlight-div"><div _ngcontent-olo-c106="" class="highlight-div-header"><div _ngcontent-olo-c106="" class="highlight-div-header-left"><div _ngcontent-olo-c106="" class="handle-button expand-button"><div _ngcontent-olo-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-olo-c106="" class="highlight-div-header-right"><div _ngcontent-olo-c106="" class="handle-button ai-button"></div><div _ngcontent-olo-c106="" class="handle-button line-button"><div _ngcontent-olo-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-olo-c106="" class="handle-button theme-button"><div _ngcontent-olo-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-olo-c106="" class="handle-button copy-button"><div _ngcontent-olo-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-olo-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-typescript" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/ImageEditTaskPool/entry/src/main/ets/view/AdjustContentView.ets#L228-L351" data-highlighted="yes"><ol class="linenums"><li>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> <span class="hljs-title function_">execImageProcessing</span>(<span class="hljs-attr">buffer</span>: <span class="hljs-title class_">ArrayBuffer</span>, <span class="hljs-attr">type</span>: <span class="hljs-title class_">AdjustId</span>, <span class="hljs-attr">value</span>: <span class="hljs-built_in">number</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">ArrayBuffer</span>&gt; {</li><li>    <span class="hljs-keyword">const</span> buffers = <span class="hljs-title function_">splitArrayBuffer</span>(buffer, <span class="hljs-number">240</span>);</li><li>    <span class="hljs-keyword">const</span> group = <span class="hljs-title function_">splitTask</span>(buffers, <span class="hljs-keyword">type</span>, value);</li><li>    <span class="hljs-keyword">try</span> {</li><li>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">mergeArrayBuffers</span>(<span class="hljs-keyword">await</span> taskpool.<span class="hljs-title function_">execute</span>(group, taskpool.<span class="hljs-property">Priority</span>.<span class="hljs-property">HIGH</span>) <span class="hljs-keyword">as</span> <span class="hljs-title class_">ArrayBuffer</span>[]);</li><li>    } <span class="hljs-keyword">catch</span> (err) {</li><li>      <span class="hljs-keyword">let</span> error = err <span class="hljs-keyword">as</span> <span class="hljs-title class_">BusinessError</span>;</li><li>      hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x0000</span>, <span class="hljs-variable constant_">TAG</span>, <span class="hljs-string">`<span class="hljs-subst">${error.code}</span>, <span class="hljs-subst">${error.message}</span>`</span>);</li><li>      <span class="hljs-keyword">return</span> buffer;</li><li>    }</li><li>  }</li><li><span class="hljs-comment">/**</span></li><li><span class="hljs-comment"> * Each task processes a portion of the pixel data and adds the task to the task group.</span></li><li><span class="hljs-comment"> *</span></li><li><span class="hljs-comment"> */</span></li><li><span class="hljs-keyword">function</span> <span class="hljs-title function_">splitTask</span>(<span class="hljs-params">buffers: <span class="hljs-built_in">ArrayBuffer</span>[], <span class="hljs-keyword">type</span>: AdjustId, value: <span class="hljs-built_in">number</span></span>): taskpool.<span class="hljs-property">TaskGroup</span> {</li><li>  <span class="hljs-comment">// Creating a Task Group</span></li><li>  <span class="hljs-keyword">let</span> <span class="hljs-attr">group</span>: taskpool.<span class="hljs-property">TaskGroup</span> = <span class="hljs-keyword">new</span> taskpool.<span class="hljs-title class_">TaskGroup</span>();</li><li>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> buffer <span class="hljs-keyword">of</span> buffers) {</li><li>    <span class="hljs-keyword">try</span> {</li><li>      group.<span class="hljs-title function_">addTask</span>(imageProcessing, {</li><li>        <span class="hljs-comment">// Add a task to a task group</span></li><li>        <span class="hljs-attr">value</span>: value,</li><li>        <span class="hljs-attr">buffer</span>: buffer,</li><li>        <span class="hljs-attr">type</span>: <span class="hljs-keyword">type</span></li><li>      });</li><li>    } <span class="hljs-keyword">catch</span> (err) {</li><li>      hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x0000</span>, <span class="hljs-string">'AdjustContentView'</span>, <span class="hljs-string">'Failed to add the task: '</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(err) ?? <span class="hljs-string">''</span>);</li><li>    }</li><li>  }</li><li>  <span class="hljs-keyword">return</span> group;</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/ImageEditTaskPool/entry/src/main/ets/view/AdjustContentView.ets#L228-L351" target="_blank">AdjustContentView.ets</a></div></div></div></div> <p></p></li></ol> <p>使用TaskPool并发方案处理耗时任务代码写法比较简洁，开发者更容易上手。</p> </div> <p>根据以上示例代码对比可以看出，使用Worker需要开发者关注线程数量的上限，管理线程生命周期，随着任务的增多也会增加线程管理的复杂度。使用TaskPool并发方案处理耗时任务代码写法比Worker简洁，开发者很容易上手。TaskPool支持任务组、任务优先级、取消任务等能力，为开发者提供了更多场景选择。</p> <div class="tiledSection"><h3 id="section14276115853613">线程创建耗时对比<i class="anchor-icon anchor-icon-link" anchorid="section14276115853613" tips="复制节点链接"></i></h3><p>从Worker与TaskPool的工作原理和编码效率我们可以得知如下结论：</p> <ul><li>Worker需要开发者关注线程数量上限，管理线程生命周期，为了避免大量的系统资源消耗，需要开发者尽量复用已创建线程处理耗时任务。</li><li>TaskPool无需开发者关注线程生命周期的管理，通过系统统一线程管理，结合动态调度和负载均衡算法，可以节约系统资源。</li></ul> <p>因此创建线程耗时 Worker &gt; TaskPool，对于应用首帧快速响应的场景推荐使用TaskPool。</p> </div> <div class="tiledSection"><h3 id="section12536228184113">数据传输方式对比<i class="anchor-icon anchor-icon-link" anchorid="section12536228184113" tips="复制节点链接"></i></h3><p>使用Worker与TaskPool处理并发任务时需要将数据从主线程传递到任务池的执行线程。目前支持传输的数据对象可以分为<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/normal-object" target="_blank">普通对象</a>、<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arraybuffer-object" target="_blank">ArrayBuffer对象</a>、<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/shared-arraybuffer-object" target="_blank">SharedArrayBuffer对象</a>、<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/transferabled-object" target="_blank">Transferable对象</a>、<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/sendable-object" target="_blank">Sendable对象</a>五种，具体可参考指南文档。Worker与TaskPool均提供了两种传递数据的方式。</p> <ul><li>转移控制权：可以将transfer列表中的ArrayBuffer对象在传输时转移控制权至工作线程，而非复制内容到工作线程。传输后当前的ArrayBuffer失效，在宿主线程中将变为不可用，不允许再访问。</li><li>深拷贝：将宿主线程的数据复制一份传递给执行线程，执行线程对数据的修改不会对宿主线程中的原数据产生影响。</li></ul> <p>其中Worker提供<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-worker#postmessage9" target="_blank">postMessage()</a>接口，TaskPool提供了<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-taskpool#settransferlist10" target="_blank">setTransferList()</a>接口，开发者可以根据实际需要，调整参数控制采用哪种方式传递数据。</p> <p>TaskPool与Worker底层都是采用了同一套序列化与反序列化的机制。主要差异体现在TaskPool支持任务方法的传递，而Worker的任务方法需要写在对应的Worker.ets文件中，相较于Worker，TaskPool多了任务方法的序列化与反序列化步骤。</p> <p>我们以TaskPool在任务数为1时（任务方法、参数、运行结果）的序列化与反序列化为例，统计一下序列化与反序列化的相关数据如下表所示：</p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><caption><b>表1 </b>一个任务时TaskPool序列化、反序列化耗时及效率情况</caption><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.10.7.2.7.1.1" valign="top" width="12.22755448910218%">&nbsp;&nbsp;</th> <th align="left" class="cellrowborder" id="mcps1.3.10.7.2.7.1.2" valign="top" width="21.105778844231153%"><p>序列化数据量（bytes）</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.10.7.2.7.1.3" valign="top" width="16.666666666666664%"><p>序列化时间（μs）</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.10.7.2.7.1.4" valign="top" width="16.666666666666664%"><p>序列化效率（B/μs）</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.10.7.2.7.1.5" valign="top" width="16.666666666666664%"><p>反序列化时间（μs）</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.10.7.2.7.1.6" valign="top" width="16.666666666666664%"><p>反序列化效率（B/μs）</p> </th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="12.22755448910218%"><p>方法</p> </td> <td class="cellrowborder" valign="top" width="21.105778844231153%"><p>58</p> </td> <td class="cellrowborder" valign="top" width="16.666666666666664%"><p>9.549</p> </td> <td class="cellrowborder" valign="top" width="16.666666666666664%"><p>6.833</p> </td> <td class="cellrowborder" valign="top" width="16.666666666666664%"><p>43.749</p> </td> <td class="cellrowborder" valign="top" width="16.666666666666664%"><p>1.457</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="12.22755448910218%"><p>参数</p> </td> <td class="cellrowborder" valign="top" width="21.105778844231153%"><p>217</p> </td> <td class="cellrowborder" valign="top" width="16.666666666666664%"><p>36.111</p> </td> <td class="cellrowborder" valign="top" width="16.666666666666664%"><p>6.023</p> </td> <td class="cellrowborder" valign="top" width="16.666666666666664%"><p>115.294</p> </td> <td class="cellrowborder" valign="top" width="16.666666666666664%"><p>1.933</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="12.22755448910218%"><p>结果</p> </td> <td class="cellrowborder" valign="top" width="21.105778844231153%"><p>47</p> </td> <td class="cellrowborder" valign="top" width="16.666666666666664%"><p>16.667</p> </td> <td class="cellrowborder" valign="top" width="16.666666666666664%"><p>2.990</p> </td> <td class="cellrowborder" valign="top" width="16.666666666666664%"><p>85.243</p> </td> <td class="cellrowborder" valign="top" width="16.666666666666664%"><p>0.567</p> </td> </tr>  </tbody></table></div> </div> <p>上面实验待编辑图片有24520520个像素字节数，如果采用转移控制权的方式，序列化的数据就小很多且效率高。采用深拷贝方式的话会增加序列化与反序列化的开销。在宿主线程将数据（支持控制权转移）传递给执行线程后，不需要紧接着对数据进行访问的场景，推荐使用<strong>转移控制权</strong>的方式，这样可以提升数据传输效率。</p> <p></p> <p>TaskPool与Worker都具有转移控制权、深拷贝两种方式，Worker不支持任务方法的传递，只能将任务方法写在Worker.ets文件中。TaskPool支持任务方法的传递，因此相较于Worker，TaskPool多了任务方法的序列化与反序列化步骤。数据传输两者差异不大。</p> </div> <div class="tiledSection"><h3 id="section13703144154212">任务执行完成耗时对比<i class="anchor-icon anchor-icon-link" anchorid="section13703144154212" tips="复制节点链接"></i></h3><p>分别在中载、重载环境下运行，随着任务数的增多，图片编辑完成任务耗时，如下图所示：</p> <div class="fignone"><span class="figcap"><b>图5 </b>中载模型下Worker与TaskPool耗时对比</span><p><span><img height="321.954164" originheight="452" originwidth="752" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163015.48215981482306230940099297088529:50001231000000:2800:0BBF0E5825A51F631D68CE5AD1B80741595DC6A43928AE1B89E919E56B201E3E.png" title="点击放大" width="535.6575"></span></p> </div> <div class="fignone"><span class="figcap"><b>图6 </b>重载模型下TaskPool与Worker耗时对比</span></div> <p><span><img height="321.96413900000005" originheight="452" originwidth="752" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163015.72122081821729527669597549744800:50001231000000:2800:B4F04747CCEB0FD7D5CA23E80A7EA2A4FC0C87AFFA15A253004A11755526EC7F.png" title="点击放大" width="535.6575"></span></p> <p>从模型实验数据可以看出：</p> <ol><li>在并发任务数为1时，执行完任务TaskPool与Worker均相近；随着并发任务数的增多，TaskPool的完成任务的耗时大致上逐渐缩短，而Worker则先下降再升高。</li><li>在任务数为4时，Worker效率最高，相比于单任务减少了约57%的耗时；</li><li>TaskPool在并发数&gt;8后优于Worker并趋于稳定，相比于单任务减少了约50%的耗时。</li></ol> <p>随着任务数的增多TaskPool逐渐优于Worker，这是由于TaskPool支持高优先级设置，在系统资源不足时，高优先级的任务更容易获得系统资源，所以TaskPool执行耗时任务相对Worker稍快一些。</p> <p>从中载模型实验数据可以看出：</p> <ol><li>在并发任务数为1时，执行完任务TaskPool与Worker分别用了119s、121s；随着并发任务数的增多完成任务的耗时逐渐缩短，在任务数为4时，执行完任务TaskPool与Worker分别用了41s、40s，相比于单任务TaskPool有65%的性能收益，Worker有67%的性能收益；</li><li>当任务数大于4时，Worker执行耗时几乎稳定在40s左右，TaskPool在任务数为8时耗时较多，这是因为TaskPool最多可以创建（内核数-1）个线程，对于8核的手机来说最多可以创建7个线程，所以当有8个任务时，其中一个任务要串行执行，因此总耗时较多，任务数大于8时完成任务耗时稳定于39s左右。</li><li>中载模型下任务数大于50时，TaskPool与Worker完成任务耗时差异不大。</li></ol> <p>经过以上中载、重载环境下的对比实验可以发现，并发可以带来约50%~65%收益，但并不是任务数越多越好，需要开发者根据任务及计算情况自己控制；随着任务数的增多在重载环境下TaskPool与Worker耗时差异比在中载环境下大，这是由于TaskPool支持高优先级设置，在系统资源不足时，高优先级的任务更容易获得系统资源，所以TaskPool执行耗时任务相对Worker稍快一些；中载环境下由于系统资源充足，TaskPool的高优先设置效果没有那么明显，所以TaskPool与Worker完成任务耗时几乎相当。</p> </div> <div class="tiledSection"><h3 id="section658114119423">运行时内存占用对比<i class="anchor-icon anchor-icon-link" anchorid="section658114119423" tips="复制节点链接"></i></h3><p>分别在中载、重载环境下，随着任务数的增多，统计图片编辑前一刻与完成任务时刻应用内存增量的变化情况，如下图所示：</p> <div class="fignone"><span class="figcap"><b>图7 </b>中载模型下TaskPool与Worker运行时内存占用对比</span><br><span><img height="222.44250000000002" originheight="277" originwidth="651" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163016.30952286013485751760715481199510:50001231000000:2800:FBC6B05D322235E9339ECCE4B23BAF55A43484B61BB68A83A052D840218A3EF7.png" title="点击放大" width="523.6875"></span></div> <div class="fignone"><span class="figcap"><b>图8 </b>重载模型下TaskPool与Worker运行时内存占用对比</span><br><span><img height="249.375" originheight="323" originwidth="677" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163016.93908833894058749002001737670248:50001231000000:2800:ACAB3DD2389D67ECE9988EE1029CD485A23D3CF11D5CB775A3F5010B40A930FE.png" title="点击放大" width="523.6875"></span></div> <p>从以上实验数据可以看出：</p> <p>任务数较少时使用Worker与TaskPool的运行内存差别不大，随着任务数的增多TaskPool的运行内存明显比Worker大。</p> <p><span style="color: rgb(36,41,46);">这是由于TaskPool</span><span style="color: rgb(36,41,46);">在Worker之上做了更多场景化封装，TaskPool实现了调度器和Worker线程池，</span>随着任务数的增多，运行时会多占用一些内存空间，待任务执行完毕之后都会进行回收和释放。</p> </div> <div class="tiledSection"><h2 id="section1941159164216">总结<i class="anchor-icon anchor-icon-link" anchorid="section1941159164216" tips="复制节点链接"></i></h2> <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><caption><b>表2 </b>TaskPool与Worker并发方案对比</caption><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.13.2.2.4.1.1" valign="top" width="11.261126112611262%"><p>对比维度</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.13.2.2.4.1.2" valign="top" width="32.893289328932894%"><p>Worker</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.13.2.2.4.1.3" valign="top" width="55.84558455845584%"><p>TaskPool</p> </th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="11.261126112611262%"><p>编码效率</p> </td> <td class="cellrowborder" valign="top" width="32.893289328932894%"><p>Worker需要开发者关注线程数量的上限，管理线程生命周期，随着任务的增多也会增加线程管理的复杂度。</p> </td> <td class="cellrowborder" valign="top" width="55.84558455845584%"><p>TaskPool简单易用，开发者很容易上手。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="11.261126112611262%"><p>线程创建耗时</p> </td> <td class="cellrowborder" valign="top" width="32.893289328932894%"><p>需要开发者自行管理线程数量上限，自行管理线程生命周期，尽可能复用已创建的线程。</p> </td> <td class="cellrowborder" valign="top" width="55.84558455845584%"><p>开发者无需要关注线程生命周期，线程创建。由系统统一调度管理。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="11.261126112611262%"><p>数据传输</p> </td> <td class="cellrowborder" valign="top" width="32.893289328932894%"><p>TaskPool与Worker都具有转移控制权、深拷贝两种方式，Worker不支持任务方法的传递，只能将任务方法写在Worker.ets文件中。</p> </td> <td class="cellrowborder" valign="top" width="55.84558455845584%"><p>传输方式与Worker相同；TaskPool支持任务方法的传递，因此相较于Worker，TaskPool多了任务方法的序列化与反序列化步骤。数据传输两者差异不大。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="11.261126112611262%"><p>任务执行耗时</p> </td> <td class="cellrowborder" valign="top" width="32.893289328932894%"><p>任务数较少时优于TaskPool，当任务数大于8后逐渐落后于TaskPool。</p> </td> <td class="cellrowborder" valign="top" width="55.84558455845584%"><p>任务数较少时劣于Worker，随着任务数的增多，TaskPool的高优先级任务模式能够更容易的抢占到系统资源，因此完成任务耗时比Worker少。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="11.261126112611262%"><p>运行时内存占用</p> </td> <td class="cellrowborder" valign="top" width="32.893289328932894%"><p>运行时占用内存较少。</p> </td> <td class="cellrowborder" valign="top" width="55.84558455845584%"><p>随着任务数的增多占用内存比Worker高。</p> </td> </tr>  </tbody></table></div> </div> <ol><li>编码效率：TaskPool写法比Worker更简洁更好掌控，TaskPool还支持任务组、任务优先级、取消任务等能力。如果有这些场景的需要，可以采用TaskPool并发方案。</li><li>线程创建耗时：Worker比TaskPool创建线程的开销大，因此对于应用首帧要求快速响应的场景推荐使用TaskPool。</li><li>数据传输：TaskPool支持将任务方法作为一个参数进行传输，任务方法的序列化与反序列化耗时很短，可以忽略其影响。在需要处理多个不同任务的场景，TaskPool可以直接传递任务方法，而Worker需要创建Worker.ets文件承载任务方法相对复杂，此场景推荐使用TaskPool；其他情况下开发者可以选择Worker，也可以选择TaskPool。</li><li>任务执行耗时：在中载场景下两种并发方案都可以选择，在重载下需要任务优先执行的场景推荐使用TaskPool并发方案。</li><li>运行时内存占用：开发者可以根据实际运行的设备内存情况选择合适的并发方案。</li></ol> <p>本实践只对比了编码效率、线程创建耗时、数据传输、任务执行耗时、应用运行内存占用方面TaskPool与Worker的差异，更多参见<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/taskpool-vs-worker" target="_blank">TaskPool和Worker的对比</a>。</p> <p></p> <p>经过以上实验分析，ArkTS图片编辑任务在重载模型下单任务执行耗时119s，4个任务时耗时41s（比单任务并发有50%~65%的收益），为非执行长耗时任务场景，从场景、编码效率等方面考量选择TaskPool方案比较合适。开发者可以根据自己业务的实际运用场景选择适合自己的并发方案。</p> </div> <div class="tiledSection"><h2 id="section147971528122310">示例代码<i class="anchor-icon anchor-icon-link" anchorid="section147971528122310" tips="复制节点链接"></i></h2><ul><li><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/tree/master/ImageEditTaskPool" target="_blank">基于TaskPool实现图片编辑功能</a></li><li><a href="https://gitee.com/harmonyos_codelabs/ImageEdit" target="_blank">基于Worker实现图片编辑功能</a></li></ul> </div> </div> <div></div></div>