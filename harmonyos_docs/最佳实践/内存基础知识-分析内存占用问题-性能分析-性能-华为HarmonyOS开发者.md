<h1 _ngcontent-xen-c119="" class="doc-title ng-star-inserted" title="内存基础知识"> 内存基础知识 </h1>

<div _ngcontent-xen-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;"> <div><div class="tiledSection"><h2 id="section085818715389">基本概念<i class="anchor-icon anchor-icon-link" anchorid="section085818715389" tips="复制节点链接"></i></h2><p><strong>内存组成关系图</strong></p> <p><span><img height="398.2997892859945" originheight="523" originwidth="1208" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163411.24076811579249779727530450367323:50001231000000:2800:77F91141C0FE32A7EFD9A5ADED24E61C1FCE2363710F561A621246EFCA0A00D0.png" title="点击放大" width="920"></span></p> <p>上图展示了内存基础的组成部分（RSS，PSS，VSS，物理内存，Swap）之间的关系, 下表对内存各组成部分进行详细介绍。</p> </div>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.2.1.5.1.1" valign="top" width="25%"><p>名称</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.2.1.5.1.2" valign="top" width="25%"><p>简介</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.2.1.5.1.3" valign="top" width="25.11%"><p>相关性/作用</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.2.1.5.1.4" valign="top" width="24.89%"><p>关系</p> </th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="25%"><p>VSS（Virtual Set Size）</p> </td> <td class="cellrowborder" valign="top" width="25%"><p>进程占用的所有虚拟内存大小，包括已分配但尚未使用的部分。</p> </td> <td class="cellrowborder" valign="top" width="25.11%"><p>反映了进程可能使用的最大地址空间。</p> </td> <td class="cellrowborder" valign="top" width="24.89%"><p>VSS = RSS + 虚拟内存已映射但未加载进物理内存的部分（如mmap映射或堆预留空间）。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="25%"><p>RSS（Resident Set Size）</p> </td> <td class="cellrowborder" valign="top" width="25%"><p>当前加载到物理内存中的那部分进程内存，包含私有内存和共享内存。</p> </td> <td class="cellrowborder" valign="top" width="25.11%"><p>显示实际占用的物理内存。</p> </td> <td class="cellrowborder" valign="top" width="24.89%"><p>RSS = USS + 共享内存。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="25%"><p>PSS（Proportional Set Size）</p> </td> <td class="cellrowborder" valign="top" width="25%"><p>按比例分摊后的内存大小，其中共享内存按参与共享的进程数平均计算。</p> </td> <td class="cellrowborder" valign="top" width="25.11%"><p>更准确地反映了多进程环境下的内存使用。</p> </td> <td class="cellrowborder" valign="top" width="24.89%"><p>PSS = USS + ∑(共享页大小 / 共享该页的进程数)。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="25%"><p>USS（Unique Set Size）</p> </td> <td class="cellrowborder" valign="top" width="25%"><p>仅属于该进程的私有内存，不包含任何共享部分。</p> </td> <td class="cellrowborder" valign="top" width="25.11%"><p>杀死进程后可释放的实际物理内存。</p> </td> <td class="cellrowborder" valign="top" width="24.89%"><p>-</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="25%"><p>交换分区（Swap）</p> </td> <td class="cellrowborder" valign="top" width="25%"><p>当物理内存不足时，系统会将一些不活跃的内存页移到硬盘上的交换区。</p> </td> <td class="cellrowborder" valign="top" width="25.11%"><p>增加系统的可用内存，但访问速度较慢。</p> </td> <td class="cellrowborder" valign="top" width="24.89%"><p>-</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="25%"><p>共享脏页（Shared Dirty Page）</p> </td> <td class="cellrowborder" valign="top" width="25%"><p>已经被修改过的共享内存页。</p> </td> <td class="cellrowborder" valign="top" width="25.11%"><p>与其他进程共享时，建议确保访问安全。</p> </td> <td class="cellrowborder" valign="top" width="24.89%"><p>-</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="25%"><p>私有脏页（Private Dirty Page）</p> </td> <td class="cellrowborder" valign="top" width="25%"><p>进程私有的并且已经被修改的内存区域。包括堆栈、已分配但尚未释放的堆内存等。</p> </td> <td class="cellrowborder" valign="top" width="25.11%"><p>完全属于单个进程，不能与其他进程共享。</p> </td> <td class="cellrowborder" valign="top" width="24.89%"><p>-</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="25%"><p>共享干净页（Shared Clean Page）</p> </td> <td class="cellrowborder" valign="top" width="25%"><p>进程间共享的、未修改的（干净）页面。比如，只读的共享库代码段就属于此类。</p> </td> <td class="cellrowborder" valign="top" width="25.11%"><p>可以被多个进程共享，且不会因为一个进程的修改而影响其他进程。</p> </td> <td class="cellrowborder" valign="top" width="24.89%"><p>-</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="25%"><p>私有干净页（Private Clean Page）</p> </td> <td class="cellrowborder" valign="top" width="25%"><p>进程中私有的、未被修改的数据或代码段。例如，可执行文件中的只读文本段。</p> </td> <td class="cellrowborder" valign="top" width="25.11%"><p>不与其他进程共享，但没有被修改过。</p> </td> <td class="cellrowborder" valign="top" width="24.89%"><p>-</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="25%"><p>匿名页（Anonymous Page）</p> </td> <td class="cellrowborder" valign="top" width="25%"><p>不对应任何具体文件的数据页，通常由堆、栈或mmap分配而来。</p> </td> <td class="cellrowborder" valign="top" width="25.11%"><p>如果没有足够的物理内存，可能会被交换出去。</p> </td> <td class="cellrowborder" valign="top" width="24.89%"><p>-</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="25%"><p>文件页（File backed Page）</p> </td> <td class="cellrowborder" valign="top" width="25%"><p>对应于某个文件的数据页，可以直接从文件系统恢复。</p> </td> <td class="cellrowborder" valign="top" width="25.11%"><p>可以直接丢弃并重新加载，无需保存到交换分区。</p> </td> <td class="cellrowborder" valign="top" width="24.89%"><p>-</p> </td> </tr>  </tbody></table></div> </div> <div class="tiledSection"><h2 id="section10295114974514">应用内存的组成<i class="anchor-icon anchor-icon-link" anchorid="section10295114974514" tips="复制节点链接"></i></h2><p><strong>应用内存组成图</strong></p> <p><span><img height="688.880416" originheight="842" originwidth="367" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163411.01051959961405090379918383087251:50001231000000:2800:45F504B9593122714EAEC09DB6D073F71AEA18FB0C64232099958E96D59593A0.png" title="点击放大" width="300.264391"></span></p> <p>上图展示了应用进程映射的虚拟内存空间基本的组成部分，下表对内存各组成部分进行详细介绍。</p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.3.5.1.5.1.1" valign="top" width="19.66%"><p>名称</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.3.5.1.5.1.2" valign="top" width="27.26%"><p>用途</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.3.5.1.5.1.3" valign="top" width="33.08%"><p>分配时机</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.3.5.1.5.1.4" valign="top" width="20%"><p>特点</p> </th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="19.66%"><p>栈（Stack）</p> </td> <td class="cellrowborder" valign="top" width="27.26%"><p>存放函数调用栈帧，包括局部变量、参数、返回地址等。</p> </td> <td class="cellrowborder" valign="top" width="33.08%"><p>每次函数调用时自动分配，函数返回后自动释放。</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>增长方向：向低地址增长。</p> <p>限制：默认大小有限（通常几MB），过深递归可能导致栈溢出。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="19.66%"><p>mmap分配区域</p> </td> <td class="cellrowborder" valign="top" width="27.26%"><p>用于文件映射、匿名映射、共享内存、大块内存分配等。</p> </td> <td class="cellrowborder" valign="top" width="33.08%"><p>使用mmap系统调用时； 使用malloc分配大块内存（超过阈值）时； 使用shmget创建共享内存； 使用mmap映射文件内容到内存进行读写。</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>优点：灵活，支持按需加载、共享访问。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="19.66%"><p>共享库（Shared Libraries）</p> </td> <td class="cellrowborder" valign="top" width="27.26%"><p>加载动态链接库（如 libc.so，libpthread.so）。</p> </td> <td class="cellrowborder" valign="top" width="33.08%"><p>程序启动时由动态链接器加载，程序运行时通过dlopen加载。</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>特点：多个进程可以共享同一份物理页（节省内存）。包含在mmap分配区域。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="19.66%"><p>堆（Heap）</p> </td> <td class="cellrowborder" valign="top" width="27.26%"><p>动态分配内存，用于malloc，calloc，new 等操作。</p> </td> <td class="cellrowborder" valign="top" width="33.08%"><p>在运行过程中根据程序需求动态扩展。</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>增长方向: 向高地址增长。</p> <p>管理方式: 通过brk和sbrk系统调用来调整堆顶。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="19.66%"><p>Heap Alloc</p> </td> <td class="cellrowborder" valign="top" width="27.26%"><p>已被分配并正在使用的堆内存大小。</p> </td> <td class="cellrowborder" valign="top" width="33.08%"><p>每当程序显式地请求内存（例如通过new关键字或类似的内存分配函数）并且成功获得所需内存时，即视为已分配内存的一部分。</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>直接反映了应用程序当前实际使用的堆内存量。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="19.66%"><p>Heap Free</p> </td> <td class="cellrowborder" valign="top" width="27.26%"><p>已在堆中分配但尚未被使用的内存。</p> </td> <td class="cellrowborder" valign="top" width="33.08%"><p>初始分配时，整个可用堆空间被视为“自由”的。随着程序运行，部分自由内存被占用，剩余未被使用的部分即为Heap Free。</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>这部分内存可供后续分配使用，但如果长时间未被利用，则可能造成浪费。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="19.66%"><p>ArkTS Heap</p> </td> <td class="cellrowborder" valign="top" width="27.26%"><p>由ArkTS管理的堆内存。它主要用于存储对象实例、变量等动态数据。</p> </td> <td class="cellrowborder" valign="top" width="33.08%"><p>ArkTS代码分配的堆内存。</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>-</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="19.66%"><p>Native Heap</p> </td> <td class="cellrowborder" valign="top" width="27.26%"><p>这是指原生代码（如C/C++编写的部分）所使用的堆内存。区别于ArkTS Heap。</p> </td> <td class="cellrowborder" valign="top" width="33.08%"><p>当使用malloc、calloc、realloc等函数或者new操作符来分配内存时发生。在调用涉及底层系统资源的操作时，例如打开文件、网络连接等，可能会在原生堆中分配内存以存储相关资源描述符或缓存数据。</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>-</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="19.66%"><p>Anonymous Page other（匿名内存页）</p> </td> <td class="cellrowborder" valign="top" width="27.26%"><p>没有关联文件映射的内存页。</p> </td> <td class="cellrowborder" valign="top" width="33.08%"><p>当程序请求更多的栈空间（比如递归调用过深）或通过mmap分配不与文件关联的内存区域会产生。动态分配的大块内存（如通过mmap直接从操作系统获取的大块内存）也可能是匿名页面。</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>这些页面通常用于存储进程私有的数据结构，比如栈空间或动态分配的内存块。因为它们是“匿名”的，所以不能被多个进程共享。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="19.66%"><p>FilePage Other</p> </td> <td class="cellrowborder" valign="top" width="27.26%"><p>这类内存页是从文件映射过来的，但是不属于任何特定的大类。</p> </td> <td class="cellrowborder" valign="top" width="33.08%"><p>当应用通过mmap将文件内容映射到内存中以便快速访问时产生。</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>当应用程序读取文件或者加载资源时，操作系统可能会将这些文件的内容映射到内存中，以便快速访问。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="19.66%"><p>GL（图形内存）</p> </td> <td class="cellrowborder" valign="top" width="27.26%"><p>这部分内存专门用于存储纹理、帧缓冲区等图形资源。</p> </td> <td class="cellrowborder" valign="top" width="33.08%"><p>创建纹理、帧缓冲区、顶点缓冲区等图形资源时，在graph library中分配内存。</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>-</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="19.66%"><p>未初始化数据段 (BSS Segment)</p> </td> <td class="cellrowborder" valign="top" width="27.26%"><p>存放未显式初始化的全局变量和静态变量。</p> </td> <td class="cellrowborder" valign="top" width="33.08%"><p>进程启动时由系统清零初始化。 示例：static int uninit_var。</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>-</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="19.66%"><p>已初始化数据段 (Data Segment)</p> </td> <td class="cellrowborder" valign="top" width="27.26%"><p>存放初始化过的全局变量和静态变量。</p> </td> <td class="cellrowborder" valign="top" width="33.08%"><p>进程启动时根据可执行文件内容初始化。 示例：int global_var = 10。</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>-</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="19.66%"><p>代码段（Text Segment）</p> </td> <td class="cellrowborder" valign="top" width="27.26%"><p>存放程序的机器指令（即编译后的二进制代码）。</p> </td> <td class="cellrowborder" valign="top" width="33.08%"><p>进程启动时由内核从可执行文件中加载。 属性：只读、可执行。</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>-</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="19.66%"><p>只读数据段（RO Data Segment）</p> </td> <td class="cellrowborder" valign="top" width="27.26%"><p>存放常量字符串、const变量等只读数据。</p> </td> <td class="cellrowborder" valign="top" width="33.08%"><p>启动时加载，与可执行文件中的.rodata段对应。 示例：const char* str = "hello"。</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>-</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="19.66%"><p>内核保留区 (Guard Pages)</p> </td> <td class="cellrowborder" valign="top" width="27.26%"><p>防止栈溢出或非法访问相邻内存区域。</p> </td> <td class="cellrowborder" valign="top" width="33.08%"><p>系统自动添加在栈下方或其他关键区域之间。</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>行为：访问该区域会触发段错误（Segmentation Fault）。</p> </td> </tr>  </tbody></table></div> </div> </div> </div> <div></div></div>