<h1 _ngcontent-mcl-c119="" class="doc-title ng-star-inserted" title="前台不可见动效问题分析"> 前台不可见动效问题分析 </h1>

<div _ngcontent-mcl-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;"> <div><p>当开发者进行应用<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-power-basic-quality-test">功耗基础质量测试</a>或提交应用上架审核时，若遇到应用存在不可见动效的问题，可参照以下步骤进行分析。</p> <div class="tiledSection"><h2 id="section154193207365">异常场景确认<i class="anchor-icon anchor-icon-link" anchorid="section154193207365" tips="复制节点链接"></i></h2></div> <p>当前应用上架检测会拦截统一合成图层DisplayNode存在不必要绘制的应用，开发者可以通过USB连接设备，按照以下hdc命令打开图形相关的debug级别日志（直接打开终端执行下述命令）：</p> <div _ngcontent-mcl-c106="" class="highlight-div"><div _ngcontent-mcl-c106="" class="highlight-div-header"><div _ngcontent-mcl-c106="" class="highlight-div-header-left"><div _ngcontent-mcl-c106="" class="handle-button expand-button"><div _ngcontent-mcl-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-mcl-c106="" class="highlight-div-header-right"><div _ngcontent-mcl-c106="" class="handle-button ai-button"></div><div _ngcontent-mcl-c106="" class="handle-button line-button"><div _ngcontent-mcl-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-mcl-c106="" class="handle-button theme-button"><div _ngcontent-mcl-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-mcl-c106="" class="handle-button copy-button"><div _ngcontent-mcl-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-mcl-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-css" data-highlighted="yes"><ol class="linenums"><li>hdc shell hilog -<span class="hljs-selector-tag">b</span> D -D <span class="hljs-number">0</span>xD001400</li><li>hdc shell hilog -<span class="hljs-selector-tag">b</span> D -D <span class="hljs-number">0</span>xD001406</li></ol></pre></div></div> <p>然后命令行执行如下流水日志采集命令监控日志输出</p> <div _ngcontent-mcl-c106="" class="highlight-div"><div _ngcontent-mcl-c106="" class="highlight-div-header"><div _ngcontent-mcl-c106="" class="highlight-div-header-left"><div _ngcontent-mcl-c106="" class="handle-button expand-button"><div _ngcontent-mcl-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-mcl-c106="" class="highlight-div-header-right"><div _ngcontent-mcl-c106="" class="handle-button ai-button"></div><div _ngcontent-mcl-c106="" class="handle-button line-button"><div _ngcontent-mcl-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-mcl-c106="" class="handle-button theme-button"><div _ngcontent-mcl-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-mcl-c106="" class="handle-button copy-button"><div _ngcontent-mcl-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-mcl-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-bash" data-highlighted="yes"><ol class="linenums"><li>hdc shell <span class="hljs-string">"hilog | grep 'Node skip'"</span></li></ol></pre></div></div> <p>运行应用复现场景，观察日志的打印情况，每一行“Node skip”打印代表有一帧统一合成图层存在空跑，若日志打印频率过高（大于5次/秒），可初步判定该界面存在前台不可见动效问题。</p> <div class="tiledSection"><h2 id="section2041913208361">分析思路<i class="anchor-icon anchor-icon-link" anchorid="section2041913208361" tips="复制节点链接"></i></h2></div> <p>前台不可见动效问题通常源于组件的生命周期管理与启停控制不当。以动图组件为例，当动图进入不可见状态但组件缺乏回调机制，或回调后未能成功停止，动图可能会在软件全场景下空跑，导致严重的功耗异常和发热问题。前台不可见动效的检测可用于识别并防止组件在不可见状态下继续进行不必要的渲染和绘制操作，从而避免额外的CPU和GPU资源消耗。要求应用在切换到后台运行、组件被遮挡、切换到新页面、滑动到屏幕外部等场景时，具备充分的事件监听能力，及时感知这些事件并停止其刷新行为。</p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><tbody><tr><td class="cellrowborder" valign="top" width="11.100000000000001%"><p>问题大类</p> </td> <td class="cellrowborder" valign="top" width="25.540000000000006%"><p>细分类别</p> </td> <td class="cellrowborder" valign="top" width="25.120000000000005%"><p>根因</p> </td> <td class="cellrowborder" valign="top" width="19.800000000000004%"><p>影响程度</p> </td> <td class="cellrowborder" valign="top" width="18.440000000000005%"><p>是否触发DisplayNode skip拦截</p> </td> </tr> <tr><td class="cellrowborder" rowspan="3" valign="top" width="11.100000000000001%"><p>Vsync冗余信号</p> </td> <td class="cellrowborder" valign="top" width="25.540000000000006%"><p>不必要请求Vsync，执行完非绘制类业务后被跳过。</p> </td> <td class="cellrowborder" valign="top" width="25.120000000000005%"><p>应用或应用框架使用帧回调函数注册固定帧率的Vsync，普遍出现在React Native、Flutter、Web类应用中。</p> </td> <td class="cellrowborder" valign="top" width="19.800000000000004%"><p>通常较小，在非UI、RS进程上有冗余负载。</p> </td> <td class="cellrowborder" valign="top" width="18.440000000000005%"><p>不可能。</p> </td> </tr> <tr><td class="cellrowborder" rowspan="2" valign="top"><p>使用Vsync方法执行绘制任务或较重的业务逻辑。</p> </td> <td class="cellrowborder" valign="top"><p>不恰当使用系统提供的DisplaySync方法执行绘制任务。</p> </td> <td class="cellrowborder" valign="top"><p>中，UI进程中有持续的DisplayVsync任务。</p> </td> <td class="cellrowborder" valign="top"><p>可能。</p> </td> </tr> <tr><td class="cellrowborder" valign="top"><p>不恰当使用NativeVsyc，造成一个较重的负载任务持续执行不停止。</p> </td> <td class="cellrowborder" valign="top"><p>大，由Vsync引起的空跑问题，高度依赖三方自行控制，系统难感知。</p> </td> <td class="cellrowborder" valign="top"><p>可能。</p> </td> </tr> <tr><td class="cellrowborder" rowspan="2" valign="top" width="11.100000000000001%"><p>UI刷新问题</p> </td> <td class="cellrowborder" valign="top" width="25.540000000000006%"><p>冗余FlushRenderTask。</p> </td> <td class="cellrowborder" valign="top" width="25.120000000000005%"><p>1. 组件离开屏幕后，依然在绘制刷新。</p> <p>2. 非必要节点属性变更导致执行布局等刷新任务。</p> </td> <td class="cellrowborder" valign="top" width="19.800000000000004%"><p>中，会对UI、RS进程产生影响，一些场景会被系统兜底，仅影响RS。</p> </td> <td class="cellrowborder" valign="top" width="18.440000000000005%"><p>可能。</p> </td> </tr> <tr><td class="cellrowborder" valign="top"><p>冗余Animate。</p> </td> <td class="cellrowborder" valign="top"><p>1. 应用使用了Animate方法，但绑定的组件生命周期管理存在缺陷。</p> <p>2. 不恰当设置了repeat、duration或开启插帧特性导致帧率不符合预期的话。</p> </td> <td class="cellrowborder" valign="top"><p>中，动画下发后，UI侧无负载，但RS的DisplayNode合成受到部分影响。</p> </td> <td class="cellrowborder" valign="top"><p>一定。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="11.100000000000001%"><p>Buffer自绘制类</p> </td> <td class="cellrowborder" valign="top" width="25.540000000000006%"><p>应用申请了不必要的自绘制内容。</p> </td> <td class="cellrowborder" valign="top" width="25.120000000000005%"><p>有Buffer持续生产，在轮转的最后一环，Buffer由于无需显示而在RSUni中Release。</p> </td> <td class="cellrowborder" valign="top" width="19.800000000000004%"><p>大，独立的Buffer轮转负载影响RS，同时Buffer生产者的负载往往较重。</p> </td> <td class="cellrowborder" valign="top" width="18.440000000000005%"><p>一定。</p> </td> </tr>  </tbody></table></div> </div> <div class="tiledSection"><h2 id="section163701735367">分析步骤<i class="anchor-icon anchor-icon-link" anchorid="section163701735367" tips="复制节点链接"></i></h2><p>在DevEco Studio 6.0.0的版本上（手机版本有要求配套HarmonyOS 6.0及以上的版本），针对前台不可见动效问题，增加了故障自动检测与分析的能力，可通过以下步骤来辅助问题定位。</p> <ol><li><span>抓取Trace信息。</span><p></p><p>点击Profiler工具，选择要分析的应用进程，创建一个Energy Session，按照复现路径操作应用进行测试。观察Energy Anomaly泳道，标注红色异常则为识别到了空跑异常。</p> <p></p></li><li><span>分析Trace信息。</span><p></p><ol><li>点击Energy Anomaly泳道红色区域（标识1）会展示Details信息</li><li>点击Details的Anomaly Count（标识2）会展示More信息，More信息展示的是每一帧空跑VSyncId和持续时间</li><li>右边有个跳转箭头（标识3），点击会跳转到当前空跑帧的详细信息</li><li>在空跑帧界面，点击Details模块下的Open Layout打开布局展示</li><li>在Component Tree展开布局组件，左边有感叹号图标的则为当前空跑帧的组件</li></ol> <p><span><img height="282.24504959422904" originheight="574" originwidth="1871" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163436.85029995571026719930978298260478:50001231000000:2800:43C605A2371191D6B4BD37F66578EA8664AB9238DE8D9556F321EDDA39A09555.png" title="点击放大" width="920"></span></p> <p></p></li></ol> <p>如果通过上面的Energy模板未找到故障组件，也可以通过下面的步骤来进行分析：</p> <ol><li><span>通过DevEco Profiler工具创建一个Energy或Frame会话，录制上述场景复现的过程。</span></li><li><span>通过trace分析确认问题是否成功复现。Trace抓取后展开render_service进程，重点关注子线程render_service（负责UI绘制指令的统一、动画的执行等）、RSUniRenderThre（负责图层绘制、多图层效果合成）以及RSHardwareThrea（负责屏幕显示），若发现RSUniRenderThre中含“H:DisplayNode skip”，意味着当前帧已生成好的统一绘制图层DisplayNode，此时无需进行屏幕显示（通常是由于屏幕内容实际无变化），此时开发者需排查UI组件是否存在空刷问题。若DisplayNode图层成功显示，可在RSHardware中找到“H:ReleaseBuffer name: DisplayNode”。</span><p></p><p><span><img height="222.49641830065357" originheight="482" originwidth="1993" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163437.59709254598293281960034575368188:50001231000000:2800:E88B62E6377E97384C553599C4CFDE7027B217ED29E937C2B447935DCC71D536.png" title="点击放大" width="920"></span></p> <p></p></li><li><span>DisplayNode作为HarmonyOS提供的统一绘制图层，若由UI下发的绘制指令在实际绘制完成后，并不会带来页面的实际刷新时，系统会触发DisplayNode skip，避免重复的页面在屏幕上刷新造成硬件功耗。故而DisplayNode skip问题的解决，依赖开发者通过Trace分析结合实际在代码中的组件刷新相关业务，分析其合理性和必要性找到问题组件。</span></li></ol> </div> <div class="tiledSection"><h2 id="section1142142023612">定位组件<i class="anchor-icon anchor-icon-link" anchorid="section1142142023612" tips="复制节点链接"></i></h2><p><strong>场景1：</strong>应用进程下发的绘制指令含冗余FlushRenderTask。</p> <p>通过故障帧，在render_service线程的trace中找到接收处理应用下发绘制指令请求的trace点，查找关键字RSMainThread::ProcessCommandUni，如下图所示表示处理来自进程5238进程的绘制指令，正在执行序列号为762的指令内容。</p> <p><span><img height="448.1967" originheight="728" originwidth="1442" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163437.42140007360341119753548729192649:50001231000000:2800:9C22E2A1BCBCD5B64F3D1C9D1F15D8398D014EC589F4C8308BD601A6BF993FE5.png" title="点击放大" width="887.7750000000001"></span></p> <p>开发者可以根据这一信息搜索[5238,762]，找到Trace点信息H:MarshRSTransactionData cmdCount: 4, transactionFlag:[5238,762]，该Trace点在此帧中有4个绘制指令由应用下发给RS。也可点击箭头，跳转到该帧，通过查找关键字“H:FlushRenderTask”，可根据后面的数字查看当前帧表示有几个组件（下图表示有2个组件有渲染任务）执行渲染任务，其下面的Trace点展示具体的每个渲染组件渲染任务的详细信息，下图中id表示当前帧渲染任务的组件的ArKUI ID，该ID与ArkUI inspector中的id一致，开发者可在找到怀疑的组件后进入ArkUI inspector查看其状态、位置验证合理性。</p> <p><span><img height="397.137601" originheight="620" originwidth="1414" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163437.08764210139183765421455344936545:50001231000000:2800:53C4CFA5579091652766ED4685D62864DF24A1D301E6AB47B7BE9B95E7AE8ACE.png" title="点击放大" width="905.73"></span></p> <p>更多不可见组件的分析和低功耗建议，参见<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/low-power-consumption-suggestions">不可见组件低功耗建议</a>。</p> <p><strong>场景2：</strong>应用下发的冗余Animate。</p> <p>在应用指令绘制下发的模式中，ProcessCommandUni主要满足了组件即时刷新的需求，除此之外，应用还可以通过Animate的方式刷新DisplayNode。应用可设置好动画的持续时间（duration），执行次数（repeat）等参数后，在第一帧通过ProcessCommandUni下发动画的绘制指令，后续的动画帧均可在render_service线程内请求Vsync。如下图，开发者可以在H:Animate中查找找到动画下发的线程（标志1所示，来自进程40980），以及动画的执行信息（标志2所示），其中标志2会打印出animation node，该node id可在ArkUI树上找到。对Animate类的问题而言，由于duration和repeat属性存在，动画往往会在render_service中自请求Vsync持续一段时间，若这段时间里动画节点被隐藏或销毁时，可能会导致H:Animate空跑的问题。</p> <p><span><img height="173.94710899999998" originheight="349" originwidth="1719" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163437.87063068606652252112440526021340:50001231000000:2800:860D2226B4CFC571026C2FE5DAEA750B3918688C1CEE5F1522DB45ABEFF86BB4.png" title="点击放大" width="856.8525000000001"></span></p> <p>开发者可根据此渲染节点的ID，从ArkUI的树状结构（ArkUI Tree）信息（txt格式）中来查找对应组件在ArkUI中的ArkUI ID，通过以下示例代码导出ArkUI树。</p> <div _ngcontent-mcl-c106="" class="highlight-div"><div _ngcontent-mcl-c106="" class="highlight-div-header"><div _ngcontent-mcl-c106="" class="highlight-div-header-left"><div _ngcontent-mcl-c106="" class="handle-button expand-button"><div _ngcontent-mcl-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-mcl-c106="" class="highlight-div-header-right"><div _ngcontent-mcl-c106="" class="handle-button ai-button"></div><div _ngcontent-mcl-c106="" class="handle-button line-button"><div _ngcontent-mcl-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-mcl-c106="" class="handle-button theme-button"><div _ngcontent-mcl-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-mcl-c106="" class="handle-button copy-button"><div _ngcontent-mcl-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-mcl-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-bash" data-highlighted="yes"><ol class="linenums"><li>hdc shell <span class="hljs-string">"hidumper -s WindowManagerService -a '-a'"</span></li><li>@<span class="hljs-built_in">set</span> /p windowId=input WindowId :</li><li>hdc shell <span class="hljs-string">"hidumper -s WindowManagerService -a '-w %windowId% -default -c'"</span> &gt; arkui.dump</li></ol></pre></div></div> <p>将上面的代码保存为bat文件，点击执行即可，在输入栏输入“Focus window:”的ID（表示此窗口的ID），就能生成ArkUI树的txt格式文件。开发者可在ArkUI树文件中通过搜索动画node，找到该node对应的ArkUI组件ID。</p> <p><span><img height="325.502205" originheight="662" originwidth="779" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163437.40448604823154127908161615046241:50001231000000:2800:72EC3718A16D78F56C510D1331B363E03B6BC2338CDA9FEEC63C20FBC507E35C.png" title="点击放大" width="383.04"></span><span><img height="318.71721" originheight="640" originwidth="1117" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163437.57387347586401003626169830755749:50001231000000:2800:ECC635651CFC7B4EBED913A8FD91C29F0C1F0AEBF1A5EFB503FC5D5548337CA6.png" title="点击放大" width="556.2459"></span></p> <div><div class="hw-editor-tip warn"><div class="title">注意</div><div class="content"><p>上述命令受安全的限制，仅对<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/performance-analysis-kit-terminology#debug版本应用" target="_blank">debug版本应用</a>生效。</p> </div></div></div> <p><strong>场景3：</strong>冗余Buffer空跑。</p> <p><span><img height="315.7701730110443" originheight="671" originwidth="1955" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163437.94382385967652050901744472089903:50001231000000:2800:92DCF464B3D5023F4D367FFF8C07F0183E235DBDBD8441445615FE36E2EA7934.png" title="点击放大" width="920"></span></p> <p>在上图Trace中，分别在RSHardware和RSUni中搜索“H:ReleaseBuffer name:”，如果Buffer内容成功在屏幕上显示，Release将会出现在RSHardware进程的末尾位置，表明Buffer在使用完成后释放，重新回到BufferQueue。</p> <p><span><img height="92.08078048780487" originheight="114" originwidth="1139" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163437.15095339991582803327583148027993:50001231000000:2800:F8BCB4651B1573FEE316A2FDD8E39FB7D14EB2B0BE156E4A04F5A44C4F5F2A47.png" title="点击放大" width="920"></span></p> <p>如果Buffer并未实际显示，ReleaseBuffer将在RSUni中进行，表明此帧Buffer触发系统兜底，无需在RSHardware中显示，该Buffer从生产到传输过程中的负载均无法体现在显示效果上，属于冗余负载。在打印信息H:ReleaseBuffer name: xxx queueId: 6631429506443 seq: 97784892中，开发者可确认该空跑Buffer的序列id为97784892。</p> <p><span><img height="102.79948990435706" originheight="218" originwidth="1951" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163437.11891591752800909316335022815000:50001231000000:2800:F44FB572241AF489B3099FA26FA680A1792916BD9F96F3062087BE460C96CA75.png" title="点击放大" width="920"></span></p> <p>进一步定位，在render_service中搜索“seq = 【空跑Buffer id】”：当开发者在RSUniRenderThre中发现了一个空跑的BufferQueue，可从中找到一个Buffer id，如100151309在render_service中搜索。搜索结果Trace会显示出该Buffer在申请完成后 ，其位置所在RS树的node id与其父组件的node id。随后开发者可以参考场景2中的方法，通过ArkUI树，搜索找到该Buffer对应的ArkUI组件。</p> <p><span><img height="160.36847457627118" originheight="380" originwidth="2180" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163437.83104917181275429144755956391949:50001231000000:2800:D94C990B6CF003EF67E128DD441EDB739A723693AA44DB824546EBBE6BF59EF8.png" title="点击放大" width="920"></span></p> <p>更多Buffer类的问题的出现情况与优化方式，请参考<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-buffer-power-optimization">Buffer低功耗优化</a>。</p> </div> <div class="tiledSection"><h2 id="section13421172083613">定位根因<i class="anchor-icon anchor-icon-link" anchorid="section13421172083613" tips="复制节点链接"></i></h2><p>在获取了ArkUI组件id后，开发者可充分利用DevEco Studio提供的ArkUI Inspector工具来进行<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-arkui-inspector" target="_blank">布局分析</a>，定位更多的组件信息。可以结合代码逻辑，与问题复现时的组件状态作对比，重点关注以下信息：</p> <ol><li>组件位置：若组件位于屏幕外，但处于活跃态，可审视代码中是否缺乏对该组件可见性的监听，确保离屏后停止刷新。</li><li>组件结构：排查该组件是否有被遮挡的可能性，与当前显示节点是否有父子兄弟关系，是否属于下拉、弹窗类动效，在未被拉起时提前创建，导致空跑。</li><li>父子组件的Attribute变量：右侧搜索框会显示组件封装时的各个变量状态，开发者可排查与播放控制相关的自定义变量是否符合预期。</li></ol> <p><span><img height="338.67180712305293" originheight="927" originwidth="2518" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163438.42969047725813977383483325059689:50001231000000:2800:843733F55B048C709308E79044E49A5B5F0C821241D60A031609B57A19D9A176.png" title="点击放大" width="920"></span></p> </div> </div> <div></div></div>