<h1 _ngcontent-ntk-c119="" class="doc-title ng-star-inserted" title="图片资源加载优化"> 图片资源加载优化 </h1>

<div _ngcontent-ntk-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;"> <div><div class="tiledSection"><h2 id="section174510171618">概述<i class="anchor-icon anchor-icon-link" anchorid="section174510171618" tips="复制节点链接"></i></h2><p>在应用开发中，当图片资源数量或大小超过特定阈值时，由于图片资源的格式需要通过CPU解压缩为纹理格式才能直接被GPU读取，将增加CPU的处理时间，导致图片加载延迟。此外，CPU解压缩生成的图片资源会占用大量内存空间，增加内存压力，可能导致卡顿和掉帧。本文从预置图片与非预置图片两个方面介绍图片资源加载优化方案。其中，预置图片主要通过纹理压缩技术进行优化；非预置图片资源则包括使用图像编辑工具压缩、降低GIF图片分辨率、优化网络图片资源、优先使用.webp图片，利用autoResize对图片资源进行降采样等优化策略。</p> </div> <div class="tiledSection"><h2 id="section91526132216">预置图片资源加载优化<i class="anchor-icon anchor-icon-link" anchorid="section91526132216" tips="复制节点链接"></i></h2><p>预置图片资源是指打包在应用安装包内的本地图片，存放于‘resource/base/media’目录下。开发者可通过纹理压缩对预置图片资源进行加载优化。</p> </div> <div class="tiledSection"><h3 id="section12256174546" class="firsth2">纹理压缩<i class="anchor-icon anchor-icon-link" anchorid="section12256174546" tips="复制节点链接"></i></h3><p>纹理压缩用于减小纹理图片文件大小，通过纹理压缩技术，在构建过程中对预置图片进行转码和压缩，从而减少CPU的处理时间，降低内存占用，提升应用性能。</p> </div> <p><strong>实现原理</strong></p> <p>预置图片在不使用纹理压缩时，需要先经CPU解码生成PixelMap，再上传给GPU生成纹理。此过程耗时较长。开发者可使用纹理压缩技术，在编译构建阶段提前完成CPU解码和纹理生成，以减少CPU处理图片的时间。纹理压缩需在编译文件中配置相关属性，构建时根据配置找到预置图片，转换生成纹理码流，并进行超压缩编码生成超压缩码流。编译完成后进入运行态，进行超压缩解码生成纹理码流，GPU读取纹理码流后进行渲染显示。</p> <p><span><img height="331.3562" originheight="606" originwidth="1453" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163424.70493731779768844471811537766118:50001231000000:2800:1BA53A26EE7FC997FCA15D5AB75E83FCE62ABEDF7826BE4BD1EA2DACFD314264.png" title="点击放大" width="798"></span></p> <p>纹理压缩在编译构建中对预置图片进行处理。首先在编辑器的编译文件中配置纹理压缩参数。根据配置参数，hvigor读取待压缩的文件资源，构造<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/restool" target="_blank">restool</a>命令解析并生成资源文件列表。然后遍历文件列表，将待转换文件转码为纹理格式。已转换的资源文件不再打包到构建产物中。最后将纹理文件和未转换的文件一起构建生成资源产物。</p> <p>编译构建资源文件开启纹理压缩时序图如下：</p> <p><span><img height="431.67810000000003" originheight="907" originwidth="1672" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163424.81563587015861187981583954708648:50001231000000:2800:44C935893AF95EBBC769074270473B3935A1A0C50A10518F10E9F58FEB008CA0.png" title="点击放大" width="798"></span></p> <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"><p>纹理压缩在编译构建时会提前处理预置图片，这可能会增加编译时间并导致包体增大。如果资源图片占用较多空间，对包体积影响显著，建议筛选图片资源，以减少纹理压缩的开销。</p> </div></div></div> <p><strong>场景案例</strong></p> <p>由于图片格式无法直接被GPU渲染，需要CPU解码后上传到GPU，这会消耗一定时间。当一个页面同时渲染一定数量的预置图片时，可能会导致图片完成时延增加。以下是一个Tab栏切换的示例，当向右滑动切换到tab2页面时，新页面通过横列布局加载40张.png格式和40张.jpg格式的预置图片。对比开启和关闭纹理压缩两种情况，图片完成时延有显著差异。未开启纹理压缩情况下切换过程的效果图如下：</p> <p><span><img height="550.3407000000001" originheight="720" originwidth="348" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163425.17783178733648350202782436233705:50001231000000:2800:0E478F17072EE14550E36AC58D570D98CFA870EBF72BC89017AEEE5DB983ADD3.gif" title="点击放大" width="266"></span></p> <p>在不使用纹理压缩的情况下，当向右滑动切换到tab2页面时，由于新页面包含多张预置图片需要加载，可能会导致部分图片加载延迟，出现显示白块的情况。</p> <p><strong>工程配置</strong></p> <p>使用纹理压缩前，需进行基础配置，选择要超压缩的预置图片。可在工程级或模块级的build-profile.json5配置文件中，于compression对象内添加media和filters属性。</p> <p>media：在media中，enable属性用于控制是否启用纹理压缩。默认值为false，表示不启用纹理压缩。需要启用纹理压缩时，将enable属性值设为true。</p> <p>filters：在filters属性中可配置method、files和exclude三个属性对象。</p> <ul><li>method中包含两个属性type和blocks。type可以设置为转换类型“sut”或“astc”。blocks用于设置转换类型的扩展参数，当前仅支持“4x4”。</li><li>files中的三个属性path、size和resolution分别指定按路径、大小和分辨率匹配的过滤条件。</li><li>在exclude中列出的属性与files中相同，从files中移除不需要压缩的文件。</li></ul> <p>基本编译配置项的类型及说明可参考<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-hvigor-build-profile#section2095319147103" target="_blank">compression</a>。纹理压缩配置的示例代码如下：</p> <div class="screenLinkPre"><div _ngcontent-ntk-c106="" class="highlight-div"><div _ngcontent-ntk-c106="" class="highlight-div-header"><div _ngcontent-ntk-c106="" class="highlight-div-header-left"><div _ngcontent-ntk-c106="" class="handle-button expand-button"><div _ngcontent-ntk-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-ntk-c106="" class="highlight-div-header-right"><div _ngcontent-ntk-c106="" class="handle-button ai-button"></div><div _ngcontent-ntk-c106="" class="handle-button line-button"><div _ngcontent-ntk-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-ntk-c106="" class="handle-button theme-button"><div _ngcontent-ntk-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-ntk-c106="" class="handle-button copy-button"><div _ngcontent-ntk-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-ntk-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-cangjie" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/TextureHypercompression/build-profile.json5#L17-L57" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-string">"buildOption"</span>: {</li><li>  <span class="hljs-string">"resOptions"</span>: {</li><li>    <span class="hljs-string">"compression"</span>: {</li><li>      <span class="hljs-string">"media"</span>: {</li><li>        <span class="hljs-string">"enable"</span>: <span class="hljs-keyword">true</span> <span class="hljs-comment">// Whether to enable texture compression for media images</span></li><li>      },</li><li>      <span class="hljs-comment">// Filtering of texture compression files. This field is not mandatory. If this field is not set, all images in the resource directory will be compressed</span></li><li>      <span class="hljs-string">"filters"</span>: [</li><li>        {</li><li>          <span class="hljs-string">"method"</span>: {</li><li>            <span class="hljs-string">"type"</span>: <span class="hljs-string">"sut"</span>, <span class="hljs-comment">// conversion type</span></li><li>            <span class="hljs-string">"blocks"</span>: <span class="hljs-string">"4x4"</span> <span class="hljs-comment">// The extended parameters of the conversion type</span></li><li>          },</li><li>          <span class="hljs-comment">// Specifies the files used for compression. Only files that meet all conditions and are not excluded can be compressed</span></li><li>          <span class="hljs-string">"files"</span>: {</li><li>            <span class="hljs-string">"path"</span>: [<span class="hljs-string">"./**/*"</span>], <span class="hljs-comment">// All files in the specified resource directory</span></li><li>            <span class="hljs-string">"size"</span>: [[<span class="hljs-number">0</span>, <span class="hljs-string">'1000k'</span>]], <span class="hljs-comment">// Files with a specified size of less than 1000k</span></li><li>            <span class="hljs-comment">// Pictures with a resolution smaller than 3000 x 3000</span></li><li>            <span class="hljs-string">"resolution"</span>: [</li><li>              [</li><li>                { <span class="hljs-string">"width"</span>: <span class="hljs-number">0</span>, <span class="hljs-string">"height"</span>: <span class="hljs-number">0</span> }, <span class="hljs-comment">// minimum width and height</span></li><li>                { <span class="hljs-string">"width"</span>: <span class="hljs-number">3000</span>, <span class="hljs-string">"height"</span>: <span class="hljs-number">3000</span> } <span class="hljs-comment">// Maximum width and height</span></li><li>              ]</li><li>            ]</li><li>          },</li><li>          <span class="hljs-comment">// Remove files that do not need to be compressed from the files list. Only files that meet all filtering conditions are deleted</span></li><li>          <span class="hljs-string">"exclude"</span>: {</li><li>            <span class="hljs-string">"path"</span>: [<span class="hljs-string">"./**/*.webp"</span>], <span class="hljs-comment">// Filter all webp files</span></li><li>            <span class="hljs-string">"size"</span>: [[<span class="hljs-number">0</span>, <span class="hljs-string">'1k'</span>]], <span class="hljs-comment">// Filter files smaller than 1k in size</span></li><li>            <span class="hljs-comment">// Filter images with a resolution smaller than 1024 x 1024</span></li><li>            <span class="hljs-string">"resolution"</span>: [</li><li>              [</li><li>                { <span class="hljs-string">"width"</span>: <span class="hljs-number">0</span>, <span class="hljs-string">"height"</span>: <span class="hljs-number">0</span> }, <span class="hljs-comment">// minimum width and height</span></li><li>                { <span class="hljs-string">"width"</span>: <span class="hljs-number">1024</span>, <span class="hljs-string">"height"</span>: <span class="hljs-number">1024</span> } <span class="hljs-comment">// Maximum width and height</span></li><li>              ]</li><li>            ]</li><li>          }</li><li>        }</li><li>      ]</li><li>    }</li><li>  }},</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/TextureHypercompression/build-profile.json5#L17-L57" target="_blank">build-profile.json5</a></div></div></div></div> <p>配置项注意点：</p> <ol><li>文件过滤配置参数filters：当工程级和模块级同时配置时，优先按模块级的过滤条件匹配。若模块级匹配成功，忽略工程级的过滤条件；若模块级未匹配成功，继续按工程级的条件匹配。</li><li>转换类型type：<ul><li>astc（Adaptive Scalable Texture Compression）：自适应可变纹理压缩，一种对GPU友好的纹理格式，可在设备侧更快地显示，有更少的内存占用。</li><li>sut（Super compression for Texture）：纹理超压缩，一种对GPU友好的纹理格式，可在设备侧更快地显示，有更少的内存占用，相比astc具备更大压缩率和更少ROM占用。</li></ul> </li><li>size（按大小匹配）和resolution（按分辨率匹配）：注意size一维数组和resolution二维数组的区别。</li></ol> <p>按大小匹配是一维数组，因此按大小匹配[0-1k，1k-2k]与按大小匹配[0-2k]的取值范围相同。</p> <p>按分辨率匹配时，匹配分辨率的宽高值是二维数组。下图左侧表示分辨率小于2048×2048的所有图片，右侧表示分辨率小于1024×1024的图片和分辨率大于1024×1024且小于2048×2048的图片。虽然两种写法看似相同，但其取值范围并不一致。</p> <p><span><img originheight="545" originwidth="916" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163425.82087981280130414339308609786456:50001231000000:2800:0C3922ACD70516363B41107B703CCE0BC64E081BC16B44390EA0A7C464F920FF.png" width="916" height="545"></span></p> <p><strong>编译执行</strong></p> <p>配置相关参数后，执行项目编译构建。编译过程中，hvigor根据配置参数获取预置图片，通过转码部件进行纹理压缩并打包。纹理压缩后的Tab栏切换效果如下：</p> <p><span><img height="550.3407000000001" originheight="720" originwidth="348" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163425.08547903555265916109962887722070:50001231000000:2800:0BC2C2B37698515045B13F3FD44C1B9544CC85692490C6F03D920475BE93A258.gif" title="点击放大" width="266"></span></p> <p>通过效果图可以看出，使用纹理压缩时，切换到tab2页面后，图片立即显示，没有延迟或白块出现。</p> <p></p> <p><strong>收益和开销</strong></p> <p>在使用纹理压缩进行预置图片资源转换时，需关注覆盖的资源文件数量，确保在获取高收益的同时，减少开销的影响。因此，纹理超压缩的性能提升应从收益和开销两个方面进行分析。</p> <p><strong>收益</strong></p> <p>纹理压缩的主要收益是将预置图片转换为纹理格式，直接被GPU读取，降低CPU和DDR的负载，加快图片加载速度。在Tab栏切换示例中，预置图片分别以原图（.png）、纹理超压缩（.sut）和自适应可变纹理压缩（.astc）三种方式测试，图片读取耗时如下图所示：</p> <p><span><img height="356.0745" originheight="615" originwidth="1589" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163425.82141049484239270915963677047025:50001231000000:2800:F4177EA0C23B675E991320C817209B214B59EC158ABA1F837CB31DAEB0578471.png" title="点击放大" width="920"></span></p> <p>统计以上H:CreateImagePixelMap的耗时得到下表：</p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.38.1.4.1.1" valign="top" width="33.33333333333333%"><p>文件</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.38.1.4.1.2" valign="top" width="33.33333333333333%"><p>耗时</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.38.1.4.1.3" valign="top" width="33.33333333333333%"><p>收益</p> </th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="33.33333333333333%"><p>原图（.png）</p> </td> <td class="cellrowborder" valign="top" width="33.33333333333333%"><p>62.103ms</p> </td> <td class="cellrowborder" valign="top" width="33.33333333333333%"><p>-</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="33.33333333333333%"><p>纹理超压缩（.sut）</p> </td> <td class="cellrowborder" valign="top" width="33.33333333333333%"><p>15.309ms</p> </td> <td class="cellrowborder" valign="top" width="33.33333333333333%"><p>4.13倍</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="33.33333333333333%"><p>自适应可变纹理压缩（.astc）</p> </td> <td class="cellrowborder" valign="top" width="33.33333333333333%"><p>38.239ms</p> </td> <td class="cellrowborder" valign="top" width="33.33333333333333%"><p>1.63倍</p> </td> </tr>  </tbody></table></div> </div> <p>使用原图（.png）格式的图片加载时间大约是纹理格式加载时间的4倍，而纹理超压缩和自适应可变纹理压缩的加载时间大约是纹理格式的2倍。开启纹理超压缩或自适应可变纹理压缩可以显著提升应用中预置图片的加载速度。</p> <p>在对比加载图片的耗时后，使用Tab栏切换示例测试内存大小，查看纹理压缩前后的内存占用情况。相关数据如下图所示：</p> <p><span><img height="329.5555" originheight="451" originwidth="1259" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163425.37038835987854082855804030742076:50001231000000:2800:19431EFB08A94C55E5F17C37DAD9693EA26C98847302AB79B17646B713530487.png" title="点击放大" width="920"></span></p> <p><span><img height="329.88900000000007" originheight="450" originwidth="1255" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163425.95992173969413370223107119191204:50001231000000:2800:F2CBE3CED01A0449270895D38BF8F222918A94941ED7A18DFD184840F2B9B927.png" title="点击放大" width="920"></span></p> <p><span><img height="320.75800000000004" originheight="440" originwidth="1262" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163425.92651866075851567778609870226658:50001231000000:2800:7F934E0C1726B635DB09EAD68C3E26FDDCD64D03186123ECA30B3E9113E3BE33.png" title="点击放大" width="920"></span></p> <p>统计纹理压缩开启前后的内存占用大小数据如下表：</p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.45.1.3.1.1" valign="top" width="50%"><p>是否开启纹理压缩</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.45.1.3.1.2" valign="top" width="50%"><p>内存占用大小</p> </th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="50%"><p>开启（.sut）</p> </td> <td class="cellrowborder" valign="top" width="50%"><p>165015KB</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="50%"><p>开启（.astc）</p> </td> <td class="cellrowborder" valign="top" width="50%"><p>167723KB</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="50%"><p>关闭</p> </td> <td class="cellrowborder" valign="top" width="50%"><p>598965KB</p> </td> </tr>  </tbody></table></div> </div> <p>通过表中数据可知，开启纹理压缩后，内存占用从598965KB 下降到165015KB 至167723KB，图片加载占用的内存显著减少。</p> <p></p> <p><strong>开销</strong></p> <p>使用纹理压缩时，编译过程中会预置图片转换，这会增加编译时间。预置图片转换为纹理格式后，根据图片格式的不同，转换后的大小也会有所不同，可能导致包体膨胀或收缩。</p> <p>编译时间长的问题是因为在编译过程中增加了纹理压缩的过程，可以各准备87张png/webp/jpg预置图片分别以全量编译、修改按分辨率过滤参数和增加1~100张图片三种情况进行编译打包，对比三种情况下纹理压缩打开和关闭的编译时长，得到相关数据如下表所示：</p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.51.1.5.1.1" valign="top" width="25%"><p>测试用例</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.51.1.5.1.2" valign="top" width="25%"><p>纹理压缩关</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.51.1.5.1.3" valign="top" width="25%"><p>纹理压缩开</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.51.1.5.1.4" valign="top" width="25%"><p>增加耗时说明</p> </th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="25%"><p>全量编译</p> </td> <td class="cellrowborder" valign="top" width="25%"><p>19s 74ms</p> </td> <td class="cellrowborder" valign="top" width="25%"><p>1min 16s</p> </td> <td class="cellrowborder" valign="top" width="25%"><p>遍历资源文件+纹理压缩+搬移资源文件</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="25%"><p>修改按分辨率过滤参数</p> </td> <td class="cellrowborder" valign="top" width="25%"><p>-</p> </td> <td class="cellrowborder" valign="top" width="25%"><p>16s 487ms</p> </td> <td class="cellrowborder" valign="top" width="25%"><p>遍历资源文件+搬移资源文件</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="25%"><p>增加1~100张图片</p> </td> <td class="cellrowborder" valign="top" width="25%"><p>10s 177ms~10s 283ms</p> </td> <td class="cellrowborder" valign="top" width="25%"><p>16s 491ms~16s 673ms</p> </td> <td class="cellrowborder" valign="top" width="25%"><p>遍历资源文件</p> </td> </tr>  </tbody></table></div> </div> <p>从上表可以看出，开启纹理压缩后，全量编译耗时较长。但是，按分辨率过滤预置图片后再次进行纹理压缩，能够显著减少编译时长。</p> <p>在对比编译时长的问题后，测量了若干示例应用，发现.jpg和.webp格式图片的体积膨胀率为2到3倍。具体开启纹理超压缩后的体积膨胀率数据如下表所示：</p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.54.1.3.1.1" valign="top" width="50%"><p>图片格式</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.54.1.3.1.2" valign="top" width="50%"><p>纹理压缩相比原图膨胀率</p> </th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="50%"><p>.jpg</p> </td> <td class="cellrowborder" valign="top" width="50%"><p>3.05</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="50%"><p>.png</p> </td> <td class="cellrowborder" valign="top" width="50%"><p>0.92</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="50%"><p>.webp</p> </td> <td class="cellrowborder" valign="top" width="50%"><p>2.50</p> </td> </tr>  </tbody></table></div> </div> <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"><p>具体工程应用会因为实际工程内资源大小、格式、分辨率和数量等因素的不同产生不同的包体膨胀率，以上数据仅供开发者参考。</p> </div></div></div> <p>.png格式的图片纹理压缩后，包体积没有增加，而.jpg格式和.webp格式的图片包体积显著增加。综合编译时长和打包体积考虑，为了使用纹理超压缩获得更好的性能，在对包体积敏感的场景下，可以采用将所有.png格式图片进行纹理压缩；对.jpg和.webp格式的图片，挑选高频使用或对关键帧有重要影响的部分进行转换的策略。</p> <div class="tiledSection"><h2 id="section9863171302210">非预置图片资源加载优化<i class="anchor-icon anchor-icon-link" anchorid="section9863171302210" tips="复制节点链接"></i></h2><p>非预置图片不是应用内的资源，而是通常来自网络或本地文件系统。这类图片一般不是固定不变的，例如：用户头像、动态内容中的图片、从服务器获取的商品图片等。本章节将从图片使用前和使用中两个层面介绍几种常见的非预置图片资源加载优化方案，具体如下。</p> <ul><li>优化使用前的图片资源：<p>预压缩到实际UI尺寸，包括<a href="/consumer/cn/doc/best-practices/bpta-texture-compression-improve-performance#section16467122642119">使用图像编辑工具压缩</a>、<a href="/consumer/cn/doc/best-practices/bpta-texture-compression-improve-performance#section1797994818210">GIF图片降低分辨率</a>；</p> <p><a href="/consumer/cn/doc/best-practices/bpta-texture-compression-improve-performance#section91581551143319">使用CDN优化网络图片资源</a>；</p> <p><a href="/consumer/cn/doc/best-practices/bpta-texture-compression-improve-performance#section574283918342">优先使用.webp图片</a>。</p> </li><li>优化使用中的图片资源：<p></p> <p><a href="/consumer/cn/doc/best-practices/bpta-texture-compression-improve-performance#section14375239203519">使用autoresize对Image组件进行降采样</a>。</p> </li></ul> </div> <div class="tiledSection"><h3 id="section16467122642119" class="firsth2">使用图像编辑工具压缩<i class="anchor-icon anchor-icon-link" anchorid="section16467122642119" tips="复制节点链接"></i></h3><p>在应用构建前，建议使用图片编辑工具或脚本，将图片分辨率调整为UI中的实际显示大小，并进行适当的压缩编码，以减小资源体积、提升加载性能。</p> </div> <div class="tiledSection"><h3 id="section1797994818210">GIF图片降低分辨率<i class="anchor-icon anchor-icon-link" anchorid="section1797994818210" tips="复制节点链接"></i></h3><p>通过使用FFmpeg三方库的能力降低分辨率，有以下两种方式实现GIF图片的压缩（也可将两种方式进行结合）。</p> <div class="p">使用-s设置图片的分辨率，例如，将一个GIF图片的分辨率降低，宽高设置为90x90像素，可以使用如下命令：<div _ngcontent-ntk-c106="" class="highlight-div"><div _ngcontent-ntk-c106="" class="highlight-div-header"><div _ngcontent-ntk-c106="" class="highlight-div-header-left"><div _ngcontent-ntk-c106="" class="handle-button expand-button"><div _ngcontent-ntk-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-ntk-c106="" class="highlight-div-header-right"><div _ngcontent-ntk-c106="" class="handle-button ai-button"></div><div _ngcontent-ntk-c106="" class="handle-button line-button"><div _ngcontent-ntk-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-ntk-c106="" class="handle-button theme-button"><div _ngcontent-ntk-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-ntk-c106="" class="handle-button copy-button"><div _ngcontent-ntk-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-ntk-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-css" data-highlighted="yes"><ol class="linenums"><li>ffmpeg -<span class="hljs-selector-tag">i</span> <span class="hljs-selector-tag">input</span><span class="hljs-selector-class">.gif</span> -s <span class="hljs-number">90</span>x90 -y output<span class="hljs-selector-class">.gif</span> （设置宽高均为<span class="hljs-number">90</span>像素）</li></ol></pre></div></div> </div> <p>或者使用-vf参数配合scale过滤器，设置宽为90像素，高度自动等比例缩放。</p> <div _ngcontent-ntk-c106="" class="highlight-div"><div _ngcontent-ntk-c106="" class="highlight-div-header"><div _ngcontent-ntk-c106="" class="highlight-div-header-left"><div _ngcontent-ntk-c106="" class="handle-button expand-button"><div _ngcontent-ntk-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-ntk-c106="" class="highlight-div-header-right"><div _ngcontent-ntk-c106="" class="handle-button ai-button"></div><div _ngcontent-ntk-c106="" class="handle-button line-button"><div _ngcontent-ntk-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-ntk-c106="" class="handle-button theme-button"><div _ngcontent-ntk-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-ntk-c106="" class="handle-button copy-button"><div _ngcontent-ntk-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-ntk-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-lua" data-highlighted="yes"><ol class="linenums"><li>ffmpeg -i <span class="hljs-built_in">input</span>.gif -vf <span class="hljs-string">"scale=90:-1"</span> -y <span class="hljs-built_in">output</span>.gif</li></ol></pre></div></div> <p>以上命令的参数的意义如下：</p> <ul><li>-s 90x90：设置图片分辨率为90x90像素。</li><li>-y：覆盖已有文件。</li><li>-vf "scale=90:-1"：设置图片滤镜，参数是单个滤镜或多个逗号分隔的滤镜链。</li></ul> </div> <p><strong>预压缩场景案例</strong></p> <p>例如，在网页或App中有一个头像显示区域，大小为80*80px，此时有一张4180*4180的大图，若直接通过代码缩放到80*80显示，会出现内存占用高、解码慢、滚动卡顿的问题；正确的做法是，提前将图片压缩并缩放为80*80的小图，然后再进行加载显示。对比压缩前和压缩后两种情况，图片完成时延有显著差异。</p> <p><span><img height="549.2900000000001" originheight="1080" originwidth="523" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163425.84613218949974151026050099117157:50001231000000:2800:FBB4A209B674294F346D3F13E59DC3D193C2C8EECD110A4B4806622872EF9614.gif" title="点击放大" width="266"></span></p> <p><strong>耗时对比</strong></p> <p>点击切换示例测试耗时时长，查看压缩前后的图片读取耗时情况。相关数据如下图所示：</p> <p><span><img height="161.00000000000003" originheight="266" originwidth="1520" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163426.79108236022493570658922695901323:50001231000000:2800:42EBD1BCDA80BB00FF29531F459C1F0D26C35030F90B9C4607D36A4F6F8552F7.png" title="点击放大" width="920"></span><span><img height="163.53" originheight="270" originwidth="1519" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163426.35699449864431342763703904915241:50001231000000:2800:97688280CF3D9E32C83B0DF421A2DA88615822ED18CEBEF2FABD599894CA39A6.png" title="点击放大" width="920"></span></p> <p>统计预压缩到实际UI尺寸前后的图片解码耗时数据如下表：</p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.67.1.3.1.1" valign="top" width="50%"><p>是否预压缩到实际UI尺寸</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.67.1.3.1.2" valign="top" width="50%"><p>图片解码耗时</p> </th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="50%"><p>否</p> </td> <td class="cellrowborder" valign="top" width="50%"><p>93ms</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="50%"><p>是</p> </td> <td class="cellrowborder" valign="top" width="50%"><p>740us</p> </td> </tr>  </tbody></table></div> </div> <p>通过表中数据可知，预压缩到实际UI尺寸后，图片加载耗时从183us下降到95us，加载速度显著提升。</p> <p></p> <p><strong>内存占用对比</strong></p> <p>点击切换示例测试内存大小，查看压缩前后的内存占用情况。相关数据如下图所示：</p> <p><span><img height="231.7365" originheight="334" originwidth="1326" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163426.12272632687109525148736423851348:50001231000000:2800:458DF628CD3C7384BD05EAE2F9FF51561DFEB15F5ADB8D6BA0D4E5104BBE34AC.png" title="点击放大" width="920"></span></p> <p><span><img height="233.30050000000003" originheight="336" originwidth="1325" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163426.90175710344013311411005229910891:50001231000000:2800:47509F28CC063432F68A6D71EE19918BFEACFD76F770742243205689EBE81B7B.png" title="点击放大" width="920"></span></p> <p>统计预压缩到实际UI尺寸前后的内存占用大小数据如下表：</p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.75.1.3.1.1" valign="top" width="50%"><p>是否预压缩到实际UI尺寸</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.75.1.3.1.2" valign="top" width="50%"><p>内存占用大小</p> </th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="50%"><p>否</p> </td> <td class="cellrowborder" valign="top" width="50%"><p>90224KB</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="50%"><p>是</p> </td> <td class="cellrowborder" valign="top" width="50%"><p>21230KB</p> </td> </tr>  </tbody></table></div> </div> <p>通过表中数据可知，预压缩到实际UI尺寸后，内存占用从90224KB下降到21230KB，图片加载占用的内存显著减少。</p> <div class="tiledSection"><h3 id="section91581551143319">使用CDN优化网络图片资源<i class="anchor-icon anchor-icon-link" anchorid="section91581551143319" tips="复制节点链接"></i></h3><p>优化网络图片资源加载有利于提升用户体验、减少流量消耗、降低内存占用以及加快页面渲染速度等。CDN（Content Delivery Network）是一种用于加快内容分发的网络技术。使用CDN裁剪图片是一种高效优化图片加载性能的方式，通过CDN提供的动态处理能力，用户可按需调整图片的尺寸、质量、格式等参数，减少宽带消耗，提高页面加载速度。</p> </div> <p><strong>实现思路</strong></p> <p>大多数CDN服务提供者（如：华为云）支持通过在图片URL后附加查询参数来动态调整图片大小、格式转换等。这些参数可以控制图片的宽度、高度、裁剪方式等属性，常见参数示例如下：</p> <ul><li>w：图片宽度</li><li>h：图片高度</li><li>fit：裁剪方式</li><li>q：图片质量</li><li>format：输出格式（如webp、jpeg）</li></ul> <p>例如，有一个URL为"https://your-cdn-url.com/path/to/image.jpg"的网络图片，需要返回一个宽度为200，高度为150，采用cover裁剪方式，质量（图片清晰度等综合指标）为85%，并且转换为.webp格式的图片。可参考以下方式实现。</p> <div class="screenLinkPre"><div _ngcontent-ntk-c106="" class="highlight-div"><div _ngcontent-ntk-c106="" class="highlight-div-header"><div _ngcontent-ntk-c106="" class="highlight-div-header-left"><div _ngcontent-ntk-c106="" class="handle-button expand-button"><div _ngcontent-ntk-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-ntk-c106="" class="highlight-div-header-right"><div _ngcontent-ntk-c106="" class="handle-button ai-button"></div><div _ngcontent-ntk-c106="" class="handle-button line-button"><div _ngcontent-ntk-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-ntk-c106="" class="handle-button theme-button"><div _ngcontent-ntk-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-ntk-c106="" class="handle-button copy-button"><div _ngcontent-ntk-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-ntk-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-typescript" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/TextureHypercompression/entry/src/main/ets/pages/OptimizeWebImagesUsingCDN.ets#L19-L34" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// It needs to be replaced with the image resource address required by the developer.</span></li><li><span class="hljs-keyword">private</span> imgUrl = <span class="hljs-string">'https://******.com/path/to/image.jpg?w=200&amp;h=150&amp;fit=cover&amp;q=85&amp;format=webp'</span>;</li><li>
</li><li><span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) {</li><li>  <span class="hljs-title class_">NavDestination</span>() {</li><li>    <span class="hljs-title class_">Column</span>() {</li><li>      <span class="hljs-title class_">Image</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">imgUrl</span>)</li><li>        .<span class="hljs-title function_">width</span>(<span class="hljs-number">200</span>)</li><li>        .<span class="hljs-title function_">height</span>(<span class="hljs-number">150</span>)</li><li>        .<span class="hljs-title function_">objectFit</span>(<span class="hljs-title class_">ImageFit</span>.<span class="hljs-property">Cover</span>)</li><li>    }</li><li>    .<span class="hljs-title function_">width</span>(<span class="hljs-string">'100%'</span>)</li><li>    .<span class="hljs-title function_">height</span>(<span class="hljs-string">'100%'</span>)</li><li>  }</li><li>  .<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-string">'#F1F3F5'</span>)</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/TextureHypercompression/entry/src/main/ets/pages/OptimizeWebImagesUsingCDN.ets#L19-L34" target="_blank">OptimizeWebImagesUsingCDN.ets</a></div></div></div></div> <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"><p>并非所有CDN服务均支持相同参数集，请查阅所用CDN服务商提供的文档了解详细参数信息。</p> </div></div></div> <div class="tiledSection"><h3 id="section574283918342">优先使用.webp图片<i class="anchor-icon anchor-icon-link" anchorid="section574283918342" tips="复制节点链接"></i></h3><p>.webp格式支持有损和无损压缩，其优势在于显著减少文件大小，同时保持高质量图像传输，是一种功能全面、适用于多种场景的图像格式。</p> </div>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><caption><b>表1 </b>.webp相较于.png和.jpg的优势</caption><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.85.2.4.1.1" valign="top" width="33.33333333333333%"><p>优势</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.85.2.4.1.2" valign="top" width="33.33333333333333%"><p>说明</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.85.2.4.1.3" valign="top" width="33.33333333333333%"><p>适用场景</p> </th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="33.33333333333333%"><p>更小的文件体积、更快加载、节省宽带</p> </td> <td class="cellrowborder" valign="top" width="33.33333333333333%"><p>同质量下比.jpg小25%~35%，比.png小25%</p> </td> <td class="cellrowborder" valign="top" width="33.33333333333333%"><p>网站图片</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="33.33333333333333%"><p>支持透明通道</p> </td> <td class="cellrowborder" valign="top" width="33.33333333333333%"><p>.png也支持，但.webp体积更小</p> </td> <td class="cellrowborder" valign="top" width="33.33333333333333%"><p>UI图标、按钮、透明图</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="33.33333333333333%"><p>支持动画</p> </td> <td class="cellrowborder" valign="top" width="33.33333333333333%"><p>可替代.gif，质量更高、体积更小</p> </td> <td class="cellrowborder" valign="top" width="33.33333333333333%"><p>动画表情包</p> </td> </tr>  </tbody></table></div> </div> <div class="tiledSection"><h3 id="section14375239203519">使用autoResize对Image组件进行降采样<i class="anchor-icon anchor-icon-link" anchorid="section14375239203519" tips="复制节点链接"></i></h3><p>autoResize适用于需要组件尺寸动态适配的场景。例如，在响应页面内容变化或设备形态差异（如不同屏幕尺寸、折叠屏展开/收起）时，图片需要根据父容器尺寸自动缩放，使用autoResize可避免图片溢出或留白，提升界面自适应能力。通过给Image组件设置<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-image#autoresize" target="_blank">autoResize</a>为true时，组件会根据显示区域的尺寸决定用于绘制的图源尺寸，有利于减少内存占用。</p> <div class="screenLinkPre"><div _ngcontent-ntk-c106="" class="highlight-div"><div _ngcontent-ntk-c106="" class="highlight-div-header"><div _ngcontent-ntk-c106="" class="highlight-div-header-left"><div _ngcontent-ntk-c106="" class="handle-button expand-button"><div _ngcontent-ntk-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-ntk-c106="" class="highlight-div-header-right"><div _ngcontent-ntk-c106="" class="handle-button ai-button"></div><div _ngcontent-ntk-c106="" class="handle-button line-button"><div _ngcontent-ntk-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-ntk-c106="" class="handle-button theme-button"><div _ngcontent-ntk-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-ntk-c106="" class="handle-button copy-button"><div _ngcontent-ntk-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-ntk-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-scss" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/TextureHypercompression/entry/src/main/ets/pages/UseAutoResizeToDownsampleTheImageComponent.ets#L29-L32" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-built_in">Image</span>(this.imageUrl)</li><li>  <span class="hljs-selector-class">.width</span>(<span class="hljs-number">300</span>)</li><li>  <span class="hljs-selector-class">.height</span>(<span class="hljs-number">200</span>)</li><li>  <span class="hljs-selector-class">.autoResize</span>(true)</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/TextureHypercompression/entry/src/main/ets/pages/UseAutoResizeToDownsampleTheImageComponent.ets#L29-L32" target="_blank">UseAutoResizeToDownsampleTheImageComponent.ets</a></div></div></div></div> </div> <div class="tiledSection"><h2 id="section1885751335520">总结<i class="anchor-icon anchor-icon-link" anchorid="section1885751335520" tips="复制节点链接"></i></h2><p>根据图片资源是否预置（即打包在应用内），优化策略有所不同。对于预置图片，推荐开发者使用纹理压缩技术。对于非预置图片，可采用预压缩至实际UI尺寸、网络图片资源优化、GIF图片压缩、优先使用.webp图片等方式对使用前的图片进行优化；通过autoResize对使用中的图片进行优化。开发者需根据实际情况，选择合适方案或方案组合对图片资源进行性能优化。</p> </div> </div> <div></div></div>