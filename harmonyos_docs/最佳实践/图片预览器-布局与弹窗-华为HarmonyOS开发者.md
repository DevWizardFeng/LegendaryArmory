<h1 _ngcontent-ysj-c119="" class="doc-title ng-star-inserted" title="图片预览器"> 图片预览器 </h1>

<div _ngcontent-ysj-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;"> <div><div class="tiledSection"><h2 id="section535715121219">概述<i class="anchor-icon anchor-icon-link" anchorid="section535715121219" tips="复制节点链接"></i></h2><p>图片预览器是常见的开发应用场景。在诸多日常使用的软件中，图片预览器都是提升用户体验的关键组件。它允许用户在上传、分享或编辑图片之前，先对图片进行预览，从而确保图片的质量和效果符合预期。本文章将深入探讨实现图片预览器过程中的几个复杂场景，具体包括：图片如何“跟手”，如何计算并合理限制图片的边界，以及如何解决Swiper组件与滑动手势之间产生的冲突问题。</p> <p><span><img height="545.0606" originheight="662" originwidth="320" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211162910.86661906342722287081324318488707:50001231000000:2800:9A4FE6F5A3AF2CF92F3CF5E17259E4768776A101B3F4D44589C320F54FF4C587.gif" title="点击放大" width="266"></span></p> <p></p> </div> <div class="tiledSection"><h2 id="section76491620111215">实现原理<i class="anchor-icon anchor-icon-link" anchorid="section76491620111215" tips="复制节点链接"></i></h2></div> <div class="tiledSection"><h3 id="section14549104191210" class="firsth2">场景描述<i class="anchor-icon anchor-icon-link" anchorid="section14549104191210" tips="复制节点链接"></i></h3><p>基础的图片预览器功能包括如下操作：</p> </div> <ol><li>双指捏合图片，即实现对图片以双指中心点为基准点的缩放操作。</li><li>双击图片即可切换其大小，当图片处于放大状态时，再次双击即恢复至默认尺寸。</li><li>大图片支持左右滑动查看。</li><li>点击或滑动图片指示器，主图会随之更新。</li></ol> <p>其中，缩放图片是通过矩阵变换功能matrix4来实现的，图片的平移是通过属性translate来实现的。</p> <div class="tiledSection"><h3 id="section1795112012712">关键技术<i class="anchor-icon anchor-icon-link" anchorid="section1795112012712" tips="复制节点链接"></i></h3><p>图片预览器中的图片查看功能，主要由大图界面来承担，交互操作相对复杂。下面，简要梳理一下大图界面中基本手势的处理与计算方式。</p> <p><strong>“跟手”的原理</strong></p> <p>“跟手”操作细分为两大类别：平移“跟手”与缩放“跟手”。</p> <p>在平移“跟手”中，无论用户的手指如何在屏幕上滑动，其触摸点相对于图片所保持的百分比位置始终保持不变。缩放“跟手”，则是在图片依据用户手势进行缩放调整时，用户手势的中心点不仅相对于屏幕上的坐标保持不变，而且相对于图片内容的百分比位置也保持不变。如下图所示，屏幕是蓝色区域，初始图片是橙色区域，放大后的图片是灰色区域。</p> <p><span><img originheight="308" originwidth="482" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211162911.06560292215030503641428597947588:50001231000000:2800:27B4A2E6BB624E82F832D160BB236B1C23890900D0A80238E650982BC1435575.png" width="482" height="308"></span></p> <p>假定当前图片位置是&lt;lastScale, offsetX, offsetY&gt;，控件原始宽高为&lt;w, h&gt;，本次缩放图片的缩放值为scale，缩放的中心点百分比位置为&lt;centerX, centerY&gt;，偏移为&lt;offX, offY&gt;，计算终点位置设为&lt;scale', offsetX', offsetY'&gt;。</p> <p><span><img height="241.48677" originheight="340" originwidth="1021" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211162911.75223942065547044789062293050595:50001231000000:2800:3C60C1743FE67741E67610FA2097CC6AE251E078126FCC76BE4E6548380A4893.png" title="点击放大" width="725.1825"></span></p> <p></p> <p>如上图所示，假定缩放时，未发生偏移，蓝色看作交互开始时的控件，橙色是交互后的控件，如果缩放中心点在图片中心（图1），那么控件最终的offset没有任何变化；如果缩放中心在最左边缘（图3），在放大的过程中，整个控件的中心向右发生了偏移。由此，可以计算出图片的最终位置。其中，图2、图3中的问号代表图片的偏移量，而图中的橙色圆点是图片缩放操作的中心点。在以下计算公式中，0.5 表示图片中心点的百分比位置，即 50% =  0.5。</p> <ul><li>scale' = 上次手势结束时的缩放值 * 本次缩放图片的缩放值。<p>= lastScale * scale</p> </li><li>offsetX' = 平移带来的偏移 + 缩放中心不在中心而带来的偏移。<p>= (offsetX + offX) +  (0.5 - centerX) * 控件大小变化之差</p> <p>= (offsetX + offX) +  (0.5 - centerX) * (w * lastScale - w * lastScale * scale)</p> <p>= (offsetX + offX) +  (0.5 - centerX) * w * (scale - 1) * lastScale</p> <p>= (offsetX + offX) +  (0.5 - centerX) * w * (1 - scale) * lastScale</p> </li><li>同理 offsetY' = 平移带来的偏移 + 缩放中心不在中心而带来的偏移。<p>= (offsetY + offY) + (0.5 - centerY) * h * (1 - scale) * lastScale</p> <p>缩放中心百分比位置&lt;centerX , centerY&gt;计算。如下图，橙色为手机屏幕，触摸点反馈的坐标(x,y)是相较屏幕左上角的（假设控件布满全屏）。</p> <p><span><img originheight="418" originwidth="691" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211162911.27261175130649498860499329667584:50001231000000:2800:C032A8D0F15278744A484EE11FF3F4342ACD8698AE6A7E518BF23B7276A46257.png" width="691" height="418"></span></p> </li><li>centerX = ( x - imgX ) / imgWidth<p>= ( 触摸点坐标x- X方向图片左上角的坐标）/  图片的宽度</p> <p>= ( 触摸点坐标x- ( ( 组件屏幕的宽度 - 当前图片的宽度) / 2 +上次图片X方向的偏移量)) / 图片的宽度</p> </li><li>同理 centerY = ( y - imgY ) / imgHeight<p>= ( 触摸点坐标y- Y方向图片左上角的坐标 ) /  图片的高度</p> <p>= ( 触摸点坐标y- ( ( 组件屏幕的高度 - 当前图片的高度) / 2 +上次图片Y方向的偏移量)) / 图片的高度</p> </li></ul> <p><strong>边界限制的原理</strong></p> <p>边界计算涉及两个方面：当前图片显示边界计算、offset范围计算。</p> <ul><li>当前图片显示边界计算可得出当前图片显示的位置，左右上下是否与显示区域边界对齐，如果已经对齐，则不能继续往某个方向继续拖动。</li><li>平移/缩放时必须对offset作限制，否则图片将被移出显示区域或是手势结束后周围有黑边。从原理上看，某个scale下offset（x&amp;y方向上）的范围是固定的，所以只需在手势交互时根据当前的scale计算得出offsetRange即可（超出边界时取边界作为结果）。</li></ul> <p>假定下面两个图中显示区域为黑框区域，当前放大倍率是curScale。</p> <p>如下图，当X方向offset到达上界时图片上边缘x坐标等于0：</p> <p><span><img originheight="223" originwidth="344" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211162911.98066483514799007665162848000321:50001231000000:2800:1AFC5D8F6A363E5A8A36C82A2156BF9066816AA12D2AD511EAD92695E0615E5B.png" width="344" height="223"></span></p> <p>到达下界时，图片右边缘与显示区域右边缘重合：</p> <p><span><img originheight="223" originwidth="344" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211162912.80492659775842169643711452949197:50001231000000:2800:EE4E69931C28886F33284FC43AD9B69564C0672672D2E4CF34BE8407CBCDA93F.png" width="344" height="223"></span></p> <div class="screenLinkPre"><div _ngcontent-ysj-c106="" class="highlight-div"><div _ngcontent-ysj-c106="" class="highlight-div-header"><div _ngcontent-ysj-c106="" class="highlight-div-header-left"><div _ngcontent-ysj-c106="" class="handle-button expand-button"><div _ngcontent-ysj-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-ysj-c106="" class="highlight-div-header-right"><div _ngcontent-ysj-c106="" class="handle-button ai-button"></div><div _ngcontent-ysj-c106="" class="handle-button line-button"><div _ngcontent-ysj-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-ysj-c106="" class="handle-button theme-button"><div _ngcontent-ysj-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-ysj-c106="" class="handle-button copy-button"><div _ngcontent-ysj-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-ysj-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-kotlin" codehub="https://gitee.com/harmonyos_samples/PicturePreview/blob/master/entry/src/main/ets/model/CommonModel.ets#L181-L196" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// Calculate the actual display size of the scaled image.</span></li><li>let scaledImageWidth = <span class="hljs-keyword">this</span>.imageWidth * <span class="hljs-keyword">this</span>.curScale;</li><li>let scaledImageHeight = <span class="hljs-keyword">this</span>.imageHeight * <span class="hljs-keyword">this</span>.curScale;</li><li>
</li><li><span class="hljs-comment">// Calculation of X-axis boundaries</span></li><li><span class="hljs-keyword">if</span> (scaledImageWidth &gt; <span class="hljs-keyword">this</span>.componentWidth) {</li><li>  <span class="hljs-comment">// If the width of the picture exceeds the width of the screen, you can move it left and right.</span></li><li>  let maxXOffset = (scaledImageWidth - <span class="hljs-keyword">this</span>.componentWidth) / <span class="hljs-number">2</span>;</li><li>  <span class="hljs-keyword">this</span>.maxOffsetX = maxXOffset;</li><li>  <span class="hljs-keyword">this</span>.minOffsetX = -maxXOffset;</li><li>} <span class="hljs-keyword">else</span> {</li><li>  <span class="hljs-comment">// The width of the image does not exceed the width of the screen. It should be centered and no X-axis offset is allowed.</span></li><li>  <span class="hljs-keyword">this</span>.maxOffsetX = <span class="hljs-number">0</span>;</li><li>  <span class="hljs-keyword">this</span>.minOffsetX = <span class="hljs-number">0</span>;</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/PicturePreview/blob/master/entry/src/main/ets/model/CommonModel.ets#L181-L196" target="_blank">CommonModel.ets</a></div></div></div></div> <p>Y方向同理，上下界为：</p> <div class="screenLinkPre"><div _ngcontent-ysj-c106="" class="highlight-div"><div _ngcontent-ysj-c106="" class="highlight-div-header"><div _ngcontent-ysj-c106="" class="highlight-div-header-left"><div _ngcontent-ysj-c106="" class="handle-button expand-button"><div _ngcontent-ysj-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-ysj-c106="" class="highlight-div-header-right"><div _ngcontent-ysj-c106="" class="handle-button ai-button"></div><div _ngcontent-ysj-c106="" class="handle-button line-button"><div _ngcontent-ysj-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-ysj-c106="" class="handle-button theme-button"><div _ngcontent-ysj-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-ysj-c106="" class="handle-button copy-button"><div _ngcontent-ysj-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-ysj-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-kotlin" codehub="https://gitee.com/harmonyos_samples/PicturePreview/blob/master/entry/src/main/ets/model/CommonModel.ets#L180-L210" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// Calculate the actual display size of the scaled image.</span></li><li>let scaledImageWidth = <span class="hljs-keyword">this</span>.imageWidth * <span class="hljs-keyword">this</span>.curScale;</li><li>let scaledImageHeight = <span class="hljs-keyword">this</span>.imageHeight * <span class="hljs-keyword">this</span>.curScale;</li><li>
</li><li><span class="hljs-comment">// ...</span></li><li>
</li><li><span class="hljs-comment">// Y-axis boundary calculation</span></li><li><span class="hljs-keyword">if</span> (scaledImageHeight &gt; <span class="hljs-keyword">this</span>.componentHeight) {</li><li>  <span class="hljs-comment">// If the image height exceeds the screen height, it can be scrolled up and down.</span></li><li>  let maxYOffset = (scaledImageHeight - <span class="hljs-keyword">this</span>.componentHeight) / <span class="hljs-number">2</span>;</li><li>  <span class="hljs-keyword">this</span>.maxOffsetY = maxYOffset;</li><li>  <span class="hljs-keyword">this</span>.minOffsetY = -maxYOffset;</li><li>} <span class="hljs-keyword">else</span> {</li><li>  <span class="hljs-comment">// The height of the image does not exceed the height of the screen. It should be centered and no Y-axis offset is allowed.</span></li><li>  <span class="hljs-keyword">this</span>.maxOffsetY = <span class="hljs-number">0</span>;</li><li>  <span class="hljs-keyword">this</span>.minOffsetY = <span class="hljs-number">0</span>;</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/PicturePreview/blob/master/entry/src/main/ets/model/CommonModel.ets#L180-L210" target="_blank">CommonModel.ets</a></div></div></div></div> </div> <div class="tiledSection"><h2 id="section16409916124915">场景实现<i class="anchor-icon anchor-icon-link" anchorid="section16409916124915" tips="复制节点链接"></i></h2></div> <div class="tiledSection"><h3 id="section5714182718499" class="firsth2">跟手的实现<i class="anchor-icon anchor-icon-link" anchorid="section5714182718499" tips="复制节点链接"></i></h3><p>跟手技术细分为两大类别：平移“跟手”与缩放“跟手”，接下来，将对这两者进行讲解。</p> <p><span><img height="545.5261" originheight="720" originwidth="348" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211162912.18642085976433808338279601182921:50001231000000:2800:668AA3B9393DB5CEA755FEA8BD59C36BCE946BE003A9E9DA89DE5678A0A8F05F.gif" title="点击放大" width="266"></span></p> <ol><li>响应平移手势：使用PanGesture接口实现滑动手势控制，为了实现单指滑动效果，需将参数fingers设置为1，当图片拖动后，即可获取当前图片的偏移量，具体为event.offsetX与event.offsetY。<div class="screenLinkPre"><div _ngcontent-ysj-c106="" class="highlight-div"><div _ngcontent-ysj-c106="" class="highlight-div-header"><div _ngcontent-ysj-c106="" class="highlight-div-header-left"><div _ngcontent-ysj-c106="" class="handle-button expand-button"><div _ngcontent-ysj-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-ysj-c106="" class="highlight-div-header-right"><div _ngcontent-ysj-c106="" class="handle-button ai-button"></div><div _ngcontent-ysj-c106="" class="handle-button line-button"><div _ngcontent-ysj-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-ysj-c106="" class="handle-button theme-button"><div _ngcontent-ysj-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-ysj-c106="" class="handle-button copy-button"><div _ngcontent-ysj-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-ysj-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-kotlin" codehub="https://gitee.com/harmonyos_samples/PicturePreview/blob/master/entry/src/main/ets/view/ImageItemView.ets#L115-L125" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// Slide picture</span></li><li><span class="hljs-comment">// Swiping left and right under the default size should switch images</span></li><li>PanGesture({ fingers: <span class="hljs-number">1</span>, distance: <span class="hljs-keyword">this</span>.isDisableSwipe ? <span class="hljs-number">3</span> : <span class="hljs-number">50</span> })</li><li>  .onActionUpdate((event: GestureEvent) =&gt; {</li><li>    <span class="hljs-keyword">this</span>.isDisableSwipe = <span class="hljs-keyword">this</span>.imageModel.panGestureUpdate(event);</li><li>  })</li><li>  .onActionEnd(() =&gt; {</li><li>    <span class="hljs-keyword">this</span>.imageModel.gestureEnd();</li><li>  }),</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/PicturePreview/blob/master/entry/src/main/ets/view/ImageItemView.ets#L115-L125" target="_blank">ImageItemView.ets</a></div></div></div></div> </li><li>图片平移：在onScale()方法中，算出图片经过拖动后，在X轴方向和Y轴方向上的新位置，分别为curOffsetX和curOffsetY，即为平移“跟手”后图片的位置。<div class="screenLinkPre"><div _ngcontent-ysj-c106="" class="highlight-div"><div _ngcontent-ysj-c106="" class="highlight-div-header"><div _ngcontent-ysj-c106="" class="highlight-div-header-left"><div _ngcontent-ysj-c106="" class="handle-button expand-button"><div _ngcontent-ysj-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-ysj-c106="" class="highlight-div-header-right"><div _ngcontent-ysj-c106="" class="handle-button ai-button"></div><div _ngcontent-ysj-c106="" class="handle-button line-button"><div _ngcontent-ysj-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-ysj-c106="" class="handle-button theme-button"><div _ngcontent-ysj-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-ysj-c106="" class="handle-button copy-button"><div _ngcontent-ysj-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-ysj-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-kotlin" codehub="https://gitee.com/harmonyos_samples/PicturePreview/blob/master/entry/src/main/ets/model/CommonModel.ets#L240-L379" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// Pan gestures callback during movement.</span></li><li>panGestureUpdate(event: GestureEvent): boolean {</li><li>  <span class="hljs-keyword">this</span>.onScale(event.scale, event.offsetX, event.offsetY);</li><li>  <span class="hljs-keyword">this</span>.pictureBoundaryRestriction();</li><li>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.isDisableSwipe;</li><li>}</li><li>
</li><li><span class="hljs-comment">// ...</span></li><li>
</li><li><span class="hljs-comment">// Calculates the offset X and offset Y of the current picture and the scaling value of the current picture.</span></li><li>onScale(scale: number, offX: number, offY: number): void {</li><li>  <span class="hljs-comment">// ...</span></li><li>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.curScale &lt; <span class="hljs-keyword">this</span>.maxScale) {</li><li>    <span class="hljs-keyword">this</span>.curOffsetY =</li><li>      (<span class="hljs-keyword">this</span>.lastOffsetY + offY) + (<span class="hljs-number">0.5</span> - <span class="hljs-keyword">this</span>.centerY) * <span class="hljs-keyword">this</span>.imageHeight * (<span class="hljs-number">1</span> - scale) * <span class="hljs-keyword">this</span>.lastScale;</li><li>    <span class="hljs-keyword">this</span>.curOffsetX =</li><li>      (<span class="hljs-keyword">this</span>.lastOffsetX + offX) + (<span class="hljs-number">0.5</span> - <span class="hljs-keyword">this</span>.centerX) * <span class="hljs-keyword">this</span>.imageWidth * (<span class="hljs-number">1</span> - scale) * <span class="hljs-keyword">this</span>.lastScale;</li><li>  }</li><li>  <span class="hljs-comment">// When the image is in the process of moving, it has not reached the boundary point.</span></li><li>  <span class="hljs-keyword">this</span>.isArriveBoundary = <span class="hljs-literal">false</span>;</li><li>  <span class="hljs-comment">// If the image has not reached the boundary, do not allow the image to be switched.</span></li><li>  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isArriveBoundary) {</li><li>    <span class="hljs-keyword">this</span>.isDisableSwipe = <span class="hljs-literal">true</span>;</li><li>  }</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/PicturePreview/blob/master/entry/src/main/ets/model/CommonModel.ets#L240-L379" target="_blank">CommonModel.ets</a></div></div></div></div> </li><li>响应缩放手势：使用捏合手势PinchGesture接口，将参数fingers设置为2。当捏合手势识别成功时，onActionStart()回调被适时触发，在这一过程中，会计算出当前图片缩放中心百分比位置。手势移动过程中会触发onActionUpdate()回调函数，在onActionUpdate()回调函数里计算出当前图片的缩放值以及图片在X方向和Y方向的偏移量，并实时更新图片的位置。<div class="screenLinkPre"><div _ngcontent-ysj-c106="" class="highlight-div"><div _ngcontent-ysj-c106="" class="highlight-div-header"><div _ngcontent-ysj-c106="" class="highlight-div-header-left"><div _ngcontent-ysj-c106="" class="handle-button expand-button"><div _ngcontent-ysj-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-ysj-c106="" class="highlight-div-header-right"><div _ngcontent-ysj-c106="" class="handle-button ai-button"></div><div _ngcontent-ysj-c106="" class="handle-button line-button"><div _ngcontent-ysj-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-ysj-c106="" class="handle-button theme-button"><div _ngcontent-ysj-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-ysj-c106="" class="handle-button copy-button"><div _ngcontent-ysj-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-ysj-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-kotlin" codehub="https://gitee.com/harmonyos_samples/PicturePreview/blob/master/entry/src/main/ets/view/ImageItemView.ets#L128-L141" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// Two-finger scaling</span></li><li>PinchGesture({ fingers: <span class="hljs-number">2</span>, distance: <span class="hljs-number">1</span> })</li><li>  .onActionStart((event: GestureEvent) =&gt; {</li><li>    <span class="hljs-keyword">this</span>.imageModel.pinchGestureStart(event);</li><li>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isOverlay) {</li><li>      <span class="hljs-keyword">this</span>.isOverlay = <span class="hljs-literal">false</span>;</li><li>    }</li><li>  })</li><li>  .onActionUpdate((event: GestureEvent) =&gt; {</li><li>    <span class="hljs-keyword">this</span>.isDisableSwipe = <span class="hljs-keyword">this</span>.imageModel.pinchGestureUpdate(event);</li><li>  })</li><li>  .onActionEnd(() =&gt; {</li><li>    <span class="hljs-keyword">this</span>.imageModel.pinchGestureEnd();</li><li>  }),</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/PicturePreview/blob/master/entry/src/main/ets/view/ImageItemView.ets#L128-L141" target="_blank">ImageItemView.ets</a></div></div></div></div> </li><li>图片缩放中心百分比位置的计算：成功识别到双指捏合手势触发onActionStart()函数，计算出图片缩放中心的百分比位置this.center，this.center用于图片缩放时，所产生的偏移量（若缩放中心并非位于图片中心点），下面将具体介绍图片缩放中心的百分比位置的计算方法：<ul><li>cX = Math.max((centerX - imgX) / imgDisplayWidth, 0)<p>= Math.max((centerX - ((this.componentWidth - ( (this.imageWidth * this.lastScale))) / 2 + this.lastOffsetX)) / (this.imageWidth * this.lastScale), 0)</p> <p>= Math.max((捏合手势中心点的X轴坐标 - ((组件屏幕的宽度 - (图片的宽度 * 上次图片的缩放值)) / 2 + 上次图片Y方向的偏移量)) / ( 图片的宽度 * 上次图片的缩放值 ), 0)</p> </li><li>cY = Math.max((centerY - imgY) / imgDisplayHeight, 0);<p>= Math.max((centerY - ((this.componentHeight - (this.imageHeight * this.lastScale)) / 2 + this.lastOffsetY)) / (this.imageHeight * this.lastScale), 0)</p> <p>= Math.max((捏合手势中心点的Y轴坐标 - ((组件屏幕的高度 - (图片的高度 * 上次图片的缩放值)) / 2 + 上次图片Y方向的偏移量)) / (图片的高度 * 上次图片的缩放值), 0)</p> <div class="screenLinkPre"><div _ngcontent-ysj-c106="" class="highlight-div"><div _ngcontent-ysj-c106="" class="highlight-div-header"><div _ngcontent-ysj-c106="" class="highlight-div-header-left"><div _ngcontent-ysj-c106="" class="handle-button expand-button"><div _ngcontent-ysj-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-ysj-c106="" class="highlight-div-header-right"><div _ngcontent-ysj-c106="" class="handle-button ai-button"></div><div _ngcontent-ysj-c106="" class="handle-button line-button"><div _ngcontent-ysj-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-ysj-c106="" class="handle-button theme-button"><div _ngcontent-ysj-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-ysj-c106="" class="handle-button copy-button"><div _ngcontent-ysj-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-ysj-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-kotlin" codehub="https://gitee.com/harmonyos_samples/PicturePreview/blob/master/entry/src/main/ets/model/CommonModel.ets#L216-L255" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// Calculates the percentage position of the current zoom center relative to the picture</span></li><li>evaluateCenter(centerX: number, centerY: number): [number, number] {</li><li>  let imgDisplayWidth = <span class="hljs-keyword">this</span>.imageWidth * <span class="hljs-keyword">this</span>.lastScale;</li><li>  let imgDisplayHeight = <span class="hljs-keyword">this</span>.imageHeight * <span class="hljs-keyword">this</span>.lastScale;</li><li>  let imgX = (<span class="hljs-keyword">this</span>.componentWidth - imgDisplayWidth) / <span class="hljs-number">2</span> + <span class="hljs-keyword">this</span>.lastOffsetX;</li><li>  let imgY = (<span class="hljs-keyword">this</span>.componentHeight - imgDisplayHeight) / <span class="hljs-number">2</span> + <span class="hljs-keyword">this</span>.lastOffsetY;</li><li>  let cX = Math.max((centerX - imgX) / imgDisplayWidth, <span class="hljs-number">0</span>);</li><li>  let cY = Math.max((centerY - imgY) / imgDisplayHeight, <span class="hljs-number">0</span>);</li><li>  <span class="hljs-keyword">return</span> [cX, cY];</li><li>}</li><li>
</li><li><span class="hljs-comment">// ...</span></li><li>
</li><li><span class="hljs-comment">// Pinch gesture recognition successful callback.</span></li><li>pinchGestureStart(event: GestureEvent): void {</li><li>  <span class="hljs-keyword">this</span>.center = <span class="hljs-keyword">this</span>.evaluateCenter(event.pinchCenterX, event.pinchCenterY);</li><li>  <span class="hljs-keyword">this</span>.centerX = <span class="hljs-number">1</span> - <span class="hljs-keyword">this</span>.center[<span class="hljs-number">0</span>];</li><li>  <span class="hljs-keyword">this</span>.centerY = <span class="hljs-number">1</span> - <span class="hljs-keyword">this</span>.center[<span class="hljs-number">1</span>];</li><li>  AppStorage.setOrCreate(<span class="hljs-string">'isImgDefaultSize'</span>, <span class="hljs-literal">false</span>);</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/PicturePreview/blob/master/entry/src/main/ets/model/CommonModel.ets#L216-L255" target="_blank">CommonModel.ets</a></div></div></div></div> </li></ul> <p></p> </li><li>图片缩放：在捏合手势触发移动操作时，通过调用自定义onScale()方法，计算得出当前图片的缩放值以及由双指缩放动作引起的水平偏移量curOffsetX和垂直偏移量curOffsetY，最后，调用matrix4.identity().scale()对图片进行缩放，至此，图片的缩放“跟手”操作已完成。<div class="screenLinkPre"><div _ngcontent-ysj-c106="" class="highlight-div"><div _ngcontent-ysj-c106="" class="highlight-div-header"><div _ngcontent-ysj-c106="" class="highlight-div-header-left"><div _ngcontent-ysj-c106="" class="handle-button expand-button"><div _ngcontent-ysj-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-ysj-c106="" class="highlight-div-header-right"><div _ngcontent-ysj-c106="" class="handle-button ai-button"></div><div _ngcontent-ysj-c106="" class="handle-button line-button"><div _ngcontent-ysj-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-ysj-c106="" class="handle-button theme-button"><div _ngcontent-ysj-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-ysj-c106="" class="handle-button copy-button"><div _ngcontent-ysj-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-ysj-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-kotlin" codehub="https://gitee.com/harmonyos_samples/PicturePreview/blob/master/entry/src/main/ets/model/CommonModel.ets#L167-L380" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// General picture scaling value method.</span></li><li>pictureScaling(scale: number): void {</li><li>  <span class="hljs-keyword">this</span>.matrix = matrix4.identity().scale({</li><li>    x: scale,</li><li>    y: scale</li><li>  }).copy();</li><li>}</li><li>
</li><li><span class="hljs-comment">// ...</span></li><li>
</li><li><span class="hljs-comment">// Pinch gestures callback during a move.</span></li><li>pinchGestureUpdate(event: GestureEvent): boolean {</li><li>  <span class="hljs-keyword">this</span>.onScale(event.scale, event.offsetX, event.offsetY);</li><li>  <span class="hljs-keyword">this</span>.pictureScaling(<span class="hljs-keyword">this</span>.curScale);</li><li>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.curScale &gt; <span class="hljs-keyword">this</span>.defaultScaleValue) {</li><li>    <span class="hljs-keyword">this</span>.isDisableSwipe = <span class="hljs-literal">true</span>;</li><li>  }</li><li>  <span class="hljs-keyword">this</span>.pictureBoundaryRestriction();</li><li>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.isDisableSwipe;</li><li>}</li><li>
</li><li><span class="hljs-comment">// ...</span></li><li>
</li><li><span class="hljs-comment">// Calculates the offset X and offset Y of the current picture and the scaling value of the current picture.</span></li><li>onScale(scale: number, offX: number, offY: number): void {</li><li>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.lastScale * scale &gt; <span class="hljs-keyword">this</span>.maxScale) {</li><li>    <span class="hljs-keyword">this</span>.curScale = <span class="hljs-keyword">this</span>.maxScale;</li><li>  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.lastScale * scale &lt; <span class="hljs-keyword">this</span>.minScale) {</li><li>    <span class="hljs-keyword">this</span>.curScale = <span class="hljs-keyword">this</span>.minScale;</li><li>  } <span class="hljs-keyword">else</span> {</li><li>    <span class="hljs-keyword">this</span>.curScale = <span class="hljs-keyword">this</span>.lastScale * scale;</li><li>  }</li><li>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.lastScale * scale === <span class="hljs-keyword">this</span>.maxScale) {</li><li>    <span class="hljs-keyword">this</span>.curScale -= <span class="hljs-number">0.001</span>;</li><li>  }</li><li>  <span class="hljs-keyword">this</span>.evaluateOffsetRange();</li><li>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.curScale &lt; <span class="hljs-keyword">this</span>.maxScale) {</li><li>    <span class="hljs-keyword">this</span>.curOffsetY =</li><li>      (<span class="hljs-keyword">this</span>.lastOffsetY + offY) + (<span class="hljs-number">0.5</span> - <span class="hljs-keyword">this</span>.centerY) * <span class="hljs-keyword">this</span>.imageHeight * (<span class="hljs-number">1</span> - scale) * <span class="hljs-keyword">this</span>.lastScale;</li><li>    <span class="hljs-keyword">this</span>.curOffsetX =</li><li>      (<span class="hljs-keyword">this</span>.lastOffsetX + offX) + (<span class="hljs-number">0.5</span> - <span class="hljs-keyword">this</span>.centerX) * <span class="hljs-keyword">this</span>.imageWidth * (<span class="hljs-number">1</span> - scale) * <span class="hljs-keyword">this</span>.lastScale;</li><li>  }</li><li>  <span class="hljs-comment">// When the image is in the process of moving, it has not reached the boundary point.</span></li><li>  <span class="hljs-keyword">this</span>.isArriveBoundary = <span class="hljs-literal">false</span>;</li><li>  <span class="hljs-comment">// If the image has not reached the boundary, do not allow the image to be switched.</span></li><li>  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isArriveBoundary) {</li><li>    <span class="hljs-keyword">this</span>.isDisableSwipe = <span class="hljs-literal">true</span>;</li><li>  }</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/PicturePreview/blob/master/entry/src/main/ets/model/CommonModel.ets#L167-L380" target="_blank">CommonModel.ets</a></div></div></div></div> </li></ol> </div> <div class="tiledSection"><h3 id="section119351544501">边界限制的实现<i class="anchor-icon anchor-icon-link" anchorid="section119351544501" tips="复制节点链接"></i></h3><ol><li>图片边界限制：主要涉及两个方面：当前图片显示边界的计算以及offset范围计算。<p>调用自定义initCurrentImageInfo()方法，计算出当前图片的宽度this.imageModel.imageWidth和高度this.imageModel.imageHeight。</p> <div class="screenLinkPre"><div _ngcontent-ysj-c106="" class="highlight-div"><div _ngcontent-ysj-c106="" class="highlight-div-header"><div _ngcontent-ysj-c106="" class="highlight-div-header-left"><div _ngcontent-ysj-c106="" class="handle-button expand-button"><div _ngcontent-ysj-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-ysj-c106="" class="highlight-div-header-right"><div _ngcontent-ysj-c106="" class="handle-button ai-button"></div><div _ngcontent-ysj-c106="" class="handle-button line-button"><div _ngcontent-ysj-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-ysj-c106="" class="handle-button theme-button"><div _ngcontent-ysj-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-ysj-c106="" class="handle-button copy-button"><div _ngcontent-ysj-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-ysj-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-javascript" codehub="https://gitee.com/harmonyos_samples/PicturePreview/blob/master/entry/src/main/ets/view/ImageItemView.ets#L57-L81" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">/**</span></li><li><span class="hljs-comment"> * Set information about the current image: uri, whRatio, pixelMap, defaultSize, maxScaleValue</span></li><li><span class="hljs-comment"> * Obtain the Image information in advance for the size setting of</span></li><li><span class="hljs-comment"> * the image component and subsequent related calculations</span></li><li><span class="hljs-comment"> */</span></li><li><span class="hljs-title function_">initCurrentImageInfo</span>(): <span class="hljs-keyword">void</span> {</li><li>  <span class="hljs-keyword">try</span> {</li><li>    <span class="hljs-keyword">let</span> img = <span class="hljs-variable language_">this</span>.<span class="hljs-property">context</span>.<span class="hljs-property">resourceManager</span>.<span class="hljs-title function_">getMediaContentSync</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">imageData</span>?.<span class="hljs-property">id</span>);</li><li>    <span class="hljs-keyword">let</span> imageSource = image.<span class="hljs-title function_">createImageSource</span>(img.<span class="hljs-property">buffer</span>.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>));</li><li>    imageSource.<span class="hljs-title function_">getImageInfo</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data: image.ImageInfo</span>) =&gt;</span> {</li><li>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">imageWHRatio</span> = data.<span class="hljs-property">size</span>.<span class="hljs-property">width</span> / data.<span class="hljs-property">size</span>.<span class="hljs-property">height</span>;</li><li>      <span class="hljs-comment">// Calculate scale ratios for both width and height to ensure image fits completely</span></li><li>      <span class="hljs-keyword">let</span> widthRatio = <span class="hljs-variable language_">this</span>.<span class="hljs-property">imageModel</span>.<span class="hljs-property">componentWidth</span> / data.<span class="hljs-property">size</span>.<span class="hljs-property">width</span>;</li><li>      <span class="hljs-keyword">let</span> heightRatio = <span class="hljs-variable language_">this</span>.<span class="hljs-property">imageModel</span>.<span class="hljs-property">componentHeight</span> / data.<span class="hljs-property">size</span>.<span class="hljs-property">height</span>;</li><li>      <span class="hljs-comment">// Use the smaller ratio to ensure the image fits within the screen bounds</span></li><li>      <span class="hljs-keyword">let</span> scaleRatio = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(widthRatio, heightRatio);</li><li>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">imageModel</span>.<span class="hljs-property">imageWidth</span> = data.<span class="hljs-property">size</span>.<span class="hljs-property">width</span> * scaleRatio;</li><li>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">imageModel</span>.<span class="hljs-property">imageHeight</span> = data.<span class="hljs-property">size</span>.<span class="hljs-property">height</span> * scaleRatio;</li><li>    }).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err: BusinessError</span>) =&gt;</span> {</li><li>      hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x0000</span>, <span class="hljs-variable constant_">TAG</span>, <span class="hljs-string">`[error][getImageInfo]<span class="hljs-subst">${err.message}</span>`</span>);</li><li>    });</li><li>  } <span class="hljs-keyword">catch</span> (err) {</li><li>    hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x0000</span>, <span class="hljs-variable constant_">TAG</span>, <span class="hljs-string">`GetMediaContentSync failed. Cause code: <span class="hljs-subst">${err.code}</span>, message: <span class="hljs-subst">${err.message}</span>`</span>);</li><li>  }</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/PicturePreview/blob/master/entry/src/main/ets/view/ImageItemView.ets#L57-L81" target="_blank">ImageItemView.ets</a></div></div></div></div> <p>调用自定义windowSize()方法，计算出当前组件的宽度this.componentWidth和高度this.componentHeight。</p> <div class="p">最后，调用自定义evaluateOffsetRange()方法，在图片缩放后，计算出图片在四个方向上的边界值：具体包括最大水平偏移量this.maxOffsetX、最小水平偏移量this.minOffsetX、最大垂直偏移量this.maxOffsetY以及最小垂直偏移量this.minOffsetY<div class="screenLinkPre"><div _ngcontent-ysj-c106="" class="highlight-div"><div _ngcontent-ysj-c106="" class="highlight-div-header"><div _ngcontent-ysj-c106="" class="highlight-div-header-left"><div _ngcontent-ysj-c106="" class="handle-button expand-button"><div _ngcontent-ysj-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-ysj-c106="" class="highlight-div-header-right"><div _ngcontent-ysj-c106="" class="handle-button ai-button"></div><div _ngcontent-ysj-c106="" class="handle-button line-button"><div _ngcontent-ysj-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-ysj-c106="" class="handle-button theme-button"><div _ngcontent-ysj-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-ysj-c106="" class="handle-button copy-button"><div _ngcontent-ysj-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-ysj-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-kotlin" codehub="https://gitee.com/harmonyos_samples/PicturePreview/blob/master/entry/src/main/ets/model/CommonModel.ets#L150-L212" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// Get window size.</span></li><li>windowSize(): void {</li><li>  window.getLastWindow(context).then((window: window.Window) =&gt; {</li><li>    <span class="hljs-keyword">try</span> {</li><li>      <span class="hljs-keyword">this</span>.componentWidth = uiContext!.px2vp(window.getWindowProperties().windowRect.width);</li><li>      <span class="hljs-keyword">this</span>.componentHeight = uiContext!.px2vp(window.getWindowProperties().windowRect.height);</li><li>    } <span class="hljs-keyword">catch</span> (err) {</li><li>      hilog.error(DOMAIN, TAG, FORMAT,</li><li>        `GetWindowProperties failed. Cause code: ${err.code}, message: ${err.message}`);</li><li>    }</li><li>  }).<span class="hljs-keyword">catch</span>((err: BusinessError) =&gt; {</li><li>    hilog.error(DOMAIN, TAG, FORMAT, `GetLastWindow failed. Cause code: ${err.code}, message: ${err.message}`);</li><li>  });</li><li>}</li><li>
</li><li><span class="hljs-comment">// ...</span></li><li>
</li><li><span class="hljs-comment">// Calculate the range of the picture boundary.</span></li><li>evaluateOffsetRange(): void {</li><li>  <span class="hljs-comment">// Calculate the actual display size of the scaled image.</span></li><li>  let scaledImageWidth = <span class="hljs-keyword">this</span>.imageWidth * <span class="hljs-keyword">this</span>.curScale;</li><li>  let scaledImageHeight = <span class="hljs-keyword">this</span>.imageHeight * <span class="hljs-keyword">this</span>.curScale;</li><li>
</li><li>  <span class="hljs-comment">// Calculation of X-axis boundaries</span></li><li>  <span class="hljs-keyword">if</span> (scaledImageWidth &gt; <span class="hljs-keyword">this</span>.componentWidth) {</li><li>    <span class="hljs-comment">// If the width of the picture exceeds the width of the screen, you can move it left and right.</span></li><li>    let maxXOffset = (scaledImageWidth - <span class="hljs-keyword">this</span>.componentWidth) / <span class="hljs-number">2</span>;</li><li>    <span class="hljs-keyword">this</span>.maxOffsetX = maxXOffset;</li><li>    <span class="hljs-keyword">this</span>.minOffsetX = -maxXOffset;</li><li>  } <span class="hljs-keyword">else</span> {</li><li>    <span class="hljs-comment">// The width of the image does not exceed the width of the screen. It should be centered and no X-axis offset is allowed.</span></li><li>    <span class="hljs-keyword">this</span>.maxOffsetX = <span class="hljs-number">0</span>;</li><li>    <span class="hljs-keyword">this</span>.minOffsetX = <span class="hljs-number">0</span>;</li><li>  }</li><li>
</li><li>  <span class="hljs-comment">// Y-axis boundary calculation</span></li><li>  <span class="hljs-keyword">if</span> (scaledImageHeight &gt; <span class="hljs-keyword">this</span>.componentHeight) {</li><li>    <span class="hljs-comment">// If the image height exceeds the screen height, it can be scrolled up and down.</span></li><li>    let maxYOffset = (scaledImageHeight - <span class="hljs-keyword">this</span>.componentHeight) / <span class="hljs-number">2</span>;</li><li>    <span class="hljs-keyword">this</span>.maxOffsetY = maxYOffset;</li><li>    <span class="hljs-keyword">this</span>.minOffsetY = -maxYOffset;</li><li>  } <span class="hljs-keyword">else</span> {</li><li>    <span class="hljs-comment">// The height of the image does not exceed the height of the screen. It should be centered and no Y-axis offset is allowed.</span></li><li>    <span class="hljs-keyword">this</span>.maxOffsetY = <span class="hljs-number">0</span>;</li><li>    <span class="hljs-keyword">this</span>.minOffsetY = <span class="hljs-number">0</span>;</li><li>  }</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/PicturePreview/blob/master/entry/src/main/ets/model/CommonModel.ets#L150-L212" target="_blank">CommonModel.ets</a></div></div></div></div> </div> </li><li>图片在滑动或缩放过程中，一旦触及边界，便会触发restrictBound()方法进行判断。若图片抵达最上方边界，则立即将当前Y方向的偏移位置this.curOffsetY设置为该方向的最大偏移值this.maxOffsetY，以此实现对边界的有效限制。同样的逻辑也适用于其他三个方向：当图片到达最下方、最左侧或最右侧边界时，也会相应地调整其偏移位置，确保图片始终在规定的范围内活动。<p>当图片滑动至左边界或右边界时，this.isDisableSwipe会被设置为false；此时，Swiper组件将激活滑动切换功能，允许用户切换图片。</p> <p><span><img height="545.5261" originheight="720" originwidth="348" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211162912.49014989430811926767553215133977:50001231000000:2800:4E78461152262D1F3377FC4A86B6BE0E2601A2E4BC083C7FD0CEF8F6341C3720.gif" title="点击放大" width="266"></span></p> <div class="screenLinkPre"><div _ngcontent-ysj-c106="" class="highlight-div"><div _ngcontent-ysj-c106="" class="highlight-div-header"><div _ngcontent-ysj-c106="" class="highlight-div-header-left"><div _ngcontent-ysj-c106="" class="handle-button expand-button"><div _ngcontent-ysj-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-ysj-c106="" class="highlight-div-header-right"><div _ngcontent-ysj-c106="" class="handle-button ai-button"></div><div _ngcontent-ysj-c106="" class="handle-button line-button"><div _ngcontent-ysj-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-ysj-c106="" class="handle-button theme-button"><div _ngcontent-ysj-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-ysj-c106="" class="handle-button copy-button"><div _ngcontent-ysj-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-ysj-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-kotlin" codehub="https://gitee.com/harmonyos_samples/PicturePreview/blob/master/entry/src/main/ets/model/CommonModel.ets#L259-L288" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// Picture Boundary Restriction</span></li><li>pictureBoundaryRestriction(): void {</li><li>  <span class="hljs-comment">// X-axis boundary restriction</span></li><li>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.curOffsetX &gt; <span class="hljs-keyword">this</span>.maxOffsetX) {</li><li>    <span class="hljs-keyword">this</span>.curOffsetX = <span class="hljs-keyword">this</span>.maxOffsetX;</li><li>    <span class="hljs-keyword">this</span>.isDisableSwipe = <span class="hljs-literal">false</span>;</li><li>    <span class="hljs-keyword">this</span>.isArriveBoundary = <span class="hljs-literal">true</span>;</li><li>  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.curOffsetX &lt; <span class="hljs-keyword">this</span>.minOffsetX) {</li><li>    <span class="hljs-keyword">this</span>.curOffsetX = <span class="hljs-keyword">this</span>.minOffsetX;</li><li>    <span class="hljs-keyword">this</span>.isDisableSwipe = <span class="hljs-literal">false</span>;</li><li>    <span class="hljs-keyword">this</span>.isArriveBoundary = <span class="hljs-literal">true</span>;</li><li>  }</li><li>  <span class="hljs-comment">// Y-axis boundary limit</span></li><li>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.curOffsetY &gt; <span class="hljs-keyword">this</span>.maxOffsetY) {</li><li>    <span class="hljs-keyword">this</span>.curOffsetY = <span class="hljs-keyword">this</span>.maxOffsetY;</li><li>  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.curOffsetY &lt; <span class="hljs-keyword">this</span>.minOffsetY) {</li><li>    <span class="hljs-keyword">this</span>.curOffsetY = <span class="hljs-keyword">this</span>.minOffsetY;</li><li>  }</li><li>  <span class="hljs-comment">// When the image cannot fill the entire screen, force it to be centered.</span></li><li>  let scaledImageWidth = <span class="hljs-keyword">this</span>.imageWidth * <span class="hljs-keyword">this</span>.curScale;</li><li>  let scaledImageHeight = <span class="hljs-keyword">this</span>.imageHeight * <span class="hljs-keyword">this</span>.curScale;</li><li>  <span class="hljs-keyword">if</span> (scaledImageWidth &lt;= <span class="hljs-keyword">this</span>.componentWidth) {</li><li>    <span class="hljs-comment">// The width of the image does not exceed the screen. Force the X-axis to be centered.</span></li><li>    <span class="hljs-keyword">this</span>.curOffsetX = <span class="hljs-number">0</span>;</li><li>  }</li><li>  <span class="hljs-keyword">if</span> (scaledImageHeight &lt;= <span class="hljs-keyword">this</span>.componentHeight) {</li><li>    <span class="hljs-comment">// The height of the image does not exceed the screen, and the Y-axis is forced to be centered.</span></li><li>    <span class="hljs-keyword">this</span>.curOffsetY = <span class="hljs-number">0</span>;</li><li>  }</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/PicturePreview/blob/master/entry/src/main/ets/model/CommonModel.ets#L259-L288" target="_blank">CommonModel.ets</a></div></div></div></div> </li></ol> <p></p> </div> <div class="tiledSection"><h3 id="section8461127131818">实现Swiper组件与滑动手势冲突的解决方案<i class="anchor-icon anchor-icon-link" anchorid="section8461127131818" tips="复制节点链接"></i></h3><p>当Swiper组件与PanGesture滑动手势事件在同一组件上并发作用时，两者之间的冲突会导致Swiper无法正常切换图片。下面，将详细讲解如何有效解决Swiper组件与滑动手势之间的冲突问题。</p> <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"><ul><li>Swiper组件内包含了<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-gestures-pangesture" target="_blank">PanGesture</a>拖动手势事件，用于滑动轮播子组件。<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-swiper#disableswipe8" target="_blank">disableSwipe</a>属性设为true会取消内部的PanGesture事件监听。</li></ul> </div></div></div> <ol><li>需要将Swiper组件的disableSwipe属性设置为变量this.isDisableSwipe，即disableSwipe(this.isDisableSwipe)。<div class="p">当图片处于默认尺寸，或是已滑动到左右边界之时，应将this.isDisableSwipe的值设定为false；当图片处于放大状态且尚未滑动至左右边界时，应将this.isDisableSwipe的值设定为true。<div class="screenLinkPre"><div _ngcontent-ysj-c106="" class="highlight-div"><div _ngcontent-ysj-c106="" class="highlight-div-header"><div _ngcontent-ysj-c106="" class="highlight-div-header-left"><div _ngcontent-ysj-c106="" class="handle-button expand-button"><div _ngcontent-ysj-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-ysj-c106="" class="highlight-div-header-right"><div _ngcontent-ysj-c106="" class="handle-button ai-button"></div><div _ngcontent-ysj-c106="" class="handle-button line-button"><div _ngcontent-ysj-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-ysj-c106="" class="handle-button theme-button"><div _ngcontent-ysj-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-ysj-c106="" class="handle-button copy-button"><div _ngcontent-ysj-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-ysj-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-cangjie" codehub="https://gitee.com/harmonyos_samples/PicturePreview/blob/master/entry/src/main/ets/pages/HomePage.ets#L157-L202" data-highlighted="yes"><ol class="linenums"><li>@<span class="hljs-title function_">Builder</span></li><li><span class="hljs-title function_">PhotoSwiper</span>() {</li><li>  <span class="hljs-title function_">Swiper</span>(<span class="hljs-keyword">this</span>.<span class="hljs-variable">homeSwipeController</span>) {</li><li>    <span class="hljs-title function_">ForEach</span>(<span class="hljs-keyword">this</span>.<span class="hljs-variable">ImgData</span>, (<span class="hljs-variable">img</span>: <span class="hljs-title class_">Resource</span>) =&gt; {</li><li>      <span class="hljs-title function_">ImageItemView</span>({</li><li>        <span class="hljs-variable">imageData</span>: <span class="hljs-title class_">img</span>,</li><li>        <span class="hljs-variable">isOverlay</span>: <span class="hljs-keyword">this</span>.<span class="hljs-title class_">isOverlay</span></li><li>      })</li><li>        .<span class="hljs-title function_">width</span>(<span class="hljs-string">'100%'</span>)</li><li>        .<span class="hljs-title function_">height</span>(<span class="hljs-string">'100%'</span>)</li><li>    }, (<span class="hljs-variable">img</span>: <span class="hljs-title class_">Resource</span>, <span class="hljs-variable">index</span>: <span class="hljs-title class_">number</span>) =&gt; <span class="hljs-variable">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-variable">img</span>) + <span class="hljs-variable">index</span>)</li><li>  }</li><li>  <span class="hljs-comment">// ...</span></li><li>  .<span class="hljs-title function_">disableSwipe</span>(<span class="hljs-keyword">this</span>.<span class="hljs-variable">isDisableSwipe</span>)</li><li>  <span class="hljs-comment">// ...</span></li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/PicturePreview/blob/master/entry/src/main/ets/pages/HomePage.ets#L157-L202" target="_blank">HomePage.ets</a></div></div></div></div> </div> </li><li>PanGesture接口被用于实现滑动手势控制，其中参数distance需根据变量进行动态设置与判断。具体而言，当this.isDisableSwipe被设置为true时，Swiper组件将禁用滑动切换功能，此时，为了保持拖动图片时的流畅性，需要将distance的值设定为一个较小的数值。相反，当this.isDisableSwipe为false时，Swiper组件则会启用滑动切换功能，此时，为了让用户能够更灵敏地触发Swiper组件的滑动操作，distance的值则需适当增大，以优化用户的交互体验。至此，Swiper组件与滑动手势之间的冲突问题便得到解决。<div class="screenLinkPre"><div _ngcontent-ysj-c106="" class="highlight-div"><div _ngcontent-ysj-c106="" class="highlight-div-header"><div _ngcontent-ysj-c106="" class="highlight-div-header-left"><div _ngcontent-ysj-c106="" class="handle-button expand-button"><div _ngcontent-ysj-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-ysj-c106="" class="highlight-div-header-right"><div _ngcontent-ysj-c106="" class="handle-button ai-button"></div><div _ngcontent-ysj-c106="" class="handle-button line-button"><div _ngcontent-ysj-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-ysj-c106="" class="handle-button theme-button"><div _ngcontent-ysj-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-ysj-c106="" class="handle-button copy-button"><div _ngcontent-ysj-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-ysj-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-cangjie" codehub="https://gitee.com/harmonyos_samples/PicturePreview/blob/master/entry/src/main/ets/view/ImageItemView.ets#L118-L118" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-title function_">PanGesture</span>({ <span class="hljs-variable">fingers</span>: <span class="hljs-number">1</span>, <span class="hljs-variable">distance</span>: <span class="hljs-keyword">this</span>.<span class="hljs-title class_">isDisableSwipe</span> ? <span class="hljs-number">3</span> : <span class="hljs-number">50</span> })</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/PicturePreview/blob/master/entry/src/main/ets/view/ImageItemView.ets#L118-L118" target="_blank">ImageItemView.ets</a></div></div></div></div> </li></ol> </div> <div class="tiledSection"><h2 id="section2656237102810">常见问题<i class="anchor-icon anchor-icon-link" anchorid="section2656237102810" tips="复制节点链接"></i></h2></div> <div class="tiledSection"><h3 id="section469512588288" class="firsth2">在Swiper组件中，当为图片子组件配置了PanGesture后，swiper无法正常翻页，该如何解决手势冲突？<i class="anchor-icon anchor-icon-link" anchorid="section469512588288" tips="复制节点链接"></i></h3></div> <p>通过使用Swiper组件的disableSwipe属性，进行动态赋值，在图片保持默认尺寸或图片在放大状态下已触及边界时，将disableSwipe属性设置为false，从而使得Swiper能够切换图片；当图片处于放大状态且尚未到达边界时，则将disableSwipe属性设为true，此时Swiper的切换功能将被禁用。</p> <div class="tiledSection"><h3 id="section204561937478">当图片被放大后，若在拖动图片的过程中，该如何控制其边界，确保图片不会超出显示区域的界限？<i class="anchor-icon anchor-icon-link" anchorid="section204561937478" tips="复制节点链接"></i></h3><p>该问题涉及到图片边界的约束。主要涉及两个方面：当前图片显示边界计算以及offset范围计算。当前图片显示边界计算可得出当前图片显示的位置，左右上下是否与显示区域边界对齐，如果已经对齐，则不能继续往某个方向继续拖动。平移/缩放时必须对offset作限制，否则图片将被移出显示区域或是手势结束后周围有黑边。只需在手势交互时根据当前的scale计算得出offset的范围即可（超出边界时取边界作为结果），即可对图片边界进行限制。</p> </div> <div class="tiledSection"><h2 id="section184771544141710">示例代码<i class="anchor-icon anchor-icon-link" anchorid="section184771544141710" tips="复制节点链接"></i></h2><ul><li><a href="https://gitee.com/harmonyos_samples/PicturePreview" target="_blank">基于ArkUI实现图片预览功能</a></li></ul> </div> </div> <div></div></div>