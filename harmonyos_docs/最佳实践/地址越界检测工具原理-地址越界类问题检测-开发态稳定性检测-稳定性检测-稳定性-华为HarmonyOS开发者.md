<h1 _ngcontent-tum-c119="" class="doc-title ng-star-inserted" title="地址越界检测工具原理"> 地址越界检测工具原理 </h1>

<div _ngcontent-tum-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;"> <div><div class="tiledSection"><h2 id="section159561141247">ASan检测原理<i class="anchor-icon anchor-icon-link" anchorid="section159561141247" tips="复制节点链接"></i></h2></div> <p>为追求C/C++的高性能，编译器和OS（Windows/Linux/Mac）运行框架不会对内存操作进行安全检测。针对该场景，DevEco Studio集成ASan（Address Sanitizer）为开发者提供面向C/C++的地址越界检测能力，并通过FaultLog展示错误的堆栈详情及导致错误的代码行。常见的ASan异常检测类型有：heap-buffer-overflow、stack-buffer-overflow/underflow、heap-use-after-free和double-free等，详情请参考<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-asan-detection#section12508111110451">ASan异常检测类型</a>。</p> <div class="tiledSection"><h3 id="section7013278195" class="firsth2">原理概述<i class="anchor-icon anchor-icon-link" anchorid="section7013278195" tips="复制节点链接"></i></h3></div> <p>ASan工具主要由插桩模块和动态运行库模块构成。</p> <p>插桩模块主要使能为：</p> <ul><li>对于栈内存的分配，ASan会插入代码来分配额外的“红区”（redzones）作为边界检查，以及可能的“影子内存”来跟踪内存的可访问性。</li><li>对于每次内存访问（读/写），ASan会插入代码来检查访问的内存是否有效，比如是否越界或是否访问了未初始化的内存。</li></ul> <p>动态运行库主要使能为：</p> <ul><li>将路径中的malloc/free函数进行了替换，在malloc函数中增加了分配redzone内存的部分，将redzone对应的shadow memory进行加锁（poison），主要的内存区域对应的影子内存不进行加锁。</li><li>将free/delete将所有分配的内存区域加锁（poison），并放入隔离区队列（FIFO）中，以确保一段时间内不会再被分配。</li></ul> <p>总结：ASan工具在编译时对代码进行插桩，在运行时关注相关内存的shadow memory值，从而判断是否有内存错误的产生。</p> <div class="tiledSection"><h3 id="section13589164561911">shadow机制<i class="anchor-icon anchor-icon-link" anchorid="section13589164561911" tips="复制节点链接"></i></h3></div> <p>ASAN利用在运行时通过影子内存（shadow memory）来标记内存的状态，从而检测出非法的内存操作。默认8个字节内存对应1字节的shadow，也就是当malloc(13)时，ASan会将其按8字节对齐分配16字节有效内存，并在前后插入8字节的红区，如下图所示：</p> <p><span><img originheight="109" originwidth="518" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163504.66119603336679849788932580427203:50001231000000:2800:859CB75C4E9619B8D14416CD1E37E0ACADF826EC237487472C509898324E4B10.png" width="518" height="109"></span></p> <p>日志中会给出Shadow byte legend，这部分解释了每个shadow byte的含义，每个shadow byte代表8个字节。这些字节被用来表示内存状态，以帮助诊断内存错误。</p> <div _ngcontent-tum-c106="" class="highlight-div"><div _ngcontent-tum-c106="" class="highlight-div-header"><div _ngcontent-tum-c106="" class="highlight-div-header-left"><div _ngcontent-tum-c106="" class="handle-button expand-button"><div _ngcontent-tum-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-tum-c106="" class="highlight-div-header-right"><div _ngcontent-tum-c106="" class="handle-button ai-button"></div><div _ngcontent-tum-c106="" class="handle-button line-button"><div _ngcontent-tum-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-tum-c106="" class="handle-button theme-button"><div _ngcontent-tum-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-tum-c106="" class="handle-button copy-button"><div _ngcontent-tum-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-tum-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-cangjie" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-variable">Shadow</span> <span class="hljs-variable">byte</span> <span class="hljs-variable">legend</span> (<span class="hljs-variable">one</span> <span class="hljs-variable">shadow</span> <span class="hljs-variable">byte</span> <span class="hljs-variable">represents</span> <span class="hljs-number">8</span> <span class="hljs-variable">application</span> <span class="hljs-variable">bytes</span>):</li><li>  <span class="hljs-variable">Addressable</span>:           <span class="hljs-number">00</span></li><li>  <span class="hljs-variable">Partially</span> <span class="hljs-variable">addressable</span>: <span class="hljs-number">01</span> <span class="hljs-number">02</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">07</span> </li><li>  <span class="hljs-variable">Heap</span> <span class="hljs-variable">left</span> <span class="hljs-variable">redzone</span>:       <span class="hljs-title class_">fa</span></li><li>  <span class="hljs-variable">Freed</span> <span class="hljs-variable">heap</span> <span class="hljs-variable">region</span>:       <span class="hljs-title class_">fd</span></li><li>  <span class="hljs-variable">Stack</span> <span class="hljs-variable">left</span> <span class="hljs-variable">redzone</span>:      <span class="hljs-title class_">f1</span></li><li>  <span class="hljs-variable">Stack</span> <span class="hljs-variable">mid</span> <span class="hljs-variable">redzone</span>:       <span class="hljs-title class_">f2</span></li><li>  <span class="hljs-variable">Stack</span> <span class="hljs-variable">right</span> <span class="hljs-variable">redzone</span>:     <span class="hljs-title class_">f3</span></li><li>  <span class="hljs-variable">Stack</span> <span class="hljs-variable">after</span> <span class="hljs-keyword">return</span>:      <span class="hljs-title class_">f5</span></li><li>  <span class="hljs-variable">Stack</span> <span class="hljs-variable">use</span> <span class="hljs-variable">after</span> <span class="hljs-variable">scope</span>:   <span class="hljs-title class_">f8</span></li><li>  <span class="hljs-variable">Global</span> <span class="hljs-variable">redzone</span>:          <span class="hljs-title class_">f9</span></li><li>  <span class="hljs-variable">Global</span> <span class="hljs-keyword">init</span> <span class="hljs-variable">order</span>:       <span class="hljs-title class_">f6</span></li><li>  <span class="hljs-variable">Poisoned</span> <span class="hljs-variable">by</span> <span class="hljs-variable">user</span>:        <span class="hljs-title class_">f7</span></li><li>  <span class="hljs-variable">Container</span> <span class="hljs-variable">overflow</span>:      <span class="hljs-title class_">fc</span></li><li>  <span class="hljs-variable">Array</span> <span class="hljs-variable">cookie</span>:            <span class="hljs-title class_">ac</span></li><li>  <span class="hljs-variable">Intra</span> <span class="hljs-variable">object</span> <span class="hljs-variable">redzone</span>:    <span class="hljs-title class_">bb</span></li><li>  <span class="hljs-variable">ASan</span> <span class="hljs-keyword">internal</span>:           <span class="hljs-title class_">fe</span></li><li>  <span class="hljs-variable">Left</span> <span class="hljs-variable">alloca</span> <span class="hljs-variable">redzone</span>:     <span class="hljs-title class_">ca</span></li><li>  <span class="hljs-variable">Right</span> <span class="hljs-variable">alloca</span> <span class="hljs-variable">redzone</span>:    <span class="hljs-title class_">cb</span></li></ol></pre></div></div>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.15.1.4.1.1" valign="top" width="17.39%"><p>值</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.15.1.4.1.2" valign="top" width="19.09%"><p>名称</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.15.1.4.1.3" valign="top" width="63.519999999999996%"><p>说明</p> </th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="17.39%"><p>00</p> </td> <td class="cellrowborder" valign="top" width="19.09%"><p>Addressable</p> </td> <td class="cellrowborder" valign="top" width="63.519999999999996%"><p>合法内存，全部可读写。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="17.39%"><p>01-07</p> </td> <td class="cellrowborder" valign="top" width="19.09%"><p>Partially addressable</p> </td> <td class="cellrowborder" valign="top" width="63.519999999999996%"><p>前k个字节可访问，剩下的8-k个字节不可访问。如03表示前3个字节可访问，后5个字节为红区。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="17.39%"><p>fa</p> </td> <td class="cellrowborder" valign="top" width="19.09%"><p>Heap left redzone</p> </td> <td class="cellrowborder" valign="top" width="63.519999999999996%"><p>堆对象左侧红区（通常右侧红区也用fa来表示）。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="17.39%"><p>fd</p> </td> <td class="cellrowborder" valign="top" width="19.09%"><p>Freed heap region</p> </td> <td class="cellrowborder" valign="top" width="63.519999999999996%"><p>已释放的堆内存区域，访问将触发use-after-free错误。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="17.39%"><p>f1</p> </td> <td class="cellrowborder" valign="top" width="19.09%"><p>Stack left redzone</p> </td> <td class="cellrowborder" valign="top" width="63.519999999999996%"><p>栈变量左侧红区，用于检测栈缓冲区下溢。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="17.39%"><p>f2</p> </td> <td class="cellrowborder" valign="top" width="19.09%"><p>Stack mid redzone</p> </td> <td class="cellrowborder" valign="top" width="63.519999999999996%"><p>栈变量间隔离区域，防止跨变量溢出。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="17.39%"><p>f3</p> </td> <td class="cellrowborder" valign="top" width="19.09%"><p>Stack right redzone</p> </td> <td class="cellrowborder" valign="top" width="63.519999999999996%"><p>栈变量右侧红区，用于检测栈缓冲区上溢。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="17.39%"><p>f5</p> </td> <td class="cellrowborder" valign="top" width="19.09%"><p>Stack after return</p> </td> <td class="cellrowborder" valign="top" width="63.519999999999996%"><p>函数返回后使用局部变量，访问将触发stack-use-after-return错误。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="17.39%"><p>f8</p> </td> <td class="cellrowborder" valign="top" width="19.09%"><p>Stack use after scope</p> </td> <td class="cellrowborder" valign="top" width="63.519999999999996%"><p>变量超出生命周期后被访问。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="17.39%"><p>f9</p> </td> <td class="cellrowborder" valign="top" width="19.09%"><p>Global redzone</p> </td> <td class="cellrowborder" valign="top" width="63.519999999999996%"><p>全局变量周围的红区，用于检测全局缓冲区溢出，访问将触发global-overflow错误。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="17.39%"><p>f6</p> </td> <td class="cellrowborder" valign="top" width="19.09%"><p>Global init order</p> </td> <td class="cellrowborder" valign="top" width="63.519999999999996%"><p>标识全局变量初始化顺序问题，访问将触发initialization-order-fiasco错误。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="17.39%"><p>f7</p> </td> <td class="cellrowborder" valign="top" width="19.09%"><p>Poisoned by user</p> </td> <td class="cellrowborder" valign="top" width="63.519999999999996%"><p>用户通ASAN_POISON_MEMORY_REGION接口去投毒，主动标记为不可访问的内存区域，访问将触发use-after-poison错误。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="17.39%"><p>fc</p> </td> <td class="cellrowborder" valign="top" width="19.09%"><p>Container overflow</p> </td> <td class="cellrowborder" valign="top" width="63.519999999999996%"><p>容器对象（如 std::vector）的溢出保护区域。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="17.39%"><p>ac</p> </td> <td class="cellrowborder" valign="top" width="19.09%"><p>Array cookie</p> </td> <td class="cellrowborder" valign="top" width="63.519999999999996%"><p>动态数组分配的元数据区（存储数组大小等信息）。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="17.39%"><p>bb</p> </td> <td class="cellrowborder" valign="top" width="19.09%"><p>Intra object redzone</p> </td> <td class="cellrowborder" valign="top" width="63.519999999999996%"><p>对象内部成员之间的红区（通过-fsanitize-address-field-padding启用）。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="17.39%"><p>fe</p> </td> <td class="cellrowborder" valign="top" width="19.09%"><p>ASan internal</p> </td> <td class="cellrowborder" valign="top" width="63.519999999999996%"><p>ASan 内部数据结构保留区域，应用程序访问视为错误。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="17.39%"><p>ca</p> </td> <td class="cellrowborder" valign="top" width="19.09%"><p>Left alloca redzone</p> </td> <td class="cellrowborder" valign="top" width="63.519999999999996%"><p>alloca() 分配内存左侧的红区。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="17.39%"><p>cb</p> </td> <td class="cellrowborder" valign="top" width="19.09%"><p>Right alloca redzone</p> </td> <td class="cellrowborder" valign="top" width="63.519999999999996%"><p>alloca() 分配内存右侧的红区。</p> </td> </tr>  </tbody></table></div> </div> <div class="tiledSection"><h3 id="section1081955981919">隔离区机制<i class="anchor-icon anchor-icon-link" anchorid="section1081955981919" tips="复制节点链接"></i></h3></div> <p>ASan对于UAF的检测依赖于隔离区。free()函数会将整个内存区域置成不可使用并将其放入隔离区，这样该区域就不会马上被malloc分配给应用程序。目前，隔离区是使用一个FIFO队列实现的，默认大小为256，可通过在asan.option中配置quarantine_size_mb来修改其大小。</p> <div><div class="hw-editor-tip warn"><div class="title">注意</div><div class="content"><ul><li>隔离区并不能永久保留已释放对象，当其容量quarantine_size_mb达到上限时（默认256），会被重新分配给其他人。当它被重新分配给其他人后，原先的持有者再次访问此块区域将不会报错。因为这一块区域的shadow memory不再是0xfd。所以这算是ASan漏检的一种情况。</li><li>若程序频繁分配和释放内存，建议合理设置quarantine_size_mb，在保证性能的同时提高检测精度。</li><li>隔离区的存在可能会增加程序运行时的内存使用量，这是ASan在提升内存错误检测能力时的trade-off。</li></ul> <p>更详细的内容可参考LLVM <a href="https://clang.llvm.org/docs/AddressSanitizer.html" target="_blank">AddressSanitizer官方文档</a>。</p> </div></div></div> <div class="tiledSection"><h2 id="section187526511146">HWASan检测原理<i class="anchor-icon anchor-icon-link" anchorid="section187526511146" tips="复制节点链接"></i></h2></div> <div class="tiledSection"><h3 id="section172704461599" class="firsth2">原理概述<i class="anchor-icon anchor-icon-link" anchorid="section172704461599" tips="复制节点链接"></i></h3></div> <p>HWASan是Hardware-Assisted Address Sanitizer的简称，它是Clang LLVM提供的一套内存错误检测系统，用来检测C/C++中常见的内存访问错误，相比之前的ASan（Address  Sanitizer），它在性能、内存上有不小提升，依赖于编译器的Address Tagging特性，该特性允许应用程序自定义数据存储到虚拟地址的最高8位，当CPU操作该虚拟地址时会自动忽略它。HWASan工具检测地址越界问题的原理如下，</p> <ol><li>将整个虚拟内存区间按照16：1的比例，划分为user memory和shadow memory；同时，无论是堆上、栈上还是全局对象，其内存起始地址都按照16字节对齐，即保证每16字节的user memory都能映射到1字节的shadow memory；</li><li>分配对象的时候，随机分配一个8位的随机tag标记到该对象的虚拟地址最高8位，同时该tag也会保存到其映射的shadow memory中；</li><li>编译器在每个内存地址的load/store之前都会插入检查指令，用于确认操作地址的最高8位保存的tag与其映射的shadow memory中的tag值是否一致；</li><li>对象回收后也会重新分配一个随机值，保存到其映射的shadow memory中，当出现内存越界行为时，就会检测到tag值不一致的异常；</li></ol> <div><div class="hw-editor-tip warn"><div class="title">注意</div><div class="content"><p>当分配的对象小于16字节时，多余的内存不会再分配给其它对象，此时shadow memory中保存的是对象所占内存的实际字节数，而tag值则保存在16字节的最后一个字节里面。</p> </div></div></div> <p>常见的HWASan异常检测类型有stack-buffer-overflow/underflow，stack-use-after-return，heap-buffer-overflow等，详见<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-hwasan-detection#section207321025115510">HWASan异常检测类型</a>。</p> <div class="tiledSection"><h3 id="section17222194819518">功能介绍<i class="anchor-icon anchor-icon-link" anchorid="section17222194819518" tips="复制节点链接"></i></h3></div> <p>HWASan能检测到ASan所能检测到的同一系列错误：</p> <ul><li>堆栈和堆缓冲区上溢/下溢。</li><li>释放之后的堆使用情况。</li><li>重复释放/错误释放。</li></ul> <p>和ASan相比，HWASan具有以下优点：</p> <ul><li>HWASan不需要安全区来检测buffer overflow，既极大地降低了工具对于内存的消耗，也不会出现ASan中某些overflow检测不到的情况。</li><li>HWASan不需要隔离区来检测UseAfterFree，因此不会出现ASan中某些UseAfterFree检测不到的情况。</li><li>此外，HWASan还可以检测返回之后的堆栈使用情况。</li></ul> <div class="tiledSection"><h3 id="section1691941315212">tag和shadow机制<i class="anchor-icon anchor-icon-link" anchorid="section1691941315212" tips="复制节点链接"></i></h3></div> <p>HWASan的tag机制是其核心部分，利用处理器TopBitIgnore特性，它通过在内存地址的高位（通常是8位）存储一个随机生成的tag值，来标识内存对象。这个tag值与指向该内存对象的指针共享，从而在内存访问时进行匹配检查。</p> <ul><li>内存分配时的tag生成：当程序分配内存时，HWASan会为该内存对象生成一个随机的8位tag值。这个tag值被存储在内存对象的top byte（最高有效位）中。</li><li>指针的tag同步：指向该内存对象的指针也会被赋予相同的tag值。这样，当程序访问该内存对象时，指针的tag值与内存对象的tag值需要一致，否则会触发错误，上报hwasan日志。</li><li>shadow memory的tag存储：除了在指针中存储tag值，HWASan还会在shadow memory中为每个内存对象存储一个对应的tag值。shadow memory是HWASan用来记录内存对象tag值的辅助存储区域，通常每16字节的内存对应1字节的shadow memory。若分配的内存小于16字节（短颗粒内存（short granules）），shadow会做特殊处理。Shadow Memory存储实际有效长度，而Tag保存内存在该16字节区域的末字节。</li></ul> <p><span><img height="256.3575" originheight="574" originwidth="1169" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163504.68879237898962760498531793204125:50001231000000:2800:518D289ED79B7C38BC57F44A4548E56A1B75C175F50AE9D7A3029638E76F5B8F.png" title="点击放大" width="523.6875"></span></p> <p>更详细的内容可参考LLVM <a href="https://clang.llvm.org/docs/HardwareAssistedAddressSanitizerDesign.html" target="_blank">Hardware-assisted AddressSanitizer官方文档</a>。</p> <div class="tiledSection"><h2 id="section102442491750">MemDebug检测原理<i class="anchor-icon anchor-icon-link" anchorid="section102442491750" tips="复制节点链接"></i></h2></div> <div class="tiledSection"><h3 id="section5423205312278" class="firsth2">原理概述<i class="anchor-icon anchor-icon-link" anchorid="section5423205312278" tips="复制节点链接"></i></h3><p>Memory_debug检测原理基于隔离区加投毒填充的机制，同时复用了HWASan的tag机制对一部分问题进行检测，主要应用于检测未进行HWASan插桩的库文件等代码的堆内存问题，同时不影响已进行插桩的代码模块。主要检测逻辑是通过隔离区将释放后的内存保存起来防止立即被再次分配出去，并在其中填充特殊值，放入隔离区中的内存理论上不允许读写，当隔离区满或线程退出时，将隔离区中部分或全部内存释放出隔离区返还给分配器并对其中填充值进行校验，若填充值被修改，则说明发生use-after-free问题。</p> <ol><li>double-free检测逻辑<p>基于HWASan检测机制，分配和释放内存时会在指针和shadow memory生成随机tag值，当释放内存时会检测指针和对应shadow memory的tag，如果不匹配则报use-after-free错误。理论上有1/256的概率出现相同，即有1/256的概率漏检。</p> </li><li>use-after-free（write）<p>同样是基于投毒和隔离区机制，内存在释放时会被填充上特殊值（0x55）并放入隔离区防止再次被分配，当写操作修改了内存中的内容时不会立即报错，当该内存从离开隔离区真正被释放返还给分配器时会检查内存填充的内容，如果内存中内容不是指定填充值说明在释放后被修改发生了UAF（write）错误。但只能激发错误且不能在发生错误时立即检测到，所以不能提供触发问题时的现场调用栈信息。</p> </li><li>heap-buffer-overflow<p>overflow无法通过memory_debug直接检测，当写越界行为发生时，可能会修改相邻chunk中的值，如果被修改chunk已被释放填充且还保留在隔离区中，则在chunk离开隔离区被返还给allocator时会被检测到，但不能检测到现场。另外，基于HWASan检测机制，当分配的chunk包含tail时，下越界写会破坏填充的tail_magic，此时可以在free到隔离区时检测到下越界写错误，该机制同样无法检测到越界写发生的现场。</p> </li></ol> </div> <div class="tiledSection"><h2 id="section555616291854">GWP-ASan检测原理<i class="anchor-icon anchor-icon-link" anchorid="section555616291854" tips="复制节点链接"></i></h2></div> <p>当前在系统上定位内存的一些非法行为的时候，可以开启ASan版本来定位此类问题，但鉴于ASan开启会对性能和内存有很大的影响，所以ASan的能力不能部署到正式生产环境中，GWP-ASan可以帮助开发者在性能影响很小的情况下检查到部分内存使用的非法行为，正是因为性能影响较小，GWP-ASan会被部署到正式环境中，避免了正式环境中出现内存问题时再去使用ASan版本做二次复现。</p> <div class="tiledSection"><h3 id="section13143122112817" class="firsth2">原理概述<i class="anchor-icon anchor-icon-link" anchorid="section13143122112817" tips="复制节点链接"></i></h3></div> <p>GWP-ASan具有一种内存分配器功能，可帮助查找释放后使用和堆缓冲区溢出bug，启用后，GWP-ASan会拦截随机选择的堆分配子集，并将其放入特殊区域，以便捕获难以检测到的堆内存损坏错误。只要用户足够多，即使在低采样率的情况下，也可以发现常规测试未能发现的堆内存安全错误。常见的GWP-ASan异常检测类型有：double free，user_after_free，invalid free left等，详见<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-gwpasan-detection#section73731529454">GWP-ASan异常检测类型</a>部分。</p> <p>GWP-ASan通过修改内存分配器来工作。它使用概率性采样，随机选择一部分内存分配进行保护。这种设计在性能和内存错误检测之间取得平衡。</p> <p>当启用GWP-ASan功能后，内存分配会以页对齐的方式分配，并通过<strong>控制页的读写权限</strong>来检测内存访问是否合法。如果某一页的权限被设置为不可读写，那么对该页的任何读写访问都会导致进程接收到SIGSEGV错误信号。</p> <p><strong>实现机制：</strong></p> <p>GWP-ASan通过在内存分配路径（如 malloc、calloc、realloc）上设置钩子（hook）来实现。它使用<a href="https://gitee.com/openharmony/third_party_llvm-project/blob/master/compiler-rt/lib/gwp_asan/guarded_pool_allocator.cpp" target="_blank">GuardedPoolAllocator</a>来进行内存分配，该分配器会为每个分配的内存块设置保护页。</p> <p>在初始化过程中，GWP-ASan会根据slots数量参数提前分配一个下图所示保护区；每个Guard Page页都被设置为不可读写权限，用于检测堆内存上下溢出。</p> <p><span><img height="56.8575" originheight="130" originwidth="1188" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163504.96848597215857036747408329414405:50001231000000:2800:AD2AF25EE0729170EC8FDADC43F0CFF60BEF8F6A39FA3B98BD440A28E22ED3BC.png" title="点击放大" width="523.6875"></span></p> <p>之后，hook应用堆内存分配行为，每次分配堆内存时，随机决定目标内存是走GWP-ASan分配，还是走系统原生分配。如果走GWP-ASan分配，那么目标内存会被随机左对齐/右对齐分配在一个空闲的Slot上，同时记录分配内存的堆栈信息。</p> <p><span><img height="298.2525" originheight="677" originwidth="1187" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163504.05516039511166051287006283966216:50001231000000:2800:C46124182517E78DC490BFDE08BE7152D910D1BC2C0FF4CEB823AA9EB323165B.png" title="点击放大" width="523.6875"></span></p> <p>当释放内存时，会先判断目标内存是否在GWP-ASan受保护内存池上，如果是，那么释放这块内存和其所在的Slot，该Slot页设置为不可读写权限，同时记录释放内存的堆栈。Slot空闲后，可以重新被用于分配。堆栈信息记录在metadata中。</p> <p><strong>更详细的内容可参考LLVM官方文档</strong> <a href="https://llvm.org/docs/GwpAsan.html" target="_blank">GWP AddressSanitizer官方文档</a></p> </div> <div></div></div>