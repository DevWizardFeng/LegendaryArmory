<h1 _ngcontent-crt-c119="" class="doc-title ng-star-inserted" title="基于Buffer模式进行视频转码"> 基于Buffer模式进行视频转码 </h1>

<div _ngcontent-crt-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;"> <div><div class="tiledSection"><h2 id="section1824515319505">概述<i class="anchor-icon anchor-icon-link" anchorid="section1824515319505" tips="复制节点链接"></i></h2></div> <p>视频转码是指通过调整编码、比特率等参数将视频文件从一种格式转换为另一种格式的过程。Buffer模式是系统提供的一种视频编解码的方式，是媒体子系统的核心能力。在Buffer模式中，编码或解码完成的数据会以共享内存的方式输出，开发者可以获取共享内存的地址和数据信息，适用于视频转码、编辑等场景。</p> <p>本文主要介绍了视频编解码的基本概念、Buffer模式下的视频编解码原理，并详细介绍了视频转码的实现方案和开发步骤。</p> <div class="tiledSection"><h2 id="section78321428677">实现原理<i class="anchor-icon anchor-icon-link" anchorid="section78321428677" tips="复制节点链接"></i></h2></div> <div class="tiledSection"><h3 id="section18485205818581" class="firsth2">基本概念<i class="anchor-icon anchor-icon-link" anchorid="section18485205818581" tips="复制节点链接"></i></h3><p>视频文件格式是视频保存的格式，常见的格式有MP4、AVI等。在视频文件（以MP4文件解码为例）解码时，首先需要将视频进行解封装，解封装会将一个封装好的音视频文件（如MP4、FLV等）中的音频和视频数据流分离出来。然后，从数据流中取出视频的媒体样本sample，通过视频解码器将媒体数据解码成YUV数据，流程如下所示。</p> <p><span><img height="131.35080000000002" originheight="239" originwidth="968" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163035.77097856488008955209270369503619:50001231000000:2800:4BC9806B64856649D34EC2E86279D62519BB4573CF448B58C872FD4847882F23.png" title="点击放大" width="532"></span></p> <p>在视频文件编码（以MP4文件编码为例）时，首先会通过视频编码器对YUV数据进行编码，将未压缩的视频数据YUV压缩成视频码流H.264，然后，将编码后的媒体数据按一定的格式封装存储到MP4文件里，流程如下所示。</p> <p><span><img height="110.88210000000001" originheight="193" originwidth="926" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163035.65556341922032999928532155969894:50001231000000:2800:614C64A0F33DD89D3EF9E260F7D7F7F06EBFDD87CA674BA9D54938670D4B91E8.png" title="点击放大" width="532"></span></p> <p>关于视频文件编解码支持的格式，详情请参考<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/avcodec-support-formats" target="_blank">AVCodec支持的格式</a>。</p> </div> <div class="tiledSection"><h3 id="section39419315541">YUV跨距对齐<i class="anchor-icon anchor-icon-link" anchorid="section39419315541" tips="复制节点链接"></i></h3><p>YUV是编译true-color颜色空间（color space）的种类，Y'UV、YUV等专有名词都可以称为YUV。I420、NV12、NV21等是YUV具体的存储格式。I420和YV12属于YUV420P格式，NV12 和NV21属于YUV420SP格式。</p> <p>由于硬件内存访问对齐要求，YUV图像数据在写入内存缓冲区时，其每行数据的存储长度会被硬件或底层驱动自动扩展至规定的对齐粒度（例如16/32/64字节），即YUV跨距对齐。在YUV跨距对齐时，会对每行有效像素数据进行边界填充（Padding），导致Stride值大于图像的有效像素宽度（以字节计算）。</p> <p>以I420格式为例，其跨距对齐后的格式如下所示。其中，w_stride是数据填充后的宽跨距，h_stride是数据填充后的高跨距，height是实际的高度，width是实际的宽度。</p> <p><span><img height="442.89000000000004" originheight="1209" originwidth="1429" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163035.86607221291325444837208386263999:50001231000000:2800:243C504A22E74DA826FB3289AE38A599C59E3ABEBE5CA6019D84D60FB8E36BA5.png" title="点击放大" width="523.6875"></span></p> </div> <div class="tiledSection"><h3 id="section2077317411553">视频编解码原理<i class="anchor-icon anchor-icon-link" anchorid="section2077317411553" tips="复制节点链接"></i></h3><p>视频编解码器的原理和实现机制是一样的，区别是处理的数据有所不同。在编码时，输入数据是原始数据（YUV），输出数据是视频数据（如H.264），解码的过程与编码相反。这里以视频解码的过程进行原理说明。</p> <p>在视频解码的过程中，主要包含两个部分，分别为输入数据流转和输出数据流转。开发者需要通过输入数据流转将需要解码的数据填充给解码器，解码器再进行解码处理。在输出数据流转中，解码器会将解码完成的数据返回给开发者使用，在开发者使用完毕后，需要通知解码器释放视频数据，从而实现整体的Buffer循环，详细原理流程如下图所示。</p> <p><span><img height="337.3412" originheight="558" originwidth="1320" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163036.13068090372928257293660491507870:50001231000000:2800:1A6FD7CEEA58C058D30829100AE9B1F887707CCAD844C698EFACCAAC5BCDE323.png" title="点击放大" width="798"></span></p> <p>输入数据流转的步骤如下所示。</p> <ol><li><span>解码器提供空的Buffer地址，该地址用于填充需要解码的视频数据。</span></li><li><span>将解封装后的视频数据（如H.264）填充到解码器提供的Buffer地址中。</span></li><li><span>通知解码器，当前Buffer地址已完成视频数据填充。</span></li><li><span>当解码器收到通知后，会对数据进行解码操作。</span></li></ol> <p>输出数据流转的步骤如下所示。</p> <ol><li><span>在完成输出数据流转后，解码器会提供已解码的数据。</span></li><li><span>获取数据后，开发者可以根据实际业务使用视频数据，如送显到屏幕。</span></li><li><span>使用完毕后，开发者需要将Buffer的使用权移交给解码器。</span></li><li><span>解码器会循环再利用Buffer地址。Buffer内的视频数据不会被释放或者清零，而是在下一次循环中，将解码好的数据直接覆盖写入到已经空闲的Buffer地址里。</span></li></ol> </div> <div class="tiledSection"><h2 id="section1614045517715">视频转码<i class="anchor-icon anchor-icon-link" anchorid="section1614045517715" tips="复制节点链接"></i></h2></div> <div class="tiledSection"><h3 id="section16852115414" class="firsth2">场景描述<i class="anchor-icon anchor-icon-link" anchorid="section16852115414" tips="复制节点链接"></i></h3><p>不同的设备和平台支持视频格式各有不同，通过转码可以将视频转化成设备或平台适配的格式，从而确保视频能够正确的播放与观看，提高视频的兼容性和可播放性。例如，部分平台仅支持特定的视频格式。在相同的视频格式下，其分辨率、帧率、比特率等参数也各有不同，通过改变相应的参数，可以缩小视频文件的大小，从而节省视频的存储空间。</p> <p>在ArkTS侧，系统提供了转码的相关接口AVTranscoder，可以实现简单的视频转码操作。而在复杂的场景下，如视频裁剪等场景，则需要调用系统的视频编解码的相关能力进行实现。在Buffer模式下的视频转码，可以对视频数据进行读写操作，能够满足更加灵活多变的场景需求。</p> </div> <div class="tiledSection"><h3 id="section06598917918">开发步骤<i class="anchor-icon anchor-icon-link" anchorid="section06598917918" tips="复制节点链接"></i></h3><p>在视频转码的场景中，视频文件会经历解封装、视频解码、视频编码和视频封装的步骤，如下图所示。</p> </div> <p><span><img height="133.41150000000002" originheight="356" originwidth="2455" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163036.99840735648561911716127582445152:50001231000000:2800:A58E6FFD6F53F127D597807346D6875A34F030E82771F4304D7D42715D4808A6.png" title="点击放大" width="920"></span></p> <p>其主要包含三个大步骤。</p> <p><strong>1. 视频编解码环境初始化</strong>：为后续视频编码、解码提前创建好对应的实例，并设置编解码所需要的参数。</p> <p><strong>2. 视频文件解码</strong>：视频文件解码包含了视频解封装、视频解码的操作，最后生成解码后的视频数据。</p> <p><strong>3. 视频文件编码</strong>：将解码后的数据进行拷贝处理，并通过编码器进行编码，最后封装到对应的视频文件中。</p> <p><strong>视频编解码环境初始化</strong>开发步骤如下所示。</p> <p>1.1 创建与配置解封装器。</p> <p>1.2 创建与配置解码器，并注册解码器的回调函数。其中，回调函数OnNeedInputBuffer()提供了解码空Buffer地址，回调函数OnNewOutputBuffer()提供了解码后的视频数据。</p> <p>1.3 创建与配置封装器。</p> <p>1.4 创建与配置编码器，并注册编码器的回调函数，回调函数需要配置的内容与解码器相同。</p> <p>在视频文件解码中，主要包含两个步骤，输入缓存处理，输出缓存处理。在OnNeedInputBuffer()回调函数中，维护了一个空Buffer的缓存队列，在实现输入缓存处理时，需要解封装、填充视频数据。在OnNewOutputBuffer()回调函数中，维护了一个已解码视频数据的缓存队列，在实现输出缓存处理时，需要处理视频数据，其调用顺序如下所示。</p> <p><span><img height="408.2435" originheight="729" originwidth="1425" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163036.78361349617398013109354234591623:50001231000000:2800:7B4D1E984D9B9782D42157F84D60D21E5F63964B9058FE2CA1BF12ED53B87F3E.png" title="点击放大" width="798"></span></p> <p><strong>视频文件解码</strong>开发步骤如下所示。</p> <p>2.1 通过inputBufferInfoQueue获取视频缓存空地址。</p> <p>2.2 通过Demuxer读取媒体数据，即视频码流数据及其格式。</p> <p>2.3 在OH_VideoDecoder_PushInputBuffer()中设置对应的视频缓存数据。</p> <p>2.4 在解码完成后，通过outputBufferInfoQueue获取视频缓存数据。</p> <p>2.5 处理缓存数据，最后通过OH_VideoDecoder_FreeOutputBuffer()刷新缓存，将缓存资源返回给解码器。</p> <p><strong>视频文件编码</strong>开发步骤如下所示。在视频文件编码中，大致的处理流程与视频文件解码类似，而编码的输入缓存的数据来源于解码的输出缓存，所以，可以在解码的输出缓存处理子线程中同步处理编码的输入缓存数据。</p> <p>3.1 通过inputBufferInfoQueue获取视频缓存地址。</p> <p>3.2 将解码的输出缓存数据拷贝到编码的输入缓存中。</p> <p>3.3 通过OH_VideoEncoder_PushInputBuffer()将已填充的输入缓存提交给编码器。</p> <p>3.4 在解码完成后，通过outputBufferInfoQueue获取视频缓存数据。</p> <p>3.5 通过Muxer将编码完成的视频数据写入到视频文件中</p> <div class="tiledSection"><h3 id="section11122112194417">代码实现<i class="anchor-icon anchor-icon-link" anchorid="section11122112194417" tips="复制节点链接"></i></h3><ol><li>视频编解码环境初始化。<ul><li>初始化视频解码环境。<div class="screenLinkPre"><div _ngcontent-crt-c106="" class="highlight-div"><div _ngcontent-crt-c106="" class="highlight-div-header"><div _ngcontent-crt-c106="" class="highlight-div-header-left"><div _ngcontent-crt-c106="" class="handle-button expand-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-crt-c106="" class="highlight-div-header-right"><div _ngcontent-crt-c106="" class="handle-button ai-button"></div><div _ngcontent-crt-c106="" class="handle-button line-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-crt-c106="" class="handle-button theme-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-crt-c106="" class="handle-button copy-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-crt-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" codehub="https://gitee.com/harmonyos_samples/avcodec-buffer-mode/blob/master/entry/src/main/cpp/sample/transcoding/Transcoding.cpp#L74-L91" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-function"><span class="hljs-type">int32_t</span> <span class="hljs-title">Transcoding::InitDecoder</span><span class="hljs-params">()</span> </span>{</li><li>    <span class="hljs-built_in">CHECK_AND_RETURN_RET_LOG</span>(!isStarted_, AVCODEC_SAMPLE_ERR_ERROR, <span class="hljs-string">"Already started."</span>);</li><li>    <span class="hljs-built_in">CHECK_AND_RETURN_RET_LOG</span>(demuxer_ == <span class="hljs-literal">nullptr</span> &amp;&amp; videoDecoder_ == <span class="hljs-literal">nullptr</span>,</li><li>                             AVCODEC_SAMPLE_ERR_ERROR, <span class="hljs-string">"Already started."</span>);</li><li>
</li><li>    videoDecoder_ = std::<span class="hljs-built_in">make_unique</span>&lt;VideoDecoder&gt;();</li><li>    demuxer_ = std::<span class="hljs-built_in">make_unique</span>&lt;Demuxer&gt;();</li><li>
</li><li>    isReleased_ = <span class="hljs-literal">false</span>;</li><li>    <span class="hljs-type">int32_t</span> ret = demuxer_-&gt;<span class="hljs-built_in">Create</span>(sampleInfo_);</li><li>
</li><li>    <span class="hljs-keyword">if</span> (ret == AVCODEC_SAMPLE_ERR_OK) {</li><li>        ret = <span class="hljs-built_in">CreateVideoDecoder</span>();</li><li>    } <span class="hljs-keyword">else</span> {</li><li>        <span class="hljs-built_in">AVCODEC_SAMPLE_LOGE</span>(<span class="hljs-string">"Create audio decoder failed"</span>);</li><li>    }</li><li>    <span class="hljs-keyword">return</span> ret;</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/avcodec-buffer-mode/blob/master/entry/src/main/cpp/sample/transcoding/Transcoding.cpp#L74-L91" target="_blank">Transcoding.cpp</a></div></div></div></div> </li><li>创建解封装器。在创建解封装器时，需要根据需要解码的视频文件fd创建对应的OH_AVSource对象，再根据该对象创建对应的解码器。<div class="screenLinkPre"><div _ngcontent-crt-c106="" class="highlight-div"><div _ngcontent-crt-c106="" class="highlight-div-header"><div _ngcontent-crt-c106="" class="highlight-div-header-left"><div _ngcontent-crt-c106="" class="handle-button expand-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-crt-c106="" class="highlight-div-header-right"><div _ngcontent-crt-c106="" class="handle-button ai-button"></div><div _ngcontent-crt-c106="" class="handle-button line-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-crt-c106="" class="handle-button theme-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-crt-c106="" class="handle-button copy-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-crt-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" codehub="https://gitee.com/harmonyos_samples/avcodec-buffer-mode/blob/master/entry/src/main/cpp/capbilities/Demuxer.cpp#L24-L40" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-function"><span class="hljs-type">int32_t</span> <span class="hljs-title">Demuxer::Create</span><span class="hljs-params">(SampleInfo &amp;info)</span> </span>{</li><li>    source_ = <span class="hljs-built_in">OH_AVSource_CreateWithFD</span>(info.inputFd, info.inputFileOffset, info.inputFileSize);</li><li>    <span class="hljs-built_in">CHECK_AND_RETURN_RET_LOG</span>(source_ != <span class="hljs-literal">nullptr</span>, AVCODEC_SAMPLE_ERR_ERROR,</li><li>                             <span class="hljs-string">"Create demuxer source failed, fd: %{public}d, offset: %{public}"</span> PRId64</li><li>                             <span class="hljs-string">", file size: %{public}"</span> PRId64,</li><li>                             info.inputFd, info.inputFileOffset, info.inputFileSize);</li><li>    demuxer_ = <span class="hljs-built_in">OH_AVDemuxer_CreateWithSource</span>(source_);</li><li>    <span class="hljs-built_in">CHECK_AND_RETURN_RET_LOG</span>(demuxer_ != <span class="hljs-literal">nullptr</span>, AVCODEC_SAMPLE_ERR_ERROR, <span class="hljs-string">"Create demuxer failed"</span>);</li><li>
</li><li>    <span class="hljs-keyword">auto</span> sourceFormat = std::<span class="hljs-built_in">shared_ptr</span>&lt;OH_AVFormat&gt;(<span class="hljs-built_in">OH_AVSource_GetSourceFormat</span>(source_), OH_AVFormat_Destroy);</li><li>    <span class="hljs-built_in">CHECK_AND_RETURN_RET_LOG</span>(sourceFormat != <span class="hljs-literal">nullptr</span>, AVCODEC_SAMPLE_ERR_ERROR, <span class="hljs-string">"Get source format failed"</span>);</li><li>
</li><li>    <span class="hljs-type">int32_t</span> ret = <span class="hljs-built_in">GetTrackInfo</span>(sourceFormat, info);</li><li>    <span class="hljs-built_in">CHECK_AND_RETURN_RET_LOG</span>(ret == AVCODEC_SAMPLE_ERR_OK, AVCODEC_SAMPLE_ERR_ERROR, <span class="hljs-string">"Get video track info failed"</span>);</li><li>
</li><li>    <span class="hljs-keyword">return</span> AVCODEC_SAMPLE_ERR_OK;</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/avcodec-buffer-mode/blob/master/entry/src/main/cpp/capbilities/Demuxer.cpp#L24-L40" target="_blank">Demuxer.cpp</a></div></div></div></div> </li><li>创建完解封装器后，可以通过解封装器获取视频对应的参数，如视频的宽高、帧率等信息。<div class="screenLinkPre"><div _ngcontent-crt-c106="" class="highlight-div"><div _ngcontent-crt-c106="" class="highlight-div-header"><div _ngcontent-crt-c106="" class="highlight-div-header-left"><div _ngcontent-crt-c106="" class="handle-button expand-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-crt-c106="" class="highlight-div-header-right"><div _ngcontent-crt-c106="" class="handle-button ai-button"></div><div _ngcontent-crt-c106="" class="handle-button line-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-crt-c106="" class="handle-button theme-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-crt-c106="" class="handle-button copy-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-crt-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" codehub="https://gitee.com/harmonyos_samples/avcodec-buffer-mode/blob/master/entry/src/main/cpp/capbilities/Demuxer.cpp#L65-L126" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-function"><span class="hljs-type">int32_t</span> <span class="hljs-title">Demuxer::GetTrackInfo</span><span class="hljs-params">(std::shared_ptr&lt;OH_AVFormat&gt; sourceFormat, SampleInfo &amp;info)</span> </span>{</li><li>    <span class="hljs-type">int32_t</span> trackCount = <span class="hljs-number">0</span>;</li><li>    <span class="hljs-built_in">OH_AVFormat_GetIntValue</span>(sourceFormat.<span class="hljs-built_in">get</span>(), OH_MD_KEY_TRACK_COUNT, &amp;trackCount);</li><li>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int32_t</span> index = <span class="hljs-number">0</span>; index &lt; trackCount; index++) {</li><li>        <span class="hljs-type">int</span> trackType = <span class="hljs-number">-1</span>;</li><li>        <span class="hljs-keyword">auto</span> trackFormat =</li><li>            std::<span class="hljs-built_in">shared_ptr</span>&lt;OH_AVFormat&gt;(<span class="hljs-built_in">OH_AVSource_GetTrackFormat</span>(source_, index), OH_AVFormat_Destroy);</li><li>        <span class="hljs-built_in">OH_AVFormat_GetIntValue</span>(trackFormat.<span class="hljs-built_in">get</span>(), OH_MD_KEY_TRACK_TYPE, &amp;trackType);</li><li>        <span class="hljs-keyword">if</span> (trackType == MEDIA_TYPE_VID) {</li><li>            <span class="hljs-built_in">OH_AVDemuxer_SelectTrackByID</span>(demuxer_, index);</li><li>            <span class="hljs-built_in">OH_AVFormat_GetIntValue</span>(trackFormat.<span class="hljs-built_in">get</span>(), OH_MD_KEY_WIDTH, &amp;info.videoWidth);</li><li>            <span class="hljs-built_in">OH_AVFormat_GetIntValue</span>(trackFormat.<span class="hljs-built_in">get</span>(), OH_MD_KEY_HEIGHT, &amp;info.videoHeight);</li><li>            <span class="hljs-built_in">OH_AVFormat_GetDoubleValue</span>(trackFormat.<span class="hljs-built_in">get</span>(), OH_MD_KEY_FRAME_RATE, &amp;info.frameRate);</li><li>            <span class="hljs-built_in">OH_AVFormat_GetLongValue</span>(trackFormat.<span class="hljs-built_in">get</span>(), OH_MD_KEY_BITRATE, &amp;info.bitrate);</li><li>            <span class="hljs-built_in">OH_AVFormat_GetIntValue</span>(trackFormat.<span class="hljs-built_in">get</span>(), OH_MD_KEY_ROTATION, &amp;info.rotation);</li><li>            <span class="hljs-type">char</span> *videoCodecMime;</li><li>            <span class="hljs-built_in">OH_AVFormat_GetStringValue</span>(trackFormat.<span class="hljs-built_in">get</span>(), OH_MD_KEY_CODEC_MIME,</li><li>                                       <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">char</span> <span class="hljs-type">const</span> **&gt;(&amp;videoCodecMime));</li><li>            info.videoCodecMime = videoCodecMime;</li><li>            <span class="hljs-built_in">OH_AVFormat_GetIntValue</span>(trackFormat.<span class="hljs-built_in">get</span>(), OH_MD_KEY_PROFILE, &amp;info.hevcProfile);</li><li>            videoTrackId_ = index;</li><li>
</li><li>            <span class="hljs-built_in">AVCODEC_SAMPLE_LOGI</span>(<span class="hljs-string">"====== Demuxer Video config ======"</span>);</li><li>            <span class="hljs-built_in">AVCODEC_SAMPLE_LOGI</span>(<span class="hljs-string">"Mime: %{public}s"</span>, videoCodecMime);</li><li>            <span class="hljs-built_in">AVCODEC_SAMPLE_LOGI</span>(<span class="hljs-string">"%{public}d*%{public}d, %{public}.1ffps, %{public}"</span> PRId64 <span class="hljs-string">"kbps"</span>, info.videoWidth,</li><li>                                info.videoHeight, info.frameRate, info.bitrate / <span class="hljs-number">1024</span>);</li><li>            <span class="hljs-built_in">AVCODEC_SAMPLE_LOGI</span>(<span class="hljs-string">"====== Demuxer Video config ======"</span>);</li><li>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (trackType == MEDIA_TYPE_AUD) {</li><li>            <span class="hljs-built_in">OH_AVDemuxer_SelectTrackByID</span>(demuxer_, index);</li><li>            <span class="hljs-built_in">OH_AVFormat_GetIntValue</span>(trackFormat.<span class="hljs-built_in">get</span>(), OH_MD_KEY_AUDIO_SAMPLE_FORMAT, &amp;info.audioSampleForamt);</li><li>            <span class="hljs-built_in">OH_AVFormat_GetIntValue</span>(trackFormat.<span class="hljs-built_in">get</span>(), OH_MD_KEY_AUD_CHANNEL_COUNT, &amp;info.audioChannelCount);</li><li>            <span class="hljs-built_in">OH_AVFormat_GetLongValue</span>(trackFormat.<span class="hljs-built_in">get</span>(), OH_MD_KEY_CHANNEL_LAYOUT, &amp;info.audioChannelLayout);</li><li>            <span class="hljs-built_in">OH_AVFormat_GetIntValue</span>(trackFormat.<span class="hljs-built_in">get</span>(), OH_MD_KEY_AUD_SAMPLE_RATE, &amp;info.audioSampleRate);</li><li>            <span class="hljs-type">char</span> *audioCodecMime;</li><li>            <span class="hljs-built_in">OH_AVFormat_GetStringValue</span>(trackFormat.<span class="hljs-built_in">get</span>(), OH_MD_KEY_CODEC_MIME,</li><li>                                       <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">char</span> <span class="hljs-type">const</span> **&gt;(&amp;audioCodecMime));</li><li>            <span class="hljs-type">uint8_t</span> *codecConfig = <span class="hljs-literal">nullptr</span>;</li><li>            <span class="hljs-built_in">OH_AVFormat_GetBuffer</span>(trackFormat.<span class="hljs-built_in">get</span>(), OH_MD_KEY_CODEC_CONFIG, &amp;codecConfig, &amp;info.codecConfigLen);</li><li>            <span class="hljs-keyword">if</span> (info.codecConfigLen &gt; <span class="hljs-number">0</span> &amp;&amp; info.codecConfigLen &lt; <span class="hljs-built_in">sizeof</span>(info.codecConfig)) {</li><li>                <span class="hljs-built_in">memcpy</span>(info.codecConfig, codecConfig, info.codecConfigLen);</li><li>                <span class="hljs-built_in">AVCODEC_SAMPLE_LOGI</span>(</li><li>                    <span class="hljs-string">"codecConfig:%{public}p, len:%{public}i, 0:0x%{public}02x 1:0x:%{public}02x, bufLen:%{public}u"</span>,</li><li>                    info.codecConfig, (<span class="hljs-type">int</span>)info.codecConfigLen, info.codecConfig[<span class="hljs-number">0</span>], info.codecConfig[<span class="hljs-number">1</span>],</li><li>                    <span class="hljs-built_in">sizeof</span>(info.codecConfig));</li><li>            }</li><li>            <span class="hljs-built_in">OH_AVFormat_GetIntValue</span>(trackFormat.<span class="hljs-built_in">get</span>(), OH_MD_KEY_AAC_IS_ADTS, &amp;info.aacAdts);</li><li>            </li><li>            info.audioCodecMime = audioCodecMime;</li><li>            audioTrackId_ = index;</li><li>
</li><li>            <span class="hljs-built_in">AVCODEC_SAMPLE_LOGI</span>(<span class="hljs-string">"====== Demuxer Audio config ======"</span>);</li><li>            <span class="hljs-built_in">AVCODEC_SAMPLE_LOGI</span>(</li><li>                <span class="hljs-string">"audioMime:%{public}s sampleForamt:%{public}d "</span></li><li>                <span class="hljs-string">"sampleRate:%{public}d channelCount:%{public}d channelLayout:%{public}d adts:%{public}i"</span>,</li><li>                info.audioCodecMime.<span class="hljs-built_in">c_str</span>(), info.audioSampleForamt, info.audioSampleRate, info.audioChannelCount,</li><li>                info.audioChannelLayout, info.aacAdts);</li><li>            <span class="hljs-built_in">AVCODEC_SAMPLE_LOGI</span>(<span class="hljs-string">"====== Demuxer Audio config ======"</span>);</li><li>        }</li><li>    }</li><li>
</li><li>    <span class="hljs-keyword">return</span> AVCODEC_SAMPLE_ERR_OK;</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/avcodec-buffer-mode/blob/master/entry/src/main/cpp/capbilities/Demuxer.cpp#L65-L126" target="_blank">Demuxer.cpp</a></div></div></div></div> </li><li>创建视频解码器。<div class="screenLinkPre"><div _ngcontent-crt-c106="" class="highlight-div"><div _ngcontent-crt-c106="" class="highlight-div-header"><div _ngcontent-crt-c106="" class="highlight-div-header-left"><div _ngcontent-crt-c106="" class="handle-button expand-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-crt-c106="" class="highlight-div-header-right"><div _ngcontent-crt-c106="" class="handle-button ai-button"></div><div _ngcontent-crt-c106="" class="handle-button line-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-crt-c106="" class="handle-button theme-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-crt-c106="" class="handle-button copy-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-crt-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" codehub="https://gitee.com/harmonyos_samples/avcodec-buffer-mode/blob/master/entry/src/main/cpp/sample/transcoding/Transcoding.cpp#L34-L45" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-function"><span class="hljs-type">int32_t</span> <span class="hljs-title">Transcoding::CreateVideoDecoder</span><span class="hljs-params">()</span> </span>{</li><li>    <span class="hljs-built_in">AVCODEC_SAMPLE_LOGW</span>(<span class="hljs-string">"video mime:%{public}s"</span>, sampleInfo_.videoCodecMime.<span class="hljs-built_in">c_str</span>());</li><li>    <span class="hljs-type">int32_t</span> ret = videoDecoder_-&gt;<span class="hljs-built_in">Create</span>(sampleInfo_.videoCodecMime);</li><li>    <span class="hljs-keyword">if</span> (ret != AVCODEC_SAMPLE_ERR_OK) {</li><li>        <span class="hljs-built_in">AVCODEC_SAMPLE_LOGW</span>(<span class="hljs-string">"Create video decoder failed, mime:%{public}s"</span>, sampleInfo_.videoCodecMime.<span class="hljs-built_in">c_str</span>());</li><li>    } <span class="hljs-keyword">else</span> {</li><li>        videoDecContext_ = <span class="hljs-keyword">new</span> CodecUserData;</li><li>        ret = videoDecoder_-&gt;<span class="hljs-built_in">Config</span>(sampleInfo_, videoDecContext_);</li><li>        <span class="hljs-built_in">CHECK_AND_RETURN_RET_LOG</span>(ret == AVCODEC_SAMPLE_ERR_OK, ret, <span class="hljs-string">"Video Decoder config failed"</span>);</li><li>    }</li><li>    <span class="hljs-keyword">return</span> AVCODEC_SAMPLE_ERR_OK;</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/avcodec-buffer-mode/blob/master/entry/src/main/cpp/sample/transcoding/Transcoding.cpp#L34-L45" target="_blank">Transcoding.cpp</a></div></div></div></div> </li><li>配置视频解码器，包括视频的宽、高、分辨率等基础信息和解码器的回调函数。<div class="screenLinkPre"><div _ngcontent-crt-c106="" class="highlight-div"><div _ngcontent-crt-c106="" class="highlight-div-header"><div _ngcontent-crt-c106="" class="highlight-div-header-left"><div _ngcontent-crt-c106="" class="handle-button expand-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-crt-c106="" class="highlight-div-header-right"><div _ngcontent-crt-c106="" class="handle-button ai-button"></div><div _ngcontent-crt-c106="" class="handle-button line-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-crt-c106="" class="handle-button theme-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-crt-c106="" class="handle-button copy-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-crt-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" codehub="https://gitee.com/harmonyos_samples/avcodec-buffer-mode/blob/master/entry/src/main/cpp/capbilities/VideoDecoder.cpp#L36-L87" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// Setting the callback function</span></li><li><span class="hljs-function"><span class="hljs-type">int32_t</span> <span class="hljs-title">VideoDecoder::SetCallback</span><span class="hljs-params">(CodecUserData *codecUserData)</span> </span>{</li><li>    <span class="hljs-type">int32_t</span> ret = AV_ERR_OK;</li><li>    ret = <span class="hljs-built_in">OH_VideoDecoder_RegisterCallback</span>(decoder_,</li><li>                                           {SampleCallback::OnCodecError, SampleCallback::OnCodecFormatChange,</li><li>                                            SampleCallback::OnNeedInputBuffer, SampleCallback::OnNewOutputBuffer},</li><li>                                           codecUserData);</li><li>    <span class="hljs-built_in">CHECK_AND_RETURN_RET_LOG</span>(ret == AV_ERR_OK, AVCODEC_SAMPLE_ERR_ERROR, <span class="hljs-string">"Set callback failed, ret: %{public}d"</span>, ret);</li><li>
</li><li>    <span class="hljs-keyword">return</span> AVCODEC_SAMPLE_ERR_OK;</li><li>}</li><li>
</li><li><span class="hljs-function"><span class="hljs-type">int32_t</span> <span class="hljs-title">VideoDecoder::Configure</span><span class="hljs-params">(<span class="hljs-type">const</span> SampleInfo &amp;sampleInfo)</span> </span>{</li><li>    OH_AVFormat *format = <span class="hljs-built_in">OH_AVFormat_Create</span>();</li><li>    <span class="hljs-built_in">CHECK_AND_RETURN_RET_LOG</span>(format != <span class="hljs-literal">nullptr</span>, AVCODEC_SAMPLE_ERR_ERROR, <span class="hljs-string">"AVFormat create failed"</span>);</li><li>
</li><li>    <span class="hljs-built_in">OH_AVFormat_SetIntValue</span>(format, OH_MD_KEY_WIDTH, sampleInfo.videoWidth);</li><li>    <span class="hljs-built_in">OH_AVFormat_SetIntValue</span>(format, OH_MD_KEY_HEIGHT, sampleInfo.videoHeight);</li><li>    <span class="hljs-built_in">OH_AVFormat_SetDoubleValue</span>(format, OH_MD_KEY_FRAME_RATE, sampleInfo.frameRate);</li><li>    <span class="hljs-built_in">OH_AVFormat_SetIntValue</span>(format, OH_MD_KEY_PIXEL_FORMAT, sampleInfo.pixelFormat);</li><li>    <span class="hljs-built_in">OH_AVFormat_SetIntValue</span>(format, OH_MD_KEY_ROTATION, sampleInfo.rotation);</li><li>
</li><li>    <span class="hljs-built_in">AVCODEC_SAMPLE_LOGI</span>(<span class="hljs-string">"====== VideoDecoder config ======"</span>);</li><li>    <span class="hljs-built_in">AVCODEC_SAMPLE_LOGI</span>(<span class="hljs-string">"%{public}d*%{public}d, %{public}.1ffps"</span>, sampleInfo.videoWidth, sampleInfo.videoHeight,</li><li>                        sampleInfo.frameRate);</li><li>    <span class="hljs-built_in">AVCODEC_SAMPLE_LOGI</span>(<span class="hljs-string">"====== VideoDecoder config ======"</span>);</li><li>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">OH_VideoDecoder_Configure</span>(decoder_, format);</li><li>    <span class="hljs-built_in">OH_AVFormat_Destroy</span>(format);</li><li>    format = <span class="hljs-literal">nullptr</span>;</li><li>    <span class="hljs-built_in">CHECK_AND_RETURN_RET_LOG</span>(ret == AV_ERR_OK, AVCODEC_SAMPLE_ERR_ERROR, <span class="hljs-string">"Config failed, ret: %{public}d"</span>, ret);</li><li>    <span class="hljs-keyword">return</span> AVCODEC_SAMPLE_ERR_OK;</li><li>}</li><li>
</li><li><span class="hljs-function"><span class="hljs-type">int32_t</span> <span class="hljs-title">VideoDecoder::Config</span><span class="hljs-params">(<span class="hljs-type">const</span> SampleInfo &amp;sampleInfo, CodecUserData *codecUserData)</span> </span>{</li><li>    <span class="hljs-built_in">CHECK_AND_RETURN_RET_LOG</span>(decoder_ != <span class="hljs-literal">nullptr</span>, AVCODEC_SAMPLE_ERR_ERROR, <span class="hljs-string">"Decoder is null"</span>);</li><li>    <span class="hljs-built_in">CHECK_AND_RETURN_RET_LOG</span>(codecUserData != <span class="hljs-literal">nullptr</span>, AVCODEC_SAMPLE_ERR_ERROR, <span class="hljs-string">"Invalid param: codecUserData"</span>);</li><li>
</li><li>    <span class="hljs-comment">// Configure video decoder</span></li><li>    <span class="hljs-type">int32_t</span> ret = <span class="hljs-built_in">Configure</span>(sampleInfo);</li><li>    <span class="hljs-built_in">CHECK_AND_RETURN_RET_LOG</span>(ret == AVCODEC_SAMPLE_ERR_OK, AVCODEC_SAMPLE_ERR_ERROR, <span class="hljs-string">"Configure failed"</span>);</li><li>    </li><li>    <span class="hljs-comment">// SetCallback for video decoder</span></li><li>    ret = <span class="hljs-built_in">SetCallback</span>(codecUserData);</li><li>    <span class="hljs-built_in">CHECK_AND_RETURN_RET_LOG</span>(ret == AVCODEC_SAMPLE_ERR_OK, AVCODEC_SAMPLE_ERR_ERROR,</li><li>                             <span class="hljs-string">"Set callback failed, ret: %{public}d"</span>, ret);</li><li>
</li><li>    <span class="hljs-comment">// Prepare video decoder</span></li><li>    ret = <span class="hljs-built_in">OH_VideoDecoder_Prepare</span>(decoder_);</li><li>    <span class="hljs-built_in">CHECK_AND_RETURN_RET_LOG</span>(ret == AV_ERR_OK, AVCODEC_SAMPLE_ERR_ERROR, <span class="hljs-string">"Prepare failed, ret: %{public}d"</span>, ret);</li><li>
</li><li>    <span class="hljs-keyword">return</span> AVCODEC_SAMPLE_ERR_OK;</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/avcodec-buffer-mode/blob/master/entry/src/main/cpp/capbilities/VideoDecoder.cpp#L36-L87" target="_blank">VideoDecoder.cpp</a></div></div></div></div> </li><li>初始化视频编码环境，包括创建配置视频编码器、视频封装器。<div class="screenLinkPre"><div _ngcontent-crt-c106="" class="highlight-div"><div _ngcontent-crt-c106="" class="highlight-div-header"><div _ngcontent-crt-c106="" class="highlight-div-header-left"><div _ngcontent-crt-c106="" class="handle-button expand-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-crt-c106="" class="highlight-div-header-right"><div _ngcontent-crt-c106="" class="handle-button ai-button"></div><div _ngcontent-crt-c106="" class="handle-button line-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-crt-c106="" class="handle-button theme-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-crt-c106="" class="handle-button copy-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-crt-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" codehub="https://gitee.com/harmonyos_samples/avcodec-buffer-mode/blob/master/entry/src/main/cpp/sample/transcoding/Transcoding.cpp#L106-L126" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-function"><span class="hljs-type">int32_t</span> <span class="hljs-title">Transcoding::InitEncoder</span><span class="hljs-params">()</span> </span>{</li><li>    <span class="hljs-built_in">CHECK_AND_RETURN_RET_LOG</span>(!isStarted_, AVCODEC_SAMPLE_ERR_ERROR, <span class="hljs-string">"Already started."</span>);</li><li>    <span class="hljs-built_in">CHECK_AND_RETURN_RET_LOG</span>(muxer_ == <span class="hljs-literal">nullptr</span> &amp;&amp; videoEncoder_ == <span class="hljs-literal">nullptr</span>,</li><li>                             AVCODEC_SAMPLE_ERR_ERROR, <span class="hljs-string">"Already started."</span>);</li><li>    </li><li>    videoEncoder_ = std::<span class="hljs-built_in">make_unique</span>&lt;VideoEncoder&gt;();</li><li>    muxer_ = std::<span class="hljs-built_in">make_unique</span>&lt;Muxer&gt;();</li><li>    </li><li>    <span class="hljs-type">int32_t</span> ret = muxer_-&gt;<span class="hljs-built_in">Create</span>(sampleInfo_.outputFd);</li><li>    <span class="hljs-built_in">CHECK_AND_RETURN_RET_LOG</span>(ret == AVCODEC_SAMPLE_ERR_OK, ret, <span class="hljs-string">"Create muxer with fd(%{public}d) failed"</span>,</li><li>                             sampleInfo_.outputFd);</li><li>    ret = muxer_-&gt;<span class="hljs-built_in">Config</span>(sampleInfo_);</li><li>    </li><li>    <span class="hljs-built_in">CHECK_AND_RETURN_RET_LOG</span>(ret == AVCODEC_SAMPLE_ERR_OK, ret, <span class="hljs-string">"Create audio encoder failed"</span>);</li><li>
</li><li>    ret = <span class="hljs-built_in">CreateVideoEncoder</span>();</li><li>    <span class="hljs-built_in">CHECK_AND_RETURN_RET_LOG</span>(ret == AVCODEC_SAMPLE_ERR_OK, ret, <span class="hljs-string">"Create video encoder failed"</span>);</li><li>    </li><li>    <span class="hljs-built_in">AVCODEC_SAMPLE_LOGI</span>(<span class="hljs-string">"Succeed"</span>);</li><li>    <span class="hljs-keyword">return</span> AVCODEC_SAMPLE_ERR_OK;</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/avcodec-buffer-mode/blob/master/entry/src/main/cpp/sample/transcoding/Transcoding.cpp#L106-L126" target="_blank">Transcoding.cpp</a></div></div></div></div> </li><li>创建视频编码器。<div class="screenLinkPre"><div _ngcontent-crt-c106="" class="highlight-div"><div _ngcontent-crt-c106="" class="highlight-div-header"><div _ngcontent-crt-c106="" class="highlight-div-header-left"><div _ngcontent-crt-c106="" class="handle-button expand-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-crt-c106="" class="highlight-div-header-right"><div _ngcontent-crt-c106="" class="handle-button ai-button"></div><div _ngcontent-crt-c106="" class="handle-button line-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-crt-c106="" class="handle-button theme-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-crt-c106="" class="handle-button copy-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-crt-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" codehub="https://gitee.com/harmonyos_samples/avcodec-buffer-mode/blob/master/entry/src/main/cpp/capbilities/VideoEncoder.cpp#L24-L29" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// Create a video coder and initialize it</span></li><li><span class="hljs-function"><span class="hljs-type">int32_t</span> <span class="hljs-title">VideoEncoder::Create</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;videoCodecMime)</span> </span>{</li><li>    encoder_ = <span class="hljs-built_in">OH_VideoEncoder_CreateByMime</span>(videoCodecMime.<span class="hljs-built_in">c_str</span>());</li><li>    <span class="hljs-built_in">CHECK_AND_RETURN_RET_LOG</span>(encoder_ != <span class="hljs-literal">nullptr</span>, AVCODEC_SAMPLE_ERR_ERROR, <span class="hljs-string">"Create failed"</span>);</li><li>    <span class="hljs-keyword">return</span> AVCODEC_SAMPLE_ERR_OK;</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/avcodec-buffer-mode/blob/master/entry/src/main/cpp/capbilities/VideoEncoder.cpp#L24-L29" target="_blank">VideoEncoder.cpp</a></div></div></div></div> </li><li>配置视频编码器。<div class="screenLinkPre"><div _ngcontent-crt-c106="" class="highlight-div"><div _ngcontent-crt-c106="" class="highlight-div-header"><div _ngcontent-crt-c106="" class="highlight-div-header-left"><div _ngcontent-crt-c106="" class="handle-button expand-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-crt-c106="" class="highlight-div-header-right"><div _ngcontent-crt-c106="" class="handle-button ai-button"></div><div _ngcontent-crt-c106="" class="handle-button line-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-crt-c106="" class="handle-button theme-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-crt-c106="" class="handle-button copy-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-crt-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" codehub="https://gitee.com/harmonyos_samples/avcodec-buffer-mode/blob/master/entry/src/main/cpp/capbilities/VideoEncoder.cpp#L33-L147" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-function"><span class="hljs-type">int32_t</span> <span class="hljs-title">VideoEncoder::Config</span><span class="hljs-params">(SampleInfo &amp;sampleInfo, CodecUserData *codecUserData)</span> </span>{</li><li>    <span class="hljs-built_in">CHECK_AND_RETURN_RET_LOG</span>(encoder_ != <span class="hljs-literal">nullptr</span>, AVCODEC_SAMPLE_ERR_ERROR, <span class="hljs-string">"Encoder is null"</span>);</li><li>    <span class="hljs-built_in">CHECK_AND_RETURN_RET_LOG</span>(codecUserData != <span class="hljs-literal">nullptr</span>, AVCODEC_SAMPLE_ERR_ERROR, <span class="hljs-string">"Invalid param: codecUserData"</span>);</li><li>
</li><li>    <span class="hljs-comment">// Configure video encoder</span></li><li>    <span class="hljs-type">int32_t</span> ret = <span class="hljs-built_in">Configure</span>(sampleInfo);</li><li>    <span class="hljs-built_in">CHECK_AND_RETURN_RET_LOG</span>(ret == AVCODEC_SAMPLE_ERR_OK, AVCODEC_SAMPLE_ERR_ERROR, <span class="hljs-string">"Configure failed"</span>);</li><li>
</li><li>    <span class="hljs-comment">// SetCallback for video encoder</span></li><li>    ret = <span class="hljs-built_in">SetCallback</span>(codecUserData);</li><li>    <span class="hljs-built_in">CHECK_AND_RETURN_RET_LOG</span>(ret == AVCODEC_SAMPLE_ERR_OK, AVCODEC_SAMPLE_ERR_ERROR,</li><li>                             <span class="hljs-string">"Set callback failed, ret: %{public}d"</span>, ret);</li><li>
</li><li>    <span class="hljs-comment">// Prepare video encoder</span></li><li>    ret = <span class="hljs-built_in">OH_VideoEncoder_Prepare</span>(encoder_);</li><li>    <span class="hljs-built_in">CHECK_AND_RETURN_RET_LOG</span>(ret == AV_ERR_OK, AVCODEC_SAMPLE_ERR_ERROR, <span class="hljs-string">"Prepare failed, ret: %{public}d"</span>, ret);</li><li>
</li><li>    <span class="hljs-keyword">return</span> AVCODEC_SAMPLE_ERR_OK;</li><li>}</li><li>
</li><li><span class="hljs-comment">// ...</span></li><li>
</li><li><span class="hljs-function"><span class="hljs-type">int32_t</span> <span class="hljs-title">VideoEncoder::Configure</span><span class="hljs-params">(<span class="hljs-type">const</span> SampleInfo &amp;sampleInfo)</span> </span>{</li><li>    OH_AVFormat *format = <span class="hljs-built_in">OH_AVFormat_Create</span>();</li><li>    <span class="hljs-built_in">CHECK_AND_RETURN_RET_LOG</span>(format != <span class="hljs-literal">nullptr</span>, AVCODEC_SAMPLE_ERR_ERROR, <span class="hljs-string">"AVFormat create failed"</span>);</li><li>
</li><li>    <span class="hljs-built_in">OH_AVFormat_SetIntValue</span>(format, OH_MD_KEY_WIDTH, sampleInfo.videoWidth);</li><li>    <span class="hljs-built_in">OH_AVFormat_SetIntValue</span>(format, OH_MD_KEY_HEIGHT, sampleInfo.videoHeight);</li><li>    <span class="hljs-built_in">OH_AVFormat_SetDoubleValue</span>(format, OH_MD_KEY_FRAME_RATE, sampleInfo.outputFrameRate);</li><li>    <span class="hljs-built_in">OH_AVFormat_SetIntValue</span>(format, OH_MD_KEY_PIXEL_FORMAT, sampleInfo.pixelFormat);</li><li>    <span class="hljs-built_in">OH_AVFormat_SetIntValue</span>(format, OH_MD_KEY_VIDEO_ENCODE_BITRATE_MODE, sampleInfo.bitrateMode);</li><li>    <span class="hljs-built_in">OH_AVFormat_SetLongValue</span>(format, OH_MD_KEY_BITRATE, sampleInfo.outputBitrate);</li><li>    <span class="hljs-built_in">OH_AVFormat_SetIntValue</span>(format, OH_MD_KEY_PROFILE, sampleInfo.hevcProfile);</li><li>    <span class="hljs-comment">// Setting HDRVivid-related parameters</span></li><li>    <span class="hljs-keyword">if</span> (sampleInfo.isHDRVivid) {</li><li>        <span class="hljs-built_in">OH_AVFormat_SetIntValue</span>(format, OH_MD_KEY_I_FRAME_INTERVAL, sampleInfo.iFrameInterval);</li><li>        <span class="hljs-built_in">OH_AVFormat_SetIntValue</span>(format, OH_MD_KEY_RANGE_FLAG, sampleInfo.rangFlag);</li><li>        <span class="hljs-built_in">OH_AVFormat_SetIntValue</span>(format, OH_MD_KEY_COLOR_PRIMARIES, sampleInfo.primary);</li><li>        <span class="hljs-built_in">OH_AVFormat_SetIntValue</span>(format, OH_MD_KEY_TRANSFER_CHARACTERISTICS, sampleInfo.transfer);</li><li>        <span class="hljs-built_in">OH_AVFormat_SetIntValue</span>(format, OH_MD_KEY_MATRIX_COEFFICIENTS, sampleInfo.matrix);</li><li>    }</li><li>    <span class="hljs-built_in">AVCODEC_SAMPLE_LOGI</span>(<span class="hljs-string">"====== VideoEncoder config ======"</span>);</li><li>    <span class="hljs-built_in">AVCODEC_SAMPLE_LOGI</span>(<span class="hljs-string">"%{public}d*%{public}d, %{public}.1ffps"</span>, sampleInfo.videoWidth, sampleInfo.videoHeight,</li><li>                        sampleInfo.frameRate);</li><li>    <span class="hljs-comment">// 1024: ratio of kbps to bps</span></li><li>    <span class="hljs-built_in">AVCODEC_SAMPLE_LOGI</span>(<span class="hljs-string">"BitRate Mode: %{public}d, BitRate: %{public}"</span> PRId64 <span class="hljs-string">"kbps"</span>, sampleInfo.bitrateMode,</li><li>                        sampleInfo.bitrate / <span class="hljs-number">1024</span>);</li><li>    <span class="hljs-built_in">AVCODEC_SAMPLE_LOGI</span>(<span class="hljs-string">"====== VideoEncoder config ======"</span>);</li><li>    </li><li>    <span class="hljs-comment">// Setting the Encoder</span></li><li>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">OH_VideoEncoder_Configure</span>(encoder_, format);</li><li>    <span class="hljs-built_in">OH_AVFormat_Destroy</span>(format);</li><li>    format = <span class="hljs-literal">nullptr</span>;</li><li>    <span class="hljs-built_in">CHECK_AND_RETURN_RET_LOG</span>(ret == AV_ERR_OK, AVCODEC_SAMPLE_ERR_ERROR, <span class="hljs-string">"Config failed, ret: %{public}d"</span>, ret);</li><li>    <span class="hljs-keyword">return</span> AVCODEC_SAMPLE_ERR_OK;</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/avcodec-buffer-mode/blob/master/entry/src/main/cpp/capbilities/VideoEncoder.cpp#L33-L147" target="_blank">VideoEncoder.cpp</a></div></div></div></div> </li><li>配置视频封装器。在配置视频封装器时，需要设置视频封装的格式，包括视频宽高、帧率、编码格式等。<div class="screenLinkPre"><div _ngcontent-crt-c106="" class="highlight-div"><div _ngcontent-crt-c106="" class="highlight-div-header"><div _ngcontent-crt-c106="" class="highlight-div-header-left"><div _ngcontent-crt-c106="" class="handle-button expand-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-crt-c106="" class="highlight-div-header-right"><div _ngcontent-crt-c106="" class="handle-button ai-button"></div><div _ngcontent-crt-c106="" class="handle-button line-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-crt-c106="" class="handle-button theme-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-crt-c106="" class="handle-button copy-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-crt-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" codehub="https://gitee.com/harmonyos_samples/avcodec-buffer-mode/blob/master/entry/src/main/cpp/capbilities/Muxer.cpp#L37-L61" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-function"><span class="hljs-type">int32_t</span> <span class="hljs-title">Muxer::Config</span><span class="hljs-params">(SampleInfo &amp;sampleInfo)</span> </span>{</li><li>    <span class="hljs-built_in">CHECK_AND_RETURN_RET_LOG</span>(muxer_ != <span class="hljs-literal">nullptr</span>, AVCODEC_SAMPLE_ERR_ERROR, <span class="hljs-string">"Muxer is null"</span>);</li><li>    OH_AVFormat *formatVideo =</li><li>        <span class="hljs-built_in">OH_AVFormat_CreateVideoFormat</span>(sampleInfo.outputVideoCodecMime.<span class="hljs-built_in">data</span>(), sampleInfo.videoWidth, sampleInfo.videoHeight);</li><li>    <span class="hljs-built_in">CHECK_AND_RETURN_RET_LOG</span>(formatVideo != <span class="hljs-literal">nullptr</span>, AVCODEC_SAMPLE_ERR_ERROR, <span class="hljs-string">"Create video format failed"</span>);</li><li>
</li><li>    <span class="hljs-built_in">OH_AVFormat_SetDoubleValue</span>(formatVideo, OH_MD_KEY_FRAME_RATE, sampleInfo.outputFrameRate);</li><li>    <span class="hljs-built_in">OH_AVFormat_SetIntValue</span>(formatVideo, OH_MD_KEY_WIDTH, sampleInfo.videoWidth);</li><li>    <span class="hljs-built_in">OH_AVFormat_SetIntValue</span>(formatVideo, OH_MD_KEY_HEIGHT, sampleInfo.videoHeight);</li><li>    <span class="hljs-built_in">OH_AVFormat_SetStringValue</span>(formatVideo, OH_MD_KEY_CODEC_MIME, sampleInfo.outputVideoCodecMime.<span class="hljs-built_in">data</span>());</li><li>    <span class="hljs-keyword">if</span> (sampleInfo.isHDRVivid) {</li><li>        <span class="hljs-built_in">OH_AVFormat_SetIntValue</span>(formatVideo, OH_MD_KEY_VIDEO_IS_HDR_VIVID, <span class="hljs-number">1</span>);</li><li>        <span class="hljs-built_in">OH_AVFormat_SetIntValue</span>(formatVideo, OH_MD_KEY_RANGE_FLAG, sampleInfo.rangFlag);</li><li>        <span class="hljs-built_in">OH_AVFormat_SetIntValue</span>(formatVideo, OH_MD_KEY_COLOR_PRIMARIES, sampleInfo.primary);</li><li>        <span class="hljs-built_in">OH_AVFormat_SetIntValue</span>(formatVideo, OH_MD_KEY_TRANSFER_CHARACTERISTICS, sampleInfo.transfer);</li><li>        <span class="hljs-built_in">OH_AVFormat_SetIntValue</span>(formatVideo, OH_MD_KEY_MATRIX_COEFFICIENTS, sampleInfo.matrix);</li><li>    }</li><li>
</li><li>    <span class="hljs-type">int32_t</span> ret = <span class="hljs-built_in">OH_AVMuxer_AddTrack</span>(muxer_, &amp;videoTrackId_, formatVideo);</li><li>    <span class="hljs-built_in">OH_AVFormat_Destroy</span>(formatVideo);</li><li>    formatVideo = <span class="hljs-literal">nullptr</span>;</li><li>    <span class="hljs-built_in">OH_AVMuxer_SetRotation</span>(muxer_, sampleInfo.rotation);</li><li>    <span class="hljs-built_in">CHECK_AND_RETURN_RET_LOG</span>(ret == AV_ERR_OK, AVCODEC_SAMPLE_ERR_ERROR, <span class="hljs-string">"AddTrack failed"</span>);</li><li>    <span class="hljs-keyword">return</span> AVCODEC_SAMPLE_ERR_OK;</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/avcodec-buffer-mode/blob/master/entry/src/main/cpp/capbilities/Muxer.cpp#L37-L61" target="_blank">Muxer.cpp</a></div></div></div></div> </li></ul> </li><li>视频文件解码。<ul><li>启动视频转码，包括视频解码输入缓存处理线程、输出缓存处理线程、编码输出缓存处理线程。<div class="screenLinkPre"><div _ngcontent-crt-c106="" class="highlight-div"><div _ngcontent-crt-c106="" class="highlight-div-header"><div _ngcontent-crt-c106="" class="highlight-div-header-left"><div _ngcontent-crt-c106="" class="handle-button expand-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-crt-c106="" class="highlight-div-header-right"><div _ngcontent-crt-c106="" class="handle-button ai-button"></div><div _ngcontent-crt-c106="" class="handle-button line-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-crt-c106="" class="handle-button theme-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-crt-c106="" class="handle-button copy-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-crt-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" codehub="https://gitee.com/harmonyos_samples/avcodec-buffer-mode/blob/master/entry/src/main/cpp/sample/transcoding/Transcoding.cpp#L132-L175" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-function"><span class="hljs-type">int32_t</span> <span class="hljs-title">Transcoding::Start</span><span class="hljs-params">()</span> </span>{</li><li>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;</li><li>    <span class="hljs-type">int32_t</span> ret;</li><li>    <span class="hljs-built_in">CHECK_AND_RETURN_RET_LOG</span>(!isStarted_, AVCODEC_SAMPLE_ERR_ERROR, <span class="hljs-string">"Already started."</span>);</li><li>    <span class="hljs-built_in">CHECK_AND_RETURN_RET_LOG</span>(demuxer_ != <span class="hljs-literal">nullptr</span>, AVCODEC_SAMPLE_ERR_ERROR, <span class="hljs-string">"Already started."</span>);</li><li>    <span class="hljs-keyword">if</span> (videoDecContext_) {</li><li>        ret = videoDecoder_-&gt;<span class="hljs-built_in">Start</span>();</li><li>        <span class="hljs-keyword">if</span> (ret != AVCODEC_SAMPLE_ERR_OK) {</li><li>            <span class="hljs-built_in">AVCODEC_SAMPLE_LOGE</span>(<span class="hljs-string">"Video Decoder start failed"</span>);</li><li>            lock.<span class="hljs-built_in">unlock</span>();</li><li>            <span class="hljs-built_in">StartRelease</span>();</li><li>            <span class="hljs-keyword">return</span> AVCODEC_SAMPLE_ERR_ERROR;</li><li>        }</li><li>        isStarted_ = <span class="hljs-literal">true</span>;</li><li>        videoDecInputThread_ = std::<span class="hljs-built_in">make_unique</span>&lt;std::thread&gt;(&amp;Transcoding::VideoDecInputThread, <span class="hljs-keyword">this</span>);</li><li>        videoDecOutputThread_ = std::<span class="hljs-built_in">make_unique</span>&lt;std::thread&gt;(&amp;Transcoding::VideoDecOutputThread, <span class="hljs-keyword">this</span>);</li><li>
</li><li>        <span class="hljs-keyword">if</span> (videoDecInputThread_ == <span class="hljs-literal">nullptr</span> || videoDecOutputThread_ == <span class="hljs-literal">nullptr</span>) {</li><li>            <span class="hljs-built_in">AVCODEC_SAMPLE_LOGE</span>(<span class="hljs-string">"Create thread failed"</span>);</li><li>            lock.<span class="hljs-built_in">unlock</span>();</li><li>            <span class="hljs-built_in">StartRelease</span>();</li><li>            <span class="hljs-keyword">return</span> AVCODEC_SAMPLE_ERR_ERROR;</li><li>        }</li><li>    }</li><li>
</li><li>    <span class="hljs-keyword">if</span> (videoEncContext_) {</li><li>        <span class="hljs-built_in">CHECK_AND_RETURN_RET_LOG</span>(videoEncoder_ != <span class="hljs-literal">nullptr</span> &amp;&amp; muxer_ != <span class="hljs-literal">nullptr</span>, AVCODEC_SAMPLE_ERR_ERROR,</li><li>                                 <span class="hljs-string">"Already started."</span>);</li><li>        <span class="hljs-type">int32_t</span> ret = muxer_-&gt;<span class="hljs-built_in">Start</span>();</li><li>        <span class="hljs-built_in">CHECK_AND_RETURN_RET_LOG</span>(ret == AVCODEC_SAMPLE_ERR_OK, ret, <span class="hljs-string">"Muxer start failed"</span>);</li><li>        ret = videoEncoder_-&gt;<span class="hljs-built_in">Start</span>();</li><li>        <span class="hljs-built_in">CHECK_AND_RETURN_RET_LOG</span>(ret == AVCODEC_SAMPLE_ERR_OK, ret, <span class="hljs-string">"Encoder start failed"</span>);</li><li>        videoEncOutputThread_ = std::<span class="hljs-built_in">make_unique</span>&lt;std::thread&gt;(&amp;Transcoding::VideoEncOutputThread, <span class="hljs-keyword">this</span>);</li><li>        <span class="hljs-keyword">if</span> (videoEncOutputThread_ == <span class="hljs-literal">nullptr</span>) {</li><li>            <span class="hljs-built_in">AVCODEC_SAMPLE_LOGE</span>(<span class="hljs-string">"Create thread failed"</span>);</li><li>            <span class="hljs-built_in">StartRelease</span>();</li><li>            <span class="hljs-keyword">return</span> AVCODEC_SAMPLE_ERR_ERROR;</li><li>        }</li><li>    }</li><li>    </li><li>    <span class="hljs-built_in">AVCODEC_SAMPLE_LOGI</span>(<span class="hljs-string">"Succeed"</span>);</li><li>    doneCond_.<span class="hljs-built_in">notify_all</span>();</li><li>    <span class="hljs-keyword">return</span> AVCODEC_SAMPLE_ERR_OK;</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/avcodec-buffer-mode/blob/master/entry/src/main/cpp/sample/transcoding/Transcoding.cpp#L132-L175" target="_blank">Transcoding.cpp</a></div></div></div></div> </li><li>视频解码输入缓存处理。<div class="screenLinkPre"><div _ngcontent-crt-c106="" class="highlight-div"><div _ngcontent-crt-c106="" class="highlight-div-header"><div _ngcontent-crt-c106="" class="highlight-div-header-left"><div _ngcontent-crt-c106="" class="handle-button expand-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-crt-c106="" class="highlight-div-header-right"><div _ngcontent-crt-c106="" class="handle-button ai-button"></div><div _ngcontent-crt-c106="" class="handle-button line-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-crt-c106="" class="handle-button theme-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-crt-c106="" class="handle-button copy-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-crt-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" codehub="https://gitee.com/harmonyos_samples/avcodec-buffer-mode/blob/master/entry/src/main/cpp/sample/transcoding/Transcoding.cpp#L273-L297" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Transcoding::VideoDecInputThread</span><span class="hljs-params">()</span> </span>{</li><li>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {</li><li>        <span class="hljs-built_in">CHECK_AND_BREAK_LOG</span>(isStarted_, <span class="hljs-string">"Decoder input thread out"</span>);</li><li>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(videoDecContext_-&gt;inputMutex)</span></span>;</li><li>        <span class="hljs-type">bool</span> condRet = videoDecContext_-&gt;inputCond.<span class="hljs-built_in">wait_for</span>(</li><li>            lock, <span class="hljs-number">5</span>s, [<span class="hljs-keyword">this</span>]() { <span class="hljs-keyword">return</span> !isStarted_ || !videoDecContext_-&gt;inputBufferInfoQueue.<span class="hljs-built_in">empty</span>(); });</li><li>        <span class="hljs-built_in">CHECK_AND_BREAK_LOG</span>(isStarted_, <span class="hljs-string">"Work done, thread out"</span>);</li><li>        <span class="hljs-built_in">CHECK_AND_CONTINUE_LOG</span>(!videoDecContext_-&gt;inputBufferInfoQueue.<span class="hljs-built_in">empty</span>(),</li><li>                               <span class="hljs-string">"Buffer queue is empty, continue, cond ret: %{public}d"</span>, condRet);</li><li>
</li><li>        CodecBufferInfo bufferInfo = videoDecContext_-&gt;inputBufferInfoQueue.<span class="hljs-built_in">front</span>();</li><li>        videoDecContext_-&gt;inputBufferInfoQueue.<span class="hljs-built_in">pop</span>();</li><li>        videoDecContext_-&gt;inputFrameCount++;</li><li>        lock.<span class="hljs-built_in">unlock</span>();</li><li>
</li><li>        demuxer_-&gt;<span class="hljs-built_in">ReadSample</span>(demuxer_-&gt;<span class="hljs-built_in">GetVideoTrackId</span>(), <span class="hljs-built_in">reinterpret_cast</span>&lt;OH_AVBuffer *&gt;(bufferInfo.buffer),</li><li>                             bufferInfo.attr);</li><li>
</li><li>        <span class="hljs-type">int32_t</span> ret = videoDecoder_-&gt;<span class="hljs-built_in">PushInputBuffer</span>(bufferInfo);</li><li>        <span class="hljs-built_in">CHECK_AND_BREAK_LOG</span>(ret == AVCODEC_SAMPLE_ERR_OK, <span class="hljs-string">"Push data failed, thread out"</span>);</li><li>
</li><li>        <span class="hljs-built_in">CHECK_AND_BREAK_LOG</span>(!(bufferInfo.attr.flags &amp; AVCODEC_BUFFER_FLAGS_EOS),</li><li>                            <span class="hljs-string">"VideoDecInputThread Catch EOS, thread out"</span>);</li><li>    }</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/avcodec-buffer-mode/blob/master/entry/src/main/cpp/sample/transcoding/Transcoding.cpp#L273-L297" target="_blank">Transcoding.cpp</a></div></div></div></div> </li><li>视频解码输出缓存处理。<div class="screenLinkPre"><div _ngcontent-crt-c106="" class="highlight-div"><div _ngcontent-crt-c106="" class="highlight-div-header"><div _ngcontent-crt-c106="" class="highlight-div-header-left"><div _ngcontent-crt-c106="" class="handle-button expand-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-crt-c106="" class="highlight-div-header-right"><div _ngcontent-crt-c106="" class="handle-button ai-button"></div><div _ngcontent-crt-c106="" class="handle-button line-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-crt-c106="" class="handle-button theme-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-crt-c106="" class="handle-button copy-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-crt-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" codehub="https://gitee.com/harmonyos_samples/avcodec-buffer-mode/blob/master/entry/src/main/cpp/sample/transcoding/Transcoding.cpp#L301-L356" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Transcoding::VideoDecOutputThread</span><span class="hljs-params">()</span> </span>{</li><li>    sampleInfo_.frameInterval = MICROSECOND / sampleInfo_.frameRate;</li><li>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {</li><li>        <span class="hljs-built_in">CHECK_AND_BREAK_LOG</span>(isStarted_, <span class="hljs-string">"Decoder output thread out"</span>);</li><li>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(videoDecContext_-&gt;outputMutex)</span></span>;</li><li>        <span class="hljs-type">bool</span> condRet = videoDecContext_-&gt;outputCond.<span class="hljs-built_in">wait_for</span>(lock, <span class="hljs-number">5</span>s, [<span class="hljs-keyword">this</span>]() {</li><li>            <span class="hljs-keyword">return</span> !isStarted_ ||</li><li>                   !(videoDecContext_-&gt;outputBufferInfoQueue.<span class="hljs-built_in">empty</span>() &amp;&amp; videoEncContext_-&gt;inputBufferInfoQueue.<span class="hljs-built_in">empty</span>());</li><li>        });</li><li>        <span class="hljs-built_in">CHECK_AND_BREAK_LOG</span>(isStarted_, <span class="hljs-string">"Decoder output thread out"</span>);</li><li>        <span class="hljs-built_in">CHECK_AND_CONTINUE_LOG</span>(!videoDecContext_-&gt;outputBufferInfoQueue.<span class="hljs-built_in">empty</span>(),</li><li>                               <span class="hljs-string">"Buffer queue is empty, continue, cond ret: %{public}d"</span>, condRet);</li><li>        <span class="hljs-built_in">CHECK_AND_CONTINUE_LOG</span>(!videoEncContext_-&gt;inputBufferInfoQueue.<span class="hljs-built_in">empty</span>(),</li><li>                               <span class="hljs-string">"Buffer queue is empty, continue, cond ret: %{public}d"</span>, condRet);</li><li>
</li><li>        CodecBufferInfo bufferInfo = videoDecContext_-&gt;outputBufferInfoQueue.<span class="hljs-built_in">front</span>();</li><li>        videoDecContext_-&gt;outputBufferInfoQueue.<span class="hljs-built_in">pop</span>();</li><li>        videoDecContext_-&gt;outputFrameCount++;</li><li>        <span class="hljs-built_in">AVCODEC_SAMPLE_LOGW</span>(<span class="hljs-string">"Out buffer count: %{public}u, size: %{public}d, flag: %{public}u, pts: %{public}"</span> PRId64,</li><li>                            videoDecContext_-&gt;outputFrameCount, bufferInfo.attr.size, bufferInfo.attr.flags,</li><li>                            bufferInfo.attr.pts);</li><li>        lock.<span class="hljs-built_in">unlock</span>();</li><li>
</li><li>        <span class="hljs-comment">// get Buffer from inputBufferInfoQueue</span></li><li>        CodecBufferInfo encBufferInfo = videoEncContext_-&gt;inputBufferInfoQueue.<span class="hljs-built_in">front</span>();</li><li>        videoEncContext_-&gt;inputBufferInfoQueue.<span class="hljs-built_in">pop</span>();</li><li>        videoEncContext_-&gt;inputFrameCount++;</li><li>        </li><li>        <span class="hljs-built_in">AVCODEC_SAMPLE_LOGW</span>(</li><li>            <span class="hljs-string">"Out bufferInfo flags: %{public}u, offset: %{public}d, pts: %{public}u, size: %{public}"</span> PRId64,</li><li>            bufferInfo.attr.flags, bufferInfo.attr.offset, bufferInfo.attr.pts, bufferInfo.attr.size);</li><li>
</li><li>
</li><li>        encBufferInfo.bufferAddr = <span class="hljs-built_in">OH_AVBuffer_GetAddr</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;OH_AVBuffer *&gt;(encBufferInfo.buffer));</li><li>        bufferInfo.bufferAddr = <span class="hljs-built_in">OH_AVBuffer_GetAddr</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;OH_AVBuffer *&gt;(bufferInfo.buffer));</li><li>        <span class="hljs-built_in">CopyStrideYUV420SP</span>(encBufferInfo, bufferInfo);</li><li>
</li><li>        <span class="hljs-built_in">AVCODEC_SAMPLE_LOGW</span>(</li><li>            <span class="hljs-string">"Out encBufferInfo flags: %{public}u, offset: %{public}d, pts: %{public}u, size: %{public}d"</span> PRId64,</li><li>            encBufferInfo.attr.flags, encBufferInfo.attr.offset, encBufferInfo.attr.pts, encBufferInfo.attr.size);</li><li>
</li><li>        <span class="hljs-built_in">OH_AVBuffer_SetBufferAttr</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;OH_AVBuffer *&gt;(encBufferInfo.buffer), &amp;encBufferInfo.attr);</li><li>
</li><li>        <span class="hljs-comment">// Free Decoder's output buffer</span></li><li>        <span class="hljs-type">int32_t</span> ret = videoDecoder_-&gt;<span class="hljs-built_in">FreeOutputBuffer</span>(bufferInfo.bufferIndex, <span class="hljs-literal">false</span>);</li><li>        <span class="hljs-built_in">CHECK_AND_BREAK_LOG</span>(ret == AVCODEC_SAMPLE_ERR_OK, <span class="hljs-string">"Decoder output thread out"</span>);</li><li>
</li><li>        <span class="hljs-comment">// Push input buffer to Encoder</span></li><li>        videoEncoder_-&gt;<span class="hljs-built_in">PushInputBuffer</span>(encBufferInfo);</li><li>
</li><li>        <span class="hljs-keyword">if</span> (bufferInfo.attr.flags &amp; AVCODEC_BUFFER_FLAGS_EOS) {</li><li>            <span class="hljs-built_in">AVCODEC_SAMPLE_LOGW</span>(<span class="hljs-string">"VideoDecOutputThread Catch EOS, thread out"</span> PRId64);</li><li>            <span class="hljs-keyword">break</span>;</li><li>        }</li><li>    }</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/avcodec-buffer-mode/blob/master/entry/src/main/cpp/sample/transcoding/Transcoding.cpp#L301-L356" target="_blank">Transcoding.cpp</a></div></div></div></div> </li></ul> </li><li>视频文件编码。<ul><li>在解码输出缓存子线程中，将解码输出缓存同步拷贝AVBuffer。同时，需要注意的是解码的数据中会进行YUV跨距对齐，需要专门处理对应的跨距，偏移填充的数据，才能正确的进行视频编码。<div class="screenLinkPre"><div _ngcontent-crt-c106="" class="highlight-div"><div _ngcontent-crt-c106="" class="highlight-div-header"><div _ngcontent-crt-c106="" class="highlight-div-header-left"><div _ngcontent-crt-c106="" class="handle-button expand-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-crt-c106="" class="highlight-div-header-right"><div _ngcontent-crt-c106="" class="handle-button ai-button"></div><div _ngcontent-crt-c106="" class="handle-button line-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-crt-c106="" class="handle-button theme-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-crt-c106="" class="handle-button copy-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-crt-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" codehub="https://gitee.com/harmonyos_samples/avcodec-buffer-mode/blob/master/entry/src/main/cpp/sample/transcoding/Transcoding.cpp#L236-L269" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Transcoding::CopyStrideYUV420SP</span><span class="hljs-params">(CodecBufferInfo &amp;encBufferInfo, CodecBufferInfo &amp;bufferInfo)</span> </span>{</li><li>    <span class="hljs-type">int32_t</span> videoWidth = videoDecContext_-&gt;width;</li><li>    <span class="hljs-type">int32_t</span> &amp;stride = videoDecContext_-&gt;widthStride;</li><li>    <span class="hljs-type">int32_t</span> size = <span class="hljs-number">0</span>;</li><li>    <span class="hljs-type">uint8_t</span> *tempBufferAddr = encBufferInfo.bufferAddr;</li><li>
</li><li>    size += videoDecContext_-&gt;height * videoWidth * <span class="hljs-number">3</span> / <span class="hljs-number">2</span>;</li><li>    <span class="hljs-keyword">if</span> (videoWidth == videoDecContext_-&gt;widthStride &amp;&amp; videoDecContext_-&gt;heightStride == videoDecContext_-&gt;height) {</li><li>        std::<span class="hljs-built_in">memcpy</span>(tempBufferAddr, bufferInfo.bufferAddr, size);</li><li>    } <span class="hljs-keyword">else</span> {</li><li>        <span class="hljs-comment">// copy Y</span></li><li>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int32_t</span> row = <span class="hljs-number">0</span>; row &lt; videoDecContext_-&gt;height; row++) {</li><li>            std::<span class="hljs-built_in">memcpy</span>(tempBufferAddr, bufferInfo.bufferAddr, videoWidth);</li><li>            tempBufferAddr += videoWidth;</li><li>            bufferInfo.bufferAddr += stride;</li><li>        }</li><li>        bufferInfo.bufferAddr += (videoDecContext_-&gt;heightStride - videoDecContext_-&gt;height) * stride;</li><li>
</li><li>        <span class="hljs-comment">// copy U/V</span></li><li>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int32_t</span> row = <span class="hljs-number">0</span>; row &lt; (videoDecContext_-&gt;height / <span class="hljs-number">2</span>); row++) {</li><li>            std::<span class="hljs-built_in">memcpy</span>(tempBufferAddr, bufferInfo.bufferAddr, videoWidth);</li><li>            tempBufferAddr += videoWidth;</li><li>            bufferInfo.bufferAddr += stride;</li><li>        }</li><li>    }</li><li>    </li><li>    encBufferInfo.attr.size = size;</li><li>    encBufferInfo.attr.flags = bufferInfo.attr.flags;</li><li>    encBufferInfo.attr.offset = bufferInfo.attr.offset;</li><li>    encBufferInfo.attr.pts = bufferInfo.attr.pts;</li><li>
</li><li>    tempBufferAddr = <span class="hljs-literal">nullptr</span>;</li><li>    <span class="hljs-keyword">delete</span> tempBufferAddr;</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/avcodec-buffer-mode/blob/master/entry/src/main/cpp/sample/transcoding/Transcoding.cpp#L236-L269" target="_blank">Transcoding.cpp</a></div></div></div></div> </li><li>同时，拷贝的AVBuffer内存需要通过OH_AVBuffer_SetBufferAttr()设置对应的属性，其中，size属性为当前数据的大小，是实际AVBuffer的数据大小。最后，通过OH_VideoEncoder_PushInputBuffer()将填充的输入缓存数据提交给编码器。<div class="screenLinkPre"><div _ngcontent-crt-c106="" class="highlight-div"><div _ngcontent-crt-c106="" class="highlight-div-header"><div _ngcontent-crt-c106="" class="highlight-div-header-left"><div _ngcontent-crt-c106="" class="handle-button expand-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-crt-c106="" class="highlight-div-header-right"><div _ngcontent-crt-c106="" class="handle-button ai-button"></div><div _ngcontent-crt-c106="" class="handle-button line-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-crt-c106="" class="handle-button theme-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-crt-c106="" class="handle-button copy-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-crt-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" codehub="https://gitee.com/harmonyos_samples/avcodec-buffer-mode/blob/master/entry/src/main/cpp/capbilities/VideoEncoder.cpp#L151-L156" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-function"><span class="hljs-type">int32_t</span> <span class="hljs-title">VideoEncoder::PushInputBuffer</span><span class="hljs-params">(CodecBufferInfo &amp;info)</span> </span>{</li><li>    <span class="hljs-built_in">CHECK_AND_RETURN_RET_LOG</span>(encoder_ != <span class="hljs-literal">nullptr</span>, AVCODEC_SAMPLE_ERR_ERROR, <span class="hljs-string">"Decoder is null"</span>);</li><li>    <span class="hljs-type">int32_t</span> ret = <span class="hljs-built_in">OH_VideoEncoder_PushInputBuffer</span>(encoder_, info.bufferIndex);</li><li>    <span class="hljs-built_in">CHECK_AND_RETURN_RET_LOG</span>(ret == AV_ERR_OK, AVCODEC_SAMPLE_ERR_ERROR, <span class="hljs-string">"Push input data failed"</span>);</li><li>    <span class="hljs-keyword">return</span> AVCODEC_SAMPLE_ERR_OK;</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/avcodec-buffer-mode/blob/master/entry/src/main/cpp/capbilities/VideoEncoder.cpp#L151-L156" target="_blank">VideoEncoder.cpp</a></div></div></div></div> </li><li>在编码输出处理中，获取已编码的视频数据。<div class="screenLinkPre"><div _ngcontent-crt-c106="" class="highlight-div"><div _ngcontent-crt-c106="" class="highlight-div-header"><div _ngcontent-crt-c106="" class="highlight-div-header-left"><div _ngcontent-crt-c106="" class="handle-button expand-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-crt-c106="" class="highlight-div-header-right"><div _ngcontent-crt-c106="" class="handle-button ai-button"></div><div _ngcontent-crt-c106="" class="handle-button line-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-crt-c106="" class="handle-button theme-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-crt-c106="" class="handle-button copy-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-crt-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" codehub="https://gitee.com/harmonyos_samples/avcodec-buffer-mode/blob/master/entry/src/main/cpp/sample/transcoding/Transcoding.cpp#L360-L392" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Transcoding::VideoEncOutputThread</span><span class="hljs-params">()</span> </span>{</li><li>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {</li><li>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(videoEncContext_-&gt;outputMutex)</span></span>;</li><li>        <span class="hljs-type">bool</span> condRet = videoEncContext_-&gt;outputCond.<span class="hljs-built_in">wait_for</span>(</li><li>            lock, <span class="hljs-number">5</span>s, [<span class="hljs-keyword">this</span>]() { <span class="hljs-keyword">return</span> !isStarted_ || !videoEncContext_-&gt;outputBufferInfoQueue.<span class="hljs-built_in">empty</span>(); });</li><li>        <span class="hljs-built_in">CHECK_AND_BREAK_LOG</span>(isStarted_, <span class="hljs-string">"Work done, thread out"</span>);</li><li>        <span class="hljs-built_in">CHECK_AND_CONTINUE_LOG</span>(!videoEncContext_-&gt;outputBufferInfoQueue.<span class="hljs-built_in">empty</span>(),</li><li>                               <span class="hljs-string">"Buffer queue is empty, continue, cond ret: %{public}d"</span>, condRet);</li><li>
</li><li>        CodecBufferInfo bufferInfo = videoEncContext_-&gt;outputBufferInfoQueue.<span class="hljs-built_in">front</span>();</li><li>        videoEncContext_-&gt;outputBufferInfoQueue.<span class="hljs-built_in">pop</span>();</li><li>        <span class="hljs-built_in">CHECK_AND_BREAK_LOG</span>(!(bufferInfo.attr.flags &amp; AVCODEC_BUFFER_FLAGS_EOS),</li><li>                            <span class="hljs-string">"VideoEncOutputThread  Catch EOS, thread out"</span>);</li><li>        lock.<span class="hljs-built_in">unlock</span>();</li><li>        <span class="hljs-keyword">if</span> ((bufferInfo.attr.flags &amp; AVCODEC_BUFFER_FLAGS_SYNC_FRAME) ||</li><li>            (bufferInfo.attr.flags == AVCODEC_BUFFER_FLAGS_NONE)) {</li><li>            videoEncContext_-&gt;outputFrameCount++;</li><li>            bufferInfo.attr.pts = videoEncContext_-&gt;outputFrameCount * MICROSECOND / sampleInfo_.frameRate;</li><li>        } <span class="hljs-keyword">else</span> {</li><li>            bufferInfo.attr.pts = <span class="hljs-number">0</span>;</li><li>        }</li><li>        <span class="hljs-built_in">AVCODEC_SAMPLE_LOGW</span>(<span class="hljs-string">"Out buffer count: %{public}u, size: %{public}d, flag: %{public}u, pts: %{public}"</span> PRId64,</li><li>                            videoEncContext_-&gt;outputFrameCount, bufferInfo.attr.size, bufferInfo.attr.flags,</li><li>                            bufferInfo.attr.pts);</li><li>
</li><li>        muxer_-&gt;<span class="hljs-built_in">WriteSample</span>(muxer_-&gt;<span class="hljs-built_in">GetVideoTrackId</span>(), <span class="hljs-built_in">reinterpret_cast</span>&lt;OH_AVBuffer *&gt;(bufferInfo.buffer),</li><li>                            bufferInfo.attr);</li><li>        <span class="hljs-type">int32_t</span> ret = videoEncoder_-&gt;<span class="hljs-built_in">FreeOutputBuffer</span>(bufferInfo.bufferIndex);</li><li>        <span class="hljs-built_in">CHECK_AND_BREAK_LOG</span>(ret == AVCODEC_SAMPLE_ERR_OK, <span class="hljs-string">"Encoder output thread out"</span>);</li><li>    }</li><li>    <span class="hljs-built_in">AVCODEC_SAMPLE_LOGI</span>(<span class="hljs-string">"Exit, frame count: %{public}u"</span>, videoEncContext_-&gt;outputFrameCount);</li><li>    <span class="hljs-built_in">StartRelease</span>();</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/avcodec-buffer-mode/blob/master/entry/src/main/cpp/sample/transcoding/Transcoding.cpp#L360-L392" target="_blank">Transcoding.cpp</a></div></div></div></div> </li><li>通过OH_AVMuxer_WriteSampleBuffer方法，将编码完成的数据写入到视频文件中，从而完成视频转码。<div class="screenLinkPre"><div _ngcontent-crt-c106="" class="highlight-div"><div _ngcontent-crt-c106="" class="highlight-div-header"><div _ngcontent-crt-c106="" class="highlight-div-header-left"><div _ngcontent-crt-c106="" class="handle-button expand-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-crt-c106="" class="highlight-div-header-right"><div _ngcontent-crt-c106="" class="handle-button ai-button"></div><div _ngcontent-crt-c106="" class="handle-button line-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-crt-c106="" class="handle-button theme-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-crt-c106="" class="handle-button copy-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-crt-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" codehub="https://gitee.com/harmonyos_samples/avcodec-buffer-mode/blob/master/entry/src/main/cpp/capbilities/Muxer.cpp#L73-L85" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-function"><span class="hljs-type">int32_t</span> <span class="hljs-title">Muxer::WriteSample</span><span class="hljs-params">(<span class="hljs-type">int32_t</span> trackId, OH_AVBuffer *buffer, OH_AVCodecBufferAttr &amp;attr)</span></span>{</li><li>    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(writeMutex_)</span></span>;</li><li>
</li><li>    <span class="hljs-built_in">CHECK_AND_RETURN_RET_LOG</span>(muxer_ != <span class="hljs-literal">nullptr</span>, AVCODEC_SAMPLE_ERR_ERROR, <span class="hljs-string">"Muxer is null"</span>);</li><li>    <span class="hljs-built_in">CHECK_AND_RETURN_RET_LOG</span>(buffer != <span class="hljs-literal">nullptr</span>, AVCODEC_SAMPLE_ERR_ERROR, <span class="hljs-string">"Get a empty buffer"</span>);</li><li>
</li><li>    <span class="hljs-type">int32_t</span> ret = <span class="hljs-built_in">OH_AVBuffer_SetBufferAttr</span>(buffer, &amp;attr);</li><li>    <span class="hljs-built_in">CHECK_AND_RETURN_RET_LOG</span>(ret == AV_ERR_OK, AVCODEC_SAMPLE_ERR_ERROR, <span class="hljs-string">"SetBufferAttr failed"</span>);</li><li>
</li><li>    ret = <span class="hljs-built_in">OH_AVMuxer_WriteSampleBuffer</span>(muxer_, trackId, buffer);</li><li>    <span class="hljs-built_in">CHECK_AND_RETURN_RET_LOG</span>(ret == AV_ERR_OK, AVCODEC_SAMPLE_ERR_ERROR, <span class="hljs-string">"Write sample failed"</span>);</li><li>    <span class="hljs-keyword">return</span> AVCODEC_SAMPLE_ERR_OK;</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/avcodec-buffer-mode/blob/master/entry/src/main/cpp/capbilities/Muxer.cpp#L73-L85" target="_blank">Muxer.cpp</a></div></div></div></div> </li></ul> </li></ol> </div> <div class="tiledSection"><h2 id="section015912171519">常见问题<i class="anchor-icon anchor-icon-link" anchorid="section015912171519" tips="复制节点链接"></i></h2></div> <div class="tiledSection"><h3 id="section2235346682" class="firsth2">通过Buffer模式进行编解码，视频出现花屏或者绿边<i class="anchor-icon anchor-icon-link" anchorid="section2235346682" tips="复制节点链接"></i></h3></div> <p>可能的原因是在视频编解码的过程中没有考虑YUV跨距的问题，需要注意宽高对齐，处理对应的跨距，关于跨距的原理，请参考<a href="/consumer/cn/doc/best-practices/bpta-buffer-mode-transcoding#section39419315541">YUV跨距对齐</a>。在视频编码时，跨距可以在编码的回调函数EncOnNeedInputBuffer()中进行获取，其中，OH_MD_KEY_VIDEO_PIC_WIDTH和OH_MD_KEY_VIDEO_PIC_HEIGHT分别是视频图片的宽和高，OH_MD_KEY_VIDEO_STRIDE和OH_MD_KEY_VIDEO_SLICE_HEIGHT分别是字节填充后的宽和高。在视频解码时，跨距可以在解码的回调函数OnNewOutputBuffer()中进行获取，参考代码如下。</p> <div class="screenLinkPre"><div _ngcontent-crt-c106="" class="highlight-div"><div _ngcontent-crt-c106="" class="highlight-div-header"><div _ngcontent-crt-c106="" class="highlight-div-header-left"><div _ngcontent-crt-c106="" class="handle-button expand-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-crt-c106="" class="highlight-div-header-right"><div _ngcontent-crt-c106="" class="handle-button ai-button"></div><div _ngcontent-crt-c106="" class="handle-button line-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-crt-c106="" class="handle-button theme-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-crt-c106="" class="handle-button copy-button"><div _ngcontent-crt-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-crt-c106="" class="highlight-scroll-div"><pre class="cpp prettyprint linenums hljs language-cpp" codehub="https://gitee.com/harmonyos_samples/avcodec-buffer-mode/blob/master/entry/src/main/cpp/common/SampleCallback.cpp#L47-L83" hw-language="cpp" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SampleCallback::OnNewOutputBuffer</span><span class="hljs-params">(OH_AVCodec *codec, <span class="hljs-type">uint32_t</span> index, OH_AVBuffer *buffer, <span class="hljs-type">void</span> *userData)</span> </span>{</li><li>    <span class="hljs-keyword">if</span> (userData == <span class="hljs-literal">nullptr</span>) {</li><li>        <span class="hljs-keyword">return</span>;</li><li>    }</li><li>    CodecUserData *codecUserData = <span class="hljs-built_in">static_cast</span>&lt;CodecUserData *&gt;(userData);</li><li>    <span class="hljs-keyword">if</span>(codecUserData-&gt;isDecFirstFrame) {</li><li>        OH_AVFormat *format = <span class="hljs-built_in">OH_VideoDecoder_GetOutputDescription</span>(codec);</li><li>        <span class="hljs-built_in">OH_AVFormat_GetIntValue</span>(format, OH_MD_KEY_VIDEO_PIC_WIDTH, &amp;codecUserData-&gt;width);</li><li>        <span class="hljs-built_in">OH_AVFormat_GetIntValue</span>(format, OH_MD_KEY_VIDEO_PIC_HEIGHT, &amp;codecUserData-&gt;height);</li><li>        <span class="hljs-built_in">OH_AVFormat_GetIntValue</span>(format, OH_MD_KEY_VIDEO_STRIDE, &amp;codecUserData-&gt;widthStride);</li><li>        <span class="hljs-built_in">OH_AVFormat_GetIntValue</span>(format, OH_MD_KEY_VIDEO_SLICE_HEIGHT, &amp;codecUserData-&gt;heightStride);</li><li>        <span class="hljs-built_in">OH_AVFormat_Destroy</span>(format);</li><li>        codecUserData-&gt;isDecFirstFrame = <span class="hljs-literal">false</span>;</li><li>    }</li><li>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(codecUserData-&gt;outputMutex)</span></span>;</li><li>    codecUserData-&gt;outputBufferInfoQueue.<span class="hljs-built_in">emplace</span>(index, buffer);</li><li>    codecUserData-&gt;outputCond.<span class="hljs-built_in">notify_all</span>();</li><li>}</li><li>
</li><li><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SampleCallback::EncOnNeedInputBuffer</span><span class="hljs-params">(OH_AVCodec *codec, <span class="hljs-type">uint32_t</span> index, OH_AVBuffer *buffer, <span class="hljs-type">void</span> *userData)</span> </span>{</li><li>    <span class="hljs-keyword">if</span> (userData == <span class="hljs-literal">nullptr</span>) {</li><li>        <span class="hljs-keyword">return</span>;</li><li>    }</li><li>    CodecUserData *codecUserData = <span class="hljs-built_in">static_cast</span>&lt;CodecUserData *&gt;(userData);</li><li>    <span class="hljs-keyword">if</span> (codecUserData-&gt;isEncFirstFrame) {</li><li>        OH_AVFormat *format = <span class="hljs-built_in">OH_VideoDecoder_GetOutputDescription</span>(codec);</li><li>        <span class="hljs-built_in">OH_AVFormat_GetIntValue</span>(format, OH_MD_KEY_VIDEO_PIC_WIDTH, &amp;codecUserData-&gt;width);</li><li>        <span class="hljs-built_in">OH_AVFormat_GetIntValue</span>(format, OH_MD_KEY_VIDEO_PIC_HEIGHT, &amp;codecUserData-&gt;height);</li><li>        <span class="hljs-built_in">OH_AVFormat_GetIntValue</span>(format, OH_MD_KEY_VIDEO_STRIDE, &amp;codecUserData-&gt;widthStride);</li><li>        <span class="hljs-built_in">OH_AVFormat_GetIntValue</span>(format, OH_MD_KEY_VIDEO_SLICE_HEIGHT, &amp;codecUserData-&gt;heightStride);</li><li>        <span class="hljs-built_in">OH_AVFormat_Destroy</span>(format);</li><li>        codecUserData-&gt;isEncFirstFrame = <span class="hljs-literal">false</span>;</li><li>    }</li><li>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(codecUserData-&gt;inputMutex)</span></span>;</li><li>    codecUserData-&gt;inputBufferInfoQueue.<span class="hljs-built_in">emplace</span>(index, buffer);</li><li>    codecUserData-&gt;inputCond.<span class="hljs-built_in">notify_all</span>();</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/avcodec-buffer-mode/blob/master/entry/src/main/cpp/common/SampleCallback.cpp#L47-L83" target="_blank">SampleCallback.cpp</a></div></div></div></div> <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"><p>在处理跨距时，需要注意size属性的计算与设置，如果size的大小和设置buffer的大小不一致，视频编解码时会出现buffer数据丢失。</p> </div></div></div> <div class="tiledSection"><h3 id="section06191670264">在视频编解码中，Surface模式和Buffer模式的区别是什么<i class="anchor-icon anchor-icon-link" anchorid="section06191670264" tips="复制节点链接"></i></h3></div> <p>视频编解码包含两种方式，分别是Surface模式和Buffer模式。在Surface模式下，会通过window对象对接其他模块，如相机、屏幕录制等模块。相对于Surface模式，Buffer模式对于视频数据处理更加灵活，也更为复杂。关于Surface模式和Buffer模式的区别可以参考<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/video-encoding#surface输入与buffer输入" target="_blank">Surface输入与Buffer输入</a>、<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/video-decoding#surface输出与buffer输出" target="_blank">Surface输出与Buffer输出</a>。</p> <div class="tiledSection"><h2 id="section619811180433">示例代码<i class="anchor-icon anchor-icon-link" anchorid="section619811180433" tips="复制节点链接"></i></h2><ul><li><a href="https://gitee.com/harmonyos_samples/avcodec-buffer-mode" target="_blank">基于Buffer模式进行视频转码</a></li></ul> </div> </div> <div></div></div>