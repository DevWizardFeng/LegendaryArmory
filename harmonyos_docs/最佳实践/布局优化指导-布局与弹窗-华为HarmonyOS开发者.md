<h1 _ngcontent-bcd-c119="" class="doc-title ng-star-inserted" title="布局优化指导"> 布局优化指导 </h1>

<div _ngcontent-bcd-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;">   <div>    <div class="tiledSection">     <h2 id="section16114121365117">ArkUI框架执行流程<i class="anchor-icon anchor-icon-link" anchorid="section16114121365117" tips="复制节点链接"></i></h2>          <p>在使用ArkUI开发中，我们通过布局组件和基础组件进行界面描述，这些描述会呈现出一个组件树的结构，基础组件在其中为叶子结点，布局组件则是中间节点，可以把这棵树称之为应用组件树。当用户执行交互（滑动，点击等行为）时会触发界面修改，界面的修改本质上是通过触发这棵组件树的重新渲染，来实现应用界面更新的过程。</p>     <p><span><img height="259.50853600000005" originheight="348" originwidth="1070" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211162904.98015960880202469525688535314432:50001231000000:2800:563674C64DD0C97B8FE256B9C89C865A14CAF9F1753BBFF36A41705B16489B57.jpg" title="点击放大" width="798"></span></p>    </div>    <p>应用界面更新的过程主要分为两个过程：<strong>数据处理过程和UI更新过程</strong>。</p>    <ol>     <li>数据处理过程中主要是对状态数据进行更新，状态数据指的是所定义的@State等相关的数据。数据变化时，会有一定的更新耗时，并且数据关联的组件数量，也影响下一步UI更新的耗时，在开发过程中需要避免无效的数据更新，从而减少冗余的UI更新耗时。关于这部分的优化措施可以参考《<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-status-management">状态管理最佳实践</a>》。</li>     <li>UI更新过程中则是对需要更新的元素进行更新操作，对应的元素会经历Build、Measure、Layout和Render等阶段。其中Build是执行组件创建和组件标脏（即标记需要更新的组件，当组件的属性状态发生变化时，框架会将其标记为"脏"状态，表示需要进行重新构建）的过程，Measure是对组件的宽高进行测量的阶段，Layout是对元素进行在屏幕上位置进行摆放的阶段，而Render则是根据测量和布局得到的大小位置等信息，进行提交绘制的过程。</li>    </ol>    <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content">      <p>在初次进入页面的时候，所有的组件都会参与到界面的渲染中（换句说法，初次渲染的时候，可以认为所有的组件都需要更新）。</p>     </div></div></div>    <div class="tiledSection">     <h3 id="section331714584515" class="firsth2">UI更新过程<i class="anchor-icon anchor-icon-link" anchorid="section331714584515" tips="复制节点链接"></i></h3>          <p>UI更新过程包含组件标脏及布局计算。初始加载阶段，所有组件（排除if/else条件不成立的分支和LazyForEach不可视区域内容）都会完整经历Build、Measure、Layout、Render流程。界面更新阶段，当触发列表滑动、显示/隐藏切换、元素属性（内容/样式/位置/尺寸）变化时，UI线程会先将脏节点进行Build，Build的过程会按照组件id，依次更新组件设置的属性，如果属性发生改变，则进行组件标脏。</p>     <ul>      <li>若布局属性变化（width/height/padding/margin等）：标记为"布局脏" ，找到布局边界，进行子树更新。</li>      <li>若非布局属性（样式属性）变化（color/backgroundColor/opacity等）：仅会影响自身属性，不会进行子树查找。</li>     </ul>     <p>多数情况下，如果某个组件的布局发生变化，也会对其他组件的布局也会产生影响，所以当有组件的布局发生变化，最简单的办法就是对整棵树进行重新布局，但是这样对整棵树进行重新布局的代价太大。标脏过程就是用来确定布局最小影响范围，来减少对整棵树进行重新布局的代价，而这个影响范围就是布局边界以内。</p>     <p>一般来讲，如果一个组件设置了固定的宽高尺寸，那这个组件就是布局边界。其内部组件布局的变化，不会影响到此布局边界外部的布局情况，那么在查找的时候，只需要在布局边界内部判断哪些组件的布局会受到影响，可以避免在整棵树结构的查找过程。</p>    </div>    <p><span><img height="395.7182250000001" originheight="502" originwidth="1011" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211162904.89008959963575436753809547838604:50001231000000:2800:15F6AD92F7BE8DFA79DAF6AE032565A8DCFAA813ABE56353D363DB200B23E0B1.jpg" title="点击放大" width="797.0025"></span></p>    <p>确定实际的脏节点数组后，根据脏节点数组来拿到对应的脏节点对象，通过递归遍历children进行Measure过程，如果该对象布局参数没有发生变化，就会跳过对应的Measure阶段。当Measure执行完成后，进行layout阶段。</p>    <p><span><img height="424.10215400000004" originheight="537" originwidth="1018" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211162904.11128390316270530656372838556479:50001231000000:2800:001EA3719AD4888226458F571155D0C2688654FC93D115606EBB49DADBAFB093.jpg" title="点击放大" width="803.985"></span></p>    <p>从以上的过程可以看出，影响UI更新过程的主要因素是参与更新的节点数量。</p>    <p>在初次加载的时候，由于所有的节点都要参与全过程，那么如果对首帧渲染的速度有要求，就需要降低整体页面的组件节点数量。</p>    <p>在页面内容更新过程中，由于状态变量的变化导致UI的更新，可以利用布局边界减少子树更新的数量以及减少布局的计算。</p>    <div class="tiledSection">     <h2 id="section9293918175210">精简节点数<i class="anchor-icon anchor-icon-link" anchorid="section9293918175210" tips="复制节点链接"></i></h2>          <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content">       <p>建议开发者优先使用<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-code-linter" target="_blank">Code Linter扫描工具</a>进行代码检查，重点关注<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide_hp-arkui-remove-container-without-property" target="_blank">@performance/hp-arkui-remove-container-without-property</a>规则。若扫描结果中出现该规则相关问题，可参考本章节提供的优化建议进行调整。</p>      </div></div></div>     <p>布局阶段是采用递归遍历所有节点的方式进行组件位置和大小的计算， 如果嵌套层级过深，将带来更多的中间节点，在布局测算阶段下，额外的节点数将导致更多的计算过程，造成性能劣化。我们通过模拟10、100、500、1000层Row嵌套的情况下，通过Profiler工具抓取Launch数据查看对应的首帧绘制，以及页面Measure/Layout时间进行对比。</p>     <div _ngcontent-bcd-c106="" class="highlight-div"><div _ngcontent-bcd-c106="" class="highlight-div-header"><div _ngcontent-bcd-c106="" class="highlight-div-header-left"><div _ngcontent-bcd-c106="" class="handle-button expand-button"><div _ngcontent-bcd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-bcd-c106="" class="highlight-div-header-right"><div _ngcontent-bcd-c106="" class="handle-button ai-button"></div><div _ngcontent-bcd-c106="" class="handle-button line-button"><div _ngcontent-bcd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-bcd-c106="" class="handle-button theme-button"><div _ngcontent-bcd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-bcd-c106="" class="handle-button copy-button"><div _ngcontent-bcd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-bcd-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-scss" data-highlighted="yes"><ol class="linenums"><li>  <span class="hljs-built_in">Row</span>() {</li><li>    ... <span class="hljs-comment">// 10、100、500、1000层Row容器嵌套</span></li><li>    <span class="hljs-built_in">Row</span>() {</li><li>      Text('Inner Text')</li><li>    } </li><li>    ... </li><li>  }</li></ol></pre></div></div>     <p>然后进一步对比在平铺的情况下，Row内组件个数在10、100、500、1000的条件下，使用Profiler工具抓取Launch的数据情况，得到如下结果如表1所示。</p>     <div _ngcontent-bcd-c106="" class="highlight-div"><div _ngcontent-bcd-c106="" class="highlight-div-header"><div _ngcontent-bcd-c106="" class="highlight-div-header-left"><div _ngcontent-bcd-c106="" class="handle-button expand-button"><div _ngcontent-bcd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-bcd-c106="" class="highlight-div-header-right"><div _ngcontent-bcd-c106="" class="handle-button ai-button"></div><div _ngcontent-bcd-c106="" class="handle-button line-button"><div _ngcontent-bcd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-bcd-c106="" class="handle-button theme-button"><div _ngcontent-bcd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-bcd-c106="" class="handle-button copy-button"><div _ngcontent-bcd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-bcd-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-scss" data-highlighted="yes"><ol class="linenums"><li> <span class="hljs-built_in">Row</span>() {</li><li>    <span class="hljs-built_in">Row</span>() {} </li><li>    ... <span class="hljs-comment">// 10、100、500、1000层Row容器并排</span></li><li>    Text('Inner Text')</li><li>  }</li></ol></pre></div></div>     <div class="tablenoborder">      <div class="tbBox"><table class="layoutFixed idpTab">       <caption>        <b>表1 </b><strong>嵌套与平铺下的布局时间对比</strong>       </caption>       <thead>        <tr>         <th align="center" class="cellrowborder" colspan="2" id="mcps1.3.12.7.2.7.1.1" valign="top">          <p>对比指标</p></th>         <th align="left" class="cellrowborder" id="mcps1.3.12.7.2.7.1.2" valign="top">          <p>10</p></th>         <th align="left" class="cellrowborder" id="mcps1.3.12.7.2.7.1.3" valign="top">          <p>100</p></th>         <th align="left" class="cellrowborder" id="mcps1.3.12.7.2.7.1.4" valign="top">          <p>500</p></th>         <th align="left" class="cellrowborder" id="mcps1.3.12.7.2.7.1.5" valign="top">          <p>1000</p></th>        </tr>       </thead>               <tbody><tr>         <td align="center" class="cellrowborder" rowspan="3" valign="top" width="9.028194361127776%">          <p></p>          <p>嵌套/层</p></td>         <td class="cellrowborder" valign="top" width="16.98660267946411%">          <p>首帧绘制</p></td>         <td class="cellrowborder" valign="top" width="18.49630073985203%">          <p>3.2ms</p></td>         <td class="cellrowborder" valign="top" width="18.49630073985203%">          <p>5.8ms</p></td>         <td class="cellrowborder" valign="top" width="18.49630073985203%">          <p>17.3ms</p></td>         <td class="cellrowborder" valign="top" width="18.49630073985203%">          <p>32ms</p></td>        </tr>        <tr>         <td class="cellrowborder" valign="top">          <p>Measure</p></td>         <td class="cellrowborder" valign="top">          <p>1.88ms</p></td>         <td class="cellrowborder" valign="top">          <p>2.89ms</p></td>         <td class="cellrowborder" valign="top">          <p>5.93ms</p></td>         <td class="cellrowborder" valign="top">          <p>10.46ms</p></td>        </tr>        <tr>         <td class="cellrowborder" valign="top">          <p>Layout</p></td>         <td class="cellrowborder" valign="top">          <p>0.38ms</p></td>         <td class="cellrowborder" valign="top">          <p>1.12ms</p></td>         <td class="cellrowborder" valign="top">          <p>5.26ms</p></td>         <td class="cellrowborder" valign="top">          <p>10.88ms</p></td>        </tr>        <tr>         <td align="center" class="cellrowborder" rowspan="3" valign="top" width="9.028194361127776%">          <p></p>          <p>平铺 /个</p></td>         <td class="cellrowborder" valign="top" width="16.98660267946411%">          <p>首帧绘制</p></td>         <td class="cellrowborder" valign="top" width="18.49630073985203%">          <p>3.6ms</p></td>         <td class="cellrowborder" valign="top" width="18.49630073985203%">          <p>4.5ms</p></td>         <td class="cellrowborder" valign="top" width="18.49630073985203%">          <p>14ms</p></td>         <td class="cellrowborder" valign="top" width="18.49630073985203%">          <p>24.3ms</p></td>        </tr>        <tr>         <td class="cellrowborder" valign="top">          <p>Measure</p></td>         <td class="cellrowborder" valign="top">          <p>2.15ms</p></td>         <td class="cellrowborder" valign="top">          <p>2.31ms</p></td>         <td class="cellrowborder" valign="top">          <p>5.61ms</p></td>         <td class="cellrowborder" valign="top">          <p>9.26ms</p></td>        </tr>        <tr>         <td class="cellrowborder" valign="top">          <p>Layout</p></td>         <td class="cellrowborder" valign="top">          <p>0.39ms</p></td>         <td class="cellrowborder" valign="top">          <p>1.38ms</p></td>         <td class="cellrowborder" valign="top">          <p>4.74ms</p></td>         <td class="cellrowborder" valign="top">          <p>9.92ms</p></td>        </tr>             </tbody></table></div>     </div>     <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content">       <p>以上数据来源均为版本DevEco Studio 4.0.3.415、SDK 4.0.10.9条件下测试得到，不同设备类型数据可能存在差异，测试数据旨在体现性能优化趋势，仅供参考。</p>      </div></div></div>     <p><span><img height="181.46126327312533" originheight="444" originwidth="2251" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211162905.32628627457716958024149241520860:50001231000000:2800:52C804346A1CE59624F64FE6A4C582B1F99947BCA9DFD1AA87EBE775063A4F4D.png" title="点击放大" width="920"></span></p>     <p>根据以上数据对比发现，组件平铺和嵌套在相同组件个数的情况下，其性能差异不大，并且整体上趋势保持一致，随着组件数量增加呈现线性增长的劣化，由此可以得到结论，真正影响布局性能的因素是参与布局的节点数量。所以在进行布局时，应该尽量减少整体的节点数，来减少布局的性能劣化。</p>     <p>针对减少总节点，主要有两个方向：</p>     <ul>      <li>移除冗余的节点。</li>      <li>使用扁平化布局减少节点数。</li>     </ul>     <p><strong>移除冗余节点</strong></p>     <p>对于常出现冗余的情况，例如可能会在Row容器包含一个同样也是Row容器的子级。这种嵌套实际是多余的，并且会给布局层次结构造成不必要的开销。</p>     <div _ngcontent-bcd-c106="" class="highlight-div"><div _ngcontent-bcd-c106="" class="highlight-div-header"><div _ngcontent-bcd-c106="" class="highlight-div-header-left"><div _ngcontent-bcd-c106="" class="handle-button expand-button"><div _ngcontent-bcd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-bcd-c106="" class="highlight-div-header-right"><div _ngcontent-bcd-c106="" class="handle-button ai-button"></div><div _ngcontent-bcd-c106="" class="handle-button line-button"><div _ngcontent-bcd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-bcd-c106="" class="handle-button theme-button"><div _ngcontent-bcd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-bcd-c106="" class="handle-button copy-button"><div _ngcontent-bcd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-bcd-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-scss" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-built_in">Row</span>() {</li><li>  <span class="hljs-built_in">Row</span>(){</li><li>    <span class="hljs-built_in">Image</span>()</li><li>    Text()</li><li>  }</li><li>  <span class="hljs-built_in">Image</span>()</li><li>}</li></ol></pre></div></div>     <p>由于其中Row容器父子布局方向相同，所以可以去掉Image和Text外层的Row来减少层级，如果视图更加复杂，布局在渲染时，会产生没有必要的计算。</p>     <div _ngcontent-bcd-c106="" class="highlight-div"><div _ngcontent-bcd-c106="" class="highlight-div-header"><div _ngcontent-bcd-c106="" class="highlight-div-header-left"><div _ngcontent-bcd-c106="" class="handle-button expand-button"><div _ngcontent-bcd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-bcd-c106="" class="highlight-div-header-right"><div _ngcontent-bcd-c106="" class="handle-button ai-button"></div><div _ngcontent-bcd-c106="" class="handle-button line-button"><div _ngcontent-bcd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-bcd-c106="" class="handle-button theme-button"><div _ngcontent-bcd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-bcd-c106="" class="handle-button copy-button"><div _ngcontent-bcd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-bcd-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-scss" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-built_in">Row</span>() {</li><li>  <span class="hljs-built_in">Image</span>()</li><li>  Text()</li><li>  <span class="hljs-built_in">Image</span>()</li><li>}</li></ol></pre></div></div>     <p>尽管在这里只是多了一层，但是实际开发中的布局往往非常复杂，冗余带来的开销可能非常影响布局性能，尤其是在列表中动态创建组件时，带来的性能影响是显著的。</p>     <p><strong>使用扁平化布局减少节点数</strong></p>     <p>在某些情况下，开发者所实现的布局在嵌套层级上是没有冗余的，但是嵌套层级仍然较深，可能无法通过调整现有的布局方案，使其不包含多余的布局，唯一的解决方案可能是，通过切换到完全不同的布局类型来实现层次结构的扁平化。</p>     <p>例如图1中元素结构示意图，传统使用线性布局的情况下，总共存在4层嵌套、共15个节点，并且其中并没有冗余的嵌套节点。而扁平化布局是一种让页面结构变浅变宽的方式，通过一些高级组件如RelativeContainer、Grid等容器，可以让元素在平面上展开。这种布局方式能够有效减少由于使用线性布局带来的嵌套深度，将其用于描述布局的容器节点进行优化，达到精简节点数的目的。图1中将线性布局改成相对布局的情况下，嵌套2层、总共10个节点，相比之下前后少了5个节点。</p>     <div class="fignone">      <span class="figcap"><b>图1 </b>扁平化布局示意图</span>      <br><span><img height="145.4355" originheight="400" originwidth="2000" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211162905.35651419434615386060317072833274:50001231000000:2800:B650A31C1F812FA7516C96EABAC42BDF41DF9536A37BE84525901B119F97F985.png" title="点击放大" width="727.1775"></span>     </div>     <p>这种方式对于布局的影响主要体现在：</p>     <ol>      <li>页面创建时，扁平化减少了中间的嵌套层级，使总的组件节点的数量越少，在进行布局时所需要进行的计算相对越少。</li>      <li>页面更新时，当要更新的结构是嵌套子树的结构，其树内包含过多节点时，整体更新会导致更新的节点数过多，造成布局性能劣化。</li>     </ol>     <p>所以当页面不存在冗余节点时，可以考虑是否能够通过替换为更高级的布局使得页面扁平化，来达到减少节点数的目的。主要方式可以参考：</p>     <ul>      <li><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-layout-development-relative-layout" target="_blank">RelativeContainer</a> 通过相对布局实现扁平化。</li>      <li><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-location#position" target="_blank">绝对定位</a> 通过锚点定位实现扁平化。</li>      <li><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-layout-development-create-grid" target="_blank">Grid</a> 通过二维布局实现扁平化。</li>     </ul>    </div>    <div class="tiledSection">     <h2 id="section151587885316">利用布局边界减少布局计算<i class="anchor-icon anchor-icon-link" anchorid="section151587885316" tips="复制节点链接"></i></h2>          <p>对于组件的宽高不需要自适应的情况下，建议在UI描述时给定组件的宽高数值，当其组件外部的容器尺寸发生变化时，例如拖拽缩放等场景下，如果组件本身的宽高是固定的，理论上来讲，该组件在布局阶段不会参与Measure阶段，其节点中保存了对应的大小信息，如果组件内容较多时，由于避免了其中组件整体的测算过程，性能会带来较大的提升。</p>     <div class="p">      我们通过修改以下示例代码中Column的宽度，对比给Row设置固定宽度.width(300).height(400)、百分比.width('100%').height('70%')以及不设置宽高的情况下的页面绘制、Measure、Layout时间。      <div _ngcontent-bcd-c106="" class="highlight-div"><div _ngcontent-bcd-c106="" class="highlight-div-header"><div _ngcontent-bcd-c106="" class="highlight-div-header-left"><div _ngcontent-bcd-c106="" class="handle-button expand-button"><div _ngcontent-bcd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-bcd-c106="" class="highlight-div-header-right"><div _ngcontent-bcd-c106="" class="handle-button ai-button"></div><div _ngcontent-bcd-c106="" class="handle-button line-button"><div _ngcontent-bcd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-bcd-c106="" class="handle-button theme-button"><div _ngcontent-bcd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-bcd-c106="" class="handle-button copy-button"><div _ngcontent-bcd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-bcd-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-kotlin" data-highlighted="yes"><ol class="linenums"><li>Column() {</li><li>  Button(<span class="hljs-string">"修改宽度"</span>).onClick(() =&gt; {</li><li>    <span class="hljs-keyword">this</span>.testWidth = <span class="hljs-string">'90%'</span></li><li>  }).height(<span class="hljs-string">'20%'</span>)</li><li>
</li><li>  Row() {</li><li>    <span class="hljs-comment">// 400条文本数据</span></li><li>  }</li><li>}.width(<span class="hljs-keyword">this</span>.testWidth )</li></ol></pre></div></div>     </div>     <p>对比的结果如下：</p>     <div class="tablenoborder">      <div class="tbBox"><table class="layoutFixed idpTab">       <caption>        <b>表2 </b><strong>设置不同宽高对布局时间影响</strong>       </caption>       <thead>        <tr>         <th align="left" class="cellrowborder" id="mcps1.3.13.5.2.5.1.1" valign="top" width="25%">          <p>对比指标/ms</p></th>         <th align="left" class="cellrowborder" id="mcps1.3.13.5.2.5.1.2" valign="top" width="25%">          <p>限定容器的宽高为固定值</p></th>         <th align="left" class="cellrowborder" id="mcps1.3.13.5.2.5.1.3" valign="top" width="25%">          <p>未设置容器的宽高</p></th>         <th align="left" class="cellrowborder" id="mcps1.3.13.5.2.5.1.4" valign="top" width="25%">          <p>限定容器的宽高为百分比</p></th>        </tr>       </thead>               <tbody><tr>         <td class="cellrowborder" valign="top" width="25%">          <p>首帧绘制</p></td>         <td class="cellrowborder" valign="top" width="25%">          <p>60.20ms</p></td>         <td class="cellrowborder" valign="top" width="25%">          <p>59.99ms</p></td>         <td class="cellrowborder" valign="top" width="25%">          <p>60.50ms</p></td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="25%">          <p>Measure</p></td>         <td class="cellrowborder" valign="top" width="25%">          <p>17.80ms</p></td>         <td class="cellrowborder" valign="top" width="25%">          <p>17.76ms</p></td>         <td class="cellrowborder" valign="top" width="25%">          <p>16.92ms</p></td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="25%">          <p>Layout</p></td>         <td class="cellrowborder" valign="top" width="25%">          <p>5.5ms</p></td>         <td class="cellrowborder" valign="top" width="25%">          <p>4.91ms</p></td>         <td class="cellrowborder" valign="top" width="25%">          <p>4.92ms</p></td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="25%">          <p>重新绘制</p></td>         <td class="cellrowborder" valign="top" width="25%">          <p><strong>2.0ms</strong></p></td>         <td class="cellrowborder" valign="top" width="25%">          <p>38.45ms</p></td>         <td class="cellrowborder" valign="top" width="25%">          <p>42.62ms</p></td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="25%">          <p>重绘的Measure</p></td>         <td class="cellrowborder" valign="top" width="25%">          <p><strong>0.50ms</strong></p></td>         <td class="cellrowborder" valign="top" width="25%">          <p>18.87ms</p></td>         <td class="cellrowborder" valign="top" width="25%">          <p>20.93ms</p></td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="25%">          <p>重绘的Layout</p></td>         <td class="cellrowborder" valign="top" width="25%">          <p><strong>0.12ms</strong></p></td>         <td class="cellrowborder" valign="top" width="25%">          <p>1.41ms</p></td>         <td class="cellrowborder" valign="top" width="25%">          <p>1.80ms</p></td>        </tr>             </tbody></table></div>     </div>     <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content">       <ul>        <li>以上数据来源均为版本DevEco Studio 4.0.3.415、SDK 4.0.10.9条件下测试得到，不同设备类型数据可能存在差异，测试数据旨在体现性能优化趋势，仅供参考。</li>       </ul>      </div></div></div>     <p>由上数据可以发现：</p>     <ul>      <li>首次绘制时，三种情况数据相差不大。</li>      <li>重新绘制时，限定容器宽高为固定值的情况下，性能提升明显。</li>     </ul>     <p>分析原因可以得到，这是由于首次绘制的情况下，无论是否设置宽高属性，都会对所有组件进行布局和测算的过程，来得到最终的组件大小和位置。而当触发按钮修改外层Column的宽度时，也就是触发重新绘制的情况下，给定容器宽高为固定值的性能远远优于未设置宽高和设置百分比宽高，这是由于对于未设置宽高以及设置百分比宽高的情况下，在外层容器宽高发生变化时，组件本身也会触发重新进行Measure的过程，对组件的宽高进行重新测算，导致其布局时间很长，而设置了固定宽高的组件，则不会经过这一过程，而是直接使用初次绘制时保留的节点大小数据，减少了测算的时间，这对于性能的提升是尤为明显的，尤其是当组件内的内容十分复杂的情况下。</p>     <p>所以对于能够在初期给定宽高的组件，在进行UI描述时尽量给定宽高数值，能够减少由于容器尺寸变化造成的重新测算过程的性能。</p>    </div>    <div class="tiledSection">     <h2 id="section12390122913536">合理使用渲染控制语法<i class="anchor-icon anchor-icon-link" anchorid="section12390122913536" tips="复制节点链接"></i></h2>         </div>    <div class="tiledSection">     <h3 id="section14111154271" class="firsth2">合理控制元素显示与隐藏<i class="anchor-icon anchor-icon-link" anchorid="section14111154271" tips="复制节点链接"></i></h3>          <p>控制元素显示与隐藏是一种常见的场景，使用Visibility.None、if条件判断等都能够实现该效果。其中if条件判断控制的是组件的创建、布局阶段，visibility属性控制的是元素在布局阶段是否参与布局渲染。使用时如果使用的方式不当，将引起性能上的问题。</p>     <p>对于不同的场景下，需要选择合适的手段，根据性能或者内存要求选择不同的实现方式：</p>     <ul>      <li>只有初始的一次渲染或者交互次数很少的情况下，建议使用if条件判断来控制元素的显示与隐藏效果，对于内存有较大提升。</li>      <li>如果会频繁响应显示与隐藏的交互效果，建议使用切换Visibility.None和Visibility.Visible来控制元素显示与隐藏，提高性能。</li>     </ul>     <p>通过对一个复杂的视图结构，例如以下示例代码中，对包含100个Image组件的Column容器进行显示与隐藏控制，分别采用if条件判断和visibility属性的方式进行控制。</p>     <div _ngcontent-bcd-c106="" class="highlight-div"><div _ngcontent-bcd-c106="" class="highlight-div-header"><div _ngcontent-bcd-c106="" class="highlight-div-header-left"><div _ngcontent-bcd-c106="" class="handle-button expand-button"><div _ngcontent-bcd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-bcd-c106="" class="highlight-div-header-right"><div _ngcontent-bcd-c106="" class="handle-button ai-button"></div><div _ngcontent-bcd-c106="" class="handle-button line-button"><div _ngcontent-bcd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-bcd-c106="" class="handle-button theme-button"><div _ngcontent-bcd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-bcd-c106="" class="handle-button copy-button"><div _ngcontent-bcd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-bcd-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-scss" data-highlighted="yes"><ol class="linenums"><li> <span class="hljs-built_in">Row</span>() {</li><li>    Text("Hello World")</li><li>    <span class="hljs-built_in">if</span>(this.visible) {</li><li>      <span class="hljs-built_in">Column</span>() {</li><li>        ... <span class="hljs-comment">// 100个Image组件</span></li><li>      }</li><li>    }</li><li>  }</li></ol></pre></div></div>     <div class="p">      通过visibility属性控制的示例代码如下：      <div _ngcontent-bcd-c106="" class="highlight-div"><div _ngcontent-bcd-c106="" class="highlight-div-header"><div _ngcontent-bcd-c106="" class="highlight-div-header-left"><div _ngcontent-bcd-c106="" class="handle-button expand-button"><div _ngcontent-bcd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-bcd-c106="" class="highlight-div-header-right"><div _ngcontent-bcd-c106="" class="handle-button ai-button"></div><div _ngcontent-bcd-c106="" class="handle-button line-button"><div _ngcontent-bcd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-bcd-c106="" class="handle-button theme-button"><div _ngcontent-bcd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-bcd-c106="" class="handle-button copy-button"><div _ngcontent-bcd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-bcd-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-scss" data-highlighted="yes"><ol class="linenums"><li> <span class="hljs-built_in">Row</span>() {</li><li>    Text("Hello World")</li><li>    <span class="hljs-built_in">Column</span>() {</li><li>      ... <span class="hljs-comment">// 100个Image组件</span></li><li>    }<span class="hljs-selector-class">.visibility</span>(this.visible?Visibility.Visible:Visibility.None)</li><li>  }</li></ol></pre></div></div>     </div>     <p>在相同的测试环境下，分别测试在初次加载页面，以及改变状态变量this.visible的值来修改显示隐藏的情况下，通过Profiler工具抓取的布局时Measure、Layout以及组件创建的时长。</p>     <p>在初次加载的情况下的测试结果如下：</p>     <div class="tablenoborder">      <div class="tbBox"><table class="layoutFixed idpTab">       <caption>        <b>表3 </b><strong>使用if/else和visibility属性控制显隐的布局时间对比</strong>       </caption>       <thead>        <tr>         <th align="left" class="cellrowborder" id="mcps1.3.15.10.2.6.1.1" valign="top" width="22.694538907781556%">          <p>对比指标</p></th>         <th align="left" class="cellrowborder" id="mcps1.3.15.10.2.6.1.2" valign="top" width="18.55371074214843%">          <p>if判断条件为true</p></th>         <th align="left" class="cellrowborder" id="mcps1.3.15.10.2.6.1.3" valign="top" width="19.89397879575915%">          <p>if判断条件为false</p></th>         <th align="left" class="cellrowborder" id="mcps1.3.15.10.2.6.1.4" valign="top" width="19.02380476095219%">          <p>Visibility.Visible</p></th>         <th align="left" class="cellrowborder" id="mcps1.3.15.10.2.6.1.5" valign="top" width="19.83396679335867%">          <p>Visibility.None</p></th>        </tr>       </thead>               <tbody><tr>         <td class="cellrowborder" valign="top" width="22.694538907781556%">          <p>组件创建时间</p></td>         <td class="cellrowborder" valign="top" width="18.55371074214843%">          <p>13.67ms</p></td>         <td class="cellrowborder" valign="top" width="19.89397879575915%">          <p><strong>3.83ms</strong></p></td>         <td class="cellrowborder" valign="top" width="19.02380476095219%">          <p>13.38ms</p></td>         <td class="cellrowborder" valign="top" width="19.83396679335867%">          <p>13.26ms</p></td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="22.694538907781556%">          <p>Measure</p></td>         <td class="cellrowborder" valign="top" width="18.55371074214843%">          <p>2.83ms</p></td>         <td class="cellrowborder" valign="top" width="19.89397879575915%">          <p><strong>0.92ms</strong></p></td>         <td class="cellrowborder" valign="top" width="19.02380476095219%">          <p>2.58ms</p></td>         <td class="cellrowborder" valign="top" width="19.83396679335867%">          <p>2.24ms</p></td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="22.694538907781556%">          <p>Layout</p></td>         <td class="cellrowborder" valign="top" width="18.55371074214843%">          <p>3.79ms</p></td>         <td class="cellrowborder" valign="top" width="19.89397879575915%">          <p><strong>0.30ms</strong></p></td>         <td class="cellrowborder" valign="top" width="19.02380476095219%">          <p>2.14ms</p></td>         <td class="cellrowborder" valign="top" width="19.83396679335867%">          <p>0.39ms</p></td>        </tr>             </tbody></table></div>     </div>     <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content">       <p>以上数据来源均为版本DevEco Studio 4.0.3.415、SDK 4.0.10.9条件下测试得到，不同设备类型数据可能存在差异，测试数据旨在体现性能优化趋势，仅供参考。</p>      </div></div></div>     <p>通过以上数据可以发现：</p>     <ul>      <li>通过if条件判断控制显示与隐藏的方式：       <ul>        <li>对比判断值为true和false时，初次加载过程中Measure、Layout时间明显存在区别，并且从组件创建时间可以判断，加载时会根据初始值判断是否创建对应组件内容。</li>        <li>当条件为false时，对应的组件内容不参与创建、Measure和Layout阶段。</li>       </ul></li>      <li>通过visibility控制显示与隐藏的方式：       <ul>        <li>在初次加载时，无论visibility的值为Visibility.None还是Visibility.Visible都会创建对应组件内容。</li>        <li>visibility属性控制的是Measure和Layout阶段，当visibility属性为Visibility.None时，对应的组件不参与Layout。</li>       </ul></li>     </ul>     <p>在切换显示状态的情况下的结果如下：</p>     <div class="tablenoborder">      <div class="tbBox"><table class="layoutFixed idpTab">       <caption>        <b>表4 </b><strong>使用if条件判断和visibility控制显隐的Measure/Layout时间对比</strong>       </caption>       <thead>        <tr>         <th align="left" class="cellrowborder" id="mcps1.3.15.15.2.6.1.1" valign="top" width="22.694538907781556%">          <p>对比指标</p></th>         <th align="left" class="cellrowborder" id="mcps1.3.15.15.2.6.1.2" valign="top" width="18.55371074214843%">          <p>if判断条件为true</p></th>         <th align="left" class="cellrowborder" id="mcps1.3.15.15.2.6.1.3" valign="top" width="19.89397879575915%">          <p>if判断条件为false</p></th>         <th align="left" class="cellrowborder" id="mcps1.3.15.15.2.6.1.4" valign="top" width="19.02380476095219%">          <p>Visibility.Visible</p></th>         <th align="left" class="cellrowborder" id="mcps1.3.15.15.2.6.1.5" valign="top" width="19.83396679335867%">          <p>Visibility.None</p></th>        </tr>       </thead>               <tbody><tr>         <td class="cellrowborder" valign="top" width="22.694538907781556%">          <p>组件创建时间</p></td>         <td class="cellrowborder" valign="top" width="18.55371074214843%">          <p>13.67ms</p></td>         <td class="cellrowborder" valign="top" width="19.89397879575915%">          <p><strong>3.83ms</strong></p></td>         <td class="cellrowborder" valign="top" width="19.02380476095219%">          <p>\</p></td>         <td class="cellrowborder" valign="top" width="19.83396679335867%">          <p>\</p></td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="22.694538907781556%">          <p>Measure</p></td>         <td class="cellrowborder" valign="top" width="18.55371074214843%">          <p><strong>3.10ms</strong></p></td>         <td class="cellrowborder" valign="top" width="19.89397879575915%">          <p>0.13ms</p></td>         <td class="cellrowborder" valign="top" width="19.02380476095219%">          <p>0.19ms</p></td>         <td class="cellrowborder" valign="top" width="19.83396679335867%">          <p>0.10ms</p></td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="22.694538907781556%">          <p>Layout</p></td>         <td class="cellrowborder" valign="top" width="18.55371074214843%">          <p><strong>1.64ms</strong></p></td>         <td class="cellrowborder" valign="top" width="19.89397879575915%">          <p>0.60ms</p></td>         <td class="cellrowborder" valign="top" width="19.02380476095219%">          <p>0.27ms</p></td>         <td class="cellrowborder" valign="top" width="19.83396679335867%">          <p>0.07ms</p></td>        </tr>             </tbody></table></div>     </div>     <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content">       <p>以上数据来源均为版本DevEco Studio 4.0.3.415、SDK 4.0.10.9条件下测试得到，不同设备类型数据可能存在差异，测试数据旨在体现性能优化趋势，仅供参考。</p>      </div></div></div>     <p>在切换显示状态的情况下：</p>     <ul>      <li>使用if条件判断切换显示时，组件会因为条件改变而判断是否参与创建、布局过程，切换过程会出现较大的Measure的性能消耗，原因是创建了新的组件，重新进行了Measure和Layout的过程。</li>     </ul>     <ul>      <li>使用visibility的情况下，无论是否隐藏，组件在初次已经创建完成，并一直都存在组件树上，不会出现组件重新创建的过程，并且在Measure和Layout阶段的性能消耗比使用if/else的方式性能小很多，原因是组件的计算在首帧时已经计算过，不需要重复计算。</li>     </ul>     <p>综上所述，在控制组件显示与隐藏时，建议遵循以下原则来选择使用控制方式：</p>     <ul>      <li>在对性能要求较高，并且会频繁切换元素的显示与隐藏的情况下，应该避免使用if条件判断，而改为通过visibility的属性控制，这样在切换Visibility.None和Visibility.Visible时，可以省去组件创建的时间，直接进入渲染过程。</li>      <li>如果组件的创建非常消耗资源，且不会立即使用，也并非频繁切换交互的情况下，只在特定条件下才会出现时，可以通过if/else来进行内容的显示与隐藏控制，来达到懒加载的效果。</li>     </ul>    </div>    <div class="tiledSection">     <h3 id="section155313424418">长列表使用懒加载与组件复用<i class="anchor-icon anchor-icon-link" anchorid="section155313424418" tips="复制节点链接"></i></h3>          <p>在列表场景下会采用List、Grid、WaterFlow等组件配合ForEach或者LazyForEach来实现，ForEach适合内容长度确定，内容在两屏以内的列表。LazyForEach适合长度超过两屏的列表情况，并且当内容布局相对固定的情况下，配合组件复用的方式来减少滑动过程中的组件创建。在<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-best-practices-long-list">长列表加载性能优化</a>中，介绍了较为详细的实践案例，这里我们仅引用一些关键性能收益数据。</p>     <p><strong>懒加载</strong></p>     <p>针对长列表这一场景，在本地模拟了10、100、1000、10000条数据，分别使用ForEach、LazyForEach，来测试关闭和开启懒加载情况下的完全显示所用时间、列表挂载时间、独占内存，并分析了其滑动过程中的丢帧率。其中，列表挂载时间是指创建组件和组件挂载数据的总时长。最终，使用DevEco Studio的Profiler工具检测下述指标，得到的数据如下所示：</p>     <div class="tablenoborder">      <div class="tbBox"><table class="layoutFixed idpTab">       <caption>        <b>表5 </b><strong>ForEach在不同数据量下的指标对比</strong>       </caption>       <thead>        <tr>         <th align="left" class="cellrowborder" id="mcps1.3.16.5.2.6.1.1" valign="top" width="20%">          <p>ForEach对比指标</p></th>         <th align="left" class="cellrowborder" id="mcps1.3.16.5.2.6.1.2" valign="top" width="20%">          <p>10条数据</p></th>         <th align="left" class="cellrowborder" id="mcps1.3.16.5.2.6.1.3" valign="top" width="20%">          <p>100条数据</p></th>         <th align="left" class="cellrowborder" id="mcps1.3.16.5.2.6.1.4" valign="top" width="20%">          <p>1000条数据</p></th>         <th align="left" class="cellrowborder" id="mcps1.3.16.5.2.6.1.5" valign="top" width="20%">          <p>10000条数据</p></th>        </tr>       </thead>               <tbody><tr>         <td class="cellrowborder" valign="top" width="20%">          <p>完全显示所用时间</p></td>         <td class="cellrowborder" valign="top" width="20%">          <p>1s 741ms</p></td>         <td class="cellrowborder" valign="top" width="20%">          <p>1s 786ms</p></td>         <td class="cellrowborder" valign="top" width="20%">          <p>1s 942ms</p></td>         <td class="cellrowborder" valign="top" width="20%">          <p>5s 841ms</p></td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="20%">          <p>列表挂载时间</p></td>         <td class="cellrowborder" valign="top" width="20%">          <p>87ms</p></td>         <td class="cellrowborder" valign="top" width="20%">          <p>88ms</p></td>         <td class="cellrowborder" valign="top" width="20%">          <p>135ms</p></td>         <td class="cellrowborder" valign="top" width="20%">          <p>3s 291ms</p></td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="20%">          <p>独占内存（滑动完成后）</p></td>         <td class="cellrowborder" valign="top" width="20%">          <p>38.2MB</p></td>         <td class="cellrowborder" valign="top" width="20%">          <p>48.7MB</p></td>         <td class="cellrowborder" valign="top" width="20%">          <p>83.7MB</p></td>         <td class="cellrowborder" valign="top" width="20%">          <p>560.1MB</p></td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="20%">          <p>丢帧率</p></td>         <td class="cellrowborder" valign="top" width="20%">          <p>0.0%</p></td>         <td class="cellrowborder" valign="top" width="20%">          <p>3.8%</p></td>         <td class="cellrowborder" valign="top" width="20%">          <p>4.5%</p></td>         <td class="cellrowborder" valign="top" width="20%">          <p>58.2%</p></td>        </tr>             </tbody></table></div>     </div>     <div class="tablenoborder">      <div class="tbBox"><table class="layoutFixed idpTab">       <caption>        <b>表6 </b><strong>LazyForEach在不同数据量下的指标对比</strong>       </caption>       <thead>        <tr>         <th align="left" class="cellrowborder" id="mcps1.3.16.6.2.6.1.1" valign="top" width="20%">          <p><strong>Lazy</strong>ForEach对比指标</p></th>         <th align="left" class="cellrowborder" id="mcps1.3.16.6.2.6.1.2" valign="top" width="20%">          <p>10条数据</p></th>         <th align="left" class="cellrowborder" id="mcps1.3.16.6.2.6.1.3" valign="top" width="20%">          <p>100条数据</p></th>         <th align="left" class="cellrowborder" id="mcps1.3.16.6.2.6.1.4" valign="top" width="19.97%">          <p>1000条数据</p></th>         <th align="left" class="cellrowborder" id="mcps1.3.16.6.2.6.1.5" valign="top" width="20.03%">          <p>10000条数据</p></th>        </tr>       </thead>               <tbody><tr>         <td class="cellrowborder" valign="top" width="20%">          <p>完全显示所用时间</p></td>         <td class="cellrowborder" valign="top" width="20%">          <p>1s 544ms</p></td>         <td class="cellrowborder" valign="top" width="20%">          <p>1s 486ms</p></td>         <td class="cellrowborder" valign="top" width="19.97%">          <p>1s 652ms</p></td>         <td class="cellrowborder" valign="top" width="20.03%">          <p>1s 707ms</p></td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="20%">          <p>列表挂载时间</p></td>         <td class="cellrowborder" valign="top" width="20%">          <p>88ms</p></td>         <td class="cellrowborder" valign="top" width="20%">          <p>89ms</p></td>         <td class="cellrowborder" valign="top" width="19.97%">          <p>94ms</p></td>         <td class="cellrowborder" valign="top" width="20.03%">          <p>97ms</p></td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="20%">          <p>独占内存（滑动完成后）</p></td>         <td class="cellrowborder" valign="top" width="20%">          <p>38.1MB</p></td>         <td class="cellrowborder" valign="top" width="20%">          <p>44.6MB</p></td>         <td class="cellrowborder" valign="top" width="19.97%">          <p>46.3MB</p></td>         <td class="cellrowborder" valign="top" width="20.03%">          <p>82.9MB</p></td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="20%">          <p>丢帧率</p></td>         <td class="cellrowborder" valign="top" width="20%">          <p>0.0%</p></td>         <td class="cellrowborder" valign="top" width="20%">          <p>2.3%</p></td>         <td class="cellrowborder" valign="top" width="19.97%">          <p>3.6%</p></td>         <td class="cellrowborder" valign="top" width="20.03%">          <p>6.6%</p></td>        </tr>             </tbody></table></div>     </div>     <p>从测试数据可以看出：</p>     <ol>      <li>在100条数据范围内ForEach和LazyForEach差距不大，总体而言两者各项性能指标都在可接受范围内，而ForEach代码逻辑比LazyForEach简单，此场景下使用ForEach即可。</li>      <li>当数据大于1000条，特别是当数据达到10000条时，ForEach在列表渲染、应用内存占用、丢帧率等各个方面都会有“指数级别”的显著劣化，滑动会出现明显的卡顿，甚至会出现应用crash等现象。</li>      <li>使用LazyForEach除了最后内存稍微增大以外，其列表渲染时间、丢帧率都不会出现明显变化，具有较好的性能。</li>     </ol>     <p></p>     <p><strong>组件复用</strong></p>     <p>对于使用LazyForEach的情况下，在滑动过程中由于要动态创建组件，会出现BuildLazyItem的耗时，通过组件复用能力，可以减少滑动过程中的组件创建耗时，而组件复用BuildRecycle耗时极短，进一步优化滑动时的性能。</p>     <p>对比长列表案例中开启组件复用和未开启的情况下，其数据如下：</p>     <div class="tablenoborder">      <div class="tbBox"><table class="layoutFixed idpTab">       <caption>        <b>表7 </b>组件复用前后丢帧率和耗时分析       </caption>       <thead>        <tr>         <th align="left" class="cellrowborder" id="mcps1.3.16.13.2.4.1.1" valign="top" width="33.3033303330333%">          <p>组件复用</p></th>         <th align="left" class="cellrowborder" id="mcps1.3.16.13.2.4.1.2" valign="top" width="33.36333633363336%">          <p>组件复用前</p></th>         <th align="left" class="cellrowborder" id="mcps1.3.16.13.2.4.1.3" valign="top" width="33.33333333333333%">          <p>组件复用后</p></th>        </tr>       </thead>               <tbody><tr>         <td class="cellrowborder" valign="top" width="33.3033303330333%">          <p>丢帧率</p></td>         <td class="cellrowborder" valign="top" width="33.36333633363336%">          <p>3.7%</p></td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">          <p>0%</p></td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.3033303330333%">          <p>BuildLazyItem耗时</p></td>         <td class="cellrowborder" valign="top" width="33.36333633363336%">          <p>10.277ms</p></td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">          <p>0.749ms</p></td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.3033303330333%">          <p>BuildRecycle耗时</p></td>         <td class="cellrowborder" valign="top" width="33.36333633363336%">          <p>不涉及</p></td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">          <p>0.221ms</p></td>        </tr>             </tbody></table></div>     </div>     <p>可以发现列表滑动时丢帧率明显降低，这是因为，List列表开启了组件复用，不会执行BuildLazyItem这个耗时操作，后续创建新组件节点时，会直接复用缓存区中的节点，这样就大幅节约了组件重新创建的时间。</p>    </div>    <div class="tiledSection">     <h2 id="section12745188175420">合理使用布局组件<i class="anchor-icon anchor-icon-link" anchorid="section12745188175420" tips="复制节点链接"></i></h2>         </div>    <div class="tiledSection">     <h3 id="section5837111044912" class="firsth2">选择合适的布局组件<i class="anchor-icon anchor-icon-link" anchorid="section5837111044912" tips="复制节点链接"></i></h3>          <p>在布局时，子组件会根据父组件的布局算法得到相应的排列规则，然后按照规则进行子组件位置的摆放。不同的布局容器使用的布局算法对性能带来的影响不同。开发者应该根据场景选用合适的布局，除非必须，尽量减少使用性能差的布局组件。</p>     <p>我们常用的基础布局组件包含以下组件：</p>     <ul>      <li>使用Row、Column构建线性布局。</li>      <li>使用Stack构建层叠布局。</li>     </ul>     <p>上述布局都属于线性布局，顾名思义，在线性布局中排布的组件是按照特定的方向线性放置，如横向/纵向/Z序方向。除上述布局类型外，还有一些复杂布局能力，如Flex、List、Grid、RelativeContainer和自定义布局等。</p>     <ul>      <li>使用Flex构建弹性布局。</li>     </ul>     <ul>      <li>List既具备线性布局的特点，同时支持懒加载和滑动的能力。</li>      <li>Grid/GridItem提供了宫格布局的能力，同时也支持懒加载和滑动能力。</li>      <li>RelativeContainer是一种相对布局，通过描述各个内容组件间相互关系来指导内容元素的布局过程，可从横纵两个方面进行布局描述，是一种二维布局算法。</li>     </ul>     <p>复杂布局提供了场景化的能力，解决一种或者多种布局场景。但是在一些场景下，不恰当的使用这些高级组件，可能带来更多的性能消耗。</p>     <p>我们通过对不同的布局方式，设置对应容器相同的嵌套深度为5、总元素节点为20个Text的情况下，来对比其性能消耗。通过Profiler工具获取其首帧绘制时间进行对比。对比结果如下表：</p>     <div class="tablenoborder">      <div class="tbBox"><table class="layoutFixed idpTab">       <caption>        <b>表8 </b><strong>不同布局的首帧绘制时间对比</strong>       </caption>       <thead>        <tr>         <th align="left" class="cellrowborder" id="mcps1.3.18.10.2.7.1.1" valign="top" width="18.04639072185563%">          <p>对比指标</p></th>         <th align="left" class="cellrowborder" id="mcps1.3.18.10.2.7.1.2" valign="top" width="14.407118576284745%">          <p>Column/Row</p></th>         <th align="left" class="cellrowborder" id="mcps1.3.18.10.2.7.1.3" valign="top" width="13.587282543491302%">          <p>Stack</p></th>         <th align="left" class="cellrowborder" id="mcps1.3.18.10.2.7.1.4" valign="top" width="13.617276544691062%">          <p>Flex</p></th>         <th align="left" class="cellrowborder" id="mcps1.3.18.10.2.7.1.5" valign="top" width="17.80643871225755%">          <p>RelativeContainer</p></th>         <th align="left" class="cellrowborder" id="mcps1.3.18.10.2.7.1.6" valign="top" width="22.535492901419715%">          <p>Grid/GridItem</p></th>        </tr>       </thead>               <tbody><tr>         <td class="cellrowborder" valign="top" width="18.04639072185563%">          <p>首帧绘制</p></td>         <td class="cellrowborder" valign="top" width="14.407118576284745%">          <p>7.13ms</p></td>         <td class="cellrowborder" valign="top" width="13.587282543491302%">          <p>7.34ms</p></td>         <td class="cellrowborder" valign="top" width="13.617276544691062%">          <p>11.71ms</p></td>         <td class="cellrowborder" valign="top" width="17.80643871225755%">          <p>9.13ms</p></td>         <td class="cellrowborder" valign="top" width="22.535492901419715%">          <p>12.62ms</p></td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="18.04639072185563%">          <p>Measure</p></td>         <td class="cellrowborder" valign="top" width="14.407118576284745%">          <p>2.63ms</p></td>         <td class="cellrowborder" valign="top" width="13.587282543491302%">          <p>2.70ms</p></td>         <td class="cellrowborder" valign="top" width="13.617276544691062%">          <p>7.59ms</p></td>         <td class="cellrowborder" valign="top" width="17.80643871225755%">          <p>3.59ms</p></td>         <td class="cellrowborder" valign="top" width="22.535492901419715%">          <p>8.68ms</p></td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="18.04639072185563%">          <p>Layout</p></td>         <td class="cellrowborder" valign="top" width="14.407118576284745%">          <p>0.74ms</p></td>         <td class="cellrowborder" valign="top" width="13.587282543491302%">          <p>0.77ms</p></td>         <td class="cellrowborder" valign="top" width="13.617276544691062%">          <p>0.83ms</p></td>         <td class="cellrowborder" valign="top" width="17.80643871225755%">          <p>0.77ms</p></td>         <td class="cellrowborder" valign="top" width="22.535492901419715%">          <p>0.92ms</p></td>        </tr>             </tbody></table></div>     </div>     <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content">       <p>以上数据来源均为版本DevEco Studio 4.0.3.415、SDK 4.0.10.9条件下测试得到，不同设备类型数据可能存在差异，测试数据旨在体现性能优化趋势，仅供参考。</p>      </div></div></div>     <p>可以发现，在布局深度和节点数相同的情况下：</p>     <ul>      <li>使用基础组件如Column和Row容器的性能明显高于其他布局。</li>      <li>Flex的性能明显低于Column和Row容器，这是由于Flex本身带来的二次布局的影响。</li>      <li>Grid/GridItem布局、相对布局RelativeContainer的性能消耗高于基础组件Column、Row、Stack等容器。</li>     </ul>     <p>以上数据都是基于相同布局层数和节点数的情况下的对比结果，反应了布局本身的相对性能消耗，并不意味着使用了该组件性能就一定差，也并非任何情况下使用基础组件都能够保持良好的性能，因为在一些情况下，使用高级组件能够大大减少嵌套层数和节点数，其带来的性能提升反而高于组件本身的性能消耗。所以在使用布局时尽量遵循以下原则：</p>     <ul>      <li>在相同嵌套层级的情况下，如果多种布局方式可以实现相同布局效果，优选低耗时的布局，如使用Column、Row替代Flex实现相同的单行布局。</li>      <li>在能够通过其他布局大幅优化节点数的情况下，可以使用高级组件替代，如使用RelativeContainer替代Row、Column实现扁平化布局，此时其收益大于布局组件本身的性能差距。</li>      <li>仅在必要的场景下使用高耗时的布局组件，如使用Flex实现折行布局、使用Grid实现二维网格布局等。</li>     </ul>    </div>    <div class="tiledSection">     <h3 id="section114841451194917">Scroll嵌套List场景下，给定List组件宽高<i class="anchor-icon anchor-icon-link" anchorid="section114841451194917" tips="复制节点链接"></i></h3>          <p>在使用Scroll容器组件嵌套List组件加载长列表时，若不指定List的宽高尺寸，则默认全部加载。</p>     <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content">       <p>Scroll嵌套List时：</p>       <ul>        <li>List没有设置宽高时，List的所有子组件ListItem都会参与布局。</li>        <li>List设置宽高，只有布局区域内的ListItem子组件会参与布局。</li>        <li>List使用ForEach加载子组件时，无论是否设置List的宽高，都会加载所有子组件。</li>        <li>List使用LazyForEach加载子组件时，没有设置List的宽高，会加载所有子组件，设置了List的宽高，会加载List显示区域内的子组件。</li>       </ul>      </div></div></div>     <p>在如下代码案例中，通过Scroll嵌套List，对比List设置宽度和不设置的情况下：</p>     <div class="screenLinkPre"><div _ngcontent-bcd-c106="" class="highlight-div"><div _ngcontent-bcd-c106="" class="highlight-div-header"><div _ngcontent-bcd-c106="" class="highlight-div-header-left"><div _ngcontent-bcd-c106="" class="handle-button expand-button"><div _ngcontent-bcd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-bcd-c106="" class="highlight-div-header-right"><div _ngcontent-bcd-c106="" class="handle-button ai-button"></div><div _ngcontent-bcd-c106="" class="handle-button line-button"><div _ngcontent-bcd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-bcd-c106="" class="handle-button theme-button"><div _ngcontent-bcd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-bcd-c106="" class="handle-button copy-button"><div _ngcontent-bcd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-bcd-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-cangjie" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/ArkUI/Proper_Use_Layout/entry/src/main/ets/segment/segment1.ets#L17-L96" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">class</span> <span class="hljs-title class_">BasicDataSource</span> <span class="hljs-variable">implements</span> <span class="hljs-variable">IDataSource</span> {</li><li>  <span class="hljs-keyword">private</span> <span class="hljs-variable">listeners</span>: <span class="hljs-title class_">DataChangeListener</span>[] = [];</li><li>  <span class="hljs-keyword">private</span> <span class="hljs-variable">originDataArray</span>: <span class="hljs-title class_">string</span>[] = [];</li><li>
</li><li>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">totalCount</span>(): <span class="hljs-title class_">number</span> {</li><li>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</li><li>  }</li><li>
</li><li>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">getData</span>(<span class="hljs-variable">index</span>: <span class="hljs-title class_">number</span>): <span class="hljs-title class_">string</span> {</li><li>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.<span class="hljs-variable">originDataArray</span>[<span class="hljs-variable">index</span>];</li><li>  }</li><li>
</li><li>  <span class="hljs-title function_">registerDataChangeListener</span>(<span class="hljs-variable">listener</span>: <span class="hljs-title class_">DataChangeListener</span>): <span class="hljs-title class_">void</span> {</li><li>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.<span class="hljs-variable">listeners</span>.<span class="hljs-title function_">indexOf</span>(<span class="hljs-variable">listener</span>) &lt; <span class="hljs-number">0</span>) {</li><li>      <span class="hljs-variable">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">'add listener'</span>);</li><li>      <span class="hljs-keyword">this</span>.<span class="hljs-variable">listeners</span>.<span class="hljs-title function_">push</span>(<span class="hljs-variable">listener</span>);</li><li>    }</li><li>  }</li><li>
</li><li>  <span class="hljs-title function_">unregisterDataChangeListener</span>(<span class="hljs-variable">listener</span>: <span class="hljs-title class_">DataChangeListener</span>): <span class="hljs-title class_">void</span> {</li><li>    <span class="hljs-keyword">const</span> <span class="hljs-variable">pos</span> = <span class="hljs-keyword">this</span>.<span class="hljs-variable">listeners</span>.<span class="hljs-title function_">indexOf</span>(<span class="hljs-variable">listener</span>);</li><li>    <span class="hljs-keyword">if</span> (<span class="hljs-variable">pos</span> &gt;= <span class="hljs-number">0</span>) {</li><li>      <span class="hljs-variable">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">'remove listener'</span>);</li><li>      <span class="hljs-keyword">this</span>.<span class="hljs-variable">listeners</span>.<span class="hljs-title function_">splice</span>(<span class="hljs-variable">pos</span>, <span class="hljs-number">1</span>);</li><li>    }</li><li>  }</li><li>
</li><li>  <span class="hljs-title function_">notifyDataReload</span>(): <span class="hljs-title class_">void</span> {</li><li>    <span class="hljs-keyword">this</span>.<span class="hljs-variable">listeners</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-variable">listener</span> =&gt; {</li><li>      <span class="hljs-variable">listener</span>.<span class="hljs-title function_">onDataReloaded</span>();</li><li>    });</li><li>  }</li><li>
</li><li>  <span class="hljs-title function_">notifyDataAdd</span>(<span class="hljs-variable">index</span>: <span class="hljs-title class_">number</span>): <span class="hljs-title class_">void</span> {</li><li>    <span class="hljs-keyword">this</span>.<span class="hljs-variable">listeners</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-variable">listener</span> =&gt; {</li><li>      <span class="hljs-variable">listener</span>.<span class="hljs-title function_">onDataAdd</span>(<span class="hljs-variable">index</span>);</li><li>    });</li><li>  }</li><li>
</li><li>  <span class="hljs-title function_">notifyDataChange</span>(<span class="hljs-variable">index</span>: <span class="hljs-title class_">number</span>): <span class="hljs-title class_">void</span> {</li><li>    <span class="hljs-keyword">this</span>.<span class="hljs-variable">listeners</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-variable">listener</span> =&gt; {</li><li>      <span class="hljs-variable">listener</span>.<span class="hljs-title function_">onDataChange</span>(<span class="hljs-variable">index</span>);</li><li>    });</li><li>  }</li><li>
</li><li>  <span class="hljs-title function_">notifyDataDelete</span>(<span class="hljs-variable">index</span>: <span class="hljs-title class_">number</span>): <span class="hljs-title class_">void</span> {</li><li>    <span class="hljs-keyword">this</span>.<span class="hljs-variable">listeners</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-variable">listener</span> =&gt; {</li><li>      <span class="hljs-variable">listener</span>.<span class="hljs-title function_">onDataDelete</span>(<span class="hljs-variable">index</span>);</li><li>    });</li><li>  }</li><li>
</li><li>  <span class="hljs-title function_">notifyDataMove</span>(<span class="hljs-keyword">from</span>: <span class="hljs-title class_">number</span>, <span class="hljs-variable">to</span>: <span class="hljs-title class_">number</span>): <span class="hljs-title class_">void</span> {</li><li>    <span class="hljs-keyword">this</span>.<span class="hljs-variable">listeners</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-variable">listener</span> =&gt; {</li><li>      <span class="hljs-variable">listener</span>.<span class="hljs-title function_">onDataMove</span>(<span class="hljs-keyword">from</span>, <span class="hljs-variable">to</span>);</li><li>    });</li><li>  }</li><li>}</li><li>
</li><li>
</li><li><span class="hljs-variable">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyDataSource</span> <span class="hljs-variable">extends</span> <span class="hljs-variable">BasicDataSource</span> {</li><li>  <span class="hljs-keyword">private</span> <span class="hljs-variable">dataArray</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">string</span>&gt; = <span class="hljs-variable">new</span> <span class="hljs-title function_">Array</span>(<span class="hljs-number">100</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-string">'test'</span>);</li><li>
</li><li>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">totalCount</span>(): <span class="hljs-title class_">number</span> {</li><li>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.<span class="hljs-variable">dataArray</span>.<span class="hljs-variable">length</span>;</li><li>  }</li><li>
</li><li>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">getData</span>(<span class="hljs-variable">index</span>: <span class="hljs-title class_">number</span>): <span class="hljs-title class_">string</span> {</li><li>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.<span class="hljs-variable">dataArray</span>[<span class="hljs-variable">index</span>];</li><li>  }</li><li>
</li><li>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">addData</span>(<span class="hljs-variable">index</span>: <span class="hljs-title class_">number</span>, <span class="hljs-variable">data</span>: <span class="hljs-title class_">string</span>): <span class="hljs-title class_">void</span> {</li><li>    <span class="hljs-keyword">this</span>.<span class="hljs-variable">dataArray</span>.<span class="hljs-title function_">splice</span>(<span class="hljs-variable">index</span>, <span class="hljs-number">0</span>, <span class="hljs-variable">data</span>);</li><li>    <span class="hljs-keyword">this</span>.<span class="hljs-title function_">notifyDataAdd</span>(<span class="hljs-variable">index</span>);</li><li>  }</li><li>
</li><li>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">pushData</span>(<span class="hljs-variable">data</span>: <span class="hljs-title class_">string</span>): <span class="hljs-title class_">void</span> {</li><li>    <span class="hljs-keyword">this</span>.<span class="hljs-variable">dataArray</span>.<span class="hljs-title function_">push</span>(<span class="hljs-variable">data</span>);</li><li>    <span class="hljs-keyword">this</span>.<span class="hljs-title function_">notifyDataAdd</span>(<span class="hljs-keyword">this</span>.<span class="hljs-variable">dataArray</span>.<span class="hljs-variable">length</span> - <span class="hljs-number">1</span>);</li><li>  }</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/ArkUI/Proper_Use_Layout/entry/src/main/ets/segment/segment1.ets#L17-L96" target="_blank">segment1.ets</a></div></div></div></div>    </div>    <p>不设置宽高的代码样例如下：</p>    <div class="screenLinkPre"><div _ngcontent-bcd-c106="" class="highlight-div"><div _ngcontent-bcd-c106="" class="highlight-div-header"><div _ngcontent-bcd-c106="" class="highlight-div-header-left"><div _ngcontent-bcd-c106="" class="handle-button expand-button"><div _ngcontent-bcd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-bcd-c106="" class="highlight-div-header-right"><div _ngcontent-bcd-c106="" class="handle-button ai-button"></div><div _ngcontent-bcd-c106="" class="handle-button line-button"><div _ngcontent-bcd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-bcd-c106="" class="handle-button theme-button"><div _ngcontent-bcd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-bcd-c106="" class="handle-button copy-button"><div _ngcontent-bcd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-bcd-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-typescript" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/ArkUI/Proper_Use_Layout/entry/src/main/ets/segment/segment2.ets#L17-L39" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">import</span> { <span class="hljs-title class_">MyDataSource</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./segment1'</span>;</li><li>
</li><li><span class="hljs-meta">@Entry</span></li><li><span class="hljs-meta">@Component</span></li><li>struct <span class="hljs-title class_">NotSetHeightTestPage</span> {</li><li>  <span class="hljs-keyword">private</span> <span class="hljs-attr">data</span>: <span class="hljs-title class_">MyDataSource</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyDataSource</span>();</li><li>
</li><li>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) {</li><li>    <span class="hljs-title class_">Scroll</span>() {</li><li>      <span class="hljs-title class_">List</span>() {</li><li>        <span class="hljs-title class_">LazyForEach</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>, <span class="hljs-function">(<span class="hljs-params">item: <span class="hljs-built_in">string</span>, index: <span class="hljs-built_in">number</span></span>) =&gt;</span> {</li><li>          <span class="hljs-title class_">ListItem</span>() {</li><li>            <span class="hljs-title class_">Row</span>() {</li><li>              <span class="hljs-title class_">Text</span>(<span class="hljs-string">'item value: '</span> + item + (index + <span class="hljs-number">1</span>))</li><li>                .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">20</span>)</li><li>                .<span class="hljs-title function_">margin</span>(<span class="hljs-number">10</span>)</li><li>            }</li><li>          }</li><li>        })</li><li>      }</li><li>    }</li><li>  }</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/ArkUI/Proper_Use_Layout/entry/src/main/ets/segment/segment2.ets#L17-L39" target="_blank">segment2.ets</a></div></div></div></div>    <p>设置固定高度的代码如下：</p>    <div class="screenLinkPre"><div _ngcontent-bcd-c106="" class="highlight-div"><div _ngcontent-bcd-c106="" class="highlight-div-header"><div _ngcontent-bcd-c106="" class="highlight-div-header-left"><div _ngcontent-bcd-c106="" class="handle-button expand-button"><div _ngcontent-bcd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-bcd-c106="" class="highlight-div-header-right"><div _ngcontent-bcd-c106="" class="handle-button ai-button"></div><div _ngcontent-bcd-c106="" class="handle-button line-button"><div _ngcontent-bcd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-bcd-c106="" class="handle-button theme-button"><div _ngcontent-bcd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-bcd-c106="" class="handle-button copy-button"><div _ngcontent-bcd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-bcd-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-typescript" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/ArkUI/Proper_Use_Layout/entry/src/main/ets/segment/segment3.ets#L17-L41" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">import</span> { <span class="hljs-title class_">MyDataSource</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./segment1'</span>;</li><li>
</li><li><span class="hljs-meta">@Entry</span></li><li><span class="hljs-meta">@Component</span></li><li>struct <span class="hljs-title class_">SetHeightTestPage</span> {</li><li>  <span class="hljs-keyword">private</span> <span class="hljs-attr">data</span>: <span class="hljs-title class_">MyDataSource</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyDataSource</span>();</li><li>
</li><li>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) {</li><li>    <span class="hljs-title class_">Scroll</span>() {</li><li>      <span class="hljs-title class_">List</span>() {</li><li>        <span class="hljs-title class_">LazyForEach</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>, <span class="hljs-function">(<span class="hljs-params">item: <span class="hljs-built_in">string</span>, index: <span class="hljs-built_in">number</span></span>) =&gt;</span> {</li><li>          <span class="hljs-title class_">ListItem</span>() {</li><li>            <span class="hljs-title class_">Row</span>() {</li><li>              <span class="hljs-title class_">Text</span>(<span class="hljs-string">'item value: '</span> + item + (index + <span class="hljs-number">1</span>))</li><li>                .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">20</span>)</li><li>                .<span class="hljs-title function_">margin</span>(<span class="hljs-number">10</span>)</li><li>            }</li><li>          }</li><li>        })</li><li>      }</li><li>      .<span class="hljs-title function_">width</span>(<span class="hljs-string">'100%'</span>)</li><li>      .<span class="hljs-title function_">height</span>(<span class="hljs-number">500</span>)</li><li>    }</li><li>  }</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/ArkUI/Proper_Use_Layout/entry/src/main/ets/segment/segment3.ets#L17-L41" target="_blank">segment3.ets</a></div></div></div></div>    <p>通过DevEco Studio的Profiler抓取launch数据可以得到如下：</p>    <div class="fignone">     <span class="figcap"><b>图2 </b>List宽高不固定</span>     <br><span><img height="123.69000000000001" originheight="324" originwidth="1366" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211162905.61626445818140717451077803624651:50001231000000:2800:7CB01D2E9926515E613CCD83568EC3AAF9021292472B123CAC40F0D43682A8C7.png" title="点击放大" width="523.6875"></span>    </div>    <div class="fignone">     <span class="figcap"><b>图3 </b>List宽高固定</span>     <br><span><img height="137.655" originheight="364" originwidth="1379" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211162905.80658392658264617627245085857819:50001231000000:2800:C717D898EF55C481EA3E509CC194B8A25F3A45824F81B56A080DF5A509D1F5D1.png" title="点击放大" width="523.6875"></span>    </div>    <div class="tablenoborder">     <div class="tbBox"><table class="layoutFixed idpTab">      <caption>       <b>表9 </b>不设置List宽高与设置宽高对比数据      </caption>      <thead>       <tr>        <th align="left" class="cellrowborder" id="mcps1.3.27.2.4.1.1" valign="top" width="33.33333333333333%">         <p>对比数据</p></th>        <th align="left" class="cellrowborder" id="mcps1.3.27.2.4.1.2" valign="top" width="33.33333333333333%">         <p>List宽高不固定</p></th>        <th align="left" class="cellrowborder" id="mcps1.3.27.2.4.1.3" valign="top" width="33.33333333333333%">         <p>List宽高固定</p></th>       </tr>      </thead>             <tbody><tr>        <td class="cellrowborder" valign="top" width="33.33333333333333%">         <p>布局任务数量LayoutTasks/个</p></td>        <td class="cellrowborder" valign="top" width="33.33333333333333%">         <p>100</p></td>        <td class="cellrowborder" valign="top" width="33.33333333333333%">         <p>12</p></td>       </tr>       <tr>        <td class="cellrowborder" valign="top" width="33.33333333333333%">         <p>布局时间/ms</p></td>        <td class="cellrowborder" valign="top" width="33.33333333333333%">         <p>32.43</p></td>        <td class="cellrowborder" valign="top" width="33.33333333333333%">         <p>6.08</p></td>       </tr>           </tbody></table></div>    </div>    <p>未设置宽高的情况下，在进行布局时，从FlushLayoutTask以及FlushRenderTask的数据可以看到参与布局的组件数量是100个，设置了List宽高的情况下，从FlushLayoutTask以及FlushRenderTask的数据可以看到参与布局的组件数量是12个。说明对于Scroll嵌套List的情况下，如果不设置List宽高，由于Scroll是可滚动容器，其高度为无穷大，List在不设置的高度的情况下，高度也为无穷大，所以此时会创建所有的内容。而设置了高度的情况下，只会创建给定高度内的组件内容，所以为12个。体现在布局时间上，没有设置宽高的情况下，总体布局时间是32.43ms，设置了固定宽高数值的情况下，时间为6.08ms，大幅提升了首次加载时的性能。</p>    <p></p>    <div class="tiledSection">     <h2 id="section1285019510551">问题定位工具<i class="anchor-icon anchor-icon-link" anchorid="section1285019510551" tips="复制节点链接"></i></h2>          <p>性能是一个涉及许多方面的复杂问题。DevEco Studio提供了工具可以为您提供关于性能瓶颈发生位置的明确提示，使用工具Profiler 查看性能参数可以参考<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-profiler-introduction" target="_blank">使用Profiler进行性能调优</a>，使用ArkUI Inspector查看组件树结构可以参考<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-arkui-inspector" target="_blank">布局分析</a>。</p>    </div>   </div>   <div></div></div>