<h1 _ngcontent-yio-c119="" class="doc-title ng-star-inserted" title="帧率问题分析"> 帧率问题分析 </h1>

<div _ngcontent-yio-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;">   <div>    <div class="tiledSection">     <h2 id="section111332546102">丢帧问题原理<i class="anchor-icon anchor-icon-link" anchorid="section111332546102" tips="复制节点链接"></i></h2>          <p>在定位应用丢帧问题前，需要了解HarmonyOS中图形渲染的流程，便于分析卡顿的阶段和原因。</p>     <p>HarmonyOS图形系统采用统一渲染模式，遵循流水线模式。90Hz刷新率下，每个Vsync周期是11.1ms。60Hz刷新率下，每个Vsync周期是16.7ms。120Hz刷新率下，每个Vsync周期是8.3ms。</p>     <div class="fignone">      <span class="figcap"><b>图1 </b>90Hz刷新率渲染流程</span>      <p><span><img height="166.68890000000002" originheight="338" originwidth="1726" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163405.14840557252347933993034933774910:50001231000000:2800:38EB003D2A5D621F804D3B1909B73C4C291E006AD03DCAA7B157DAF4F6439496.png" title="点击放大" width="851.2"></span></p>     </div>     <p>在整个渲染流程中，应用侧首先响应屏幕点击等输入事件，处理后提交给Render Service。Render Service协调GPU等资源处理，最终将图像送到屏幕上显示。</p>     <ol>      <li>应用侧处理用户的屏幕点击等输入事件，生成界面描述数据结构。数据包括UI元素的位置、大小、资源、绘制指令及动效属性。</li>      <li>Render Service是图形栈中负责界面内容绘制的模块，主要职责是对接ArkUI框架，支撑ArkUI应用的界面显示，包括控件和动效等UI元素。Render Service的RenderThread线程在Vsync信号触发下进行UI绘制，绘制过程包含三个阶段：动效、描画和提交。</li>      <li>Display是显示屏幕的抽象概念，既包括实际的物理屏，也包括虚拟屏。</li>     </ol>     <p>其中应用侧的渲染流程如下图所示，了解ArkUI的渲染流程有助于定位应用侧的卡顿问题。如下图所示：</p>     <div class="fignone">      <span class="figcap"><b>图2 </b>ArkUI渲染管线结构与Frame Insight性能打点</span>      <br><span><img height="225.30200000000002" originheight="433" originwidth="1714" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163405.89891652103046398700593410431932:50001231000000:2800:158646EA26BB91711D9EE17F20E0D21EE177EC2F2CF38934E0D59A55CF9D15DF.png" title="点击放大" width="851.2"></span>     </div>     <ul>      <li>Animation：动画阶段，动画过程中会修改相应的FrameNode节点，触发脏区标记。在特定场景下，会执行用户侧ETS代码实现自定义动画。</li>      <li>Events：事件处理阶段，例如手势事件处理。手势处理过程中会修改FrameNode节点，触发脏区标记。在特定场景下，会执行用户侧ETS代码实现自定义事件。</li>      <li>UpdateUI：自定义组件（@Component）在首次创建挂载或状态变量变更时会标记为需要重建状态。在下一次Vsync到来时，执行重建流程，生成相应的组件树结构和属性样式修改任务。</li>      <li>Measure：布局包装器执行相关的大小测算任务，确定UI元素的尺寸。</li>      <li>Layout：布局包装器执行相关的布局任务，确定UI元素的位置。</li>      <li>Render：绘制任务包装器执行相关的绘制任务，完成后标记请求刷新RSNode绘制。</li>      <li>SendMessage：请求刷新界面绘制，确保界面更新。</li>     </ul>     <p>应用侧和Render Service侧可能出现卡顿，最终用户会观测到丢帧。我们将这两种情况分别命名为AppDeadlineMissed和RenderDeadlineMissed。AppDeadlineMissed通常由应用逻辑代码处理效率低引起，RenderDeadlineMissed则可能由界面结构复杂或GPU渲染负载高导致。这两个故障模型在Frame模板中可以直观地看到。相关故障模型如下面两幅图所示：</p>     <div class="fignone">      <span class="figcap"><b>图3 </b>应用卡顿导致丢帧的故障模型</span>     </div>     <p><span><img height="184.28480000000002" originheight="324" originwidth="1403" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163405.79791264257724930912573148945347:50001231000000:2800:21599A02473AFC925B00FD3602C83E6E57F4CF33F1B947935AC554C936E147B4.png" title="点击放大" width="798"></span></p>     <div class="fignone">      <span class="figcap"><b>图4 </b>Render Service卡顿导致丢帧的故障模型</span>     </div>     <p><span><img height="180.08200000000002" originheight="320" originwidth="1418" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163405.80867564138859092204218311467420:50001231000000:2800:C4A11AF51B59CCFCA6EDF45E8643D46151EF7FE4EF4024D9F32F69AECE5D6CE0.png" title="点击放大" width="798"></span></p>    </div>    <div class="tiledSection">     <h2 id="section16554191716487">丢帧问题思路分析<i class="anchor-icon anchor-icon-link" anchorid="section16554191716487" tips="复制节点链接"></i></h2>          <p>下图展示了解决丢帧问题的简要流程：</p>     <div class="fignone">      <span class="figcap"><b>图5 </b>丢帧问题处理流程</span>      <br><span><img originheight="502" originwidth="473" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163405.54943777144168746110758554901118:50001231000000:2800:1A0BEE04886E26FD1C7314AAC7E0E9063ECDE051C3DED405F91B24779A6B5D63.png" width="473" height="502"></span>     </div>     <p>从上图可以看到处理丢帧问题可以采用以下步骤：</p>     <ol>      <li><span>识别卡顿：首先使用<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-app-analyzer" target="_blank">AppAnalyzer</a>检测滑动场景是否存在性能问题，如果检测存在丢帧，会得到相应的体检报告。</span></li>      <li><span>查看建议：在体检报告中，可以看到工具定位出的故障位置，优化建议等。</span></li>      <li><span>分析原因：根据工具的建议，结合代码逻辑，分析判断产生性能问题的原因。也可以结合代码分析Trace、查看函数调用栈等定位丢帧原因。</span></li>      <li><span>选择优化方案：根据分析的丢帧原因，选择适合的优化方案。</span></li>      <li><span>验证优化效果：优化完成后需要重新测试验证丢帧问题是否得到解决。</span></li>     </ol>     <p>本文以“<a href="https://gitee.com/harmonyos_samples/hmosworld#hmos世界" target="_blank">HMOS世界</a>”应用的首页列表为例，介绍通过Frame分析、定位和解决卡顿问题的全过程。为了便于演示，列表初始加载了1000条数据。</p>     <p>在滑动列表时，会逐渐出现卡顿现象。接下来，我们将介绍如何分析并解决卡顿问题。</p>     <div class="fignone">      <span class="figcap"><b>图6 </b>”HMOS世界”首页长列表示意图</span>     </div>     <p><span><img height="549.024" originheight="1026" originwidth="494" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163405.27442343584043134727238340490607:50001231000000:2800:739F3249928D2A2341FB939A94BDEF637826996A614060EE69C2ACADC6250F55.png" title="点击放大" width="266"></span></p>    </div>    <div class="tiledSection">     <h3 id="section114240360418" class="firsth2">第1步：丢帧问题检测<i class="anchor-icon anchor-icon-link" anchorid="section114240360418" tips="复制节点链接"></i></h3>          <p><strong>使用AppAnalyzer检测性能问题</strong></p>     <p>首先使用AppAnalyzer工具进行性能问题检测，AppAnalyzer是DevEco Studio中提供的检测评分工具，用于测试并评价HarmonyOS应用或元服务的质量，能快速提供评估结果和改进建议，当前支持的测试类型包括兼容性、性能、UX测试和最佳实践等。因为本文主要是介绍丢帧问题的分析，所以下面重点介绍了使用AppAnalyzer对列表滑动响应和滑动过程中的流畅性能检测，具体使用可参考<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-app-analyzer" target="_blank">《应用与元服务体检》</a>。</p>     <p>在进行规则体检或场景化体检之前，先要确保<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-run-device" target="_blank">DevEco Studio与真机设备已连接</a>，并根据<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-signing" target="_blank">应用/元服务签名</a>章节进行签名，再编译生成HAP或HSP。</p>     <ol>      <li><span>在DevEco Studio中启动AppAnalyzer工具，详细请参考：<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-performance-detection#section135451444171" target="_blank">AppAnalyzer</a>。</span>       <p></p>       <p><span><img height="589.6156" originheight="788" originwidth="711" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163405.28726298899065188961115646422694:50001231000000:2800:A22DFE96E8B8BEEE9F656346D6BF620F6AF9E65E024178AACCBD1745B638CD35.png" title="点击放大" width="532"></span></p>       <p></p></li>      <li><span>执行滑动场景体检。选择场景化体检，然后点击“手动性能页面滑动体检”，工具会进行准备，自动编译、安装、运行当前工程，需要保持手机解锁状态。</span>       <p></p>       <ol>        <li>当提示“准备完成，请操作手机至检测页面”等内容时，需要在手机应用中找到待检测的滑动页面，然后点击开始按钮。         <p><span><img height="367.87800000000004" originheight="659" originwidth="953" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163405.83006327961828326652202599418978:50001231000000:2800:D355145167B60B5E50B53F6F930961F4BAD9901E332327BF6711B1B08EF65B77.png" title="点击放大" width="532"></span></p></li>        <li>等待工具录制准备，当提示“体检中，请操作手机”时，在手机上的待检测页面执行滑动若干次。等待剩余时间结束或点击暂停按钮，再点击停止完成本次检测。         <p><span><img height="369.1814" originheight="653" originwidth="941" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163405.36109376091494160180115747309535:50001231000000:2800:4F7FF1CF55EC800C1091F55189CA4B58DA41B62C14868C6F8C0219870BC61D20.png" title="点击放大" width="532"></span></p></li>       </ol>       <p></p></li>      <li><span>生成性能体检报告。工具分析后，若检测未通过如下所示。</span>       <p></p>       <p><span><img height="456.00380000000007" originheight="744" originwidth="868" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163405.59292538813304695766734835853493:50001231000000:2800:7FB303D827FC99B111618F1A2B1DCBA463DDF2A680C1588EE327D5FAECD0592D.png" title="点击放大" width="532"></span></p>       <p></p></li>     </ol>    </div>    <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content">      <p>AppAnalyzer在以下场景中可能检测不到丢帧：</p>      <p>页面中视频播放或动画运行时存在补帧，此时检测页面内的UI滑动组件。例如视频播放页中的滑动评论区，对评论区进行滑动场景检测，可能识别不了丢帧。</p>     </div></div></div>    <div class="tiledSection">     <h3 id="section117831333645">第2步：丢帧问题分析<i class="anchor-icon anchor-icon-link" anchorid="section117831333645" tips="复制节点链接"></i></h3>          <p>AppAnalyzer在详情报告中会显示具体的故障原因，并提供相应的优化建议。此处列举以下问题原因进行说明：</p>     <p><strong>问题1：UI线程应用自身方法耗时长</strong></p>     <p>UI线程方法耗时过长会导致滑动卡顿，工具会将耗时长的函数方法名、总耗时、平均耗时、执行次数等，以表格形式呈现出来。</p>     <p>当开发者点击函数超链接，可以直接跳转到代码行，当开发者点击总耗时列的超链接，可以跳转到profiler并看到函数内部Callstack泳道。开发者可以根据表格信息检视代码进行优化。</p>     <p>具体有以下三种情况：</p>     <ul>      <li>如果函数的单次调用耗时长（查看平均耗时），说明是函数本身耗时长，开发者自行优化函数，将函数放到子线程或者进行缓存，开发者可参考<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-time-optimization-of-the-main-thread#section4365993361" target="_blank">其他主线程优化思路</a>。       <p><span><img height="185.3537142857143" originheight="294" originwidth="1483" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163405.27465741562972151653028688815285:50001231000000:2800:A6F98150D554C69E3C3A52ABA69246D7F13BDB38C1160FF15D23C33381A9F3F1.png" title="点击放大" width="920"></span></p></li>      <li>如果函数本身耗时不长，但是函数调用次数多（例如在高频回调里打日志等操作）       <p><span><img height="121.47942857142858" originheight="186" originwidth="1448" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163406.69313915611622812654568481843304:50001231000000:2800:3AF27FAF603B3D376C9BFD9DC65B7EB390D26CC5B211B21AACA3AEE2F8428E15.png" title="点击放大" width="920"></span></p>       <p>确认函数是不是每次都要调用，能否通过一些全局或者缓存的方式降低调用次数，避免高频回调，开发者可参考<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-time-optimization-of-the-main-thread#section10112623611" target="_blank">高频回调场景</a>。</p></li>      <li>如果方法名aboutToBeDeleted调用次数过多，如下图所示：       <p><span><img height="65.21485714285714" originheight="97" originwidth="1447" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163406.08311702900189131575920737752237:50001231000000:2800:D0CD73CE946667957972571C7AF09DC1E2D2D1A5602EF93160E0BDB8C9E8D594.png" title="点击放大" width="920"></span></p>       <p>此时需要点击<strong>总耗时</strong>列的超链接，打开trace向前排查主线程是否有阻塞。如下图所示也是因为前面的主线程阻塞导致的，因为destroy只会发生在idle，如果主线程阻塞一直没有idle，就会积压；</p>       <p><span><img height="589.3097" originheight="1587" originwidth="2149" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163406.89328357725793987259560641531641:50001231000000:2800:33CCF1785E8291A530953EF00797AF81DAB952FEED0D395FAEFE10A962EC3BC3.png" title="点击放大" width="798"></span></p>       <p>解决方案：可以采用并行化，或者缓存的方式来优化业务逻辑。开发者可参考<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-time-optimization-of-the-main-thread#section4365993361" target="_blank">其他主线程优化思路</a>。</p>       <p>设置子线程优先级的方法有两种，具体可参考：<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-taskpool#priority" target="_blank">Priority</a>和<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/qos-guidelines" target="_blank">QoS开发指导</a>。</p></li>     </ul>     <p><strong>问题2：组件未有效复用</strong></p>     <p>工具通过实时检测组件的复用情况，有效避免组件对象在运行过程中被频繁创建与销毁，从而减少内存回收的频率，提升整体性能。</p>     <p>在测试结果列表中，工具会明确标识出滑动等高频操作中存在创建行为的组件，这些组件可能存在优化空间，建议结合“<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-component-reuse" target="_blank">组件复用</a>”机制进行相应调整。组件的复用更新流程与常规状态管理更新方式保持一致，具体可参考<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-status-management" target="_blank">状态管理最佳实践</a>。各种复用问题的分析优化可参考<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-component-reuse-issue-diagnosis-and-analysis">组件复用问题诊断分析</a>。</p>     <p><span><img height="340.8337142857143" originheight="546" originwidth="1484" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163406.55351028544748452730390191593178:50001231000000:2800:B167D12E90C0FD8D1072A22C15F12E89201DD1A465A2796F8AAB4EBD126EEBAE.png" title="点击放大" width="920"></span></p>     <p><strong>问题3：图片纹理过大</strong></p>     <p><span><img height="195.868" originheight="311" originwidth="1483" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163406.08813137746350105838185308342341:50001231000000:2800:90807BA9FE1528E878998092BB391C83AE4550F21AB85DCF54D888A2A14B8B59.png" title="点击放大" width="920"></span></p>     <p>开发者可以根据<strong>图片组件所在源码文件</strong>，以及<strong>图片来源</strong>中的路径信息，查找图片并修改；</p>     <p><strong>图片来源</strong>有 5 种：</p>     <ul>      <li>代码工程 rawfile 目录图片路径，可通过点击图片来源超链接直接在 IDE 中预览。</li>      <li>代码工程 media 目录图片路径，可通过点击图片来源超链接直接在 IDE 中预览。</li>      <li>沙箱图片路径，是应用的独立沙箱空间存储位置。</li>      <li>共享媒体库目录图片路径，可被多个应用或用户共同访问的媒体文件存储位置。</li>      <li>网络图片路径，可通过点击图片来源超链接直接在浏览器中预览。</li>     </ul>     <p><strong>源图尺寸</strong>显示源图的宽 (px)× 高 (px)。</p>     <p><strong>目标尺寸</strong>显示实际 Image 组件的宽 (px)× 高 (px)。</p>     <p><strong>超出尺寸占比</strong>表示源图超过目标尺寸的程度。</p>     <p>图片大纹理检测尺寸大于 256*256 像素且超出组件尺寸 10% 的图片建议开发者优化，针对不同来源与种类的图片可以采取每行对应的优化建议进行修改。例如，针对IDE中存放的本地图片可参考<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-texture-compression-improve-performance" target="_blank">图片资源加载优化</a>，针对沙箱类型的图片可以设置Image组件的<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-image#autoresize" target="_blank">autoResize属性</a>为true来让源图尺寸贴近组件尺寸，针对网络图片可以采取webp的压缩手段缩小图片体积，针对Gif图片可以降低每帧分辨率。</p>    </div>    <div class="tiledSection">     <h3 id="section1246411481617">第3步：验证优化效果<i class="anchor-icon anchor-icon-link" anchorid="section1246411481617" tips="复制节点链接"></i></h3>          <p>使用合理的优化方案修改工程后，可以再次使AppAnalyzer进行测试，验证优化后的效果。当没有异常信息报告时，表明这次优化达到了预期。</p>     <p>如下图所示：</p>     <p><span><img height="453.1177" originheight="758" originwidth="891" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163406.39541397009098304961509841044432:50001231000000:2800:FEA45A069351303619124AFF23BCAB2820BC6ECC3A9FDF4B9C06FC3F92DC1A30.png" title="点击放大" width="532"></span></p>     <p>如果问题仍未解决，可以根据建议，进一步分析Trace定位问题，然后选择优化方式。</p>    </div>    <div class="tiledSection">     <h3 id="section155462513445">使用Trace分析定位丢帧问题<i class="anchor-icon anchor-icon-link" anchorid="section155462513445" tips="复制节点链接"></i></h3>          <p><strong>录制Frame模板</strong></p>     <p>发现卡顿丢帧问题后，创建Frame模板进行录制。在录制期间，复现卡顿丢帧场景。具体操作步骤请参见<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/deep-recording" target="_blank">性能问题定位：深度录制</a>。</p>     <p>录制完成后，在时间轴上拖动鼠标选定要查看的时间段，例如2.5秒的时间区段。选中Frame主泳道，查看Statistics栏，可以发现应用在这个时间段内丢失了16帧，丢帧率为7%。</p>     <p><span><img height="263.2868" originheight="602" originwidth="1849" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163406.07035323227870715919919838166589:50001231000000:2800:66FB4AAB414756F4025F033DC675F70CB1ACC1A35C0C84238E41B11D59D00172.png" title="点击放大" width="798"></span></p>     <p><strong>认识卡顿帧</strong></p>     <p>使用Frame Profiler录制了一段Trace。在时间轴上拖动鼠标选定要查看的时间段，选择了一个2.5秒的时间区段。选中Frame主泳道，查看下面的Statistics栏，发现应用在这个时间段内丢失了16帧，丢帧率为7%。</p>     <p><span><img height="263.2868" originheight="602" originwidth="1849" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163406.74124125857976126154561657467035:50001231000000:2800:369B0DFDF34FCBFA6EE0E03C299E2BEB8E6A60E1EA9977F8884D93D1EF56CD97.png" title="点击放大" width="798"></span></p>     <p>丢帧问题可能出现在Render Service或App侧。上图中的丢帧主要出现在应用帧，针对这种现象，继续分析，放大右侧图表，选中超时帧查看详细数据。期望时间为8.3毫秒（当前设备为120赫兹），而实际处理时间为8.9毫秒。</p>     <p><span><img height="293.37140000000005" originheight="686" originwidth="1866" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163406.56959428291026978378619014219941:50001231000000:2800:BCD177BEFEBB0E4513A303FCC0FDE64BDEE0659CD3AC1A694159F4F40986E987.png" title="点击放大" width="798"></span></p>     <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content">       <p>在“RS Frame”和“App Frame”标签的泳道中，正常完成渲染的帧显示为绿色，出现卡顿的帧显示为红色。其中期望结束时间点之前的部分为浅红色（两条白色竖线区间），超出期望结束时间的部分为深红色，异常帧显示为黄色。</p>      </div></div></div>     <p>发现问题后，我们接着分析丢帧问题。应用丢帧的原因包括应用本身、系统和硬件层。不同卡顿原因在Trace中的表现各异，识别这些原因需要丰富的经验。</p>    </div>    <div class="subsection" id="section15102163551517">     <a name="section15102163551517"></a><a name="section15102163551517"></a>     <p><strong>分析丢帧原因</strong></p>     <p>分析丢帧问题时，结合App主进程和Render Service渲染进程的Trace数据，先排查系统异常，再分析应用原因。开发者可按以下步骤定位问题：</p>     <p><strong>1 看线程状态和运行核，看是否被其他进程抢占资源，排除系统侧运行异常。</strong></p>     <p>从下图可以看到，应用线程大部分时间处于Running状态，无特殊异常，运行在CPU10和CPU11上。</p>     <div class="fignone">      <span class="figcap"><b>图7 </b>丢帧处应用主线程状态</span>      <br><span><img height="242.29940000000002" originheight="566" originwidth="1864" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163406.67888158457992151322578915050345:50001231000000:2800:0D17243732F4E98971CD111252AC15E053A96BF21DBB108D449791FB343D6332.png" title="点击放大" width="798"></span>     </div>     <p>查看关键任务是否在小核上以低频运行。从图8的CPU Slice和Frequency泳道中，可以看到丢帧处的应用线程和前面正常帧类似，主要运行在大核上（该设备0~3号CPU为小核，4~11号CPU为大核）。将鼠标悬停在Frequency泳道上，可以查看CPU的运行频率。</p>     <div class="fignone">      <span class="figcap"><b>图8 </b>丢帧处应用主线程运行核</span>      <p><span><img height="241.00930000000002" originheight="563" originwidth="1864" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163406.12623444750840361236960281779069:50001231000000:2800:B3C1836FE174ECBE4FDDF7717E3AB279ACE48A657DE01116A8FFA808DCB361CC.png" title="点击放大" width="798"></span></p>     </div>     <p>通过分析，应用线程在CPU大核上正常运行，且频率正常。因此，可以排除系统异常。</p>     <p>如果应用线程运行出现以下问题，开发者可以进行<a href="https://developer.huawei.com/consumer/cn/support/feedback/#/?channel=ICS0000" target="_blank">在线提单</a>反馈异常。</p>     <ul>      <li>执行频率较低</li>      <li>线程在小核上工作</li>      <li>线程频繁在Running和Runnable之间切换</li>      <li>线程频繁在Running和Sleep之间切换</li>      <li>不重要的线程占用了大核</li>     </ul>     <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content">       <p>出于兼顾高性能、低功耗的需求，多核工程机常采用异构架构设计，根据CPU频率，区分大中小核等。</p>      </div></div></div>     <p><strong>2 找到Trace中每一帧耗时的部分，大致定位是App侧问题还是RS侧问题，并结合Trace标签，初步定位原因。</strong></p>     <p>通过Frame泳道，可以快速发现丢帧位置并完成初步定界：</p>     <ul>      <li>App侧出现红色，需要审视UI线程的处理逻辑是否过于复杂或低效，以及是否被其他任务抢占资源。</li>      <li>如果是Render Service帧处理出现红色，需要审视是否是界面布局过于复杂。可以借助DevEco Studio内的ArkUI Inspector、HiDumper等工具进一步分析，参考<a href="/consumer/cn/doc/best-practices/bpta-zhenlv#section1861971332220">布局嵌套过深</a>示例。</li>     </ul>     <p>前面示例中的丢帧主要出现在应用侧。针对这种丢帧现象，继续分析。放大右侧图表，选中超时的帧（220#帧）查看详细数据。期望处理时间为8.3ms（当前设备为120Hz），而实际处理时间为8.9ms。</p>     <p><span><img height="293.37140000000005" originheight="686" originwidth="1866" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163406.38418242483151838737891968807577:50001231000000:2800:A9303FC93CA6A314BBC2825CA5481B070B68E4FE27E1BD4A2AC07BF151115495.png" title="点击放大" width="798"></span></p>     <p>接下来通过Trace查看每一帧的具体耗时。可以点击泳道信息区的收藏按钮，将应用帧处理的泳道收藏置顶，防止上下文信息丢失。点击图标跳转到卡顿帧应用侧Trace详情，如下图所示：</p>     <p><span><img height="274.84450000000004" originheight="642" originwidth="1864" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163406.63184498423636759739714472884751:50001231000000:2800:5B9F208F99138E8FE61A20E1BFC843F70EE1630B6381AED017CB8BE2DF36E857.png" title="点击放大" width="798"></span></p>     <p>这几帧的卡顿可能是由于BuildLazyItem方法耗时较长导致的。可以推测，列表懒加载时，Item绘制时间较长是主要原因。</p>     <p>在ArkUI Component泳道上，可以直观地看到自定义组件ArticleView的绘制频率较高且较为耗时。频繁绘制组件可能会影响应用的帧率。</p>     <p><span><img height="290.2592" originheight="678" originwidth="1864" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163407.58708424885453982656598305207959:50001231000000:2800:4EE82D097E1344C74F58AA827B36AA87838ABC242BAF8EC663DCBA879C8F5D90.png" title="点击放大" width="798"></span></p>     <p>在Frame模板中，要查看ArkUI Component泳道，需在泳道录制前手动勾选，如图所示：</p>     <p><span><img originheight="365" originwidth="613" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163407.70559477817705198615604930915322:50001231000000:2800:7B0D70F2DA0BC91F32291FF40808116CD7542EBA266799F1F98484572E3529E2.png" width="613" height="365"></span></p>     <p><strong>3 查看ArkTS函数调用栈信息，排查应用代码。</strong></p>     <p>可以结合Frame Profiler工具，选择ArkTS Callstack泳道查看热点函数，方便地跳转到源码，定位绘制时间较长的自定义组件。如下图所示，可以看到自定义组件ArticleCardView的绘制频繁。下面以220#帧为例子，通过热点函数可以看到其中initialRenderView 和__lazyForEachItemGenFunction这两个方法比较耗时，占比分别达到52.7%和22.9%，其中绿色的”ArkTS”表示双击该行可以跳转到应用源码。</p>     <p><span><img height="220.0485" originheight="514" originwidth="1864" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163407.57142644397095084914340501238565:50001231000000:2800:B7B3AD923092ADF9990DA7571F4AC4A61AE95DB78D3365E36BE29EEF78A9E992.png" title="点击放大" width="798"></span></p>     <p>以initialRenderView函数的耗时为例进行分析，展开函数后，可以看到主要耗时在列表项ListItem的子组件ArticleCardView的创建上。</p>     <p><span><img height="229.4649" originheight="536" originwidth="1864" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163407.23373153359850013611214904286737:50001231000000:2800:23D48C94352A2380C2406378B4ADF46B24D4EB7E49A8F59BEC8F641F40E13398.png" title="点击放大" width="798"></span></p>     <p>展开组件函数调用链进行详细分析，通过查看函数调用可以发现，使用了@Prop变量。@Prop装饰的变量会对父组件传入的状态值进行深拷贝，如果@Prop装饰器装饰的变量为复杂对象、类或其类型数组时，会增加状态创建时间并占用大量内存。双击跳转到源码，可以看到自定义组件ActionButtonView中确实使用了@Prop装饰器变量。</p>     <p><span><img height="403.2693" originheight="944" originwidth="1868" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163407.74103912679768115739623921738746:50001231000000:2800:BD5F53C192A17CB2FBE677B8C64F84BEDCF4DD671FAB593B67894BAC7CD2EC32.png" title="点击放大" width="798"></span></p>     <p>其它函数的详细调用和耗时情况在此不再一一列举。</p>    </div>    <div class="subsection" id="section12559101516198">     <a name="section12559101516198"></a><a name="section12559101516198"></a>     <p><strong>选择优化方案</strong></p>     <p>选择优化方案需要一些经验的积累，开发者可以参考一些<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-performance-optimization" target="_blank">性能优化</a>的最佳实践，来选择相应的优化方法。</p>     <p>对丢帧问题进行优化。根据前面的分析结果，从两方面解决卡顿问题：</p>     <ul>      <li>使用组件复用能力@Reusable来减少组件的频繁创建。可复用组件从组件树上移除时，会进入到一个回收缓存区。后续创建新组件节点时，会复用缓存区中的节点，节约组件重新创建的时间。</li>      <li>简化组件创建的逻辑，使用更高效的@Builder来构建列表项Item的子组件，替代原有@Component自定义组件的方式。此外使用@Builder以后，就不需要使用@Prop变量了，从而减少了数据的深拷贝耗时。</li>     </ul>     <p>优化后的示例代码如下：</p>     <div class="screenLinkPre"><div _ngcontent-yio-c106="" class="highlight-div"><div _ngcontent-yio-c106="" class="highlight-div-header"><div _ngcontent-yio-c106="" class="highlight-div-header-left"><div _ngcontent-yio-c106="" class="handle-button expand-button"><div _ngcontent-yio-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-yio-c106="" class="highlight-div-header-right"><div _ngcontent-yio-c106="" class="handle-button ai-button"></div><div _ngcontent-yio-c106="" class="handle-button line-button"><div _ngcontent-yio-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-yio-c106="" class="handle-button theme-button"><div _ngcontent-yio-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-yio-c106="" class="handle-button copy-button"><div _ngcontent-yio-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-yio-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-typescript" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/PerformanceAnalysis/BptaFramePractice/entry/src/main/ets/components/DiscoverView.ets#L21-L76" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-meta">@Component</span></li><li>struct <span class="hljs-title class_">DiscoverView</span> {</li><li>  <span class="hljs-comment">// ...</span></li><li>
</li><li>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) {</li><li>    <span class="hljs-title class_">List</span>() {</li><li>      <span class="hljs-title class_">ForEach</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">dataSource</span>, <span class="hljs-function">(<span class="hljs-params">item: LearningResource</span>) =&gt;</span> {</li><li>        <span class="hljs-title class_">ListItem</span>() {</li><li>          <span class="hljs-title class_">ArticleCardView</span>()</li><li>            .<span class="hljs-title function_">reuseId</span>(<span class="hljs-string">'article'</span>)</li><li>        }</li><li>      }, <span class="hljs-function">(<span class="hljs-params">item: LearningResource</span>) =&gt;</span> item.<span class="hljs-property">id</span>.<span class="hljs-title function_">toString</span>())</li><li>    }</li><li>  }</li><li>}</li><li>
</li><li><span class="hljs-comment">// ...</span></li><li><span class="hljs-comment">// Add @Reusable Decorator Use Component Reuse</span></li><li><span class="hljs-meta">@Reusable</span></li><li><span class="hljs-meta">@Component</span></li><li><span class="hljs-keyword">export</span> struct <span class="hljs-title class_">ArticleCardView</span> {</li><li>  <span class="hljs-comment">// ...</span></li><li>  <span class="hljs-title function_">aboutToReuse</span>(<span class="hljs-attr">params</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Object</span>&gt;): <span class="hljs-built_in">void</span> {</li><li>    <span class="hljs-comment">// ...</span></li><li>  }</li><li>  <span class="hljs-title class_">Row</span>() {</li><li>    <span class="hljs-title class_">ActionButtonBuilder</span>()</li><li>    <span class="hljs-title class_">ActionButtonBuilder</span>()</li><li>    <span class="hljs-title class_">ActionButtonBuilder</span>()</li><li>  }</li><li>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) {</li><li>    <span class="hljs-comment">// ...</span></li><li>  }</li><li>}</li><li>
</li><li>
</li><li><span class="hljs-comment">// Build subcomponents using @Builder</span></li><li><span class="hljs-meta">@Builder</span></li><li><span class="hljs-keyword">function</span> <span class="hljs-title function_">ActionButtonBuilder</span>(<span class="hljs-params"></span>) {</li><li>  <span class="hljs-comment">// ...</span></li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/PerformanceAnalysis/BptaFramePractice/entry/src/main/ets/components/DiscoverView.ets#L21-L76" target="_blank">DiscoverView.ets</a></div></div></div></div>    </div>    <div class="subsection" id="section5733145211910">     <a name="section5733145211910"></a><a name="section5733145211910"></a>    </div>    <div class="tiledSection">     <h2 id="section182598135219">常见丢帧问题<i class="anchor-icon anchor-icon-link" anchorid="section182598135219" tips="复制节点链接"></i></h2>          <p>下面列举了一些常见的丢帧问题及其对应的Trace，并提供了一些优化方案，便于开发者识别和定位问题。</p>    </div>    <div class="tiledSection">     <h3 id="section1625312350214" class="firsth2">自定义动画丢帧问题<i class="anchor-icon anchor-icon-link" anchorid="section1625312350214" tips="复制节点链接"></i></h3>          <p>在播放或生成动画时，画面停滞导致帧率降低的现象称为动画丢帧。</p>     <p>播放动画时，系统必须在一个刷新周期内完成动画曲线计算和组件布局绘制。建议使用系统提供的动画接口，设置曲线类型、终点位置和时长，即可满足常用动画需求，减轻UI主线程的负载。</p>     <p>下面使用了自定义动画，动画曲线的计算过程可能会增加UI线程的负载，从而导致丢帧。</p>     <div class="screenLinkPre"><div _ngcontent-yio-c106="" class="highlight-div"><div _ngcontent-yio-c106="" class="highlight-div-header"><div _ngcontent-yio-c106="" class="highlight-div-header-left"><div _ngcontent-yio-c106="" class="handle-button expand-button"><div _ngcontent-yio-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-yio-c106="" class="highlight-div-header-right"><div _ngcontent-yio-c106="" class="handle-button ai-button"></div><div _ngcontent-yio-c106="" class="handle-button line-button"><div _ngcontent-yio-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-yio-c106="" class="handle-button theme-button"><div _ngcontent-yio-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-yio-c106="" class="handle-button copy-button"><div _ngcontent-yio-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-yio-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-typescript" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/PerformanceAnalysis/BptaFramePractice/entry/src/main/ets/pages/Index.ets#L17-L65" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-meta">@Entry</span></li><li><span class="hljs-meta">@Component</span></li><li>struct <span class="hljs-title class_">AnimationDemo1</span> {</li><li>  <span class="hljs-meta">@State</span> <span class="hljs-attr">widthSize</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">200</span>;</li><li>  <span class="hljs-meta">@State</span> <span class="hljs-attr">heightSize</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">100</span>;</li><li>  <span class="hljs-meta">@State</span> <span class="hljs-attr">flag</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">true</span>;</li><li>
</li><li>  <span class="hljs-title function_">computeSize</span>(<span class="hljs-params"></span>) {</li><li>    <span class="hljs-keyword">let</span> duration = <span class="hljs-number">2000</span>;</li><li>    <span class="hljs-keyword">let</span> period = <span class="hljs-number">16</span>;</li><li>    <span class="hljs-keyword">let</span> widthSizeEnd = <span class="hljs-number">0</span>;</li><li>    <span class="hljs-keyword">let</span> heightSizeEnd = <span class="hljs-number">0</span>;</li><li>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">flag</span>) {</li><li>      widthSizeEnd = <span class="hljs-number">100</span>;</li><li>      heightSizeEnd = <span class="hljs-number">50</span>;</li><li>    } <span class="hljs-keyword">else</span> {</li><li>      widthSizeEnd = <span class="hljs-number">200</span>;</li><li>      heightSizeEnd = <span class="hljs-number">100</span>;</li><li>    }</li><li>    <span class="hljs-keyword">let</span> doTimes = duration / period;</li><li>    <span class="hljs-keyword">let</span> deltaHeight = (heightSizeEnd - <span class="hljs-variable language_">this</span>.<span class="hljs-property">heightSize</span>) / doTimes;</li><li>    <span class="hljs-keyword">let</span> deltaWeight = (widthSizeEnd - <span class="hljs-variable language_">this</span>.<span class="hljs-property">widthSize</span>) / doTimes;</li><li>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= doTimes; i++) {</li><li>      <span class="hljs-keyword">let</span> t = period * (i);</li><li>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {</li><li>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">heightSize</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">heightSize</span> + deltaHeight;</li><li>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">widthSize</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">widthSize</span> + deltaWeight;</li><li>      }, t);</li><li>    }</li><li>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">flag</span> = !<span class="hljs-variable language_">this</span>.<span class="hljs-property">flag</span>;</li><li>  }</li><li>
</li><li>
</li><li>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) {</li><li>    <span class="hljs-title class_">Column</span>() {</li><li>      <span class="hljs-title class_">Button</span>(<span class="hljs-string">'click me'</span>)</li><li>        .<span class="hljs-title function_">onClick</span>(<span class="hljs-function">() =&gt;</span> {</li><li>          <span class="hljs-keyword">let</span> delay = <span class="hljs-number">500</span>;</li><li>          <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {</li><li>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">computeSize</span>();</li><li>          }, delay);</li><li>        })</li><li>        .<span class="hljs-title function_">width</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">widthSize</span>)</li><li>        .<span class="hljs-title function_">height</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">heightSize</span>)</li><li>        .<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-number">0x317aff</span>)</li><li>    }.<span class="hljs-title function_">width</span>(<span class="hljs-string">'100%'</span>)</li><li>    .<span class="hljs-title function_">margin</span>({ <span class="hljs-attr">top</span>: <span class="hljs-number">5</span> })</li><li>  }</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/PerformanceAnalysis/BptaFramePractice/entry/src/main/ets/pages/Index.ets#L17-L65" target="_blank">Index.ets</a></div></div></div></div>     <p>使用Frame Profiler录制Trace，可以看到动画帧率为63fps，而当前设备支持120Hz的刷新率。</p>     <p><span><img height="247.8854" originheight="579" originwidth="1864" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163407.42933719192881492106082486431145:50001231000000:2800:9555D9D77E1F04F5EB3530C24EA9B8B427004F7672A5BB5D4BA49FC0CA73E7BF.png" title="点击放大" width="798"></span></p>     <p>建议开发者使用系统属性动效API实现动效功能，下面以属性动画为例：</p>     <div class="screenLinkPre"><div _ngcontent-yio-c106="" class="highlight-div"><div _ngcontent-yio-c106="" class="highlight-div-header"><div _ngcontent-yio-c106="" class="highlight-div-header-left"><div _ngcontent-yio-c106="" class="handle-button expand-button"><div _ngcontent-yio-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-yio-c106="" class="highlight-div-header-right"><div _ngcontent-yio-c106="" class="handle-button ai-button"></div><div _ngcontent-yio-c106="" class="handle-button line-button"><div _ngcontent-yio-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-yio-c106="" class="handle-button theme-button"><div _ngcontent-yio-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-yio-c106="" class="handle-button copy-button"><div _ngcontent-yio-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-yio-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-kotlin" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/PerformanceAnalysis/BptaFramePractice/entry/src/main/ets/pages/page2.ets#L21-L56" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-meta">@Entry</span></li><li><span class="hljs-meta">@Component</span></li><li>struct AnimationDemo2 {</li><li>  <span class="hljs-meta">@State</span> widthSize: number = <span class="hljs-number">200</span>;</li><li>  <span class="hljs-meta">@State</span> heightSize: number = <span class="hljs-number">100</span>;</li><li>  <span class="hljs-meta">@State</span> flag: boolean = <span class="hljs-literal">true</span>;</li><li>
</li><li>
</li><li>  build() {</li><li>    Column() {</li><li>      Button(<span class="hljs-string">'click me'</span>)</li><li>        .onClick(() =&gt; {</li><li>          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.flag) {</li><li>            <span class="hljs-keyword">this</span>.widthSize = <span class="hljs-number">100</span>;</li><li>            <span class="hljs-keyword">this</span>.heightSize = <span class="hljs-number">50</span>;</li><li>          } <span class="hljs-keyword">else</span> {</li><li>            <span class="hljs-keyword">this</span>.widthSize = <span class="hljs-number">200</span>;</li><li>            <span class="hljs-keyword">this</span>.heightSize = <span class="hljs-number">100</span>;</li><li>          }</li><li>          <span class="hljs-keyword">this</span>.flag = !<span class="hljs-keyword">this</span>.flag;</li><li>        })</li><li>        .width(<span class="hljs-keyword">this</span>.widthSize)</li><li>        .height(<span class="hljs-keyword">this</span>.heightSize)</li><li>        .backgroundColor(<span class="hljs-number">0x317aff</span>)</li><li>        .animation({</li><li>          duration: <span class="hljs-number">2000</span>,</li><li>          curve: Curve.Linear,</li><li>          delay: <span class="hljs-number">500</span>,</li><li>          iterations: <span class="hljs-number">1</span>,</li><li>          playMode: PlayMode.Normal</li><li>        })</li><li>    }</li><li>    .width(<span class="hljs-string">'100%'</span>)</li><li>    .margin({ top: <span class="hljs-number">5</span> })</li><li>  }</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/PerformanceAnalysis/BptaFramePractice/entry/src/main/ets/pages/page2.ets#L21-L56" target="_blank">page2.ets</a></div></div></div></div>     <p>使用Frame Profiler录制优化后的Trace，动画帧率提升至116.9fps。</p>     <p><span><img height="200.3512" originheight="468" originwidth="1864" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163407.40972486728070905156507754627255:50001231000000:2800:0CB564F8A5D51350DDBC96C7675F9DB5823D269EC63E0B3AA247B70E545CB4C9.png" title="点击放大" width="798"></span></p>    </div>    <div class="tiledSection">     <h3 id="section1861971332220">布局嵌套过深<i class="anchor-icon anchor-icon-link" anchorid="section1861971332220" tips="复制节点链接"></i></h3>          <p>视图的嵌套层次会影响应用性能。在120Hz刷新率的设备上，每8.3ms刷新一帧。如果视图嵌套层次多，可能无法在8.3ms内完成屏幕刷新，导致丢帧卡顿，影响用户体验。推荐移除多余嵌套层次，使用相对布局（RelativeContainer），缩短组件刷新时间。</p>     <p>以下示例在列表中加载了2000条数据，子组件ChildComponent的布局嵌套了20层Stack组件。</p>     <div class="screenLinkPre"><div _ngcontent-yio-c106="" class="highlight-div"><div _ngcontent-yio-c106="" class="highlight-div-header"><div _ngcontent-yio-c106="" class="highlight-div-header-left"><div _ngcontent-yio-c106="" class="handle-button expand-button"><div _ngcontent-yio-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-yio-c106="" class="highlight-div-header-right"><div _ngcontent-yio-c106="" class="handle-button ai-button"></div><div _ngcontent-yio-c106="" class="handle-button line-button"><div _ngcontent-yio-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-yio-c106="" class="handle-button theme-button"><div _ngcontent-yio-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-yio-c106="" class="handle-button copy-button"><div _ngcontent-yio-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-yio-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-cangjie" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/PerformanceAnalysis/BptaFramePractice/entry/src/main/ets/pages/page3.ets#L21-L93" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyDataSource</span> <span class="hljs-variable">implements</span> <span class="hljs-variable">IDataSource</span> {</li><li>  <span class="hljs-keyword">private</span> <span class="hljs-variable">dataArray</span>: <span class="hljs-title class_">string</span>[] = [];</li><li>
</li><li>
</li><li>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">pushData</span>(<span class="hljs-variable">data</span>: <span class="hljs-title class_">string</span>): <span class="hljs-title class_">void</span> {</li><li>    <span class="hljs-keyword">this</span>.<span class="hljs-variable">dataArray</span>.<span class="hljs-title function_">push</span>(<span class="hljs-variable">data</span>);</li><li>  }</li><li>
</li><li>
</li><li>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">totalCount</span>(): <span class="hljs-title class_">number</span> {</li><li>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.<span class="hljs-variable">dataArray</span>.<span class="hljs-variable">length</span>;</li><li>  }</li><li>
</li><li>
</li><li>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">getData</span>(<span class="hljs-variable">index</span>: <span class="hljs-title class_">number</span>): <span class="hljs-title class_">string</span> {</li><li>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.<span class="hljs-variable">dataArray</span>[<span class="hljs-variable">index</span>];</li><li>  }</li><li>
</li><li>
</li><li>  <span class="hljs-title function_">registerDataChangeListener</span>(<span class="hljs-variable">listener</span>: <span class="hljs-title class_">DataChangeListener</span>): <span class="hljs-title class_">void</span> {</li><li>  }</li><li>
</li><li>
</li><li>  <span class="hljs-title function_">unregisterDataChangeListener</span>(<span class="hljs-variable">listener</span>: <span class="hljs-title class_">DataChangeListener</span>): <span class="hljs-title class_">void</span> {</li><li>  }</li><li>}</li><li>
</li><li>
</li><li>@<span class="hljs-title function_">Entry</span></li><li>@<span class="hljs-title function_">Component</span></li><li><span class="hljs-keyword">struct</span> <span class="hljs-title class_">StackDemo1</span> {</li><li>  <span class="hljs-comment">// The LazyForEach data initialization process is omitted here.</span></li><li>
</li><li>
</li><li>  <span class="hljs-keyword">private</span> <span class="hljs-variable">data</span>: <span class="hljs-title class_">MyDataSource</span> = <span class="hljs-variable">new</span> <span class="hljs-title function_">MyDataSource</span>();</li><li>
</li><li>
</li><li>  <span class="hljs-title function_">build</span>() {</li><li>    <span class="hljs-title function_">List</span>() {</li><li>      <span class="hljs-title function_">LazyForEach</span>(<span class="hljs-keyword">this</span>.<span class="hljs-variable">data</span>, (<span class="hljs-variable">item</span>: <span class="hljs-title class_">string</span>) =&gt; {</li><li>        <span class="hljs-title function_">ListItem</span>() {</li><li>          <span class="hljs-title function_">ChildComponent</span>({ <span class="hljs-variable">item</span>: <span class="hljs-title class_">item</span> })</li><li>        }</li><li>        .<span class="hljs-title function_">reuseId</span>(<span class="hljs-string">'child'</span>)</li><li>      }, (<span class="hljs-variable">item</span>: <span class="hljs-title class_">string</span>) =&gt; <span class="hljs-variable">item</span>)</li><li>    }.<span class="hljs-title function_">cachedCount</span>(<span class="hljs-number">5</span>)</li><li>  }</li><li>}</li><li>
</li><li>
</li><li>@<span class="hljs-title function_">Reusable</span></li><li>@<span class="hljs-title function_">Component</span></li><li><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ChildComponent</span> {</li><li>  @<span class="hljs-title function_">State</span> <span class="hljs-variable">item</span>: <span class="hljs-title class_">string</span> = <span class="hljs-string">''</span>;</li><li>
</li><li>
</li><li>  <span class="hljs-title function_">aboutToReuse</span>(<span class="hljs-variable">params</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-title class_">string</span>, <span class="hljs-title class_">Object</span>&gt;): <span class="hljs-title class_">void</span> {</li><li>    <span class="hljs-keyword">this</span>.<span class="hljs-variable">item</span> = <span class="hljs-variable">params</span>.<span class="hljs-variable">item</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">string</span>;</li><li>  }</li><li>
</li><li>
</li><li>  <span class="hljs-title function_">build</span>() {</li><li>    <span class="hljs-title function_">Stack</span>() {</li><li>      <span class="hljs-title function_">Stack</span>() {</li><li>        <span class="hljs-comment">// Stack nesting is omitted here</span></li><li>        <span class="hljs-title function_">Text</span>(<span class="hljs-keyword">this</span>.<span class="hljs-variable">item</span>)</li><li>          .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">50</span>)</li><li>          .<span class="hljs-title function_">margin</span>({ <span class="hljs-variable">left</span>: <span class="hljs-number">10</span>, <span class="hljs-variable">right</span>: <span class="hljs-number">10</span> })</li><li>      }</li><li>      <span class="hljs-comment">// ...</span></li><li>    }</li><li>  }</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/PerformanceAnalysis/BptaFramePractice/entry/src/main/ets/pages/page3.ets#L21-L93" target="_blank">page3.ets</a></div></div></div></div>     <p>使用Frame Profiler进行录制，直接查看应用侧的Trace数据，具体分析步骤请参见前面的丢帧问题分析思路章节。</p>     <p><span><img height="238.89460000000003" originheight="558" originwidth="1864" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163407.05244281017618773733947950439845:50001231000000:2800:6D3EEFB93C2F43A3A1E43D0E9518FA339211960B68B66A0DC025D0FF9070D2D0.png" title="点击放大" width="798"></span></p>     <p>结合卡顿帧对应时间段的Trace数据，定位到FlushLayoutTask耗时过长。其作用是重新测量和布局所有Item，Measure方法耗时较长。卡顿原因可能是布局处理逻辑复杂或低效。</p>     <p>开发者可以使用ArkUI Inspector，在DevEco Studio上查看应用在真机上的UI显示效果。利用ArkUI Inspector工具，开发者可以快速定位布局问题或其他UI相关问题。效果图如下：</p>     <p><span><img height="247.3933" originheight="581" originwidth="1874" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163407.47272249236062784037948795247153:50001231000000:2800:D0C15E4E52B53AAE07A6209D6711AE30054E6096216040F8EB57FCB4BA49403E.png" title="点击放大" width="798"></span></p>     <p>可以直观看到Item的嵌套较深。接下来，减少不必要的嵌套以解决丢帧问题。示例代码如下：</p>     <div class="screenLinkPre"><div _ngcontent-yio-c106="" class="highlight-div"><div _ngcontent-yio-c106="" class="highlight-div-header"><div _ngcontent-yio-c106="" class="highlight-div-header-left"><div _ngcontent-yio-c106="" class="handle-button expand-button"><div _ngcontent-yio-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-yio-c106="" class="highlight-div-header-right"><div _ngcontent-yio-c106="" class="handle-button ai-button"></div><div _ngcontent-yio-c106="" class="handle-button line-button"><div _ngcontent-yio-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-yio-c106="" class="handle-button theme-button"><div _ngcontent-yio-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-yio-c106="" class="handle-button copy-button"><div _ngcontent-yio-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-yio-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-typescript" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/PerformanceAnalysis/BptaFramePractice/entry/src/main/ets/pages/page4.ets#L21-L39" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-meta">@Reusable</span></li><li><span class="hljs-meta">@Component</span></li><li>struct <span class="hljs-title class_">ChildComponent</span> {</li><li>  <span class="hljs-meta">@State</span> <span class="hljs-attr">item</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">''</span>;</li><li>
</li><li>
</li><li>  <span class="hljs-title function_">aboutToReuse</span>(<span class="hljs-attr">params</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Object</span>&gt;): <span class="hljs-built_in">void</span> {</li><li>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">item</span> = params.<span class="hljs-property">item</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>;</li><li>  }</li><li>
</li><li>
</li><li>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) {</li><li>    <span class="hljs-title class_">Stack</span>() {</li><li>      <span class="hljs-title class_">Text</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">item</span>)</li><li>        .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">50</span>)</li><li>        .<span class="hljs-title function_">margin</span>({ <span class="hljs-attr">left</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">right</span>: <span class="hljs-number">10</span> })</li><li>    }</li><li>  }</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/PerformanceAnalysis/BptaFramePractice/entry/src/main/ets/pages/page4.ets#L21-L39" target="_blank">page4.ets</a></div></div></div></div>     <p>再次使用Frame Profiler进行录制，可以看到丢帧问题已经解决。</p>     <p><span><img height="238.4557" originheight="557" originwidth="1864" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163407.42414758797962893827936711979695:50001231000000:2800:AADBDF2D35B8A1D23EDD48BBC51FA3C8DB55E55CB8770F28CD878416DE9E2A28.png" title="点击放大" width="798"></span></p>    </div>    <div class="tiledSection">     <h3 id="section940831813581">主线程中执行冗余和耗时操作<i class="anchor-icon anchor-icon-link" anchorid="section940831813581" tips="复制节点链接"></i></h3>          <p>避免在主线程中执行冗余或耗时操作，这可能导致UI渲染阻塞，引起界面卡顿或掉帧，尤其在高频回调中。参考<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-time-optimization-of-the-main-thread" target="_blank">主线程耗时操作优化指导</a>。</p>    </div>    <div class="tiledSection">     <h2 id="section15921550132318">丢帧问题优化建议<i class="anchor-icon anchor-icon-link" anchorid="section15921550132318" tips="复制节点链接"></i></h2>          <p>图形渲染流程包括两个关键步骤：应用侧生成界面描述数据结构，Render Service进行绘制。这两个步骤中可能出现AppDeadlineMissed和RenderDeadlineMissed卡顿。AppDeadlineMissed通常由应用逻辑处理代码效率低下引起，可结合Trace数据和热点函数分析；RenderDeadlineMissed可能由界面结构复杂或GPU负载过大引起，可使用ArkUI Inspector工具和HiDumper命令行工具辅助分析。</p>     <p>针对常见的丢帧问题，以下列出了一些优化建议：</p>     <ul>      <li>尽量减少布局的嵌套层数，<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-improve-layout-performance" target="_blank">合理使用布局</a>，使用<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-layout-development-relative-layout" target="_blank">相对布局 (RelativeContainer)</a>来减少层级。</li>      <li>使用<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-best-practices-long-list#section36781044162218">组件复用</a>减少组件的重复创建与渲染。</li>      <li>合理管理状态变量，精准控制组件更新范围，避免冗余刷新。具体参考<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-status-management" target="_blank">状态管理最佳实践</a>。</li>      <li>使用LazyForEach加载长列表，具体优化方法可以参考<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-best-practices-long-list" target="_blank">优化长列表加载慢丢帧问题</a>。</li>      <li>使用系统提供的动画接口，避免动画丢帧。</li>      <li>优化主线程中的耗时操作，具体可以参考<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-time-optimization-of-the-main-thread" target="_blank">主线程耗时操作优化指导</a>。</li>     </ul>    </div>   </div>   <div></div></div>