<h1 _ngcontent-ega-c119="" class="doc-title ng-star-inserted" title="应用内存占用优化"> 应用内存占用优化 </h1>

<div _ngcontent-ega-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;"> <div><div class="tiledSection"><h2 id="section1142114144213">概述<i class="anchor-icon anchor-icon-link" anchorid="section1142114144213" tips="复制节点链接"></i></h2><p>随着用户功能的增加，应用逐渐变得复杂，占用的内存也在增加。由于内存是系统中的稀缺资源，当应用程序占用过多内存时，系统可能会频繁进行内存回收和重新分配，导致应用性能下降，甚至出现崩溃和卡顿。因此，减少应用内存占用对于整个系统至关重要。通过减少内存占用，可以有效提高应用性能和响应速度，节省系统资源，提升设备运行效率，延长设备续航时间。开发者在应用开发过程中应注重内存管理，采取措施减少内存占用，优化应用性能和用户体验。</p> <p>HarmonyOS提供了一些内存管理的工具和接口，帮助开发者有效地管理内存资源：</p> <ol><li>onMemoryLevel()接口：开发者可通过该接口监听系统内存的变化，并根据系统内存的实时情况，动态地调整应用的内存，以避免内存过度占用导致的性能问题。</li><li>LRUCache：缓存空间不足时，替换近期最少使用的数据。</li><li><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-page-custom-components-lifecycle" target="_blank">生命周期管理</a>：释放不再使用的系统资源，包括应用内存、监听事件、网络句柄。</li><li>Purgeable Memory机制：创建PurgeableMemory对象，管理Purgeable内存。</li><li>图片加载和渲染：调整图片尺寸，使其与组件大小一致，避免显示问题，提高用户体验。</li></ol> <p>本文介绍五个方面优化应用内存占用问题。</p> </div> <div class="tiledSection"><h2 id="section483194634212">使用onMemoryLevel()监听内存变化<i class="anchor-icon anchor-icon-link" anchorid="section483194634212" tips="复制节点链接"></i></h2><p>onMemoryLevel()是 HarmonyOS 提供的用于监听系统内存变化的接口，通过该接口，开发者可以调整应用内存。onMemoryLevel()回调包括三种方式：AbilityStage、UIAbility 和 EnvironmentCallback。</p> <ul><li>AbilityStage：系统首次加载HAP中的代码到进程时，会创建AbilityStage实例。当系统需要调整内存时，会回调AbilityStage实例的onMemoryLevel()方法。</li></ul> <ul><li>UIAbility：Ability是UIAbility的基类，提供系统内存变化的回调方法。</li><li>EnvironmentCallback：EnvironmentCallback模块提供对系统环境变化的监听回调能力。</li></ul> <p>MemoryLevel分为 MEMORY_LEVEL_MODERATE、MEMORY_LEVEL_LOW 和 MEMORY_LEVEL_CRITICAL 三种。MEMORY_LEVEL_MODERATE 表示当前系统内存压力适中，应用可以正常运行且受到的影响较小。MEMORY_LEVEL_LOW表示当前系统内存较低，应用应释放不必要的内存资源，避免系统卡顿。MEMORY_LEVEL_CRITICAL表示当前系统内存非常紧张，应用应尽可能释放更多资源，确保系统稳定性和性能。开发人员应根据不同的内存级别采取相应措施，例如释放资源、优化内存使用，以确保应用在不同内存状态下均能正常运行。MemoryLevel具体等级定义如下所示：</p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><caption><b>表1 </b>onMemoryLevel等级定义</caption><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.2.6.2.4.1.1" valign="top" width="18.161816181618164%"><p>等级</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.2.6.2.4.1.2" valign="top" width="17.241724172417243%"><p>值</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.2.6.2.4.1.3" valign="top" width="64.5964596459646%"><p>说明</p> </th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="18.161816181618164%"><p>MEMORY_LEVEL_MODERATE</p> </td> <td class="cellrowborder" valign="top" width="17.241724172417243%"><p>0</p> </td> <td class="cellrowborder" valign="top" width="64.5964596459646%"><p>系统内存达到中等水平。系统将根据LRU缓存规则开始杀死进程。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="18.161816181618164%"><p>MEMORY_LEVEL_LOW</p> </td> <td class="cellrowborder" valign="top" width="17.241724172417243%"><p>1</p> </td> <td class="cellrowborder" valign="top" width="64.5964596459646%"><p>系统内存不足。此时应释放不必要的资源以提升系统性能。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="18.161816181618164%"><p>MEMORY_LEVEL_CRITICAL</p> </td> <td class="cellrowborder" valign="top" width="17.241724172417243%"><p>2</p> </td> <td class="cellrowborder" valign="top" width="64.5964596459646%"><p>系统内存不足。此时应立即释放所有不必要的资源，因为系统可能会终止所有缓存中的进程，并且开始终止应当保持运行的进程，例如后台服务。</p> </td> </tr>  </tbody></table></div> </div> <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"><p>后台已冻结的应用，AbilityStage、UIAbility和EnvironmentCallback的onMemoryLevel()不可回调。</p> </div></div></div> </div> <div class="tiledSection"><h2 id="section1518265464211">使用LRUCache优化ArkTS内存<i class="anchor-icon anchor-icon-link" anchorid="section1518265464211" tips="复制节点链接"></i></h2><p>LRU（最近最少使用）算法基于时间局部性原理，即最近被访问的数据在未来被访问的概率较高。</p> <p>LRUCache`是 ArkTS 中常用的缓存工具，基于 LRU 算法实现。它主要用于缓存频繁访问的数据，如图片和网络请求结果。通过维护一个缓存空间来存储数据，当缓存空间不足时，根据 LRU 算法替换最近最少使用的数据，确保缓存空间的有效利用。</p> </div> <div class="tiledSection"><h3 id="section1090515188412" class="firsth2">原理介绍<i class="anchor-icon anchor-icon-link" anchorid="section1090515188412" tips="复制节点链接"></i></h3><p>LRUCache通过LinkedHashMap来实现LRU。LinkedHashMap继承于HashMap，HashMap用于快速查找数据，LinkedHashMap双向链表用于记录数据的顺序关系。因此，对于get()、put()、remove()等操作，LinkedHashMap除了包含HashMap的功能，还需要实现调整Entry顺序链表的工作。其数据结构如下图所示：</p> <div class="fignone"><span class="figcap"><b>图1 </b>LRUCache的LinkedHashMap数据结构图</span><br><span><img height="517.7025" originheight="524" originwidth="530" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163421.23215036928847527892108293252758:50001231000000:2800:D13D40AD84E6E8D7747E116CD222D58823E6B74FC34CBB82955E57B2468C01EA.png" title="点击放大" width="523.6875"></span></div> <p>LruCache中将LinkedHashMap的顺序设置为LRU顺序，链表头部的对象为近期最少用到的对象。常用的方法及其说明如下所示：</p> <ul><li>调用get()方法：根据key查询对应，如果没有查到则返回undefined。查询到对应对象后，将该对象移到链表的尾端，并返回查询的对象。</li><li>调用put()方法：将key-value对添加到缓存中，同时将新对象存储在链表尾端。当内存缓存达到最大值时，移除链表头部的对象。如果key已存在，则更新其对应的value。</li><li>调用remove()方法：删除key对应的缓存value，如果key对应的value不在，则返回为undefined，否则，返回已删除的key-value键值对。</li><li>调用updateCapacity()方法，设置缓存存储容量。如果新容量小于原容量，仅保留新容量大小的数据。</li></ul> </div> <div class="tiledSection"><h3 id="section9416157970">参考案例<i class="anchor-icon anchor-icon-link" anchorid="section9416157970" tips="复制节点链接"></i></h3><p>设计缓存工具类，包含LRUCache单例及操作LRUCache的方法，如添加、获取、删除数据。通过静态方法获取LRUCache实例，确保全局唯一。缓存工具类支持各组件间共享缓存数据，避免重复创建实例和数据冗余，提高系统性能和效率，减少内存占用，提升数据访问速度。</p> <div class="screenLinkPre"><div _ngcontent-ega-c106="" class="highlight-div"><div _ngcontent-ega-c106="" class="highlight-div-header"><div _ngcontent-ega-c106="" class="highlight-div-header-left"><div _ngcontent-ega-c106="" class="handle-button expand-button"><div _ngcontent-ega-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-ega-c106="" class="highlight-div-header-right"><div _ngcontent-ega-c106="" class="handle-button ai-button"></div><div _ngcontent-ega-c106="" class="handle-button line-button"><div _ngcontent-ega-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-ega-c106="" class="handle-button theme-button"><div _ngcontent-ega-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-ega-c106="" class="handle-button copy-button"><div _ngcontent-ega-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-ega-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-typescript" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/OptimizationAppMemoryUsage/entry/src/main/ets/utils/LRUCacheUtil.ets#L2-L60" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">import</span> { util } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.ArkTS'</span>;</li><li>
</li><li><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCacheUtil</span> {</li><li>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-attr">instance</span>: <span class="hljs-title class_">LRUCacheUtil</span>;</li><li>  <span class="hljs-keyword">private</span> <span class="hljs-attr">lruCache</span>: util.<span class="hljs-property">LRUCache</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Object</span>&gt;;</li><li>
</li><li>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {</li><li>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">lruCache</span> = <span class="hljs-keyword">new</span> util.<span class="hljs-title class_">LRUCache</span>(<span class="hljs-number">64</span>);</li><li>  }</li><li>
</li><li>  <span class="hljs-comment">// Get the singleton of LRUCacheUtil</span></li><li>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title function_">getInstance</span>(): <span class="hljs-title class_">LRUCacheUtil</span> {</li><li>    <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">LRUCacheUtil</span>.<span class="hljs-property">instance</span>) {</li><li>      <span class="hljs-title class_">LRUCacheUtil</span>.<span class="hljs-property">instance</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LRUCacheUtil</span>();</li><li>    }</li><li>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">LRUCacheUtil</span>.<span class="hljs-property">instance</span>;</li><li>  }</li><li>
</li><li>  <span class="hljs-comment">// Determine whether the lruCache cache is empty</span></li><li>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">isEmpty</span>(): <span class="hljs-built_in">boolean</span> {</li><li>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">lruCache</span>.<span class="hljs-title function_">isEmpty</span>();</li><li>  }</li><li>
</li><li>  <span class="hljs-comment">// Get the capacity of lruCache</span></li><li>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">getCapacity</span>(): <span class="hljs-built_in">number</span> {</li><li>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">lruCache</span>.<span class="hljs-title function_">getCapacity</span>();</li><li>  }</li><li>
</li><li>  <span class="hljs-comment">// Reset the capacity of lruCache</span></li><li>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">updateCapacity</span>(<span class="hljs-params">newCapacity: <span class="hljs-built_in">number</span></span>) {</li><li>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">lruCache</span>.<span class="hljs-title function_">updateCapacity</span>(newCapacity);</li><li>  }</li><li>
</li><li>  <span class="hljs-comment">// Add cache to lruCache</span></li><li>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">putCache</span>(<span class="hljs-params">key: <span class="hljs-built_in">string</span>, value: <span class="hljs-built_in">Object</span></span>) {</li><li>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">lruCache</span>.<span class="hljs-title function_">put</span>(key, value);</li><li>  }</li><li>
</li><li>  <span class="hljs-comment">// Delete the cache corresponding to the key</span></li><li>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">remove</span>(<span class="hljs-params">key: <span class="hljs-built_in">string</span></span>) {</li><li>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">lruCache</span>.<span class="hljs-title function_">remove</span>(key);</li><li>  }</li><li>
</li><li>  <span class="hljs-comment">// Get the cache corresponding to the key</span></li><li>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">getCache</span>(<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title class_">Object</span> | <span class="hljs-literal">undefined</span> {</li><li>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">lruCache</span>.<span class="hljs-title function_">get</span>(key);</li><li>  }</li><li>
</li><li>  <span class="hljs-comment">// Determine whether the cache corresponding to the key is included.</span></li><li>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">contains</span>(<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">boolean</span> {</li><li>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">lruCache</span>.<span class="hljs-title function_">contains</span>(key);</li><li>  }</li><li>
</li><li>  <span class="hljs-comment">// Clear the cached data and reset the size of lruCache</span></li><li>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">clearCache</span>(<span class="hljs-params"></span>) {</li><li>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">lruCache</span>.<span class="hljs-title function_">clear</span>();</li><li>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">lruCache</span>.<span class="hljs-title function_">updateCapacity</span>(<span class="hljs-number">64</span>);</li><li>  }</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/OptimizationAppMemoryUsage/entry/src/main/ets/utils/LRUCacheUtil.ets#L2-L60" target="_blank">LRUCacheUtil.ets</a></div></div></div></div> <p>在对应的组件中设置缓存，示例代码如下所示：</p> <div class="screenLinkPre"><div _ngcontent-ega-c106="" class="highlight-div"><div _ngcontent-ega-c106="" class="highlight-div-header"><div _ngcontent-ega-c106="" class="highlight-div-header-left"><div _ngcontent-ega-c106="" class="handle-button expand-button"><div _ngcontent-ega-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-ega-c106="" class="highlight-div-header-right"><div _ngcontent-ega-c106="" class="handle-button ai-button"></div><div _ngcontent-ega-c106="" class="handle-button line-button"><div _ngcontent-ega-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-ega-c106="" class="handle-button theme-button"><div _ngcontent-ega-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-ega-c106="" class="handle-button copy-button"><div _ngcontent-ega-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-ega-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-typescript" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/OptimizationAppMemoryUsage/entry/src/main/ets/pages/Demo.ets#L2-L48" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">import</span> { <span class="hljs-title class_">LRUCacheUtil</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'../utils/LRUCacheUtil'</span>;</li><li>
</li><li><span class="hljs-meta">@Entry</span></li><li><span class="hljs-meta">@Component</span></li><li>struct <span class="hljs-title class_">Index</span> {</li><li>  <span class="hljs-meta">@State</span> <span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">'Hello World'</span>;</li><li>
</li><li>  <span class="hljs-title function_">aboutToAppear</span>(): <span class="hljs-built_in">void</span> {</li><li>    <span class="hljs-keyword">let</span> lruCache = <span class="hljs-title class_">LRUCacheUtil</span>.<span class="hljs-title function_">getInstance</span>();</li><li>    <span class="hljs-comment">// Add a &lt;key, value&gt; to lrucache</span></li><li>    lruCache.<span class="hljs-title function_">putCache</span>(<span class="hljs-string">'nation'</span>,<span class="hljs-number">10</span>);</li><li>    <span class="hljs-comment">// Add another &lt;key, value&gt; to lrucache</span></li><li>    lruCache.<span class="hljs-title function_">putCache</span>(<span class="hljs-string">'menu'</span>,<span class="hljs-number">8</span>);</li><li>    <span class="hljs-comment">// Query value through key</span></li><li>    <span class="hljs-keyword">let</span> result0 = lruCache.<span class="hljs-title function_">getCache</span>(<span class="hljs-string">'2'</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">number</span>;</li><li>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'result0:'</span> + result0);</li><li>    <span class="hljs-comment">// Delete the specified key and its associated values from the current buffer</span></li><li>    <span class="hljs-keyword">let</span> result1 = lruCache.<span class="hljs-title function_">remove</span>(<span class="hljs-string">'2'</span>);</li><li>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'result1:'</span> + result1);</li><li>    <span class="hljs-comment">// Check whether the current buffer contains the specified object</span></li><li>    <span class="hljs-keyword">let</span> result2 = lruCache.<span class="hljs-title function_">contains</span>(<span class="hljs-string">'1'</span>);</li><li>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'result2:'</span> + result2);</li><li>    <span class="hljs-comment">// Set a new capacity size</span></li><li>    <span class="hljs-keyword">let</span> result4 = lruCache.<span class="hljs-title function_">updateCapacity</span>(<span class="hljs-number">110</span>);</li><li>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'result4:'</span> + result4);</li><li>  }</li><li>
</li><li>
</li><li>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) {</li><li>    <span class="hljs-title class_">Row</span>() {</li><li>      <span class="hljs-title class_">Column</span>() {</li><li>        <span class="hljs-title class_">Text</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span>)</li><li>          .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">50</span>)</li><li>          .<span class="hljs-title function_">fontWeight</span>(<span class="hljs-title class_">FontWeight</span>.<span class="hljs-property">Bold</span>)</li><li>        <span class="hljs-title class_">Column</span>() {</li><li>          <span class="hljs-title class_">Image</span>($r(<span class="hljs-string">'app.media.image'</span>))</li><li>            .<span class="hljs-title function_">width</span>(<span class="hljs-string">"500px"</span>)</li><li>            .<span class="hljs-title function_">height</span>(<span class="hljs-string">"500px"</span>)</li><li>        }</li><li>      }</li><li>      .<span class="hljs-title function_">width</span>(<span class="hljs-string">'100%'</span>)</li><li>    }</li><li>    .<span class="hljs-title function_">height</span>(<span class="hljs-string">'100%'</span>)</li><li>  }</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/OptimizationAppMemoryUsage/entry/src/main/ets/pages/Demo.ets#L2-L48" target="_blank">Demo.ets</a></div></div></div></div> <p>可以通过onMemoryLevel()监听内存变化，设置对应清理缓存的机制。示例代码如下：</p> <div class="screenLinkPre"><div _ngcontent-ega-c106="" class="highlight-div"><div _ngcontent-ega-c106="" class="highlight-div-header"><div _ngcontent-ega-c106="" class="highlight-div-header-left"><div _ngcontent-ega-c106="" class="handle-button expand-button"><div _ngcontent-ega-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-ega-c106="" class="highlight-div-header-right"><div _ngcontent-ega-c106="" class="handle-button ai-button"></div><div _ngcontent-ega-c106="" class="handle-button line-button"><div _ngcontent-ega-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-ega-c106="" class="handle-button theme-button"><div _ngcontent-ega-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-ega-c106="" class="handle-button copy-button"><div _ngcontent-ega-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-ega-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-javascript" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/OptimizationAppMemoryUsage/entry/src/main/ets/entryability/EntryAbility.ets#L2-L26" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">import</span> { <span class="hljs-title class_">AbilityConstant</span>, <span class="hljs-title class_">UIAbility</span>, <span class="hljs-title class_">Want</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.AbilityKit'</span>;</li><li><span class="hljs-keyword">import</span> { hilog } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.PerformanceAnalysisKit'</span>;</li><li><span class="hljs-keyword">import</span> { <span class="hljs-variable language_">window</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.ArkUI'</span>;</li><li><span class="hljs-keyword">import</span> { <span class="hljs-title class_">LRUCacheUtil</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'../utils/LRUCacheUtil'</span>;</li><li>
</li><li><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EntryAbility</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">UIAbility</span> {</li><li>  <span class="hljs-comment">// Monitor the changes in memory</span></li><li>  <span class="hljs-title function_">onMemoryLevel</span>(<span class="hljs-attr">level</span>: <span class="hljs-title class_">AbilityConstant</span>.<span class="hljs-property">MemoryLevel</span>): <span class="hljs-keyword">void</span> {</li><li>    <span class="hljs-comment">// Execute memory management policies according to changes in memory</span></li><li>    <span class="hljs-keyword">if</span> (level === <span class="hljs-title class_">AbilityConstant</span>.<span class="hljs-property">MemoryLevel</span>.<span class="hljs-property">MEMORY_LEVEL_CRITICAL</span>) {</li><li>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'The memory of device is critical, release memory.'</span>);</li><li>      <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">LRUCacheUtil</span>.<span class="hljs-title function_">getInstance</span>().<span class="hljs-title function_">isEmpty</span>()) {</li><li>        <span class="hljs-title class_">LRUCacheUtil</span>.<span class="hljs-title function_">getInstance</span>().<span class="hljs-title function_">clearCache</span>();</li><li>      }</li><li>    }</li><li>  }</li><li>
</li><li>  <span class="hljs-title function_">onCreate</span>(<span class="hljs-attr">want</span>: <span class="hljs-title class_">Want</span>, <span class="hljs-attr">launchParam</span>: <span class="hljs-title class_">AbilityConstant</span>.<span class="hljs-property">LaunchParam</span>): <span class="hljs-keyword">void</span> {</li><li>    hilog.<span class="hljs-title function_">info</span>(<span class="hljs-number">0x0000</span>, <span class="hljs-string">'testTag'</span>, <span class="hljs-string">'%{public}s'</span>, <span class="hljs-string">'Ability onCreate'</span>);</li><li>  }</li><li>
</li><li>  <span class="hljs-title function_">onDestroy</span>(): <span class="hljs-keyword">void</span> {</li><li>    hilog.<span class="hljs-title function_">info</span>(<span class="hljs-number">0x0000</span>, <span class="hljs-string">'testTag'</span>, <span class="hljs-string">'%{public}s'</span>, <span class="hljs-string">'Ability onDestroy'</span>);</li><li>  }</li><li>};</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/OptimizationAppMemoryUsage/entry/src/main/ets/entryability/EntryAbility.ets#L2-L26" target="_blank">EntryAbility.ets</a></div></div></div></div> </div> <div class="tiledSection"><h2 id="section1884114147411">使用生命周期管理优化ArkTS内存<i class="anchor-icon anchor-icon-link" anchorid="section1884114147411" tips="复制节点链接"></i></h2><p>组件的生命周期指的是组件在特定时间点或遇到特定页面行为时会自动执行的方法。</p> </div> <div class="tiledSection"><h3 id="section206354541074" class="firsth2">原理介绍<i class="anchor-icon anchor-icon-link" anchorid="section206354541074" tips="复制节点链接"></i></h3><p>在开发过程中，管理对象的生命周期，以释放资源、销毁对象、优化ArkTS内存。</p> <ul><li>在UIAbility组件的生命周期中，调用相应生命周期方法创建或销毁资源。在Create或Foreground方法中创建资源，在Background或Destroy方法中销毁资源。</li><li>在页面生命周期中，调用对应生命周期的方法，创建或销毁资源。如在<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-custom-component-lifecycle#onpageshow" target="_blank">onPageShow()</a>方法中创建资源，在<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-custom-component-lifecycle#onpagehide" target="_blank">onPageHide()</a>方法中销毁对应的资源。</li><li>在组件生命周期中，调用对应生命周期的方法，创建或销毁资源。如在<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-custom-component-lifecycle#abouttoappear" target="_blank">aboutToAppear()</a>方法中创建资源，在<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-custom-component-lifecycle#abouttodisappear" target="_blank">aboutToDisappear()</a>方法中销毁不再使用的对象、注销不再使用的订阅事件。</li><li>调用组件自带的方法，创建、销毁组件。如调用XComponent的<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-xcomponent#ondestroy" target="_blank">onDestroy()</a>方法。</li></ul> </div> <div class="tiledSection"><h3 id="section9442572819">aboutToDisappear()中销毁订阅事件<i class="anchor-icon anchor-icon-link" anchorid="section9442572819" tips="复制节点链接"></i></h3><p>aboutToDisappear函数会在组件销毁前执行。如下示例所示，在完成网络管理的网络连接模块使用后，取消订阅默认网络状态变化的通知。</p> <div class="screenLinkPre"><div _ngcontent-ega-c106="" class="highlight-div"><div _ngcontent-ega-c106="" class="highlight-div-header"><div _ngcontent-ega-c106="" class="highlight-div-header-left"><div _ngcontent-ega-c106="" class="handle-button expand-button"><div _ngcontent-ega-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-ega-c106="" class="highlight-div-header-right"><div _ngcontent-ega-c106="" class="handle-button ai-button"></div><div _ngcontent-ega-c106="" class="handle-button line-button"><div _ngcontent-ega-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-ega-c106="" class="handle-button theme-button"><div _ngcontent-ega-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-ega-c106="" class="handle-button copy-button"><div _ngcontent-ega-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-ega-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-kotlin" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/OptimizationAppMemoryUsage/entry/src/main/ets/pages/Index.ets#L2-L154" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">import</span> { connection } from <span class="hljs-string">'@kit.NetworkKit'</span>;</li><li><span class="hljs-keyword">import</span> { BusinessError } from <span class="hljs-string">'@kit.BasicServicesKit'</span>;</li><li><span class="hljs-keyword">import</span> { promptAction } from <span class="hljs-string">'@kit.ArkUI'</span>;</li><li><span class="hljs-keyword">import</span> { Logger } from <span class="hljs-string">'../utils/Logger'</span>;</li><li>
</li><li><span class="hljs-meta">@Entry</span></li><li><span class="hljs-meta">@Component</span></li><li>struct Index {</li><li>  <span class="hljs-meta">@State</span> networkId: string = <span class="hljs-string">'123'</span>;</li><li>  <span class="hljs-meta">@State</span> netMessage: string = <span class="hljs-string">'初始化网络成功'</span>;</li><li>  <span class="hljs-meta">@State</span> connectionMessage: string = <span class="hljs-string">'链接成功'</span>;</li><li>  <span class="hljs-meta">@State</span> netStateMessage: string = <span class="hljs-string">''</span>;</li><li>  <span class="hljs-meta">@State</span> hostName: string = <span class="hljs-string">''</span>;</li><li>  <span class="hljs-meta">@State</span> ip: string = <span class="hljs-string">''</span>;</li><li>  <span class="hljs-keyword">private</span> controller: TabsController = new TabsController();</li><li>  <span class="hljs-keyword">private</span> netHandle: connection.NetHandle | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;</li><li>  <span class="hljs-keyword">private</span> netCon: connection.NetConnection | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;</li><li>  scroller: Scroller = new Scroller();</li><li>
</li><li>  aboutToDisappear(): void {</li><li>    <span class="hljs-comment">// unregister NetConnection</span></li><li>    <span class="hljs-keyword">this</span>.unUseNetworkRegister;</li><li>  }</li><li>
</li><li>  build() {</li><li>    Column() {</li><li>      Text(<span class="hljs-string">'Hello Word'</span>)</li><li>        .fontSize(<span class="hljs-number">20</span>)</li><li>        .fontWeight(FontWeight.Bold)</li><li>        .textAlign(TextAlign.Start)</li><li>        .margin({ left: <span class="hljs-number">10</span> })</li><li>        .width(<span class="hljs-number">100</span>)</li><li>
</li><li>      Column() {</li><li>        Row() {</li><li>          Text(<span class="hljs-string">'Title'</span>)</li><li>            .fontSize(<span class="hljs-number">16</span>)</li><li>            .margin(<span class="hljs-number">20</span>)</li><li>            .fontWeight(FontWeight.Medium)</li><li>          Blank()</li><li>          Toggle({ type: ToggleType.Switch, isOn: <span class="hljs-literal">false</span> })</li><li>            .selectedColor(Color.Blue)</li><li>            .margin({ right: <span class="hljs-number">20</span> })</li><li>            .width(<span class="hljs-number">20</span>)</li><li>            .height(<span class="hljs-number">100</span>)</li><li>            .onChange((isOn) =&gt; {</li><li>              <span class="hljs-keyword">if</span> (isOn) {</li><li>                <span class="hljs-keyword">this</span>.useNetworkRegister();</li><li>              } <span class="hljs-keyword">else</span> {</li><li>                <span class="hljs-keyword">this</span>.unUseNetworkRegister();</li><li>              }</li><li>            })</li><li>        }</li><li>        .height(<span class="hljs-number">100</span>)</li><li>        .borderRadius(<span class="hljs-number">10</span>)</li><li>        .margin({ left: <span class="hljs-number">10</span>, right: <span class="hljs-number">10</span> })</li><li>        .width(<span class="hljs-number">200</span>)</li><li>        .backgroundColor(Color.Black)</li><li>
</li><li>        TextArea({ text: <span class="hljs-keyword">this</span>.netStateMessage })</li><li>          .fontSize(<span class="hljs-number">16</span>)</li><li>          .width(<span class="hljs-number">200</span>)</li><li>          .height(<span class="hljs-number">100</span>)</li><li>          .margin(<span class="hljs-number">10</span>)</li><li>          .borderRadius(<span class="hljs-number">10</span>)</li><li>          .textAlign(TextAlign.Start)</li><li>          .focusOnTouch(<span class="hljs-literal">false</span>)</li><li>
</li><li>        Button(<span class="hljs-string">'Clear'</span>)</li><li>          .fontSize(<span class="hljs-number">18</span>)</li><li>          .width(<span class="hljs-number">200</span>)</li><li>          .height(<span class="hljs-number">40</span>)</li><li>          .margin({</li><li>            left: <span class="hljs-number">10</span>,</li><li>            right: <span class="hljs-number">10</span>,</li><li>            bottom: <span class="hljs-number">10</span></li><li>          })</li><li>          .onClick(() =&gt; {</li><li>            <span class="hljs-keyword">this</span>.netStateMessage = <span class="hljs-string">''</span>;</li><li>          })</li><li>        Blank()</li><li>      }</li><li>      .height(<span class="hljs-number">100</span>)</li><li>      .justifyContent(FlexAlign.Start)</li><li>    }</li><li>    .width(<span class="hljs-number">200</span>)</li><li>  }</li><li>
</li><li>  getConnectionProperties() {</li><li>    connection.getDefaultNet().then((netHandle: connection.NetHandle) =&gt; {</li><li>      connection.getConnectionProperties(netHandle, (error: BusinessError, connectionProperties: connection.ConnectionProperties) =&gt; {</li><li>        <span class="hljs-keyword">if</span> (error) {</li><li>          <span class="hljs-keyword">this</span>.connectionMessage = <span class="hljs-string">'连接错误'</span>;</li><li>          Logger.error(<span class="hljs-string">'getConnectionProperties error:'</span> + error.code + error.message);</li><li>          <span class="hljs-keyword">return</span>;</li><li>        }</li><li>        <span class="hljs-keyword">this</span>.connectionMessage = <span class="hljs-string">'连接'</span> + connectionProperties.interfaceName</li><li>          + <span class="hljs-string">'developer.huawei.com'</span> + connectionProperties.domains</li><li>          + <span class="hljs-string">'/cn'</span> + JSON.stringify(connectionProperties.linkAddresses)</li><li>          + <span class="hljs-string">'/doc'</span> + JSON.stringify(connectionProperties.routes)</li><li>          + <span class="hljs-string">'/best-practices'</span> + JSON.stringify(connectionProperties.dnses)</li><li>          + <span class="hljs-string">'btpa-memory-optimization'</span> + connectionProperties.mtu + <span class="hljs-string">'\n'</span>;</li><li>      })</li><li>    });</li><li>  }</li><li>
</li><li>  useNetworkRegister() {</li><li>    <span class="hljs-keyword">this</span>.netCon = connection.createNetConnection();</li><li>    <span class="hljs-keyword">this</span>.netStateMessage += <span class="hljs-string">'连接'</span>;</li><li>    <span class="hljs-keyword">this</span>.netCon.register((error) =&gt; {</li><li>      <span class="hljs-keyword">if</span> (error) {</li><li>        Logger.error(<span class="hljs-string">'register error:'</span> + error.message);</li><li>        <span class="hljs-keyword">return</span>;</li><li>      }</li><li>      <span class="hljs-keyword">this</span>.getUIContext().getPromptAction().showToast({</li><li>        message: <span class="hljs-string">'连接成功'</span>,</li><li>        duration: <span class="hljs-number">1000</span></li><li>      });</li><li>    })</li><li>    <span class="hljs-keyword">this</span>.netCon.on(<span class="hljs-string">'netAvailable'</span>, (netHandle) =&gt; {</li><li>      <span class="hljs-keyword">this</span>.netStateMessage += <span class="hljs-string">'连接'</span> + netHandle.netId + <span class="hljs-string">'\n'</span>;</li><li>    })</li><li>    <span class="hljs-keyword">this</span>.netCon.on(<span class="hljs-string">'netBlockStatusChange'</span>, (<span class="hljs-keyword">data</span>) =&gt; {</li><li>      <span class="hljs-keyword">this</span>.netStateMessage += <span class="hljs-string">'更换'</span> + <span class="hljs-keyword">data</span>.netHandle.netId + <span class="hljs-string">'\n'</span>;</li><li>    })</li><li>    <span class="hljs-keyword">this</span>.netCon.on(<span class="hljs-string">'netCapabilitiesChange'</span>, (<span class="hljs-keyword">data</span>) =&gt; {</li><li>      <span class="hljs-keyword">this</span>.netStateMessage += <span class="hljs-string">'id'</span> + <span class="hljs-keyword">data</span>.netHandle.netId</li><li>        + <span class="hljs-string">'cap'</span> + JSON.stringify(<span class="hljs-keyword">data</span>.netCap) + <span class="hljs-string">'\n'</span>;</li><li>    })</li><li>    <span class="hljs-keyword">this</span>.netCon.on(<span class="hljs-string">'netConnectionPropertiesChange'</span>, (<span class="hljs-keyword">data</span>) =&gt; {</li><li>      <span class="hljs-keyword">this</span>.netStateMessage += <span class="hljs-string">'id'</span> + <span class="hljs-keyword">data</span>.netHandle.netId</li><li>        + <span class="hljs-string">'propertis'</span> + JSON.stringify(<span class="hljs-keyword">data</span>.connectionProperties) + <span class="hljs-string">'\n'</span>;</li><li>    })</li><li>  }</li><li>
</li><li>  unUseNetworkRegister() {</li><li>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.netCon) {</li><li>      <span class="hljs-keyword">this</span>.netCon.unregister((error: BusinessError) =&gt; {</li><li>        <span class="hljs-keyword">if</span> (error) {</li><li>          Logger.error(<span class="hljs-string">'unregister error:'</span> + error.message);</li><li>          <span class="hljs-keyword">return</span>;</li><li>        }</li><li>        <span class="hljs-keyword">this</span>.getUIContext().getPromptAction().showToast({</li><li>          message: <span class="hljs-string">'message'</span>,</li><li>          duration: <span class="hljs-number">1000</span></li><li>        });</li><li>        <span class="hljs-keyword">this</span>.netStateMessage += <span class="hljs-string">'listener'</span>;</li><li>      })</li><li>    } <span class="hljs-keyword">else</span> {</li><li>      <span class="hljs-keyword">this</span>.netStateMessage += <span class="hljs-string">'listener_fail'</span>;</li><li>    }</li><li>  }</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/OptimizationAppMemoryUsage/entry/src/main/ets/pages/Index.ets#L2-L154" target="_blank">Index.ets</a></div></div></div></div> </div> <div class="tiledSection"><h2 id="section9861133114316">使用purgeable优化C++内存<i class="anchor-icon anchor-icon-link" anchorid="section9861133114316" tips="复制节点链接"></i></h2><p><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/capi-purgeable-memory-h" target="_blank">Purgeable Memory</a>是HarmonyOS中native层的内存管理机制，适用于图像处理的Bitmap、流媒体应用的一次性数据和图片等。应用可使用 Purgeable Memory 存放内部缓存数据，系统根据淘汰策略管理所有Purgeable内存。当系统内存不足时，系统通过丢弃Purgeable内存快速回收资源，释放更多内存给其他应用程序，实现高效的全局缓存数据管理，提高系统稳定性和流畅性。在使用Purgeable内存时，开发者可以调用接口释放Purgeable内存，但需要注意在适当的时机释放Purgeable内存，以确保内存资源能够得到有效管理，避免内存占用过高导致的性能问题和内存泄漏的情况。通过合理使用Purgeable内存，开发者可以更好地管理应用程序的内存，提高用户体验。</p> </div> <div class="tiledSection"><h3 id="section735116550594" class="firsth2">原理介绍<i class="anchor-icon anchor-icon-link" anchorid="section735116550594" tips="复制节点链接"></i></h3><p>访问Purgeable内存的流程如下图所示。首先，判断Purgeable内存的数据是否已被回收。如果已回收，需重建数据。访问Purgeable内存时，其引用计数refcnt加1；访问结束后，refcnt减1。当refcnt为0时，Purgeable内存可被系统回收。</p> <div class="fignone"><span class="figcap"><b>图2 </b>Purgeable内存访问流程图</span><br><span><img originheight="809" originwidth="517" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163421.91056093733425786169952732533033:50001231000000:2800:968F44CC7AEECE942DBAFBF4702D1668FE050491497F5A4A74C14D887946BB3D.png" width="517" height="809"></span></div> <p>Purgeable内存回收流程图如下所示。当引用计数为0时，丢弃Purgeable内存中的数据，并标记为已回收。</p> </div> <div class="fignone"><span class="figcap"><b>图3 </b>Purgeable内存回收流程图</span><br><span><img originheight="678" originwidth="371" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163421.02529267333022644662329247961578:50001231000000:2800:309CC0F923FB56D23DCEAB5E7CA5DCA13571E315011DB89F8FDD283BEEC35F0B.png" width="371" height="678"></span></div> <div class="tiledSection"><h3 id="section173236818225">参考案例<i class="anchor-icon anchor-icon-link" anchorid="section173236818225" tips="复制节点链接"></i></h3><p>在CMakeLists.txt文件中引入Purgeable对应的动态链接库libpurgeable_memory_ndk.z.so，具体如下所示：</p> <div class="screenLinkPre"><div _ngcontent-ega-c106="" class="highlight-div"><div _ngcontent-ega-c106="" class="highlight-div-header"><div _ngcontent-ega-c106="" class="highlight-div-header-left"><div _ngcontent-ega-c106="" class="handle-button expand-button"><div _ngcontent-ega-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-ega-c106="" class="highlight-div-header-right"><div _ngcontent-ega-c106="" class="handle-button ai-button"></div><div _ngcontent-ega-c106="" class="handle-button line-button"><div _ngcontent-ega-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-ega-c106="" class="handle-button theme-button"><div _ngcontent-ega-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-ega-c106="" class="handle-button copy-button"><div _ngcontent-ega-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-ega-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-scss" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/OptimizationAppMemoryUsage/entry/src/main/ets/utils/CMakeLists.txt#L2-L13" data-highlighted="yes"><ol class="linenums"><li># the minimum version of CMake.</li><li><span class="hljs-built_in">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.4</span>.<span class="hljs-number">1</span>)</li><li><span class="hljs-built_in">project</span>(MyNativeApplication)</li><li><span class="hljs-built_in">set</span>(NATIVERENDER_ROOT_PATH ${CMAKE_CURRENT_SOURCE_DIR})</li><li><span class="hljs-built_in">if</span>(DEFINED PACKAGE_FIND_FILE)</li><li>    <span class="hljs-built_in">include</span>(${PACKAGE_FIND_FILE})</li><li><span class="hljs-built_in">endif</span>()</li><li><span class="hljs-built_in">include_directories</span>(${NATIVERENDER_ROOT_PATH}</li><li>                    ${NATIVERENDER_ROOT_PATH}/include)</li><li><span class="hljs-built_in">add_library</span>(entry SHARED napi_init.cpp)</li><li># Introduce libpurgeable_memory_ndk<span class="hljs-selector-class">.z</span><span class="hljs-selector-class">.so</span> dynamic link library.</li><li><span class="hljs-built_in">target_link_libraries</span>(entry PUBLIC libace_napi.z.so libpurgeable_memory_ndk.z.so)</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/OptimizationAppMemoryUsage/entry/src/main/ets/utils/CMakeLists.txt#L2-L13" target="_blank">CMakeLists.txt</a></div></div></div></div> </div> <p>引入purgeable_memory头文件，声明ModifyFunc函数，调用OH_PurgeableMemory_Create创建PurgeableMemory对象。</p> <p>在读取PurgeableMemory对象的内容时，需要调用OH_PurgeableMemory_BeginRead，读取完成后，需要调用OH_PurgeableMemory_EndRead。其中，OH_PurgeableMemory_GetContent可以获取PurgeableMemory对象的内存数据。</p> <p>在修改PurgeableMemory对象的内容时，需要调用OH_PurgeableMemory_BeginWrite，修改完成后，需要调用OH_PurgeableMemory_EndWrite。其中，OH_PurgeableMemory_AppendModify可以更新PurgeableMemory对象重建规则。</p> <div class="screenLinkPre"><div _ngcontent-ega-c106="" class="highlight-div"><div _ngcontent-ega-c106="" class="highlight-div-header"><div _ngcontent-ega-c106="" class="highlight-div-header-left"><div _ngcontent-ega-c106="" class="handle-button expand-button"><div _ngcontent-ega-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-ega-c106="" class="highlight-div-header-right"><div _ngcontent-ega-c106="" class="handle-button ai-button"></div><div _ngcontent-ega-c106="" class="handle-button line-button"><div _ngcontent-ega-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-ega-c106="" class="handle-button theme-button"><div _ngcontent-ega-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-ega-c106="" class="handle-button copy-button"><div _ngcontent-ega-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-ega-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-cpp" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/OptimizationAppMemoryUsage/entry/src/main/ets/cpps/AddCpp.cpp#L2-L75" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"napi/native_api.h"</span></span></li><li><span class="hljs-meta">#<span class="hljs-keyword">define</span> DATASIZE (4 * 1024 * 1024)</span></li><li><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"purgeable_memory/purgeable_memory.h"</span></span></li><li>
</li><li><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ModifyFunc</span><span class="hljs-params">(<span class="hljs-type">void</span> *data, <span class="hljs-type">size_t</span> size, <span class="hljs-type">void</span> *param)</span> </span>{</li><li>    data = param;</li><li>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</li><li>}</li><li><span class="hljs-comment">// Business definition object type</span></li><li><span class="hljs-keyword">class</span> <span class="hljs-title class_">ReqObj</span>;</li><li><span class="hljs-function"><span class="hljs-type">static</span> napi_value <span class="hljs-title">Add</span><span class="hljs-params">(napi_env env, napi_callback_info info)</span></span></li><li><span class="hljs-function"></span>{</li><li>    <span class="hljs-type">size_t</span> requireArgc = <span class="hljs-number">2</span>;</li><li>    <span class="hljs-type">size_t</span> argc = <span class="hljs-number">2</span>;</li><li>    napi_value args[<span class="hljs-number">2</span>] = {<span class="hljs-literal">nullptr</span>};</li><li>    <span class="hljs-built_in">napi_get_cb_info</span>(env, info, &amp;argc, args , <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);</li><li>    napi_valuetype valuetype0;</li><li>    <span class="hljs-built_in">napi_typeof</span>(env, args[<span class="hljs-number">0</span>], &amp;valuetype0);</li><li>    napi_valuetype valuetype1;</li><li>    <span class="hljs-built_in">napi_typeof</span>(env, args[<span class="hljs-number">1</span>], &amp;valuetype1);</li><li>    <span class="hljs-type">double</span> value0;</li><li>    <span class="hljs-built_in">napi_get_value_double</span>(env, args[<span class="hljs-number">0</span>], &amp;value0);</li><li>    <span class="hljs-type">double</span> value1;</li><li>    <span class="hljs-built_in">napi_get_value_double</span>(env, args[<span class="hljs-number">1</span>], &amp;value1);</li><li>    <span class="hljs-type">double</span> result = value0 + value1;</li><li>    <span class="hljs-comment">// Create a PurgeableMemory object</span></li><li>    OH_PurgeableMemory *pPurgmem = <span class="hljs-built_in">OH_PurgeableMemory_Create</span>(DATASIZE, ModifyFunc, &amp;result);</li><li>    <span class="hljs-comment">// Read the object</span></li><li>    <span class="hljs-built_in">OH_PurgeableMemory_BeginRead</span>(pPurgmem);</li><li>    <span class="hljs-comment">// Get the size of PurgeableMemory object</span></li><li>    <span class="hljs-type">size_t</span> size = <span class="hljs-built_in">OH_PurgeableMemory_ContentSize</span>(pPurgmem);</li><li>    <span class="hljs-comment">// Get the content of the PurgeableMemory object</span></li><li>    ReqObj *pReqObj = (ReqObj *)<span class="hljs-built_in">OH_PurgeableMemory_GetContent</span>(pPurgmem);</li><li>    <span class="hljs-comment">// Read the end of the PurgeableMemory object</span></li><li>    <span class="hljs-built_in">OH_PurgeableMemory_EndRead</span>(pPurgmem);</li><li>    </li><li>    <span class="hljs-comment">// Modify the PurgeableMemory object</span></li><li>    <span class="hljs-built_in">OH_PurgeableMemory_BeginWrite</span>(pPurgmem);</li><li>    <span class="hljs-comment">// Declare the parameters of the extended creation function</span></li><li>    <span class="hljs-type">double</span> newResult = value0 + value0;</li><li>    <span class="hljs-comment">// Update PurgeableMemory object reconstruction rules</span></li><li>    <span class="hljs-built_in">OH_PurgeableMemory_AppendModify</span>(pPurgmem, ModifyFunc, &amp;newResult);</li><li>    <span class="hljs-comment">// End of modifying the PurgeableMemory object</span></li><li>    <span class="hljs-built_in">OH_PurgeableMemory_EndWrite</span>(pPurgmem);</li><li>    <span class="hljs-comment">// Destroyed object</span></li><li>    <span class="hljs-built_in">OH_PurgeableMemory_Destroy</span>(pPurgmem);</li><li>    napi_value sum;</li><li>    <span class="hljs-built_in">napi_create_double</span>(env, result, &amp;sum);</li><li>    <span class="hljs-keyword">return</span> sum;</li><li>}</li><li><span class="hljs-function">EXTERN_C_START</span></li><li><span class="hljs-function"><span class="hljs-type">static</span> napi_value <span class="hljs-title">Init</span><span class="hljs-params">(napi_env env, napi_value exports)</span></span></li><li><span class="hljs-function"></span>{</li><li>    napi_property_descriptor desc[] = {</li><li>        { <span class="hljs-string">"add"</span>, <span class="hljs-literal">nullptr</span>, Add, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, napi_default, <span class="hljs-literal">nullptr</span> }</li><li>    };</li><li>    <span class="hljs-built_in">napi_define_properties</span>(env, exports, <span class="hljs-built_in">sizeof</span>(desc) / <span class="hljs-built_in">sizeof</span>(desc[<span class="hljs-number">0</span>]), desc);</li><li>    <span class="hljs-keyword">return</span> exports;</li><li>}</li><li>EXTERN_C_END</li><li>
</li><li><span class="hljs-type">static</span> napi_module demoModule = {</li><li>    .nm_version = <span class="hljs-number">1</span>,</li><li>    .nm_flags = <span class="hljs-number">0</span>,</li><li>    .nm_filename = <span class="hljs-literal">nullptr</span>,</li><li>    .nm_register_func = Init,</li><li>    .nm_modname = <span class="hljs-string">"entry"</span>,</li><li>    .nm_priv = ((<span class="hljs-type">void</span>*)<span class="hljs-number">0</span>),</li><li>    .reserved = { <span class="hljs-number">0</span> },</li><li>};</li><li><span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> __attribute__((constructor)) <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RegisterEntryModule</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span></li><li><span class="hljs-function"></span>{</li><li>    <span class="hljs-built_in">napi_module_register</span>(&amp;demoModule);</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/OptimizationAppMemoryUsage/entry/src/main/ets/cpps/AddCpp.cpp#L2-L75" target="_blank">AddCpp.cpp</a></div></div></div></div> <div class="tiledSection"><h2 id="section199879042313">使用合理尺寸的图片优化应用内存<i class="anchor-icon anchor-icon-link" anchorid="section199879042313" tips="复制节点链接"></i></h2></div> <div class="tiledSection"><h3 id="section145861337102316" class="firsth2">原理介绍<i class="anchor-icon anchor-icon-link" anchorid="section145861337102316" tips="复制节点链接"></i></h3><p>在定义界面时，应用需根据组件类型绘制相应内容。图片组件用于加载和显示图片，同时会占用内存。ArkTS 使用引用计数机制管理内存。引用计数通过记录每个对象的引用次数来确定何时释放对象。如果组件未正确释放，即使其他地方不再使用该组件，相关资源也不会被释放，可能导致内存泄漏。</p> <p>一张全屏的图片，不同分辨率的内存占用大小如下：</p> <p><span><img height="345.93300000000005" originheight="891" originwidth="1336" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163422.73864955537752776090592648505365:50001231000000:2800:18A4403EB514191EBBDB19B56A4379C961C740BF49CA341025C5C23142077265.png" title="点击放大" width="518.7"></span></p> <p>由上图可以看出，对于页面多、图片多、效果丰富的资源密集型应用，内存容易达到较高水平。当应用的内存占用超过系统设定的阈值（例如4GB，不同系统的阈值可能不同）时，系统可能会认为应用存在严重的内存问题，并可能强制终止该应用进程，以保证设备系统的稳定性和性能。为了避免应用被系统终止，开发者可以考虑以下两点：</p> <ol><li>优化资源使用：通过合理设置图片源文件大小，合理使用内存资源，减少图片所占应用内存。</li><li><a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-best-practices-long-list#section155051250172217" target="_blank">布局优化</a>：通过减少布局嵌套层级，减少过度绘制可以产生较大的性能收益。</li></ol> <p>本章节指导开发者合理设置图片源文件大小，优化内存使用，减少图片占用的应用内存。</p> </div> <div class="tiledSection"><h3 id="section932653132411">避免加载超过显示尺寸的图片<i class="anchor-icon anchor-icon-link" anchorid="section932653132411" tips="复制节点链接"></i></h3><div class="screenLinkPre"><div _ngcontent-ega-c106="" class="highlight-div"><div _ngcontent-ega-c106="" class="highlight-div-header"><div _ngcontent-ega-c106="" class="highlight-div-header-left"><div _ngcontent-ega-c106="" class="handle-button expand-button"><div _ngcontent-ega-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-ega-c106="" class="highlight-div-header-right"><div _ngcontent-ega-c106="" class="handle-button ai-button"></div><div _ngcontent-ega-c106="" class="handle-button line-button"><div _ngcontent-ega-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-ega-c106="" class="handle-button theme-button"><div _ngcontent-ega-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-ega-c106="" class="handle-button copy-button"><div _ngcontent-ega-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-ega-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-scss" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/OptimizationAppMemoryUsage/entry/src/main/ets/pages/Demo.ets#L37-L41" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-built_in">Column</span>() {</li><li>  <span class="hljs-built_in">Image</span>($r('app.media.image'))</li><li>    <span class="hljs-selector-class">.width</span>("<span class="hljs-number">500px</span>")</li><li>    <span class="hljs-selector-class">.height</span>("<span class="hljs-number">500px</span>")</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/OptimizationAppMemoryUsage/entry/src/main/ets/pages/Demo.ets#L37-L41" target="_blank">Demo.ets</a></div></div></div></div>  <p>使用500×500尺寸的Image组件加载一张4032×3024的RGBA格式图片时，图片申请了约46.5 MB的内存。这是因为图片原始尺寸较大，加载到Image组件中时需要缩放到500×500尺寸，这个过程会占用一定的内存。</p> <p>纹理图片内存大小 = imageWidth x imageHeight x format（4032*3024 * 4 = 48771072 bytes ≈ 46.5M）。</p> <p>组件实际需要的尺寸为500*500，所需内存约为1M。</p> <p><span><img height="345.93300000000005" originheight="891" originwidth="1336" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163422.11564946747703952724201060554049:50001231000000:2800:F56DF4EF7C354D63999ECBE18E0E040E502C40C6B08BD5B4739415001453BAC2.png" title="点击放大" width="518.7"></span></p> <p>当图片尺寸超过控件显示区域时，图片会被裁剪或缩放。频繁的裁剪和缩放不仅会降低视图效果，还会浪费内存，增加功耗。为了节省内存，开发者可以手动调整源文件的尺寸，使其与组件大小一致。这样可以避免不必要的内存浪费，并提高应用程序的性能和效率。开发者可以使用图像处理工具来调整图像尺寸，进一步节省内存空间。</p> </div> <div class="tiledSection"><h2 id="section6411482299">其他方法<i class="anchor-icon anchor-icon-link" anchorid="section6411482299" tips="复制节点链接"></i></h2><p>在日常开发中，常见的其他减少内存方式有如下几种：</p> <ul><li>使用虚引用（Weak Reference）：在HarmonyOS应用开发中，可以使用虚引用（Weak Reference）来避免内存泄漏。通过使用Weak Reference，可以避免循环引用导致的内存泄漏问题，确保对象在不再需要时能够被正确释放。</li><li>使用Sendable：符合Sendable协议的数据可以在ArkTS并发实例间传递，从而减少拷贝的开销及其内存。关于Sendable的详细内容可参考<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-sendable" target="_blank">《Sendable开发指导》</a>。</li><li>使用可共享对象：共享对象SharedArrayBuffer，拥有固定长度，可以存储任何类型的数据，包括数字、字符串等。共享对象传输指SharedArrayBuffer支持在多线程之间传递，传递之后的SharedArrayBuffer对象和原始的SharedArrayBuffer对象指向同一块内存，进而达到内存共享的目的。详细内容可参考<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/shared-arraybuffer-object" target="_blank">《SharedArrayBuffer对象》</a>。</li></ul> </div> </div> <div></div></div>