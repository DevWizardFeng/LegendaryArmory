<h1 _ngcontent-puf-c119="" class="doc-title ng-star-inserted" title="应用并发设计"> 应用并发设计 </h1>

<div _ngcontent-puf-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;"> <div><div class="tiledSection"><h2 id="section125161119164620">概述<i class="anchor-icon anchor-icon-link" anchorid="section125161119164620" tips="复制节点链接"></i></h2></div> <p><span>ArkTS</span><span>是HarmonyOS APP的开发语言，它在保持</span><span>TypeScript</span><span>（简称</span><span>TS</span><span>）基本语法风格的基础上，一方面规范强化静态检查提升开发者代码的规范性；另一方面基于</span><span>TypeScript</span><span>增强了一些特性提升开发体验和执行效率，尤其是在并发能力上的提升。</span></p> <p><span>本文档主要面向HarmonyOS APP的设计人员或开发人员，介绍应用在并行任务方案设计过程中，可能会遇到的典型场景以及对应的推荐设计方案，同时给出了方案的关键点及参考案例。</span></p> <div class="tiledSection"><h2 id="section65214754718">典型业务场景<i class="anchor-icon anchor-icon-link" anchorid="section65214754718" tips="复制节点链接"></i></h2><p>根据当前HarmonyOS APP开发过程中遇到的实际并发业务场景，总结提炼出如下典型场景，可供更多APP参考，设计其并发业务方案。</p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><tbody><tr><td class="cellrowborder" valign="top" width="8.16%"><p><span>场景编号</span></p> </td> <td class="cellrowborder" valign="top" width="26.83%"><p><span>场景分类</span></p> </td> <td class="cellrowborder" valign="top" width="36.44%"><p><span>场景名称</span></p> </td> <td class="cellrowborder" valign="top" width="28.57%"><p><span>简述</span></p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="8.16%"><p><span>1</span></p> </td> <td class="cellrowborder" rowspan="4" valign="top" width="26.83%"><p><span>并发能力选择</span></p> </td> <td class="cellrowborder" valign="top" width="36.44%"><p><a href="/consumer/cn/doc/best-practices/bpta-app-concurrency-design#section15392153922413">耗时任务并发执行场景</a></p> </td> <td class="cellrowborder" valign="top" width="28.57%"><p>相对独立的耗时任务放到单独的子线程中执行，推荐TaskPool</p> </td> </tr> <tr><td class="cellrowborder" valign="top"><p>2</p> </td> <td class="cellrowborder" valign="top"><p><a href="/consumer/cn/doc/best-practices/bpta-app-concurrency-design#section76941238135110">常驻任务并发执行场景</a></p> </td> <td class="cellrowborder" valign="top"><p>常驻的耗时任务放到单独的子线程中执行，推荐Worker</p> </td> </tr> <tr><td class="cellrowborder" valign="top"><p>3</p> </td> <td class="cellrowborder" valign="top"><p><a href="/consumer/cn/doc/best-practices/bpta-app-concurrency-design#section196265243512">传统共享内存并发业务</a></p> </td> <td class="cellrowborder" valign="top"><p>开发共享内存并发业务，推荐TaskPool和Worker的API</p> </td> </tr> <tr><td class="cellrowborder" valign="top"><p>4</p> </td> <td class="cellrowborder" valign="top"><p><a href="/consumer/cn/doc/best-practices/bpta-app-concurrency-design#section484614505514">长时任务并发执行场景</a></p> </td> <td class="cellrowborder" valign="top"><p>长时间运行的任务不独占线程执行，推荐TaskPool长时任务</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="8.16%"><p>5</p> </td> <td class="cellrowborder" rowspan="5" valign="top" width="26.83%"><p><span>并发任务管理</span></p> </td> <td class="cellrowborder" valign="top" width="36.44%"><p><a href="/consumer/cn/doc/best-practices/bpta-app-concurrency-design#section843404931116">多任务关联执行（串行顺序依赖）</a></p> </td> <td class="cellrowborder" valign="top" width="28.57%"><p>有顺序的任务不希望并发执行</p> </td> </tr> <tr><td class="cellrowborder" valign="top"><p>6</p> </td> <td class="cellrowborder" valign="top"><p><a href="/consumer/cn/doc/best-practices/bpta-app-concurrency-design#section154701412191218">多任务关联执行（树状依赖）</a></p> </td> <td class="cellrowborder" valign="top"><p>任务存在依赖关系，等待依赖执行完再调度</p> </td> </tr> <tr><td class="cellrowborder" valign="top"><p>7</p> </td> <td class="cellrowborder" valign="top"><p><a href="/consumer/cn/doc/best-practices/bpta-app-concurrency-design#section13759133112128">多任务同步等待结果（任务组）</a></p> </td> <td class="cellrowborder" valign="top"><p>多个任务等待全部结果返回后再进行后续操作</p> </td> </tr> <tr><td class="cellrowborder" valign="top"><p>8</p> </td> <td class="cellrowborder" valign="top"><p><a href="/consumer/cn/doc/best-practices/bpta-app-concurrency-design#section873704510120">多任务优先级调度</a></p> </td> <td class="cellrowborder" valign="top"><p>设置不同任务的优先级</p> </td> </tr> <tr><td class="cellrowborder" valign="top"><p>9</p> </td> <td class="cellrowborder" valign="top"><p><a href="/consumer/cn/doc/best-practices/bpta-app-concurrency-design#section18304175813129">任务延时调度</a></p> </td> <td class="cellrowborder" valign="top"><p>任务延时调度</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="8.16%"><p>10</p> </td> <td class="cellrowborder" rowspan="5" valign="top" width="26.83%"><p><span>线程间通信</span></p> </td> <td class="cellrowborder" valign="top" width="36.44%"><p><a href="/consumer/cn/doc/best-practices/bpta-app-concurrency-design#section35851753051">同语言线程间通信（ArkTS内）</a></p> </td> <td class="cellrowborder" valign="top" width="28.57%"><p>介绍ArkTS线程间通信机制</p> </td> </tr> <tr><td class="cellrowborder" valign="top"><p><span>11</span></p> </td> <td class="cellrowborder" valign="top"><p><a href="/consumer/cn/doc/best-practices/bpta-app-concurrency-design#section101785720619">跨语言多线程通信（C++与ArkTS）</a></p> </td> <td class="cellrowborder" valign="top"><p>介绍C++与ArkTS线程间通信机制</p> </td> </tr> <tr><td class="cellrowborder" valign="top"><p><span>12</span></p> </td> <td class="cellrowborder" valign="top"><p><a href="/consumer/cn/doc/best-practices/bpta-app-concurrency-design#section19259192873">线程间模块共享（单例模式）</a></p> </td> <td class="cellrowborder" valign="top"><p>介绍进程内单例场景</p> </td> </tr> <tr><td class="cellrowborder" valign="top"><p>13</p> </td> <td class="cellrowborder" valign="top"><p><a href="/consumer/cn/doc/best-practices/bpta-app-concurrency-design#section154816558122">线程间不可变数据共享</a></p> </td> <td class="cellrowborder" valign="top"><p>介绍不可变数据共享场景</p> </td> </tr> <tr><td class="cellrowborder" valign="top"><p>14</p> </td> <td class="cellrowborder" valign="top"><p><a href="/consumer/cn/doc/best-practices/bpta-app-concurrency-design#section9833163071612">生产者与消费者模式</a></p> </td> <td class="cellrowborder" valign="top"><p>介绍生产者与消费者模式</p> </td> </tr>  </tbody></table></div> </div> </div> <div class="tiledSection"><h2 id="section07961951115019">并发能力整体架构<i class="anchor-icon anchor-icon-link" anchorid="section07961951115019" tips="复制节点链接"></i></h2></div> <div class="tiledSection"><h3 id="section118341449155112" class="firsth2">并发能力概述<i class="anchor-icon anchor-icon-link" anchorid="section118341449155112" tips="复制节点链接"></i></h3><p>并发能力框架如下：</p> <p><span><img height="286.2825" originheight="1079" originwidth="1972" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163006.16793729376810629928210967868534:50001231000000:2800:424D32549876FC231539EC837CEA88D5EDD6FF11842712240CF9A33BFBD393A3.png" title="点击放大" width="523.6875"></span></p> <ul><li><strong>主线程：</strong>执行UI业务、不耗时操作、单次I/O任务，与其他ArkTS线程共享系统I/O线程池，不阻塞ArkTS线程。</li><li><strong>TaskPool</strong><strong>高并发任务池：</strong>执行耗时任务，封装任务入口，统计模块负载，开发者无需管理线程生命周期。</li><li><strong>Worker</strong><strong>线程：</strong>执行常驻任务，CPU密集型、耗时任务，限制线程个数为64。</li><li><strong>FFRT</strong><strong>任务池：</strong><ol><li>系统任务，如异步I/O任务，由系统分发到FFRT线程，开发者无需关注。</li><li>用户任务：开发者创建的C/C++耗时任务，支持负载均衡及线程生命周期管理。</li></ol> </li><li><strong>Pthread</strong><strong>线程：</strong>采用C/C++开发的模块，后台运行或耗时的ArkTS无关业务，不限制线程个数。</li></ul> </div> <div class="tiledSection"><h2 id="section930410513547">并发模型与业界模型的差异<i class="anchor-icon anchor-icon-link" anchorid="section930410513547" tips="复制节点链接"></i></h2></div> <div class="tiledSection"><h3 id="section137409247549" class="firsth2">共享内存并发模型<i class="anchor-icon anchor-icon-link" anchorid="section137409247549" tips="复制节点链接"></i></h3><p><span><img height="416.95500000000004" originheight="629" originwidth="790" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163006.15617360147097761213141892606253:50001231000000:2800:6388DD48E58804386E6E659D62AC3B70EED6B22742931B3F9D73DB37ACE93D90.jpg" title="点击放大" width="523.6875"></span></p> <p>共享内存模型采用线程和锁的并发机制，不同线程共享内存并通过锁保护临界区。对于包含I/O操作或锁的业务，为防止阻塞，需开启多个线程执行不同业务。线程情况如下图所示：</p> <p><span><img height="285.285" originheight="973" originwidth="1781" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163006.57315398867665056623066527542219:50001231000000:2800:B3243B0F60F280171790480F7251AAF1A520FF9800508EF1C3CEABA66D03CA1D.jpg" title="点击放大" width="523.6875"></span></p> <p>因此，应用经常存在几百个线程，增加调度开销和内存占用。</p> </div> <div class="tiledSection"><h3 id="section9621172315568">ArkTS并发模型<i class="anchor-icon anchor-icon-link" anchorid="section9621172315568" tips="复制节点链接"></i></h3><p><span><img height="430.92" originheight="659" originwidth="800" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163007.25869558618157795871598153587530:50001231000000:2800:2C3D89281A227B59B3AC6FCCC651BCDBE69F4D6F6719528C4D3EF39131AC4C10.jpg" title="点击放大" width="523.6875"></span></p> <p>ArkTS采用内存隔离的线程模型，不同线程间通过消息通信，线程内无锁化运行。业务内部的I/O操作由系统分发到后台的I/O任务池，不阻塞ArkTS上层逻辑，线程情况如下图所示。</p> <p><span><img height="254.3625" originheight="827" originwidth="1697" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163007.88354160090780455366789226798020:50001231000000:2800:17155B57E82B28654FD2FB1204303AD6B1E15A0BA7873B851058D48DA427FA84.jpg" title="点击放大" width="523.6875"></span></p> <p>异步I/O不阻塞ArkTS线程，TaskPool及I/O线程池由系统管理，提升能效。</p> <p>ArkTS语言支持了TaskPool和Worker的并发能力，接下来简单介绍TaskPool和Worker的功能。</p> <p>TaskPool的运作机制可参考<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/taskpool-introduction" target="_blank">TaskPool简介</a>，TaskPool提供任务分发入口，支持分发任务到不同优先级队列。TaskPool底层管理一定数量的工作线程，从队列获取任务执行。工作线程根据任务数量自动扩缩容，保证执行效率。TaskPool根据任务量及线程数量，决定是否扩容或缩容。例如，8核设备的线程数上限为7-15。</p> <p>Worker的运作机制可参考<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/worker-introduction" target="_blank">Worker简介</a>，空任务的Worker线程的内存占用大约2MB左右，因此需要控制线程的数量，避免内存过大。</p> </div> <div class="tiledSection"><h3 id="section17421641924">ArkTS与传统共享内存并行化的差异<i class="anchor-icon anchor-icon-link" anchorid="section17421641924" tips="复制节点链接"></i></h3><p>通过并发模型对比，ArkTS中的异步I/O操作分发到I/O任务池，不阻塞执行。Java需大量线程进行阻塞I/O操作，导致线程数较多。</p> <p>ArkTS采用内存隔离的并发模型，不支持跨线程共享对象，必须进行线程间数据通信。Java可以直接访问不同线程的对象，但需要使用锁确保数据的线程安全。</p> </div> <div class="tiledSection"><h2 id="section19196755316">并发能力选择<i class="anchor-icon anchor-icon-link" anchorid="section19196755316" tips="复制节点链接"></i></h2></div> <div class="tiledSection"><h3 id="section187644199714" class="firsth2">概述<i class="anchor-icon anchor-icon-link" anchorid="section187644199714" tips="复制节点链接"></i></h3><p>不同的业务场景使用不同的并发能力，本章对常见场景进行分类，介绍各类场景的HarmonyOS APP开发方案。</p> </div> <div class="tiledSection"><h3 id="section15392153922413">耗时任务并发执行场景<i class="anchor-icon anchor-icon-link" anchorid="section15392153922413" tips="复制节点链接"></i></h3><ul><li><strong>场景描述</strong><p>在应用业务实现过程中，对于相对独立的耗时任务，如果在主线程中执行会阻塞主线程的UI业务，导致卡顿丢帧等问题，影响用户体验。需要将这些独立的耗时任务放到单独的子线程中执行。典型的耗时任务包括CPU密集型任务、I/O密集型任务和同步任务。</p> <div class="p">常见的业务场景如下所示： <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><tbody><tr><td class="cellrowborder" rowspan="2" valign="top"><p>常见业务场景</p> </td> <td class="cellrowborder" rowspan="2" valign="top"><p>具体业务描述</p> </td> <td class="cellrowborder" colspan="3" valign="top"><p>场景类型</p> </td> </tr> <tr><td class="cellrowborder" valign="top"><p>CPU密集型</p> </td> <td class="cellrowborder" valign="top"><p>I/O密集型</p> </td> <td class="cellrowborder" valign="top"><p>同步任务</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="18.81%"><p>图片/视频编解码</p> </td> <td class="cellrowborder" valign="top" width="35.8%"><p>将图片或视频进行编解码再展示</p> </td> <td class="cellrowborder" valign="top" width="15.129999999999999%"><p><strong>√</strong></p> </td> <td class="cellrowborder" valign="top" width="15.129999999999999%"><p><strong>√</strong></p> </td> <td class="cellrowborder" valign="top" width="15.129999999999999%"><p><strong>×</strong></p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="18.81%"><p>压缩/解压缩</p> </td> <td class="cellrowborder" valign="top" width="35.8%"><p>对本地压缩包进行解压操作，或者本地文件的压缩操作</p> </td> <td class="cellrowborder" valign="top" width="15.129999999999999%"><p><strong>√</strong></p> </td> <td class="cellrowborder" valign="top" width="15.129999999999999%"><p><strong>√</strong></p> </td> <td class="cellrowborder" valign="top" width="15.129999999999999%"><p><strong>×</strong></p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="18.81%"><p>JSON解析</p> </td> <td class="cellrowborder" valign="top" width="35.8%"><p>对JSON字符串的序列化和反序列化操作</p> </td> <td class="cellrowborder" valign="top" width="15.129999999999999%"><p><strong>√</strong></p> </td> <td class="cellrowborder" valign="top" width="15.129999999999999%"><p><strong>×</strong></p> </td> <td class="cellrowborder" valign="top" width="15.129999999999999%"><p><strong>×</strong></p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="18.81%"><p>模型运算</p> </td> <td class="cellrowborder" valign="top" width="35.8%"><p>对数据进行模型运算分析等</p> </td> <td class="cellrowborder" valign="top" width="15.129999999999999%"><p><strong>√</strong></p> </td> <td class="cellrowborder" valign="top" width="15.129999999999999%"><p><strong>×</strong></p> </td> <td class="cellrowborder" valign="top" width="15.129999999999999%"><p><strong>×</strong></p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="18.81%"><p>网络下载</p> </td> <td class="cellrowborder" valign="top" width="35.8%"><p>密集网络请求下载资源、图片、文件等</p> </td> <td class="cellrowborder" valign="top" width="15.129999999999999%"><p><strong>×</strong></p> </td> <td class="cellrowborder" valign="top" width="15.129999999999999%"><p><strong>√</strong></p> </td> <td class="cellrowborder" valign="top" width="15.129999999999999%"><p><strong>×</strong></p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="18.81%"><p>数据库操作</p> </td> <td class="cellrowborder" valign="top" width="35.8%"><p>将聊天记录、页面布局信息、音乐列表信息等保存到数据库，或者应用二次启动时，读取数据库展示相关信息</p> </td> <td class="cellrowborder" valign="top" width="15.129999999999999%"><p><strong>×</strong></p> </td> <td class="cellrowborder" valign="top" width="15.129999999999999%"><p><strong>√</strong></p> </td> <td class="cellrowborder" valign="top" width="15.129999999999999%"><p><strong>×</strong></p> </td> </tr>  </tbody></table></div> </div> </div> <p>上述业务场景均为独立的耗时任务，任务执行周期短，与外部交互较少，仅包含有限的输入和输出。这些任务可以分发到后台线程执行，再获取结果。使用TaskPool可以简化开发工作量，避免管理复杂的生命周期，防止线程泛滥。开发者只需将这些独立任务放入TaskPool队列，等待结果即可。</p> </li><li><strong>实现方案介绍</strong><p>ArkTS提供了任务池（TaskPool）的并发能力，可以将独立的耗时任务分发到子线程中执行，满足上述业务场景并行化执行的诉求，开发者只需要如下三个步骤即可完成任务并发编程。实现方案介绍：</p> <p>步骤一：将需要在子线程执行的任务封装成一个@Concurrent修饰的函数。</p> <p>步骤二：通过TaskPool的任务执行接口将任务分发到子线程。</p> <p>步骤三：异步执行结束后在宿主线程接收结果，进行后续处理。</p> </li><li><strong>业务实现中的关键点</strong><ol><li>TaskPool中执行的任务需要考虑通信开销。<p>由于TaskPool采用内存隔离的并发模型，对象跨线程传输存在性能开销，需控制线程间传递对象的大小及交互频率（200 KB的典型耗时约1 ms）。</p> </li><li>TaskPool中执行的任务不能因阻塞导致执行时间过长（非异步任务的执行时间不应超过3分钟）。<p>执行时间超过3分钟的任务会占据任务池中的线程，导致其他任务无法调度，因此系统会回收这些任务。</p> <p>网络下载、文件访问等异步I/O操作由系统分发到I/O线程池，不受上述规则约束。</p> </li><li>TaskPool中执行的任务不能有上下文依赖。<p>TaskPool任务在子线程执行，与宿主线程上下文环境不同，因此需保证任务独立性，内部实现依赖模块化导入或参数传入。</p> </li></ol> </li><li><strong>案例参考</strong><div class="screenLinkPre"><div _ngcontent-puf-c106="" class="highlight-div"><div _ngcontent-puf-c106="" class="highlight-div-header"><div _ngcontent-puf-c106="" class="highlight-div-header-left"><div _ngcontent-puf-c106="" class="handle-button expand-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-puf-c106="" class="highlight-div-header-right"><div _ngcontent-puf-c106="" class="handle-button ai-button"></div><div _ngcontent-puf-c106="" class="handle-button line-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-puf-c106="" class="handle-button theme-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-puf-c106="" class="handle-button copy-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-puf-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-typescript" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/UseSendable/entry/src/main/ets/pages/ConcurrencyCapabilitySelection1.ets#L20-L37" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">import</span> { <span class="hljs-title class_">BusinessError</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.BasicServicesKit'</span>;</li><li><span class="hljs-keyword">import</span> { hilog } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.PerformanceAnalysisKit'</span>;</li><li><span class="hljs-keyword">import</span> { taskpool } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.ArkTS'</span>;</li><li><span class="hljs-comment">// ...</span></li><li><span class="hljs-meta">@Concurrent</span></li><li><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>) {</li><li>  <span class="hljs-keyword">return</span> a + b;</li><li>}</li><li>
</li><li>taskpool.<span class="hljs-title function_">execute</span>(foo, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">ret: <span class="hljs-built_in">Object</span></span>) =&gt;</span> { <span class="hljs-comment">// Result processing</span></li><li>  hilog.<span class="hljs-title function_">info</span>(<span class="hljs-variable constant_">DOMAIN</span>, <span class="hljs-variable constant_">TAG</span>, <span class="hljs-variable constant_">FORMAT</span>, <span class="hljs-string">'Return:'</span> + ret);</li><li>}).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err: BusinessError</span>) =&gt;</span> {</li><li>  hilog.<span class="hljs-title function_">error</span>(<span class="hljs-variable constant_">DOMAIN</span>, <span class="hljs-variable constant_">TAG</span>, <span class="hljs-variable constant_">FORMAT</span>, <span class="hljs-string">`taskpool execute error. Cause code: <span class="hljs-subst">${err.code}</span>,message: <span class="hljs-subst">${err.message}</span>`</span>);</li><li>});</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/UseSendable/entry/src/main/ets/pages/ConcurrencyCapabilitySelection1.ets#L20-L37" target="_blank">ConcurrencyCapabilitySelection1.ets</a></div></div></div></div> </li><li><strong>与业界方案特殊差异说明</strong><p><span>业界均采用线程池方案，与</span><span>TaskPool</span><span>无特殊差异</span>。</p> </li><li><strong>不推荐应用实现方式</strong><p>不建议用Worker实现独立的耗时任务。</p> </li></ul> </div> <div class="tiledSection"><h3 id="section76941238135110">常驻任务并发执行场景<i class="anchor-icon anchor-icon-link" anchorid="section76941238135110" tips="复制节点链接"></i></h3><ul><li><strong>场景描述</strong><p>在应用业务实现过程中，对于长耗时（大于3分钟）且并发量较小的常驻任务场景，使用Worker在后台线程中运行这些耗时逻辑，避免阻塞主线程而导致丢帧卡顿等影响用户体验的问题。</p> <p>常驻任务不是指可以在后台保活运行的任务，而是指相比于短时任务，运行时间更长的任务，其生命周期可能与主线程一致。</p> <p>常见的业务场景如下所示：</p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><tbody><tr><td class="cellrowborder" valign="top" width="25.542554255425543%"><p>常见业务场景</p> </td> <td class="cellrowborder" valign="top" width="58.15581558155816%"><p>具体业务描述</p> </td> <td class="cellrowborder" valign="top" width="16.301630163016302%"><p>场景类型</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="25.542554255425543%"><p>游戏中台场景</p> </td> <td class="cellrowborder" valign="top" width="58.15581558155816%"><p>启动子线程作为游戏业务的主逻辑线程，UI线程只负责渲染</p> </td> <td class="cellrowborder" valign="top" width="16.301630163016302%"><p>常驻任务</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="25.542554255425543%"><p>产线硬件压测</p> </td> <td class="cellrowborder" valign="top" width="58.15581558155816%"><p>需要阻塞调用硬件能力，做老化测试，阻塞式</p> </td> <td class="cellrowborder" valign="top" width="16.301630163016302%"><p>阻塞任务</p> </td> </tr>  </tbody></table></div> </div> </li><li><strong>实现方案介绍</strong><p>ArkTS提供了Worker的并发能力，支持Worker线程与宿主线程之间进行通信，开发者需要主动创建或关闭Worker线程。实现方案介绍：</p> <p>步骤一：创建Worker对象；</p> <p>步骤二：在Worker线程中绑定Worker对象，并处理需要在子线程执行的逻辑；</p> <p>步骤三：宿主线程可以与子线程双向通信，处理数据。</p> </li><li><strong>业务实现中的关键点</strong><ol><li><span>Worker</span><span>的生命周期需要开发者自行维护</span><p>由于Worker一旦创建不会主动销毁，若不处于任务状态会持续运行，这会导致资源浪费。因此，需要及时关闭空闲的Worker。</p> </li><li>同时运行的Worker子线程数量限制为64个。</li><li><span>Worker</span><span>的一些监听事件的回调</span><p>onmessage是宿主线程接收来自其创建的Worker发送的消息时被调用的事件处理程序，处理程序在宿主线程中执行。</p> <p>onerror表示Worker执行过程中发生异常时被调用的事件处理程序，该处理程序在宿主线程中执行。</p> <p>onmessageerror表示当Worker对象接收到无法序列化的消息时，在宿主线程中执行的事件处理程序。</p> <p>onexit表示Worker销毁时的事件处理程序，该处理程序在宿主线程中执行。</p> </li></ol> </li><li><strong>参考链接</strong><p><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-worker" target="_blank">@ohos.worker (启动一个Worker)</a></p> </li><li><strong>与业界方案特殊差异说明</strong><p>与业界方案一致，均采用独立线程执行常驻任务。</p> </li><li><strong>不推荐应用实现方式</strong><p>常驻任务不建议作为任务分发给TaskPool。</p> </li></ul> </div> <div class="tiledSection"><h3 id="section196265243512">传统共享内存并发业务<i class="anchor-icon anchor-icon-link" anchorid="section196265243512" tips="复制节点链接"></i></h3><ul><li><strong>场景描述</strong><p>在当前的HarmonyOS应用开发过程中，多数应用是通过共享内存模型语言（如Java）开发的原型应用迁移过来的。其中，并发多线程是差异较大的部分，开发者在应用初期调研阶段需要考虑并发的差异，并设计应用的架构。</p> </li><li><strong>实现方案介绍</strong><p>ArkTS语言的并发多线程开发，推荐使用TaskPool和Worker的API进行开发。</p> <p>TaskPool适用于独立任务，任务在线程中执行，无需关注线程生命周期。为了线程池调度效率，不建议执行常驻任务。</p> <p>Worker适用于长时间占据线程的任务，需要主动管理线程生命周期。</p> </li><li><strong>业务实现中的关键点</strong><p>应用开发时，若不频繁进行I/O操作，无需开启独占线程。</p> <p>在并发场景下，注意内存隔离线程模型的差异，确保子线程任务独立，减少与外部的数据交互，降低性能开销。</p> <p>如果需要使用内存共享，可以通过Node-API到C++层进行，或定义Sendable对象实现线程间数据共享。</p> </li><li><strong>与业界方案特殊差异说明</strong><p>Java上的并发多使用内存共享的跨线程对象访问。HarmonyOS APP开发时，注意内存隔离线程模型差异。</p> </li><li><strong>不推荐应用实现方式</strong><p>控制并发任务的粒度，避免频繁跨线程交互。</p> </li></ul> </div> <div class="tiledSection"><h3 id="section484614505514">长时任务并发执行场景<i class="anchor-icon anchor-icon-link" anchorid="section484614505514" tips="复制节点链接"></i></h3></div> <ul><li><strong>场景描述</strong><p>在应用业务实现过程中，对于需要长时间运行的独立耗时任务，如果放在主线程中执行会阻塞UI业务，导致卡顿和丢帧，影响用户体验。应将这个独立的长时任务放到单独的子线程中执行。</p> <p>典型的长时任务场景如下所示：</p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><tbody><tr><td class="cellrowborder" valign="top" width="28.07%"><p>常见业务场景</p> </td> <td class="cellrowborder" valign="top" width="71.93%"><p>具体业务描述</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="28.07%"><p>定期传感器数据采集</p> </td> <td class="cellrowborder" valign="top" width="71.93%"><p>周期性采集一些传感器信息（例如位置信息、速度传感器等），应用运行阶段常驻运行。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="28.07%"><p>Socket端口信息监听</p> </td> <td class="cellrowborder" valign="top" width="71.93%"><p>长时间监听Socket数据，不定时需要响应处理。</p> </td> </tr>  </tbody></table></div> </div> <p>上述业务场景均为独立的长时任务，每个任务的执行周期较长，与外部的交互较为简单。将这些任务分发到后台线程后，需要不定期响应以获取结果。使用TaskPool可以简化开发工作量，避免管理复杂的生命周期和线程泛滥。开发者只需将独立的长时任务放入TaskPool队列，然后等待结果即可。</p> </li><li><strong>实现方案介绍</strong><p>ArkTS提供了任务池（TaskPool）的并发能力，可以将长时间任务分发到子线程中执行，满足上述业务场景并行化执行的需求。开发者只需以下三个步骤即可完成任务并发编程。实现方案如下：</p> <p>第一步：将需要在子线程执行的任务封装成一个@Concurrent修饰的函数；</p> <p>第二步：通过TaskPool的长时任务执行接口将任务分发到子线程；</p> <p>第三步：任务执行过程中，不定期接收数据，返回给宿主线程处理。</p> </li><li><strong>业务实现中的关键点</strong><p>长时任务与阻塞任务不同，它运行周期较长，但每次执行不会长时间阻塞线程。因此，不建议将需要独占线程的任务封装为长时任务。</p> </li><li><strong>案例参考</strong><div class="screenLinkPre"><div _ngcontent-puf-c106="" class="highlight-div"><div _ngcontent-puf-c106="" class="highlight-div-header"><div _ngcontent-puf-c106="" class="highlight-div-header-left"><div _ngcontent-puf-c106="" class="handle-button expand-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-puf-c106="" class="highlight-div-header-right"><div _ngcontent-puf-c106="" class="handle-button ai-button"></div><div _ngcontent-puf-c106="" class="handle-button line-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-puf-c106="" class="handle-button theme-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-puf-c106="" class="handle-button copy-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-puf-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-javascript" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/UseSendable/entry/src/main/ets/pages/ConcurrencyCapabilitySelection2.ets#L20-L52" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">import</span> { taskpool } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.ArkTS'</span>;</li><li><span class="hljs-keyword">import</span> { <span class="hljs-title class_">BusinessError</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.BasicServicesKit'</span>;</li><li><span class="hljs-keyword">import</span> { hilog } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.PerformanceAnalysisKit'</span>;</li><li><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">DOMAIN</span> = <span class="hljs-number">0x0000</span>;</li><li><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">TAG</span> = <span class="hljs-string">'ConcurrencyCapabilitySelection2'</span>;</li><li><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">FORMAT</span> = <span class="hljs-string">'%{public}s'</span>;</li><li>@<span class="hljs-title class_">Concurrent</span></li><li><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {</li><li>  <span class="hljs-keyword">try</span> {</li><li>    <span class="hljs-comment">// Long listening and other tasks</span></li><li>    taskpool.<span class="hljs-property">Task</span>.<span class="hljs-title function_">sendData</span>();</li><li>  } <span class="hljs-keyword">catch</span> (err) {</li><li>    hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x0000</span>, <span class="hljs-string">'TAG'</span>, <span class="hljs-string">'%{public}s'</span>, <span class="hljs-string">`sendData failed. Cause code: <span class="hljs-subst">${err.code}</span>,message: <span class="hljs-subst">${err.message}</span>`</span>);</li><li>  }</li><li>}</li><li>
</li><li><span class="hljs-keyword">function</span> <span class="hljs-title function_">executeTaskPool</span>(<span class="hljs-params"></span>) {</li><li>  <span class="hljs-keyword">let</span> <span class="hljs-attr">longTask</span>: taskpool.<span class="hljs-property">LongTask</span> = <span class="hljs-keyword">new</span> taskpool.<span class="hljs-title class_">LongTask</span>(foo);</li><li>  longTask.<span class="hljs-title function_">onReceiveData</span>(<span class="hljs-function">(<span class="hljs-params">msg: <span class="hljs-built_in">Object</span></span>) =&gt;</span> {</li><li>    <span class="hljs-comment">// Listening callback</span></li><li>    hilog.<span class="hljs-title function_">info</span>(<span class="hljs-variable constant_">DOMAIN</span>, <span class="hljs-variable constant_">TAG</span>, <span class="hljs-variable constant_">FORMAT</span>, <span class="hljs-string">`onReceiveData, <span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify(msg)}</span>`</span>);</li><li>  });</li><li>
</li><li>  taskpool.<span class="hljs-title function_">execute</span>(longTask).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {</li><li>    hilog.<span class="hljs-title function_">info</span>(<span class="hljs-variable constant_">DOMAIN</span>, <span class="hljs-variable constant_">TAG</span>, <span class="hljs-variable constant_">FORMAT</span>, <span class="hljs-string">'execute'</span>);</li><li>  }).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err: BusinessError</span>) =&gt;</span> {</li><li>    hilog.<span class="hljs-title function_">error</span>(<span class="hljs-variable constant_">DOMAIN</span>, <span class="hljs-variable constant_">TAG</span>, <span class="hljs-variable constant_">FORMAT</span>, <span class="hljs-string">`taskpool execute error. Cause code: <span class="hljs-subst">${err.code}</span>,message: <span class="hljs-subst">${err.message}</span>`</span>);</li><li>  });</li><li>}</li><li>
</li><li><span class="hljs-title function_">executeTaskPool</span>();</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/UseSendable/entry/src/main/ets/pages/ConcurrencyCapabilitySelection2.ets#L20-L52" target="_blank">ConcurrencyCapabilitySelection2.ets</a></div></div></div></div> </li><li><strong>与业界方案特殊差异说明</strong><p>业界通常使用单独的线程池，HarmonyOS使用可调度的任务。</p> </li><li><strong>不推荐应用实现方式</strong><p>对于非驻留的长期任务，不建议使用Worker实现。</p> <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"><p>长时任务是指长时间不间断运行的独立任务，例如监听某个事件，发起执行后不会再接收发起方的输入。虽然也可以使用Worker（推荐用于常驻后台任务），但更推荐使用TaskPool，因为TaskPool更方便且资源消耗更低。<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/taskpool-vs-worker#实现特点对比" target="_blank">TaskPool和Worker的实现特点对比</a>。</p> </div></div></div> </li></ul> <div class="tiledSection"><h2 id="section13423183312113">并发任务管理<i class="anchor-icon anchor-icon-link" anchorid="section13423183312113" tips="复制节点链接"></i></h2></div> <div class="tiledSection"><h3 id="section11506154214117" class="firsth2">概述<i class="anchor-icon anchor-icon-link" anchorid="section11506154214117" tips="复制节点链接"></i></h3><p>目前已提供多种任务执行方式，可以管理任务的执行顺序和优先级。本章节将对需要控制任务执行方式的场景进行分类，并分别介绍各类任务执行场景下的HarmonyOS APP开发方案设计。</p> </div> <div class="tiledSection"><h3 id="section843404931116">多任务关联执行（串行顺序依赖）<i class="anchor-icon anchor-icon-link" anchorid="section843404931116" tips="复制节点链接"></i></h3><ul><li><strong>场景描述</strong><p>在应用业务实现过程中，使用串行队列机制，使多个任务按特定顺序依次执行，避免并发和乱序。串行队列确保任务执行顺序与数据一致性，防止多线程竞争和死锁，简化多线程编程，适用于后置任务依赖前置任务的场景。</p> <p>常见的业务场景如下所示：</p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><tbody><tr><td class="cellrowborder" valign="top" width="27.400000000000002%"><p>常见业务场景</p> </td> <td class="cellrowborder" valign="top" width="72.6%"><p>具体业务描述</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="27.400000000000002%"><p>API执行队列</p> </td> <td class="cellrowborder" valign="top" width="72.6%"><p>调用模块接口，存在执行顺序要求</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="27.400000000000002%"><p>渲染指令队列</p> </td> <td class="cellrowborder" valign="top" width="72.6%"><p>操作DOM树、渲染等，需要按顺序执行</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="27.400000000000002%"><p>启动时遍历程序包</p> </td> <td class="cellrowborder" valign="top" width="72.6%"><p>启动遍历小程序包、清理包、资源加载等串行操作</p> </td> </tr>  </tbody></table></div> </div> </li><li><strong>实现方案介绍</strong><p>ArkTS 提供串行队列（SequenceRunner）功能，可以将多个任务加入到串行队列中，使任务按顺序执行。此外，还可以创建多组串行队列进行分组管理，以满足上述场景的串行执行需求。以下步骤介绍了如何创建和执行串行任务队列。</p> <p><span>步骤一：创建需要串行执行的任务</span><span>task_1 ~ task_n</span><span>；</span></p> <p><span>步骤二：创建串行队列</span><span>runner</span><span>；</span></p> <p>步骤三：按照需要执行的顺序，依次将任务添加至runner内。</p> </li><li><strong>业务实现中的关键点</strong><ol><li><span>添加到串行队列的任务，不支持添加依赖</span><span>addDependency</span><span>；</span><p><span>额外添加的任务依赖可能导致串行队列冲突，即使添加的依赖本身遵循串行队列顺序也会被拦截。</span></p> </li><li><span>添加到串行队列的任务，同样也受</span><span>TaskPool</span><span>执行任务的约束与限制；</span><p>当串行队列任务执行失败或被取消时，后续任务仍会执行。</p> </li></ol> </li><li><strong>案例参考</strong><div class="screenLinkPre"><div _ngcontent-puf-c106="" class="highlight-div"><div _ngcontent-puf-c106="" class="highlight-div-header"><div _ngcontent-puf-c106="" class="highlight-div-header-left"><div _ngcontent-puf-c106="" class="handle-button expand-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-puf-c106="" class="highlight-div-header-right"><div _ngcontent-puf-c106="" class="handle-button ai-button"></div><div _ngcontent-puf-c106="" class="handle-button line-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-puf-c106="" class="handle-button theme-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-puf-c106="" class="handle-button copy-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-puf-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-typescript" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/UseSendable/entry/src/main/ets/pages/ConcurrentTaskManagement1.ets#L20-L71" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">import</span> { <span class="hljs-title class_">BusinessError</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.BasicServicesKit'</span>;</li><li><span class="hljs-keyword">import</span> { hilog } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.PerformanceAnalysisKit'</span>;</li><li><span class="hljs-keyword">import</span> { taskpool } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.ArkTS'</span>;</li><li><span class="hljs-comment">// ...</span></li><li><span class="hljs-meta">@Concurrent</span></li><li><span class="hljs-keyword">function</span> <span class="hljs-title function_">additionDelay</span>(<span class="hljs-params">delay: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">void</span> {</li><li>  <span class="hljs-keyword">let</span> <span class="hljs-attr">start</span>: <span class="hljs-built_in">number</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>();</li><li>  <span class="hljs-keyword">while</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>() - start &lt; delay) {</li><li>    <span class="hljs-keyword">continue</span>;</li><li>  }</li><li>}</li><li>
</li><li><span class="hljs-meta">@Concurrent</span></li><li><span class="hljs-keyword">function</span> <span class="hljs-title function_">waitForRunner</span>(<span class="hljs-params">resString: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">string</span> {</li><li>  <span class="hljs-keyword">return</span> resString;</li><li>}</li><li>
</li><li><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">seqRunner</span>(<span class="hljs-params"></span>) {</li><li>  <span class="hljs-keyword">let</span> <span class="hljs-attr">result</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">''</span>;</li><li>  <span class="hljs-keyword">let</span> <span class="hljs-attr">task1</span>: taskpool.<span class="hljs-property">Task</span> = <span class="hljs-keyword">new</span> taskpool.<span class="hljs-title class_">Task</span>(additionDelay, <span class="hljs-number">300</span>);</li><li>  <span class="hljs-keyword">let</span> <span class="hljs-attr">task2</span>: taskpool.<span class="hljs-property">Task</span> = <span class="hljs-keyword">new</span> taskpool.<span class="hljs-title class_">Task</span>(additionDelay, <span class="hljs-number">200</span>);</li><li>  <span class="hljs-keyword">let</span> <span class="hljs-attr">task3</span>: taskpool.<span class="hljs-property">Task</span> = <span class="hljs-keyword">new</span> taskpool.<span class="hljs-title class_">Task</span>(additionDelay, <span class="hljs-number">100</span>);</li><li>  <span class="hljs-keyword">let</span> <span class="hljs-attr">task4</span>: taskpool.<span class="hljs-property">Task</span> = <span class="hljs-keyword">new</span> taskpool.<span class="hljs-title class_">Task</span>(waitForRunner, <span class="hljs-number">50</span>);</li><li>
</li><li>  <span class="hljs-keyword">let</span> <span class="hljs-attr">runner</span>: taskpool.<span class="hljs-property">SequenceRunner</span> = <span class="hljs-keyword">new</span> taskpool.<span class="hljs-title class_">SequenceRunner</span>();</li><li>  runner.<span class="hljs-title function_">execute</span>(task1).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {</li><li>    result += <span class="hljs-string">'a'</span>;</li><li>  }).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err: BusinessError</span>) =&gt;</span> {</li><li>    hilog.<span class="hljs-title function_">error</span>(<span class="hljs-variable constant_">DOMAIN</span>, <span class="hljs-variable constant_">TAG</span>, <span class="hljs-variable constant_">FORMAT</span>, <span class="hljs-string">`taskpool execute error. Cause code: <span class="hljs-subst">${err.code}</span>,message: <span class="hljs-subst">${err.message}</span>`</span>);</li><li>  });</li><li>
</li><li>  runner.<span class="hljs-title function_">execute</span>(task2).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {</li><li>    result += <span class="hljs-string">'b'</span>;</li><li>  }).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err: BusinessError</span>) =&gt;</span> {</li><li>    hilog.<span class="hljs-title function_">error</span>(<span class="hljs-variable constant_">DOMAIN</span>, <span class="hljs-variable constant_">TAG</span>, <span class="hljs-variable constant_">FORMAT</span>, <span class="hljs-string">`taskpool execute error. Cause code: <span class="hljs-subst">${err.code}</span>,message: <span class="hljs-subst">${err.message}</span>`</span>);</li><li>  });</li><li>
</li><li>  runner.<span class="hljs-title function_">execute</span>(task3).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {</li><li>    result += <span class="hljs-string">'c'</span>;</li><li>  }).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err: BusinessError</span>) =&gt;</span> {</li><li>    hilog.<span class="hljs-title function_">error</span>(<span class="hljs-variable constant_">DOMAIN</span>, <span class="hljs-variable constant_">TAG</span>, <span class="hljs-variable constant_">FORMAT</span>, <span class="hljs-string">`taskpool execute error. Cause code: <span class="hljs-subst">${err.code}</span>,message: <span class="hljs-subst">${err.message}</span>`</span>);</li><li>  });</li><li>
</li><li>  <span class="hljs-keyword">await</span> runner.<span class="hljs-title function_">execute</span>(task4).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err: BusinessError</span>) =&gt;</span> {</li><li>    hilog.<span class="hljs-title function_">error</span>(<span class="hljs-variable constant_">DOMAIN</span>, <span class="hljs-variable constant_">TAG</span>, <span class="hljs-variable constant_">FORMAT</span>, <span class="hljs-string">`taskpool execute error. Cause code: <span class="hljs-subst">${err.code}</span>,message: <span class="hljs-subst">${err.message}</span>`</span>);</li><li>  });</li><li>  hilog.<span class="hljs-title function_">info</span>(<span class="hljs-variable constant_">DOMAIN</span>, <span class="hljs-variable constant_">TAG</span>, <span class="hljs-variable constant_">FORMAT</span>, <span class="hljs-string">'SequenceRunner: result is '</span> + result);</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/UseSendable/entry/src/main/ets/pages/ConcurrentTaskManagement1.ets#L20-L71" target="_blank">ConcurrentTaskManagement1.ets</a></div></div></div></div> </li><li><strong>与业界方案特殊差异说明</strong><p>对于串行队列中任务执行失败后的处理，业界尚无统一规范。</p> <p>当前HarmonyOS APP开发中，即使某个任务执行失败，后续任务仍然会继续执行。如果后续任务依赖上一个任务的结果输出，开发者需考虑任务失败场景的异常处理。</p> </li></ul> </div> <div class="tiledSection"><h3 id="section154701412191218">多任务关联执行（树状依赖）<i class="anchor-icon anchor-icon-link" anchorid="section154701412191218" tips="复制节点链接"></i></h3><ul><li><strong>场景描述</strong><p>任务依赖机制用于管理并发任务的执行顺序。通过任务依赖，可以指定一个任务在另一个任务完成后才能执行，从而构建复杂的任务执行流程。任务依赖帮助开发者控制任务间的依赖关系，确保任务按预期顺序执行。在TaskPool中，任务依赖通过调用<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-taskpool#adddependency11" target="_blank">addDependency()</a>和<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-taskpool#removedependency11" target="_blank">removeDependency()</a>方法实现。</p> <p>常见的业务场景如下所示：</p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><tbody><tr><td class="cellrowborder" rowspan="2" valign="top"><p>常见业务场景</p> </td> <td class="cellrowborder" rowspan="2" valign="top"><p>具体业务描述</p> </td> <td class="cellrowborder" colspan="3" valign="top"><p>场景类型</p> </td> </tr> <tr><td class="cellrowborder" valign="top"><p>CPU密集型</p> </td> <td class="cellrowborder" valign="top"><p>I/O密集型</p> </td> <td class="cellrowborder" valign="top"><p>同步任务</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="18.81%"><p>图片解码</p> </td> <td class="cellrowborder" valign="top" width="35.8%"><p>解析一张大图，将大图数据拆成n份并放到n个任务中执行，执行完后通过这n个任务都依赖的一个任务对结果进行处理并返回</p> </td> <td class="cellrowborder" valign="top" width="15.129999999999999%"><p><strong>√</strong></p> </td> <td class="cellrowborder" valign="top" width="15.129999999999999%"><p><strong>√</strong></p> </td> <td class="cellrowborder" valign="top" width="15.129999999999999%"><p><strong>×</strong></p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="18.81%"><p>数据库操作</p> </td> <td class="cellrowborder" valign="top" width="35.8%"><p>A任务执行需要B任务执行结果。B任务执行完将结果更新到数据库，再执行依赖B的A任务，A任务从数据库中获取B任务结果</p> </td> <td class="cellrowborder" valign="top" width="15.129999999999999%"><p><strong>×</strong></p> </td> <td class="cellrowborder" valign="top" width="15.129999999999999%"><p><strong>√</strong></p> </td> <td class="cellrowborder" valign="top" width="15.129999999999999%"><p><strong>×</strong></p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="18.81%"><p>网络下载</p> </td> <td class="cellrowborder" valign="top" width="35.8%"><p>A任务下载数据，B任务对数据进行处理。B任务执行依赖A任务结果</p> </td> <td class="cellrowborder" valign="top" width="15.129999999999999%"><p><strong>×</strong></p> </td> <td class="cellrowborder" valign="top" width="15.129999999999999%"><p><strong>√</strong></p> </td> <td class="cellrowborder" valign="top" width="15.129999999999999%"><p><strong>×</strong></p> </td> </tr>  </tbody></table></div> </div> </li><li><strong>实现方案介绍</strong><p>TaskPool提供<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-taskpool#adddependency11" target="_blank">addDependency()</a>和<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-taskpool#removedependency11" target="_blank">removeDependency()</a>两个接口，用于设置任务的依赖关系。默认情况下，任务不依赖其他任务。</p> <p>TaskPool维护任务依赖关系列表，调用<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-taskpool#adddependency11" target="_blank">addDependency()</a>/<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-taskpool#removedependency11" target="_blank">removeDependency()</a>更新列表。任务执行前查询列表，若任务依赖其他任务，则等待依赖任务完成；若任务被其他任务依赖，任务执行结束将依赖任务加入队列。</p> </li><li><strong>业务实现中的关键点</strong><ol><li>合理设置任务依赖关系。如果两个任务的执行不依赖对方的结果，则无需设置依赖关系。</li><li>设置依赖关系时，应确保高优先级任务不依赖于低优先级任务，以防止高优先级任务的优先级设置失效。</li><li>任务依赖与任务组、串行队列的交互表现如下：<p>- 已经执行过的任务不能设置依赖关系。</p> <p>- 任务组中的任务不能设置依赖关系。</p> <p>- 串行队列中的任务不能设置依赖关系。</p> <p>- 具有依赖关系的任务执行结束后不能再次执行。</p> <p>- 具有依赖关系的任务不能放入任务组。</p> <p>- 具有依赖关系的任务不能放入串行队列。</p> </li></ol> </li><li><strong>案例参考</strong><div class="screenLinkPre"><div _ngcontent-puf-c106="" class="highlight-div"><div _ngcontent-puf-c106="" class="highlight-div-header"><div _ngcontent-puf-c106="" class="highlight-div-header-left"><div _ngcontent-puf-c106="" class="handle-button expand-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-puf-c106="" class="highlight-div-header-right"><div _ngcontent-puf-c106="" class="handle-button ai-button"></div><div _ngcontent-puf-c106="" class="handle-button line-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-puf-c106="" class="handle-button theme-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-puf-c106="" class="handle-button copy-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-puf-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-typescript" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/UseSendable/entry/src/main/ets/pages/ConcurrentTaskManagement2.ets#L20-L72" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">import</span> { taskpool } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.ArkTS'</span>;</li><li><span class="hljs-keyword">import</span> { hilog } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.PerformanceAnalysisKit'</span>;</li><li><span class="hljs-keyword">import</span> { <span class="hljs-title class_">BusinessError</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.BasicServicesKit'</span>;</li><li>
</li><li><span class="hljs-comment">// ...</span></li><li><span class="hljs-meta">@Concurrent</span></li><li><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateSAB</span>(<span class="hljs-params">args: <span class="hljs-built_in">Uint32Array</span></span>) {</li><li>  <span class="hljs-keyword">if</span> (args[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) {</li><li>    args[<span class="hljs-number">0</span>] = <span class="hljs-number">100</span>;</li><li>    <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;</li><li>  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (args[<span class="hljs-number">0</span>] == <span class="hljs-number">100</span>) {</li><li>    args[<span class="hljs-number">0</span>] = <span class="hljs-number">200</span>;</li><li>    <span class="hljs-keyword">return</span> <span class="hljs-number">200</span>;</li><li>  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (args[<span class="hljs-number">0</span>] == <span class="hljs-number">200</span>) {</li><li>    args[<span class="hljs-number">0</span>] = <span class="hljs-number">300</span>;</li><li>    <span class="hljs-keyword">return</span> <span class="hljs-number">300</span>;</li><li>  }</li><li>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</li><li>}</li><li>
</li><li><span class="hljs-keyword">let</span> sab = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SharedArrayBuffer</span>(<span class="hljs-number">20</span>);</li><li><span class="hljs-keyword">let</span> typedArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint32Array</span>(sab);</li><li><span class="hljs-keyword">let</span> task1 = <span class="hljs-keyword">new</span> taskpool.<span class="hljs-title class_">Task</span>(updateSAB, typedArray);</li><li><span class="hljs-keyword">let</span> task2 = <span class="hljs-keyword">new</span> taskpool.<span class="hljs-title class_">Task</span>(updateSAB, typedArray);</li><li><span class="hljs-keyword">let</span> task3 = <span class="hljs-keyword">new</span> taskpool.<span class="hljs-title class_">Task</span>(updateSAB, typedArray);</li><li><span class="hljs-keyword">try</span> {</li><li>  task1.<span class="hljs-title function_">addDependency</span>(task2);</li><li>  task2.<span class="hljs-title function_">addDependency</span>(task3);</li><li>} <span class="hljs-keyword">catch</span> (err) {</li><li>  hilog.<span class="hljs-title function_">error</span>(<span class="hljs-variable constant_">DOMAIN</span>, <span class="hljs-variable constant_">TAG</span>, <span class="hljs-variable constant_">FORMAT</span>, <span class="hljs-string">`sendData failed. Cause code: <span class="hljs-subst">${err.code}</span>,message: <span class="hljs-subst">${err.message}</span>`</span>);</li><li>}</li><li>
</li><li>taskpool.<span class="hljs-title function_">execute</span>(task1).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res: <span class="hljs-built_in">object</span></span>) =&gt;</span> {</li><li>  hilog.<span class="hljs-title function_">info</span>(<span class="hljs-variable constant_">DOMAIN</span>, <span class="hljs-variable constant_">TAG</span>, <span class="hljs-variable constant_">FORMAT</span>, <span class="hljs-string">'taskpool:: execute task1 res: '</span> + res);</li><li>}).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err: BusinessError</span>) =&gt;</span> {</li><li>  hilog.<span class="hljs-title function_">error</span>(<span class="hljs-variable constant_">DOMAIN</span>, <span class="hljs-variable constant_">TAG</span>, <span class="hljs-variable constant_">FORMAT</span>, <span class="hljs-string">`taskpool execute error. Cause code: <span class="hljs-subst">${err.code}</span>,message: <span class="hljs-subst">${err.message}</span>`</span>);</li><li>});</li><li>
</li><li>taskpool.<span class="hljs-title function_">execute</span>(task2).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res: <span class="hljs-built_in">object</span></span>) =&gt;</span> {</li><li>  hilog.<span class="hljs-title function_">info</span>(<span class="hljs-variable constant_">DOMAIN</span>, <span class="hljs-variable constant_">TAG</span>, <span class="hljs-variable constant_">FORMAT</span>, <span class="hljs-string">'taskpool:: execute task2 res: '</span> + res);</li><li>}).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err: BusinessError</span>) =&gt;</span> {</li><li>  hilog.<span class="hljs-title function_">error</span>(<span class="hljs-variable constant_">DOMAIN</span>, <span class="hljs-variable constant_">TAG</span>, <span class="hljs-variable constant_">FORMAT</span>, <span class="hljs-string">`taskpool execute error. Cause code: <span class="hljs-subst">${err.code}</span>,message: <span class="hljs-subst">${err.message}</span>`</span>);</li><li>});</li><li>
</li><li>taskpool.<span class="hljs-title function_">execute</span>(task3).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res: <span class="hljs-built_in">object</span></span>) =&gt;</span> {</li><li>  hilog.<span class="hljs-title function_">info</span>(<span class="hljs-variable constant_">DOMAIN</span>, <span class="hljs-variable constant_">TAG</span>, <span class="hljs-variable constant_">FORMAT</span>, <span class="hljs-string">'taskpool:: execute task3 res: '</span> + res);</li><li>}).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err: BusinessError</span>) =&gt;</span> {</li><li>  hilog.<span class="hljs-title function_">error</span>(<span class="hljs-variable constant_">DOMAIN</span>, <span class="hljs-variable constant_">TAG</span>, <span class="hljs-variable constant_">FORMAT</span>, <span class="hljs-string">`taskpool execute error. Cause code: <span class="hljs-subst">${err.code}</span>,message: <span class="hljs-subst">${err.message}</span>`</span>);</li><li>});</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/UseSendable/entry/src/main/ets/pages/ConcurrentTaskManagement2.ets#L20-L72" target="_blank">ConcurrentTaskManagement2.ets</a></div></div></div></div> </li><li><strong>与业界方案特殊差异说明</strong><p><span>业界实现的多数任务依赖机制，与</span>TaskPool<span>提供的任务依赖机制表现无明显差异。</span></p> </li></ul> </div> <div class="tiledSection"><h3 id="section13759133112128">多任务同步等待结果（任务组）<i class="anchor-icon anchor-icon-link" anchorid="section13759133112128" tips="复制节点链接"></i></h3><ul><li><strong>场景描述</strong><p>多个任务并发执行，所有任务完成后统一返回完整结果。若任意任务失败或取消，整个任务结果将失败。</p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><tbody><tr><td class="cellrowborder" valign="top" width="18.81%"><p>常见业务场景</p> </td> <td class="cellrowborder" valign="top" width="35.8%"><p>具体业务描述</p> </td> <td class="cellrowborder" valign="top" width="45.39%"><p>场景类型</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="18.81%"><p>图片解析生成直方图</p> </td> <td class="cellrowborder" valign="top" width="35.8%"><p>一张图片，为了并发加速，拆分成多个ArrayBuffer进行解析，在所有任务解析完成后统一返回结果将解析结果拼成一个完整的直方图进行渲染</p> </td> <td class="cellrowborder" valign="top" width="45.39%"><p>CPU密集型</p> </td> </tr>  </tbody></table></div> </div> </li><li><strong>实现方案介绍</strong><p>任务组能力目前通过TaskPool模块提供，以图片生成直方图为例进行介绍。</p> <p>步骤一：定义并发函数（@Concurrent function），将承载图片数据的ArrayBuffer的解析逻辑封装在一个并发函数中；</p> <p>步骤二：遍历ArrayBuffer，每个ArrayBuffer对应构造一个并发解析任务，将这些任务都添加到任务组中；</p> <p>步骤三：通过TaskPool执行任务组，并在回调函数中执行直方图的拼接逻辑或异常处理逻辑。</p> </li><li><strong>业务实现中的关键点</strong><ol><li>任务组任务应达成统一目的，输出统一结果。</li><li>任务组的结果在所有任务执行结束后统一返回，因此需要先执行完的任务优先处理的场景不要使用任务组。</li></ol> </li><li><strong>案例参考</strong><div class="screenLinkPre"><div _ngcontent-puf-c106="" class="highlight-div"><div _ngcontent-puf-c106="" class="highlight-div-header"><div _ngcontent-puf-c106="" class="highlight-div-header-left"><div _ngcontent-puf-c106="" class="handle-button expand-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-puf-c106="" class="highlight-div-header-right"><div _ngcontent-puf-c106="" class="handle-button ai-button"></div><div _ngcontent-puf-c106="" class="handle-button line-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-puf-c106="" class="handle-button theme-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-puf-c106="" class="handle-button copy-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-puf-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-cangjie" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/UseSendable/entry/src/main/ets/pages/ConcurrentTaskManagement3.ets#L20-L59" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">import</span> { <span class="hljs-variable">taskpool</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.ArkTS'</span>;</li><li><span class="hljs-keyword">import</span> { <span class="hljs-variable">hilog</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.PerformanceAnalysisKit'</span>;</li><li><span class="hljs-keyword">import</span> { <span class="hljs-variable">BusinessError</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.BasicServicesKit'</span>;</li><li>
</li><li><span class="hljs-comment">// ...</span></li><li><span class="hljs-comment">// Define asynchronous tasks</span></li><li>@<span class="hljs-title function_">Concurrent</span></li><li><span class="hljs-variable">function</span> <span class="hljs-title function_">imageProcessing</span>(<span class="hljs-variable">arrayBuffer</span>: <span class="hljs-title class_">ArrayBuffer</span>): <span class="hljs-title class_">ArrayBuffer</span> {</li><li>  <span class="hljs-comment">// Here add business logic, the input is ArrayBuffer, and the output is an ArrayBuffer storing the parsed results.</span></li><li>  <span class="hljs-keyword">let</span> <span class="hljs-variable">message</span>: <span class="hljs-title class_">ArrayBuffer</span> = <span class="hljs-variable">arrayBuffer</span>;</li><li>  <span class="hljs-keyword">return</span> <span class="hljs-variable">message</span>;</li><li>}</li><li>
</li><li><span class="hljs-keyword">let</span> <span class="hljs-variable">taskGroup</span>: <span class="hljs-title class_">taskpool</span>.<span class="hljs-title class_">TaskGroup</span> = <span class="hljs-variable">new</span> <span class="hljs-variable">taskpool</span>.<span class="hljs-title function_">TaskGroup</span>();</li><li><span class="hljs-keyword">let</span> <span class="hljs-variable">TASK_POOL_CAPACITY</span>: <span class="hljs-title class_">number</span> = <span class="hljs-number">10</span>;</li><li>
</li><li><span class="hljs-variable">function</span> <span class="hljs-title function_">histogramStatistic</span>(<span class="hljs-variable">pixelBuffer</span>: <span class="hljs-title class_">ArrayBuffer</span>): <span class="hljs-title class_">void</span> {</li><li>  <span class="hljs-comment">// Add tasks to the task group</span></li><li>  <span class="hljs-keyword">let</span> <span class="hljs-variable">byteLengthOfTask</span>: <span class="hljs-title class_">number</span> = <span class="hljs-variable">pixelBuffer</span>.<span class="hljs-variable">byteLength</span> / <span class="hljs-variable">TASK_POOL_CAPACITY</span>;</li><li>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> <span class="hljs-variable">i</span> = <span class="hljs-number">0</span>; <span class="hljs-variable">i</span> &lt; <span class="hljs-title class_">TASK_POOL_CAPACITY</span>; <span class="hljs-title class_">i</span>++) {</li><li>    <span class="hljs-keyword">let</span> <span class="hljs-variable">dataSlice</span>: <span class="hljs-title class_">ArrayBuffer</span> = (<span class="hljs-variable">i</span> === <span class="hljs-variable">TASK_POOL_CAPACITY</span> - <span class="hljs-number">1</span>) ? <span class="hljs-variable">pixelBuffer</span>.<span class="hljs-title function_">slice</span>(<span class="hljs-variable">i</span> * <span class="hljs-variable">byteLengthOfTask</span>) :</li><li>    <span class="hljs-variable">pixelBuffer</span>.<span class="hljs-title function_">slice</span>(<span class="hljs-variable">i</span> * <span class="hljs-variable">byteLengthOfTask</span>, (<span class="hljs-variable">i</span> + <span class="hljs-number">1</span>) * <span class="hljs-variable">byteLengthOfTask</span>);</li><li>    <span class="hljs-keyword">let</span> <span class="hljs-variable">task</span>: <span class="hljs-title class_">taskpool</span>.<span class="hljs-title class_">Task</span> = <span class="hljs-variable">new</span> <span class="hljs-variable">taskpool</span>.<span class="hljs-title function_">Task</span>(<span class="hljs-variable">imageProcessing</span>, <span class="hljs-variable">dataSlice</span>);</li><li>    <span class="hljs-keyword">try</span> {</li><li>      <span class="hljs-variable">taskGroup</span>.<span class="hljs-title function_">addTask</span>(<span class="hljs-variable">task</span>);</li><li>    } <span class="hljs-keyword">catch</span> (<span class="hljs-variable">err</span>) {</li><li>      <span class="hljs-variable">hilog</span>.<span class="hljs-title function_">error</span>(<span class="hljs-variable">DOMAIN</span>, <span class="hljs-variable">TAG</span>, <span class="hljs-variable">FORMAT</span>, `<span class="hljs-variable">addTask</span> <span class="hljs-variable">failed</span>. <span class="hljs-variable">Cause</span> <span class="hljs-variable">code</span>: ${<span class="hljs-variable">err</span>.<span class="hljs-variable">code</span>},<span class="hljs-variable">message</span>: ${<span class="hljs-variable">err</span>.<span class="hljs-variable">message</span>}`);</li><li>    }</li><li>  }</li><li>  <span class="hljs-variable">taskpool</span>.<span class="hljs-title function_">execute</span>(<span class="hljs-variable">taskGroup</span>, <span class="hljs-variable">taskpool</span>.<span class="hljs-variable">Priority</span>.<span class="hljs-variable">HIGH</span>).<span class="hljs-title function_">then</span>((<span class="hljs-variable">res</span>: <span class="hljs-title class_">Object</span>[]): <span class="hljs-title class_">void</span> | <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">void</span>&gt; =&gt; {</li><li>    <span class="hljs-comment">// Result data processing</span></li><li>    <span class="hljs-variable">hilog</span>.<span class="hljs-title function_">info</span>(<span class="hljs-variable">DOMAIN</span>, <span class="hljs-variable">TAG</span>, <span class="hljs-variable">FORMAT</span>, `<span class="hljs-variable">res</span>:${<span class="hljs-variable">res</span>}`);</li><li>  }).<span class="hljs-keyword">catch</span>((<span class="hljs-variable">error</span>: <span class="hljs-title class_">BusinessError</span>) =&gt; {</li><li>    <span class="hljs-variable">hilog</span>.<span class="hljs-title function_">error</span>(<span class="hljs-variable">DOMAIN</span>, <span class="hljs-variable">TAG</span>, <span class="hljs-variable">FORMAT</span>, `<span class="hljs-variable">taskpool</span> <span class="hljs-variable">excute</span> <span class="hljs-variable">error</span>: ${<span class="hljs-variable">error</span>}`);</li><li>  });</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/UseSendable/entry/src/main/ets/pages/ConcurrentTaskManagement3.ets#L20-L59" target="_blank">ConcurrentTaskManagement3.ets</a></div></div></div></div> </li></ul> </div> <div class="tiledSection"><h3 id="section873704510120">多任务优先级调度<i class="anchor-icon anchor-icon-link" anchorid="section873704510120" tips="复制节点链接"></i></h3><ul><li><strong>场景描述</strong><p>优先级反映了任务在当前业务场景下的重要性。在并发场景中，系统和线程池的资源是有限的。在资源固定的情况下，系统会优先分配更多资源处理高优先级任务，确保这些任务的即时性，而低优先级任务的调度会相应延迟。TaskPool 提供了多任务优先级调度机制，帮助开发者根据业务需求合理设置优先级。</p> <p>常见的业务场景如下所示：</p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><tbody><tr><td class="cellrowborder" rowspan="2" valign="top"><p>常见业务场景</p> </td> <td class="cellrowborder" rowspan="2" valign="top"><p>具体业务描述</p> </td> <td class="cellrowborder" colspan="3" valign="top"><p>场景类型</p> </td> </tr> <tr><td class="cellrowborder" valign="top"><p>CPU密集型</p> </td> <td class="cellrowborder" valign="top"><p>I/O密集型</p> </td> <td class="cellrowborder" valign="top"><p>即时性</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="18.81%"><p>处理高分辨率图片数据，处理时间约为500毫秒</p> </td> <td class="cellrowborder" valign="top" width="35.8%"><p>拍摄输入或美化图片时，会将图片数据放在TaskPool中处理，并需要在一定毫秒内将数据返回主线程渲染。为保证任务的即时性，避免影响用户体验，可以设置高优先级使任务被优先调度。</p> </td> <td class="cellrowborder" valign="top" width="15.129999999999999%"><p><strong>√</strong></p> </td> <td class="cellrowborder" valign="top" width="15.129999999999999%"><p><strong>×</strong></p> </td> <td class="cellrowborder" valign="top" width="15.129999999999999%"><p><strong>√</strong></p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="18.81%"><p>日志落盘</p> </td> <td class="cellrowborder" valign="top" width="35.8%"><p>将业务日志信息写到文件或数据库中，优先级较低。</p> </td> <td class="cellrowborder" valign="top" width="15.129999999999999%"><p><strong>×</strong></p> </td> <td class="cellrowborder" valign="top" width="15.129999999999999%"><p><strong>√</strong></p> </td> <td class="cellrowborder" valign="top" width="15.129999999999999%"><p><strong>×</strong></p> </td> </tr>  </tbody></table></div> </div> </li><li><strong>实现方案介绍</strong><p></p> <p>TaskPool提供四种优先级属性：HIGH、MEDIUM、LOW 和 IDLE。</p> <p>目前，仅taskpool.Task支持优先级属性设置，function类型不支持。默认优先级为MEDIUM。开发者可通过taskpool.execute()接口显式指定优先级。</p> <p>TaskPool 对高、中、低优先级任务的调度比例为 5:5:1。具体来说，每调用 5 个高优先级任务后会调用 1 个中优先级任务，每调用 5 个中优先级任务后会调用 1 个低优先级任务。通过配置这一比例关系，确保高优先级任务优先执行，同时中优先级任务得到合理调度，低优先级任务不会被忽略。</p> <p>优先级机制与QoS（quality-of-service）底层对接，3种属性对应不同的线程优先级。高优先级任务在TaskPool队列中优先调度，并在CPU调度中获得更多系统资源。</p> <p><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-taskpool#priority" target="_blank">Priority</a>的IDLE优先级是用来标记需要在后台运行的耗时任务（例如数据同步、备份。），它的优先级别是最低的。这种优先级标记的任务只会在所有线程都空闲的情况下触发执行，并且只会占用一个线程来执行。</p> </li><li><strong>业务实现中的关键点</strong><ol><li>合理设置高优先级任务的数量。如果在特定场景下高优先级任务过多，任务池将无法有效区分优先级差异，导致优先级调度可能退化为按入队顺序执行。此外，高优先级任务会抢占系统资源，影响其他线程和应用的执行。</li><li>依赖多个任务的执行时需要考虑优先级的分配。避免高优先级任务依赖低优先级任务的执行，以防止优先级倒置。</li></ol> </li><li><strong>案例参考</strong><div class="screenLinkPre"><div _ngcontent-puf-c106="" class="highlight-div"><div _ngcontent-puf-c106="" class="highlight-div-header"><div _ngcontent-puf-c106="" class="highlight-div-header-left"><div _ngcontent-puf-c106="" class="handle-button expand-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-puf-c106="" class="highlight-div-header-right"><div _ngcontent-puf-c106="" class="handle-button ai-button"></div><div _ngcontent-puf-c106="" class="handle-button line-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-puf-c106="" class="handle-button theme-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-puf-c106="" class="handle-button copy-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-puf-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-javascript" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/UseSendable/entry/src/main/ets/pages/ConcurrentTaskManagement4.ets#L20-L47" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">import</span> { hilog } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.PerformanceAnalysisKit'</span>;</li><li><span class="hljs-keyword">import</span> { taskpool } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.ArkTS'</span>;</li><li><span class="hljs-keyword">import</span> { <span class="hljs-title class_">BusinessError</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.BasicServicesKit'</span>;</li><li>
</li><li><span class="hljs-comment">// ...</span></li><li><span class="hljs-keyword">function</span> <span class="hljs-title function_">exec</span>(<span class="hljs-params">bufferArray: <span class="hljs-built_in">ArrayBuffer</span></span>): <span class="hljs-keyword">void</span> {</li><li>  taskpool.<span class="hljs-title function_">execute</span>(execColorInfo, bufferArray, taskpool.<span class="hljs-property">Priority</span>.<span class="hljs-property">HIGH</span>).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error: BusinessError</span>) =&gt;</span> {</li><li>    hilog.<span class="hljs-title function_">error</span>(<span class="hljs-variable constant_">DOMAIN</span>, <span class="hljs-variable constant_">TAG</span>, <span class="hljs-variable constant_">FORMAT</span>, <span class="hljs-string">`taskpool excute error: <span class="hljs-subst">${error}</span>`</span>);</li><li>  });</li><li>}</li><li>
</li><li>@<span class="hljs-title class_">Concurrent</span></li><li><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">execColorInfo</span>(<span class="hljs-params">bufferArray: <span class="hljs-built_in">ArrayBuffer</span></span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">ArrayBuffer</span>&gt; {</li><li>  <span class="hljs-keyword">if</span> (!bufferArray) {</li><li>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">0</span>);</li><li>  }</li><li>  <span class="hljs-keyword">const</span> newBufferArr = bufferArray;</li><li>  <span class="hljs-keyword">let</span> colorInfo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(newBufferArr);</li><li>  <span class="hljs-keyword">let</span> <span class="hljs-variable constant_">PIXEL_STEP</span> = <span class="hljs-number">2</span>;</li><li>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; colorInfo?.<span class="hljs-property">length</span>; i += <span class="hljs-variable constant_">PIXEL_STEP</span>) {</li><li>    <span class="hljs-comment">// data processing</span></li><li>  }</li><li>  <span class="hljs-keyword">return</span> newBufferArr;</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/UseSendable/entry/src/main/ets/pages/ConcurrentTaskManagement4.ets#L20-L47" target="_blank">ConcurrentTaskManagement4.ets</a></div></div></div></div> </li><li><strong>与业界方案特殊差异说明</strong><p>业界普遍提供了优先级机制，与TaskPool中的优先级没有显著差异。</p> </li><li><strong>不推荐应用实现方式</strong><p>不推荐过多设置高优先级或不合理优先级。</p> </li></ul> </div> <div class="tiledSection"><h3 id="section18304175813129">任务延时调度<i class="anchor-icon anchor-icon-link" anchorid="section18304175813129" tips="复制节点链接"></i></h3><ul><li><strong>场景描述</strong><p>在应用业务实现过程中，不是所有任务都需立刻执行，部分任务需延时一段时间后才需执行。</p> <p>常见的业务场景如下所示：</p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><tbody><tr><td class="cellrowborder" valign="top" width="34.44%"><p>常见业务场景</p> </td> <td class="cellrowborder" valign="top" width="65.56%"><p>具体业务描述</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="34.44%"><p>缓存业务延时执行，不影响冷启动耗时</p> </td> <td class="cellrowborder" valign="top" width="65.56%"><p>应用启动时，存在大量低优先级任务，例如二级界面的资源下载等，需设置3秒后执行，防止影响冷启动耗时。</p> </td> </tr>  </tbody></table></div> </div> </li><li><strong>实现方案介绍</strong><p>TaskPool提供了延时执行的能力。目前，仅taskpool.Task支持延时执行。开发者只需以下三个步骤即可完成延时实现。</p> <p>步骤一：创建Task对象；</p> <p>步骤二：调用taskpool.executeDelayed实现延时执行，依次填写延时时间delayTime、执行任务task和任务优先级priority（不填默认为MEDIUM）。</p> <p>步骤三：接收延时任务返回的数据并作处理。</p> </li><li><strong>业务实现中的关键点</strong><ol><li>非必需情况下不建议使用任务延时调度。在业务复杂的场景中使用任务延时调度可能会导致结果处理时序问题，进而影响应用业务的正常运行。</li><li>不建议将多个任务延时到同一时间执行。这可能导致任务排队，从而影响部分任务在指定延时时间后立即执行。</li></ol> </li><li><strong>案例参考</strong><div class="screenLinkPre"><div _ngcontent-puf-c106="" class="highlight-div"><div _ngcontent-puf-c106="" class="highlight-div-header"><div _ngcontent-puf-c106="" class="highlight-div-header-left"><div _ngcontent-puf-c106="" class="handle-button expand-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-puf-c106="" class="highlight-div-header-right"><div _ngcontent-puf-c106="" class="handle-button ai-button"></div><div _ngcontent-puf-c106="" class="handle-button line-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-puf-c106="" class="handle-button theme-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-puf-c106="" class="handle-button copy-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-puf-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-typescript" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/UseSendable/entry/src/main/ets/pages/ConcurrentTaskManagement5.ets#L20-L43" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">import</span> { hilog } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.PerformanceAnalysisKit'</span>;</li><li><span class="hljs-keyword">import</span> { taskpool } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.ArkTS'</span>;</li><li><span class="hljs-keyword">import</span> { <span class="hljs-title class_">BusinessError</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.BasicServicesKit'</span>;</li><li>
</li><li><span class="hljs-comment">// ...</span></li><li><span class="hljs-meta">@Concurrent</span></li><li><span class="hljs-keyword">function</span> <span class="hljs-title function_">concurrentTask</span>(<span class="hljs-params">num: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> {</li><li>  hilog.<span class="hljs-title function_">info</span>(<span class="hljs-number">0x0000</span>, <span class="hljs-string">'TAG'</span>, <span class="hljs-string">'%{public}s'</span>, <span class="hljs-string">'Add the task that needs to be executed with delay'</span>);</li><li>  <span class="hljs-keyword">return</span> num;</li><li>}</li><li>
</li><li><span class="hljs-comment">// create a task</span></li><li><span class="hljs-keyword">let</span> <span class="hljs-attr">task</span>: taskpool.<span class="hljs-property">Task</span> = <span class="hljs-keyword">new</span> taskpool.<span class="hljs-title class_">Task</span>(concurrentTask, <span class="hljs-number">100</span>);</li><li><span class="hljs-comment">// Delayed execution of task</span></li><li>taskpool.<span class="hljs-title function_">executeDelayed</span>(<span class="hljs-number">3000</span>, task, taskpool.<span class="hljs-property">Priority</span>.<span class="hljs-property">HIGH</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value: <span class="hljs-built_in">Object</span></span>) =&gt;</span> {</li><li>  <span class="hljs-comment">// Processing delayed task results</span></li><li>  hilog.<span class="hljs-title function_">info</span>(<span class="hljs-variable constant_">DOMAIN</span>, <span class="hljs-variable constant_">TAG</span>, <span class="hljs-variable constant_">FORMAT</span>, <span class="hljs-string">'taskpool result: '</span> + value);</li><li>}).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err: BusinessError</span>) =&gt;</span> {</li><li>  hilog.<span class="hljs-title function_">error</span>(<span class="hljs-variable constant_">DOMAIN</span>, <span class="hljs-variable constant_">TAG</span>, <span class="hljs-variable constant_">FORMAT</span>, <span class="hljs-string">`taskpool execute error. Cause code: <span class="hljs-subst">${err.code}</span>,message: <span class="hljs-subst">${err.message}</span>`</span>);</li><li>});</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/UseSendable/entry/src/main/ets/pages/ConcurrentTaskManagement5.ets#L20-L43" target="_blank">ConcurrentTaskManagement5.ets</a></div></div></div></div> </li><li><strong>与业界方案特殊差异说明</strong><p>业界大部分提供了任务延时调度功能，与TaskPool中的任务延时调度无明显差异。</p> </li><li><strong>不推荐应用实现方式</strong><p>在非必须场景中，不建议使用任务延时调度，以防止延时结果处理不当。</p> </li></ul> </div> <div class="tiledSection"><h2 id="section1464215361757">线程间通信<i class="anchor-icon anchor-icon-link" anchorid="section1464215361757" tips="复制节点链接"></i></h2></div> <div class="tiledSection"><h3 id="section7150947352" class="firsth2">概述<i class="anchor-icon anchor-icon-link" anchorid="section7150947352" tips="复制节点链接"></i></h3><p>线程间通信指并发多线程间的数据交换，已支持ArkTS、C++等开发语言。不同语言和线程间的通信场景将在下文详细展开。</p> </div> <div class="tiledSection"><h3 id="section35851753051">同语言线程间通信（ArkTS内）<i class="anchor-icon anchor-icon-link" anchorid="section35851753051" tips="复制节点链接"></i></h3><ul><li><strong>场景描述</strong><p>ArkTS线程包含主线程、TaskPool线程和Worker线程，这些线程可以通过不同接口通信。</p> <p><span>常见业务场景如下所示：</span></p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><tbody><tr><td class="cellrowborder" valign="top" width="38.15%"><p><strong>常见业务场景</strong></p> </td> <td class="cellrowborder" valign="top" width="61.85000000000001%"><p><strong>具体业务描述</strong></p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="38.15%"><p>宿主JS线程与TaskPool线程</p> </td> <td class="cellrowborder" valign="top" width="61.85000000000001%"><p>使用TaskPool分发任务到子线程。TaskPool子任务与其宿主线程之间需要通信的场景</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="38.15%"><p>宿主JS线程与Worker线程</p> </td> <td class="cellrowborder" valign="top" width="61.85000000000001%"><p>使用Worker启动子线程，执行任务。Worker子线程与其宿主线程之间需要通信的场景</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="38.15%"><p>任意JS线程与任意JS线程</p> </td> <td class="cellrowborder" valign="top" width="61.85000000000001%"><p>描述其他任意两个JS线程需要通信的场景</p> </td> </tr>  </tbody></table></div> </div> </li><li><strong>实现方案介绍</strong> <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><tbody><tr><td class="cellrowborder" valign="top" width="25.78%"><p><strong>跨线程交互场景</strong></p> </td> <td class="cellrowborder" valign="top" width="53.56000000000001%"><p><strong>通信方式</strong></p> </td> <td class="cellrowborder" valign="top" width="20.660000000000004%"><p><strong>通信优先级</strong></p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="25.78%"><p>宿主JS线程到TaskPool线程</p> </td> <td class="cellrowborder" valign="top" width="53.56000000000001%"><p>参数传递后分发任务，过程中不支持正向通信。</p> </td> <td class="cellrowborder" valign="top" width="20.660000000000004%"><p>支持</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="25.78%"><p>TaskPool线程到宿主JS线程</p> </td> <td class="cellrowborder" valign="top" width="53.56000000000001%"><p>结果返回时，sendData触发宿主线程的异步回调，底层实现为uv_async_send。</p> </td> <td class="cellrowborder" valign="top" width="20.660000000000004%"><p>不支持</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="25.78%"><p>宿主JS线程到Worker线程</p> </td> <td class="cellrowborder" valign="top" width="53.56000000000001%"><p>采用postMessage和onmessage进行异步通信</p> </td> <td class="cellrowborder" valign="top" width="20.660000000000004%"><p>不支持</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="25.78%"><p>Worker线程到宿主JS线程</p> </td> <td class="cellrowborder" valign="top" width="53.56000000000001%"><p>异步方式：使用postMessage和onmessage进行异步通信</p> <p>同步方式：Worker线程可以同步调用宿主线程注册的方法并返回结果。</p> </td> <td class="cellrowborder" valign="top" width="20.660000000000004%"><p>不支持</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="25.78%"><p>任意JS线程与任意JS线程</p> </td> <td class="cellrowborder" valign="top" width="53.56000000000001%"><p>使用@ohos.emitter实现双向异步通信功能。</p> </td> <td class="cellrowborder" valign="top" width="20.660000000000004%"><p>支持</p> </td> </tr>  </tbody></table></div> </div> </li><li><strong>业务实现中的关键点</strong><p>推荐使用TaskPool和Worker的接口进行ArkTS线程通信。</p> </li><li><strong>参考链接</strong><p><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-worker" target="_blank">@ohos.worker (启动一个Worker)</a></p> <p><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-taskpool" target="_blank">@ohos.taskpool（启动任务池）</a></p> <p><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-emitter" target="_blank">@ohos.events.emitter (Emitter)</a></p> </li><li><strong>与业界方案特殊差异说明</strong><p><span>线程通信采用消息循环的机制，与业界一致。</span></p> </li></ul> </div> <div class="tiledSection"><h3 id="section101785720619">跨语言多线程通信（C++与ArkTS）<i class="anchor-icon anchor-icon-link" anchorid="section101785720619" tips="复制节点链接"></i></h3><ul><li><strong>场景描述</strong><p>ArkTS线程包含ArkTS运行环境，包括主线程、TaskPool线程和Worker线程。HarmonyOS支持通过Node-API开发C++业务，开发者可以在C++层创建线程，因此C++线程需要与ArkTS线程通信。</p> <p><span>常见业务场景如下所示：</span></p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><tbody><tr><td class="cellrowborder" valign="top" width="49.07%"><p>常见业务场景</p> </td> <td class="cellrowborder" valign="top" width="50.93%"><p>具体业务描述</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="49.07%"><p>ArkTS线程（ArkTS）与pthread线程</p> </td> <td class="cellrowborder" valign="top" width="50.93%"><p>ArkTS线程的ArkTS部分与pthread线程的通信场景</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="49.07%"><p>ArkTS线程（C++部分） 与 pthread线程</p> </td> <td class="cellrowborder" valign="top" width="50.93%"><p>ArkTS线程的C++部分与pthread线程的通信场景</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="49.07%"><p>pthread线程与pthread线程</p> </td> <td class="cellrowborder" valign="top" width="50.93%"><p>C++线程间的通信场景</p> </td> </tr>  </tbody></table></div> </div> </li><li><strong>实现方案介绍</strong> <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><tbody><tr><td class="cellrowborder" valign="top" width="43.065693430656935%"><p><strong>跨线程交互场景</strong></p> </td> <td class="cellrowborder" valign="top" width="37.95620437956204%"><p><strong>通信方式</strong></p> </td> <td class="cellrowborder" valign="top" width="18.97810218978102%"><p><strong>通信优先级</strong></p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="43.065693430656935%"><p><span>ArkTS</span><span>线程（</span><span>ArkTS</span><span>）</span><span>到pthread</span><span>线程</span></p> </td> <td class="cellrowborder" valign="top" width="37.95620437956204%"><p><span>不支持，需要转到</span><span>C++</span></p> </td> <td class="cellrowborder" valign="top" width="18.97810218978102%"><p><span>不涉及</span></p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="43.065693430656935%"><p><span>pthread</span><span>线程</span><span>到ArkTS</span><span>线程（</span><span>ArkTS</span><span>）</span></p> </td> <td class="cellrowborder" rowspan="2" valign="top" width="37.95620437956204%"><p>使用napi_threadsafe_function通信。</p> </td> <td class="cellrowborder" rowspan="2" valign="top" width="18.97810218978102%"><p><span>支持</span></p> </td> </tr> <tr><td class="cellrowborder" valign="top"><p>pthread线程<span>到</span> ArkTS线程（C++部分）</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="43.065693430656935%"><p>ArkTS线程（C++部分）<span>到</span>pthread线程</p> </td> <td class="cellrowborder" rowspan="2" valign="top" width="37.95620437956204%"><p>开发者自定义</p> </td> <td class="cellrowborder" rowspan="2" valign="top" width="18.97810218978102%"><p><span>开发者自定义行为</span></p> </td> </tr> <tr><td class="cellrowborder" valign="top"><p>pthread线程与pthread线程</p> </td> </tr>  </tbody></table></div> </div> </li><li><strong>案例参考</strong><div class="screenLinkPre"><div _ngcontent-puf-c106="" class="highlight-div"><div _ngcontent-puf-c106="" class="highlight-div-header"><div _ngcontent-puf-c106="" class="highlight-div-header-left"><div _ngcontent-puf-c106="" class="handle-button expand-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-puf-c106="" class="highlight-div-header-right"><div _ngcontent-puf-c106="" class="handle-button ai-button"></div><div _ngcontent-puf-c106="" class="handle-button line-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-puf-c106="" class="handle-button theme-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-puf-c106="" class="handle-button copy-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-puf-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-java" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/UseSendable/entry/src/main/cpp/napi_init.cpp#L49-L103" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// napi_init.cpp</span></li><li>struct CallbackData {</li><li>    napi_env env;</li><li>    <span class="hljs-type">napi_async_work</span> <span class="hljs-variable">asyncWork</span> <span class="hljs-operator">=</span> nullptr;</li><li>    <span class="hljs-type">napi_threadsafe_function</span> <span class="hljs-variable">tsfn</span> <span class="hljs-operator">=</span> nullptr;</li><li>    <span class="hljs-type">int32_t</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;</li><li>};</li><li>
</li><li><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">CallJs</span><span class="hljs-params">(napi_env env, napi_value jsCb, <span class="hljs-keyword">void</span> *context, <span class="hljs-keyword">void</span> *data)</span> {</li><li>    CallbackData *callbackData = reinterpret_cast&lt;CallbackData *&gt;(data);</li><li>    napi_value global;</li><li>    <span class="hljs-keyword">assert</span>(napi_get_global(env, &amp;global) == napi_ok);</li><li>    napi_value number;</li><li>    <span class="hljs-keyword">assert</span>(napi_create_int32(env, callbackData-&gt;data, &amp;number) == napi_ok);</li><li>    <span class="hljs-keyword">assert</span>(napi_call_function(env, global, jsCb, <span class="hljs-number">1</span>, &amp;number, nullptr) == napi_ok);</li><li>}</li><li><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">NativeThread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *data)</span> {</li><li>    CallbackData *callbackData = reinterpret_cast&lt;CallbackData *&gt;(data);</li><li>    <span class="hljs-comment">/* Cross-thread call */</span></li><li>    {</li><li>        <span class="hljs-keyword">assert</span>(napi_acquire_threadsafe_function(callbackData-&gt;tsfn) == napi_ok);</li><li>
</li><li>        callbackData-&gt;data = <span class="hljs-number">123456</span>;</li><li>        <span class="hljs-type">napi_status</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> napi_call_threadsafe_function(callbackData-&gt;tsfn, callbackData, napi_tsfn_blocking);</li><li>        <span class="hljs-keyword">assert</span>(status == napi_ok);</li><li>    }</li><li>}</li><li><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ThreadFinished</span><span class="hljs-params">(napi_env env, <span class="hljs-keyword">void</span> *data, [[maybe_unused]] <span class="hljs-keyword">void</span> *context)</span> {</li><li>    CallbackData *callbackData = reinterpret_cast&lt;CallbackData *&gt;(data);</li><li>
</li><li>    <span class="hljs-keyword">assert</span>(napi_release_threadsafe_function(callbackData-&gt;tsfn, napi_tsfn_release) == napi_ok);</li><li>    ;</li><li>    callbackData-&gt;asyncWork = nullptr;</li><li>    callbackData-&gt;tsfn = nullptr;</li><li>    delete callbackData;</li><li>}</li><li><span class="hljs-keyword">static</span> napi_value <span class="hljs-title function_">NativeCall</span><span class="hljs-params">(napi_env env, napi_callback_info info)</span> {</li><li>    <span class="hljs-type">napi_value</span> <span class="hljs-variable">resourceName</span> <span class="hljs-operator">=</span> nullptr;</li><li>    CallbackData *callbackData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CallbackData</span>;</li><li>    callbackData-&gt;env = env;</li><li>
</li><li>    <span class="hljs-type">napi_value</span> <span class="hljs-variable">jsCb</span> <span class="hljs-operator">=</span> nullptr;</li><li>    <span class="hljs-type">size_t</span> <span class="hljs-variable">argc</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;</li><li>
</li><li>    <span class="hljs-keyword">assert</span>(napi_get_cb_info(env, info, &amp;argc, &amp;jsCb, nullptr, nullptr) == napi_ok);</li><li>    <span class="hljs-keyword">assert</span>(argc == <span class="hljs-number">1</span>);</li><li>
</li><li>    <span class="hljs-keyword">assert</span>(napi_create_string_utf8(env, <span class="hljs-string">"Call thread-safe function from c++ thread"</span>, NAPI_AUTO_LENGTH, &amp;resourceName) ==</li><li>           napi_ok);</li><li>    napi_status status;</li><li>    status = napi_create_threadsafe_function(env, jsCb, nullptr, resourceName, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, callbackData, ThreadFinished,</li><li>                                             callbackData, CallJs, &amp;(callbackData-&gt;tsfn));</li><li>    <span class="hljs-keyword">assert</span>(status == napi_ok);</li><li>    <span class="hljs-keyword">return</span> nullptr;</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/UseSendable/entry/src/main/cpp/napi_init.cpp#L49-L103" target="_blank">napi_init.cpp</a></div></div></div></div> <div class="screenLinkPre"><div _ngcontent-puf-c106="" class="highlight-div"><div _ngcontent-puf-c106="" class="highlight-div-header"><div _ngcontent-puf-c106="" class="highlight-div-header-left"><div _ngcontent-puf-c106="" class="handle-button expand-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-puf-c106="" class="highlight-div-header-right"><div _ngcontent-puf-c106="" class="handle-button ai-button"></div><div _ngcontent-puf-c106="" class="handle-button line-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-puf-c106="" class="handle-button theme-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-puf-c106="" class="handle-button copy-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-puf-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-typescript" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/UseSendable/entry/src/main/ets/pages/InterthreadCommunication1.ets#L44-L52" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// Index.ets</span></li><li><span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) {</li><li>  <span class="hljs-title class_">Button</span>(<span class="hljs-string">'click me'</span>)</li><li>    .<span class="hljs-title function_">onClick</span>(<span class="hljs-function">() =&gt;</span> {</li><li>      nativeModule.<span class="hljs-title function_">nativeCall</span>(<span class="hljs-function">(<span class="hljs-params">a: <span class="hljs-built_in">number</span></span>) =&gt;</span> {</li><li>        hilog.<span class="hljs-title function_">info</span>(<span class="hljs-variable constant_">DOMAIN</span>, <span class="hljs-variable constant_">TAG</span>, <span class="hljs-variable constant_">FORMAT</span>, <span class="hljs-string">'Received data from thread-function: %{public}d'</span>, a);</li><li>      })</li><li>    })</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/UseSendable/entry/src/main/ets/pages/InterthreadCommunication1.ets#L44-L52" target="_blank">InterthreadCommunication1.ets</a></div></div></div></div> </li><li><strong>与业界方案特殊差异说明</strong><ol><li>Java与C++通信时，业界使用JNI调用，与Node-API机制类似。</li><li>Java与C++通信时，业界支持C++线程通过attach方式反射调用Java方法。HarmonyOS APP开发时需通过napi_threadsafe_function异步通信。</li></ol> </li><li><strong>不推荐应用实现方式</strong><p>不建议在C++层增加wait等同步机制，这会导致卡死或掉帧等问题。</p> </li></ul> </div> <div class="tiledSection"><h3 id="section19259192873">线程间模块共享（单例模式）<i class="anchor-icon anchor-icon-link" anchorid="section19259192873" tips="复制节点链接"></i></h3><ul><li><strong>场景描述</strong><p>进程的唯一ArkTS实例初始化流程复杂，整体耗时较长。如果在主线程中进行初始化，会导致应用启动时间延长并阻塞主线程的执行。因此，建议将这些实例的初始化流程放在ArkTS子线程中进行。初始化完成后，主线程可以直接使用该实例。</p> <p>常见的业务场景如下所示：</p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><tbody><tr><td class="cellrowborder" valign="top" width="17.75%"><p>常见业务场景</p> </td> <td class="cellrowborder" valign="top" width="82.25%"><p>具体业务描述</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="17.75%"><p>SDK初始化</p> </td> <td class="cellrowborder" valign="top" width="82.25%"><p>在ArkTS子线程中调用API的Init初始化得到一个单例对象，完成后传给其他ArkTS线程使用</p> </td> </tr>  </tbody></table></div> </div> </li><li><strong>实现方案介绍（方案一）</strong><p>步骤一：使用C++单例模式封装，并在上层封装JS壳，子线程中进行初始化。</p> <p>步骤二：初始化完成后通知主线程，主线程导入并使用该单例对象。</p> <p><span><img height="370.07250000000005" originheight="1080" originwidth="1526" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163007.55246479248709609897868003560589:50001231000000:2800:DA733315F220332CDB36A3E5BC5AF2F165AB6B8B234BF4B85350EA843CDD92AA.jpg" title="点击放大" width="523.6875"></span></p> </li><li><strong>业务实现中的关键点</strong><ol><li>JS模块对象<p>模块定义的导出对象即为使用者导入时获得的对象。</p> <p>JS模块对象中的JS函数通过Node-API方法绑定到模块的Native静态方法。调用JS函数时，实际会调用Native静态方法来提供功能。</p> </li><li>Native Instance<p>模块对象的成员对象（ExternalReference）通过Native Class的GetCurrentInstance（标准单例实现）获取，进程内同模块均指向同一个Native单例。此设计适用于已有线程安全C++类的Native实现，Native成员方法需进行同步保护。</p> <p>该模块对象即使包含其他JS成员，也类似于“局部变量”，即线程间不共享。</p> </li><li>Native静态方法<p>Native静态方法提供对应模块的Native功能实现。通过napi_get_cb_info获取JS绑定函数的`this`对象，从而通过this获取绑定在JS模块对象上的Native实例，再调用Native实例对应的Native成员方法，即可完成对应功能的实现。</p> <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"><p>同上，方法实现中不能进行非线程安全的全局变量操作。</p> </div></div></div> </li><li>生命周期问题<p>模块对象通常在主线程退出时进行析构。</p> <p>若需精细化控制，可以绑定finalizeCallback进行管理。线程对象回收时，该线程会调用析构方法。</p> </li></ol> </li><li><strong>案例参考</strong><div class="screenLinkPre"><div _ngcontent-puf-c106="" class="highlight-div"><div _ngcontent-puf-c106="" class="highlight-div-header"><div _ngcontent-puf-c106="" class="highlight-div-header-left"><div _ngcontent-puf-c106="" class="handle-button expand-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-puf-c106="" class="highlight-div-header-right"><div _ngcontent-puf-c106="" class="handle-button ai-button"></div><div _ngcontent-puf-c106="" class="handle-button line-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-puf-c106="" class="handle-button theme-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-puf-c106="" class="handle-button copy-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-puf-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-cpp" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/UseSendable/entry/src/main/cpp/napi_init.cpp#L110-L159" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// napi_init.cpp</span></li><li><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> {</li><li><span class="hljs-keyword">public</span>:</li><li>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton &amp;<span class="hljs-title">GetInstance</span><span class="hljs-params">()</span> </span>{</li><li>        <span class="hljs-type">static</span> Singleton instance;</li><li>        <span class="hljs-keyword">return</span> instance;</li><li>    }</li><li>    <span class="hljs-function"><span class="hljs-type">static</span> napi_value <span class="hljs-title">GetAddress</span><span class="hljs-params">(napi_env env, napi_callback_info info)</span> </span>{</li><li>        <span class="hljs-type">uint64_t</span> addressVal = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uint64_t</span>&gt;(&amp;<span class="hljs-built_in">GetInstance</span>());</li><li>        napi_value napiAddress = <span class="hljs-literal">nullptr</span>;</li><li>        <span class="hljs-built_in">napi_create_bigint_uint64</span>(env, addressVal, &amp;napiAddress);</li><li>        <span class="hljs-keyword">return</span> napiAddress;</li><li>    }</li><li>    <span class="hljs-function"><span class="hljs-type">static</span> napi_value <span class="hljs-title">GetSetSize</span><span class="hljs-params">(napi_env env, napi_callback_info info)</span> </span>{</li><li>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(Singleton::GetInstance().numberSetMutex_)</span></span>;</li><li>        <span class="hljs-type">uint32_t</span> setSize = Singleton::<span class="hljs-built_in">GetInstance</span>().numberSet_.<span class="hljs-built_in">size</span>();</li><li>        napi_value napiSize = <span class="hljs-literal">nullptr</span>;</li><li>        <span class="hljs-built_in">napi_create_uint32</span>(env, setSize, &amp;napiSize);</li><li>        <span class="hljs-keyword">return</span> napiSize;</li><li>    }</li><li>    <span class="hljs-function"><span class="hljs-type">static</span> napi_value <span class="hljs-title">Store</span><span class="hljs-params">(napi_env env, napi_callback_info info)</span> </span>{</li><li>        <span class="hljs-type">size_t</span> argc = <span class="hljs-number">1</span>;</li><li>        napi_value args[<span class="hljs-number">1</span>] = {<span class="hljs-literal">nullptr</span>};</li><li>        <span class="hljs-built_in">napi_get_cb_info</span>(env, info, &amp;argc, args, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);</li><li>        <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">1</span>) {</li><li>            <span class="hljs-built_in">napi_throw_error</span>(env, <span class="hljs-string">"ERROR: "</span>, <span class="hljs-string">"store args number must be one"</span>);</li><li>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;</li><li>        }</li><li>        napi_valuetype type = napi_undefined;</li><li>        <span class="hljs-built_in">napi_typeof</span>(env, args[<span class="hljs-number">0</span>], &amp;type);</li><li>        <span class="hljs-keyword">if</span> (type != napi_number) {</li><li>            <span class="hljs-built_in">napi_throw_error</span>(env, <span class="hljs-string">"ERROR: "</span>, <span class="hljs-string">"store args is not number"</span>);</li><li>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;</li><li>        }</li><li>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(Singleton::GetInstance().numberSetMutex_)</span></span>;</li><li>        <span class="hljs-type">uint32_t</span> value = <span class="hljs-number">0</span>;</li><li>        <span class="hljs-built_in">napi_get_value_uint32</span>(env, args[<span class="hljs-number">0</span>], &amp;value);</li><li>        Singleton::<span class="hljs-built_in">GetInstance</span>().numberSet_.<span class="hljs-built_in">insert</span>(value);</li><li>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;</li><li>    }</li><li>
</li><li><span class="hljs-keyword">private</span>:</li><li>    <span class="hljs-built_in">Singleton</span>() {}                                    <span class="hljs-comment">// Private constructor to prevent external instantiation of objects</span></li><li>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton &amp;) = <span class="hljs-keyword">delete</span>;            <span class="hljs-comment">// Do not copy the constructor</span></li><li>    Singleton &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton &amp;) = <span class="hljs-keyword">delete</span>; <span class="hljs-comment">// The assignment operator is prohibited</span></li><li>
</li><li><span class="hljs-keyword">public</span>:</li><li>    std::unordered_set&lt;<span class="hljs-type">uint32_t</span>&gt; numberSet_{};</li><li>    std::mutex numberSetMutex_{};</li><li>};</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/UseSendable/entry/src/main/cpp/napi_init.cpp#L110-L159" target="_blank">napi_init.cpp</a></div></div></div></div> <div class="screenLinkPre"><div _ngcontent-puf-c106="" class="highlight-div"><div _ngcontent-puf-c106="" class="highlight-div-header"><div _ngcontent-puf-c106="" class="highlight-div-header-left"><div _ngcontent-puf-c106="" class="handle-button expand-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-puf-c106="" class="highlight-div-header-right"><div _ngcontent-puf-c106="" class="handle-button ai-button"></div><div _ngcontent-puf-c106="" class="handle-button line-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-puf-c106="" class="handle-button theme-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-puf-c106="" class="handle-button copy-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-puf-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-typescript" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/UseSendable/entry/src/main/ets/pages/InterthreadCommunication2.ets#L20-L81" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// Index.ets</span></li><li><span class="hljs-keyword">import</span> { taskpool } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.ArkTS'</span>;</li><li><span class="hljs-keyword">import</span> singleton <span class="hljs-keyword">from</span> <span class="hljs-string">'libentry.so'</span>;</li><li><span class="hljs-keyword">import</span> { hilog } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.PerformanceAnalysisKit'</span>;</li><li><span class="hljs-keyword">import</span> { <span class="hljs-title class_">BusinessError</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.BasicServicesKit'</span>;</li><li>
</li><li><span class="hljs-comment">// ...</span></li><li><span class="hljs-meta">@Concurrent</span></li><li><span class="hljs-keyword">function</span> <span class="hljs-title function_">getAddress</span>(<span class="hljs-params"></span>) {</li><li>  <span class="hljs-keyword">let</span> address = singleton.<span class="hljs-title function_">getAddress</span>();</li><li>  hilog.<span class="hljs-title function_">info</span>(<span class="hljs-number">0x0000</span>, <span class="hljs-string">'TAG'</span>, <span class="hljs-string">'%{public}s'</span>, <span class="hljs-string">'taskpool:: address is '</span> + address);</li><li>}</li><li>
</li><li><span class="hljs-meta">@Concurrent</span></li><li><span class="hljs-keyword">function</span> <span class="hljs-title function_">store</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span>, c: <span class="hljs-built_in">number</span></span>) {</li><li>  <span class="hljs-keyword">let</span> size = singleton.<span class="hljs-title function_">getSetSize</span>();</li><li>  hilog.<span class="hljs-title function_">info</span>(<span class="hljs-number">0x0000</span>, <span class="hljs-string">'TAG'</span>, <span class="hljs-string">'%{public}s'</span>, <span class="hljs-string">'set size is '</span> + size + <span class="hljs-string">' before store'</span>);</li><li>  singleton.<span class="hljs-title function_">store</span>(a);</li><li>  singleton.<span class="hljs-title function_">store</span>(b);</li><li>  singleton.<span class="hljs-title function_">store</span>(c);</li><li>  size = singleton.<span class="hljs-title function_">getSetSize</span>();</li><li>  hilog.<span class="hljs-title function_">info</span>(<span class="hljs-number">0x0000</span>, <span class="hljs-string">'TAG'</span>, <span class="hljs-string">'%{public}s'</span>, <span class="hljs-string">'set size is '</span> + size + <span class="hljs-string">' after store'</span>);</li><li>}</li><li>
</li><li><span class="hljs-meta">@Entry</span></li><li><span class="hljs-meta">@Component</span></li><li>struct <span class="hljs-title class_">Index</span> {</li><li>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) {</li><li>    <span class="hljs-title class_">Row</span>() {</li><li>      <span class="hljs-title class_">Column</span>() {</li><li>        <span class="hljs-title class_">Button</span>(<span class="hljs-string">'TestSingleton'</span>)</li><li>          .<span class="hljs-title function_">onClick</span>(<span class="hljs-function">() =&gt;</span> {</li><li>            <span class="hljs-keyword">let</span> address = singleton.<span class="hljs-title function_">getAddress</span>();</li><li>            hilog.<span class="hljs-title function_">info</span>(<span class="hljs-variable constant_">DOMAIN</span>, <span class="hljs-variable constant_">TAG</span>, <span class="hljs-variable constant_">FORMAT</span>, <span class="hljs-string">`host thread address is <span class="hljs-subst">${address}</span>`</span>);</li><li>            <span class="hljs-keyword">let</span> task1 = <span class="hljs-keyword">new</span> taskpool.<span class="hljs-title class_">Task</span>(getAddress);</li><li>            taskpool.<span class="hljs-title function_">execute</span>(task1).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err: BusinessError</span>) =&gt;</span> {</li><li>              hilog.<span class="hljs-title function_">error</span>(<span class="hljs-variable constant_">DOMAIN</span>, <span class="hljs-variable constant_">TAG</span>, <span class="hljs-variable constant_">FORMAT</span>,</li><li>                <span class="hljs-string">`taskpool execute error. Cause code: <span class="hljs-subst">${err.code}</span>,message: <span class="hljs-subst">${err.message}</span>`</span>);</li><li>            });</li><li>
</li><li>            <span class="hljs-keyword">let</span> task2 = <span class="hljs-keyword">new</span> taskpool.<span class="hljs-title class_">Task</span>(store, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);</li><li>            taskpool.<span class="hljs-title function_">execute</span>(task2).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err: BusinessError</span>) =&gt;</span> {</li><li>              hilog.<span class="hljs-title function_">error</span>(<span class="hljs-variable constant_">DOMAIN</span>, <span class="hljs-variable constant_">TAG</span>, <span class="hljs-variable constant_">FORMAT</span>,</li><li>                <span class="hljs-string">`taskpool execute error. Cause code: <span class="hljs-subst">${err.code}</span>,message: <span class="hljs-subst">${err.message}</span>`</span>);</li><li>            });</li><li>
</li><li>            <span class="hljs-keyword">let</span> task3 = <span class="hljs-keyword">new</span> taskpool.<span class="hljs-title class_">Task</span>(store, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);</li><li>            taskpool.<span class="hljs-title function_">execute</span>(task3).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err: BusinessError</span>) =&gt;</span> {</li><li>              hilog.<span class="hljs-title function_">error</span>(<span class="hljs-variable constant_">DOMAIN</span>, <span class="hljs-variable constant_">TAG</span>, <span class="hljs-variable constant_">FORMAT</span>,</li><li>                <span class="hljs-string">`taskpool execute error. Cause code: <span class="hljs-subst">${err.code}</span>,message: <span class="hljs-subst">${err.message}</span>`</span>);</li><li>            });</li><li>          })</li><li>      }</li><li>      .<span class="hljs-title function_">width</span>(<span class="hljs-string">'100%'</span>)</li><li>    }</li><li>    .<span class="hljs-title function_">height</span>(<span class="hljs-string">'100%'</span>)</li><li>  }</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/UseSendable/entry/src/main/ets/pages/InterthreadCommunication2.ets#L20-L81" target="_blank">InterthreadCommunication2.ets</a></div></div></div></div> </li><li><strong>实现方案介绍（方案二）</strong><p>步骤一：使用ArkTS对象定义Sendable类的单例，封装为共享模块（进程内共享），并在子线程中初始化。</p> <p>步骤二：初始化完成后通知主线程，主线程使用该单例对象。</p> </li><li><strong>业务实现中的关键点</strong><p>Sendable类需要满足一定的约束，可参考<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-sendable#sendable装饰器" target="_blank">@Sendable装饰器</a>。</p> </li><li><strong>案例参考</strong><div class="screenLinkPre"><div _ngcontent-puf-c106="" class="highlight-div"><div _ngcontent-puf-c106="" class="highlight-div-header"><div _ngcontent-puf-c106="" class="highlight-div-header-left"><div _ngcontent-puf-c106="" class="handle-button expand-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-puf-c106="" class="highlight-div-header-right"><div _ngcontent-puf-c106="" class="handle-button ai-button"></div><div _ngcontent-puf-c106="" class="handle-button line-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-puf-c106="" class="handle-button theme-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-puf-c106="" class="handle-button copy-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-puf-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-csharp" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/UseSendable/entry/src/main/ets/pages/Demo.ets#L21-L41" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// Demo.ets</span></li><li><span class="hljs-string">"use shared"</span></li><li>
</li><li>@Sendable</li><li>export <span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> {</li><li>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> instance: Demo;</li><li>
</li><li>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">constructor</span>()</span> {</li><li>  }</li><li>
</li><li>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title">getInstance</span>(): Demo</span> {</li><li>    <span class="hljs-keyword">if</span> (!Demo.instance) {</li><li>      Demo.instance = <span class="hljs-keyword">new</span> Demo();</li><li>    }</li><li>    <span class="hljs-keyword">return</span> Demo.instance;</li><li>  }</li><li>
</li><li>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">init</span>(): <span class="hljs-keyword">void</span></span> {</li><li>    <span class="hljs-comment">// initialization logic</span></li><li>  }</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/UseSendable/entry/src/main/ets/pages/Demo.ets#L21-L41" target="_blank">Demo.ets</a></div></div></div></div> <div class="screenLinkPre"><div _ngcontent-puf-c106="" class="highlight-div"><div _ngcontent-puf-c106="" class="highlight-div-header"><div _ngcontent-puf-c106="" class="highlight-div-header-left"><div _ngcontent-puf-c106="" class="handle-button expand-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-puf-c106="" class="highlight-div-header-right"><div _ngcontent-puf-c106="" class="handle-button ai-button"></div><div _ngcontent-puf-c106="" class="handle-button line-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-puf-c106="" class="handle-button theme-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-puf-c106="" class="handle-button copy-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-puf-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-javascript" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/UseSendable/entry/src/main/ets/pages/InterthreadCommunication3.ets#L20-L43" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">import</span> { <span class="hljs-title class_">BusinessError</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.BasicServicesKit'</span>;</li><li><span class="hljs-keyword">import</span> { hilog } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.PerformanceAnalysisKit'</span>;</li><li><span class="hljs-keyword">import</span> { taskpool } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.ArkTS'</span>;</li><li><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Demo</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./demo'</span>;</li><li><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">DOMAIN</span> = <span class="hljs-number">0x0000</span>;</li><li><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">TAG</span> = <span class="hljs-string">'InterthreadCommunication3'</span>;</li><li><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">FORMAT</span> = <span class="hljs-string">'%{public}s'</span>;</li><li>@<span class="hljs-title class_">Concurrent</span></li><li><span class="hljs-keyword">function</span> <span class="hljs-title function_">initSingleton</span>(<span class="hljs-params"></span>): <span class="hljs-keyword">void</span> {</li><li>  <span class="hljs-keyword">let</span> demo = <span class="hljs-title class_">Demo</span>.<span class="hljs-title function_">getInstance</span>();</li><li>  demo.<span class="hljs-title function_">init</span>();</li><li>  <span class="hljs-comment">// Notify the main thread that initialization is complete</span></li><li>}</li><li>
</li><li><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">executeTaskPool</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-keyword">void</span>&gt; {</li><li>  <span class="hljs-keyword">let</span> task = <span class="hljs-keyword">new</span> taskpool.<span class="hljs-title class_">Task</span>(initSingleton);</li><li>  <span class="hljs-keyword">await</span> taskpool.<span class="hljs-title function_">execute</span>(task).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err: BusinessError</span>) =&gt;</span> {</li><li>    hilog.<span class="hljs-title function_">error</span>(<span class="hljs-variable constant_">DOMAIN</span>, <span class="hljs-variable constant_">TAG</span>, <span class="hljs-variable constant_">FORMAT</span>, <span class="hljs-string">`taskpool execute error. Cause code: <span class="hljs-subst">${err.code}</span>,message: <span class="hljs-subst">${err.message}</span>`</span>);</li><li>  });</li><li>}</li><li>
</li><li><span class="hljs-title function_">executeTaskPool</span>();</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/UseSendable/entry/src/main/ets/pages/InterthreadCommunication3.ets#L20-L43" target="_blank">InterthreadCommunication3.ets</a></div></div></div></div> </li><li><strong>与业界方案特殊差异说明</strong><p>Java存在ClassLoader机制，所有类型是静态且唯一的，因此可以方便地导入类并支持单例模式。而在HarmonyOS APP开发中，需要借助共享模块来保证类只加载一次，确保唯一性。</p> </li></ul> </div> <div class="tiledSection"><h3 id="section154816558122">线程间不可变数据共享<i class="anchor-icon anchor-icon-link" anchorid="section154816558122" tips="复制节点链接"></i></h3><ul><li><strong>场景描述</strong><p>定义为Sendable类型的对象在发送到其他TS线程后可被多线程读写，开发者需要通过异步锁机制进行管理。为确保数据在多线程访问时的准确性，可以使用锁机制或使对象变为只读。</p> <p>以下是一些常见的业务场景：</p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><tbody><tr><td class="cellrowborder" valign="top" width="34.44%"><p>常见业务场景</p> </td> <td class="cellrowborder" valign="top" width="65.56%"><p>具体业务描述</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="34.44%"><p>全局环境变量共享</p> </td> <td class="cellrowborder" valign="top" width="65.56%"><p>应用启动时生成的资源加载入口、配置参数和全局变量等不需要更新的变量，可通过冻结能力冻结后共享到多个ArkTS子线程</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="34.44%"><p>一次性产物不可变共享</p> </td> <td class="cellrowborder" valign="top" width="65.56%"><p>业务阶段性生成的页面布局数据，在工作线程生成后传输并缓存在UI线程，缓存后不会修改，可能会多次作为UI渲染的输入使用</p> </td> </tr>  </tbody></table></div> </div> </li><li><strong>实现方案介绍</strong><p>通过冻结API，将共享对象变为只读。</p> <p>步骤一：定义业务逻辑，生成所需的Sendable对象。</p> <p>步骤二：发送到其他ArkTS线程前，使用Object.Freeze API冻结该对象。</p> <p>步骤三：通过taskpool或worker的消息通信机制将对象共享到其他ArkTS线程。</p> </li><li><strong>业务实现中的关键</strong><p>冻结后的对象不可修改，尝试修改将导致抛出ArkTS异常。</p> </li><li><strong>案例参考</strong><p>以全局环境变量共享为例：</p> <div class="screenLinkPre"><div _ngcontent-puf-c106="" class="highlight-div"><div _ngcontent-puf-c106="" class="highlight-div-header"><div _ngcontent-puf-c106="" class="highlight-div-header-left"><div _ngcontent-puf-c106="" class="handle-button expand-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-puf-c106="" class="highlight-div-header-right"><div _ngcontent-puf-c106="" class="handle-button ai-button"></div><div _ngcontent-puf-c106="" class="handle-button line-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-puf-c106="" class="handle-button theme-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-puf-c106="" class="handle-button copy-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-puf-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-typescript" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/UseSendable/entry/src/main/ets/pages/InterthreadCommunication4.ets#L20-L44" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">import</span> { worker } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.ArkTS'</span>;</li><li><span class="hljs-keyword">import</span> { freezeObj } <span class="hljs-keyword">from</span> <span class="hljs-string">'./freezeObj'</span>;</li><li><span class="hljs-keyword">import</span> { hilog } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.PerformanceAnalysisKit'</span>;</li><li><span class="hljs-comment">// ...</span></li><li><span class="hljs-meta">@Sendable</span></li><li><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GlobalConfig</span> {</li><li>  <span class="hljs-comment">// Some configuration properties and methods</span></li><li>  <span class="hljs-title function_">init</span>(<span class="hljs-params"></span>) {</li><li>    <span class="hljs-comment">// Initialization-related logic</span></li><li>    <span class="hljs-title function_">freezeObj</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">// Freeze the current object after initialization is completed.</span></li><li>  }</li><li>}</li><li>
</li><li><span class="hljs-keyword">try</span> {</li><li>  <span class="hljs-keyword">let</span> globalConfig = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GlobalConfig</span>();</li><li>  globalConfig.<span class="hljs-title function_">init</span>();</li><li>  <span class="hljs-keyword">const</span> workerInstance = <span class="hljs-keyword">new</span> worker.<span class="hljs-title class_">ThreadWorker</span>(<span class="hljs-string">'entry/ets/workers/Worker.ets`'</span>, { <span class="hljs-attr">name</span>: <span class="hljs-string">'Worker1'</span> });</li><li>  workerInstance.<span class="hljs-title function_">postMessage</span>(globalConfig);</li><li>} <span class="hljs-keyword">catch</span> (err) {</li><li>  hilog.<span class="hljs-title function_">error</span>(<span class="hljs-variable constant_">DOMAIN</span>, <span class="hljs-variable constant_">TAG</span>, <span class="hljs-variable constant_">FORMAT</span>, <span class="hljs-string">`postMessage failed. Cause code: <span class="hljs-subst">${err.code}</span>,message: <span class="hljs-subst">${err.message}</span>`</span>);</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/UseSendable/entry/src/main/ets/pages/InterthreadCommunication4.ets#L20-L44" target="_blank">InterthreadCommunication4.ets</a></div></div></div></div> <div class="screenLinkPre"><div _ngcontent-puf-c106="" class="highlight-div"><div _ngcontent-puf-c106="" class="highlight-div-header"><div _ngcontent-puf-c106="" class="highlight-div-header-left"><div _ngcontent-puf-c106="" class="handle-button expand-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-puf-c106="" class="highlight-div-header-right"><div _ngcontent-puf-c106="" class="handle-button ai-button"></div><div _ngcontent-puf-c106="" class="handle-button line-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-puf-c106="" class="handle-button theme-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-puf-c106="" class="handle-button copy-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-puf-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-javascript" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/UseSendable/entry/src/main/ets/workers/Worker.ets#L20-L31" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// The worker file path is: entry/ets/workers/Worker.ets</span></li><li><span class="hljs-comment">// Worker.ets</span></li><li><span class="hljs-keyword">import</span> { <span class="hljs-title class_">MessageEvents</span>, <span class="hljs-title class_">ThreadWorkerGlobalScope</span>, worker } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.ArkTS'</span>;</li><li><span class="hljs-keyword">import</span> { <span class="hljs-title class_">GlobalConfig</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'../pages/InterthreadCommunication4'</span>;</li><li><span class="hljs-keyword">import</span> { hilog } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.PerformanceAnalysisKit'</span>;</li><li>
</li><li><span class="hljs-keyword">const</span> <span class="hljs-attr">workerPort</span>: <span class="hljs-title class_">ThreadWorkerGlobalScope</span> = worker.<span class="hljs-property">workerPort</span>;</li><li>workerPort.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">e: MessageEvents</span>) =&gt;</span> {</li><li>  <span class="hljs-keyword">let</span> <span class="hljs-attr">globalConfig</span>: <span class="hljs-title class_">GlobalConfig</span> = e.<span class="hljs-property">data</span>;</li><li>  hilog.<span class="hljs-title function_">info</span>(<span class="hljs-number">0x0000</span>, <span class="hljs-string">'TAG'</span>, <span class="hljs-string">'%{public}s'</span>, <span class="hljs-string">`globalConfig: <span class="hljs-subst">${globalConfig}</span>`</span>);</li><li>  <span class="hljs-comment">// use the globalConfig object</span></li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/UseSendable/entry/src/main/ets/workers/Worker.ets#L20-L31" target="_blank">Worker.ets</a></div></div></div></div> <div class="screenLinkPre"><div _ngcontent-puf-c106="" class="highlight-div"><div _ngcontent-puf-c106="" class="highlight-div-header"><div _ngcontent-puf-c106="" class="highlight-div-header-left"><div _ngcontent-puf-c106="" class="handle-button expand-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-puf-c106="" class="highlight-div-header-right"><div _ngcontent-puf-c106="" class="handle-button ai-button"></div><div _ngcontent-puf-c106="" class="handle-button line-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-puf-c106="" class="handle-button theme-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-puf-c106="" class="handle-button copy-button"><div _ngcontent-puf-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-puf-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-javascript" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/UseSendable/entry/src/main/ets/pages/freezeObj.ts#L20-L23" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// freezeObj.ts</span></li><li><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">freezeObj</span>(<span class="hljs-params">obj: any</span>) {</li><li>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">freeze</span>(obj);</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/UseSendable/entry/src/main/ets/pages/freezeObj.ts#L20-L23" target="_blank">freezeObj.ts</a></div></div></div></div> </li><li><strong>与业界方案特殊差异说明</strong><p>内存共享模型中，Java/C++对象在不同线程间均可见。Sendable对象需要将对象引用发送到其他线程才能使用。</p> </li></ul> </div> <div class="tiledSection"><h3 id="section9833163071612">生产者与消费者模式<i class="anchor-icon anchor-icon-link" anchorid="section9833163071612" tips="复制节点链接"></i></h3><ul><li><strong>场景描述</strong><p>生产者与消费者模式表现为以下几个特征：</p> <p>1. 生产者可以是单个或多个，同时并发地生产数据。</p> <p>2. 消费者可以单个或多个并发地消费数据；</p> <p>3. 存在一个数据缓存区。生产者将数据存储在缓存区，消费者从缓存区取数据。缓存区满时通知生产者停止生产，缓存区空时通知消费者休眠。</p> <p>常见的业务场景如下所示：</p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><tbody><tr><td class="cellrowborder" valign="top" width="18.81%"><p>常见业务场景</p> </td> <td class="cellrowborder" valign="top" width="35.8%"><p>具体业务描述</p> </td> <td class="cellrowborder" valign="top" width="45.39%"><p>场景类型</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="18.81%"><p>阅读应用页面预加载</p> </td> <td class="cellrowborder" valign="top" width="35.8%"><p>用户每次翻页或跳转后，需要预加载多张前后页。将前后页的加载请求缓存到一个加载队列中，并并发执行队列中的页面布局解析任务。</p> </td> <td class="cellrowborder" valign="top" width="45.39%"><p>CPU密集型+IO密集型</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="18.81%"><p>本地文件上传</p> </td> <td class="cellrowborder" valign="top" width="35.8%"><p>用户在主线程中一次上传一个或多个文件。上传文件的请求被存储在上传队列中，并发处理队列中的文件上传到云端。</p> </td> <td class="cellrowborder" valign="top" width="45.39%"><p>CPU密集型+IO密集型</p> </td> </tr>  </tbody></table></div> </div> </li><li><strong>实现方案介绍</strong><p>以阅读应用场景为例：</p> <p>步骤一：用户每次翻页时，系统会生成多个前后页的预加载请求。</p> <p>步骤二：通过网络接口从云端下载多个页面的原始数据。</p> <p>步骤三：通过taskpool并发解析页面原始数据生成page对象。page对象描述页面布局和组成部分。</p> <p>步骤四：taskpool执行结果返回到UI线程的缓存队列。</p> <p>步骤五：渲染缓存队列中临近当前页的page对象。</p> </li><li><strong>业务实现中的关键</strong><ol><li>如果Page对象回到主线程仅需使用其中的数据，可以考虑通过序列化在线程间传递。如果Page对象引用了多个自定义类型的对象，为了将其完整地返回UI线程，需要将其定义为Sendable类型的对象。</li><li>如果页面原始数据是TS线程间共享的，可以在UI线程执行下载任务（异步并发，不阻塞UI线程）。如果不是，则需在taskpool工作线程中执行下载，</li><li>对时延敏感的场景不建议使用并发模块处理相关逻辑。并发功能可将负载从UI线程转移到工作线程，但会增加时延（并发不排队时约为500μs）。</li></ol> </li><li><strong>与业界方案特殊差异说明</strong><p>1. 内存共享模型如Java/C++对象在不同线程间可见。ArkTS的线程间内存隔离模型中，对象在不同线程间使用需要序列化（拷贝），Sendable对象需要将对象引用发送到其他线程才可使用。</p> <p>2. Sendable对象存在较多约束，尽量只将必须共享的对象定义为Sendable对象，普通ArkTS对象持有Sendable对象并串联整个流程。</p> </li></ul> </div> <div class="tiledSection"><h2 id="section1078520389541">示例代码<i class="anchor-icon anchor-icon-link" anchorid="section1078520389541" tips="复制节点链接"></i></h2><ul><li><a href="https://gitee.com/harmonyos_samples/UseSendable" target="_blank">应用并发设计</a></li></ul> </div> </div> <div></div></div>