<h1 _ngcontent-cys-c119="" class="doc-title ng-star-inserted" title="应用被查杀类问题分析方法"> 应用被查杀类问题分析方法 </h1>

<div _ngcontent-cys-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;"> <div><div class="tiledSection"><h2 id="section1889834675116">日志获取<i class="anchor-icon anchor-icon-link" anchorid="section1889834675116" tips="复制节点链接"></i></h2><p>目前应用可以通过两种方式感知到应用被异常查杀</p> <ol><li>元能力提供的Ability的onCreate回调参数中来获取到查杀原因。具体来说就是LaunchParam启动参数中的LastExitReason字段，请参考<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-ability-abilityconstant#lastexitreason" target="_blank">LastExitReason</a>。</li><li>通过HiAppEvent订阅APP_KILLED事件，订阅后就能在收到的回调函数中解析出查杀原因（如APP_FREEZE等），请参考<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/hiappevent-watcher-app-killed-events" target="_blank">应用查杀事件介绍</a>。</li></ol> </div> <div class="tiledSection"><h2 id="section1040984015410">分析思路和分析步骤<i class="anchor-icon anchor-icon-link" anchorid="section1040984015410" tips="复制节点链接"></i></h2><ol><li>通过Ability的onCreate回调参数中获取查杀原因<p>根据LastExitReason的不同取值，可参考下表采取对应处理策略：</p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.2.2.1.2.1.4.1.1" valign="top" width="25.85%"><p><strong>LastExitReason(enum</strong>)</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.2.2.1.2.1.4.1.2" valign="top" width="35.06%"><p>产生原因</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.2.2.1.2.1.4.1.3" valign="top" width="39.09%"><p>处理策略</p> </th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="25.85%"><p>APP_FREEZE</p> </td> <td class="cellrowborder" valign="top" width="35.06%"><p>由于watchdog检测出应用冻屏故障，导致应用程序退出。</p> </td> <td class="cellrowborder" valign="top" width="39.09%"><p>通过HiAppEvent订阅<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/freeze-events" target="_blank">应用冻屏事件</a>，到应用冻屏事件中去匹配。</p> </td> </tr> <tr><td class="cellrowborder" rowspan="6" valign="top" width="25.85%"><p>RESOURCE_CONTROL</p> </td> <td class="cellrowborder" valign="top" width="35.06%"><p>CPU高负载。</p> </td> <td class="cellrowborder" valign="top" width="39.09%"><p>尝试降低应用自身的CPU负载。</p> </td> </tr> <tr><td class="cellrowborder" valign="top"><p>快速CPU负载检测。</p> </td> <td class="cellrowborder" valign="top"><p>尝试降低应用自身的CPU负载。</p> </td> </tr> <tr><td class="cellrowborder" valign="top"><p>I/O管控。</p> </td> <td class="cellrowborder" valign="top"><p>尝试降低应用自身的IO用量。</p> </td> </tr> <tr><td class="cellrowborder" valign="top"><p>应用内存超限劣化。</p> </td> <td class="cellrowborder" valign="top"><p>尝试通过HiAppEvent订阅RESOURCE_OVERLIMIT获取更多日志。</p> </td> </tr> <tr><td class="cellrowborder" valign="top"><p>温度管控。</p> </td> <td class="cellrowborder" valign="top"><p>尝试降低应用自身的CPU负载。</p> </td> </tr> <tr><td class="cellrowborder" valign="top"><p>整机低内存触发按优先级由低到高查杀。</p> </td> <td class="cellrowborder" valign="top"><p>尝试降低应用自身的内存占用，以减少被整机查杀策略选中的概率。</p> </td> </tr>  </tbody></table></div> </div> </li><li>通过使用HiAppEvent订阅APP_KILLED事件<p>通过APP_KILLED事件，能获取到查杀原因、应用前后台信息等关键信息，可以对照如下表进行处理</p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.2.2.2.2.1.7.1.1" valign="top" width="18.4981501849815%"><p>reason（string）</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.2.2.2.2.1.7.1.2" valign="top" width="20.16798320167983%"><p>产生原因</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.2.2.2.2.1.7.1.3" valign="top" width="24.147585241475852%"><p>处理策略</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.2.2.2.2.1.7.1.4" valign="top" width="9.739026097390262%"><p>是否应用自身异常触发管控</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.2.2.2.2.1.7.1.5" valign="top" width="19.928007199280074%"><p>是否有关联事件</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.2.2.2.2.1.7.1.6" valign="top" width="7.519248075192481%"><p>是否会查杀前台应用</p> </th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="18.4981501849815%"><p>LowMemoryKill</p> </td> <td class="cellrowborder" valign="top" width="20.16798320167983%"><p>同前面的lastExitMessage值为Memory Pressure场景，即整机低内存触发按优先级由低到高查杀</p> </td> <td class="cellrowborder" valign="top" width="24.147585241475852%"><p>尝试降低应用自身的内存占用，以减少被整机查杀策略选中的概率</p> </td> <td class="cellrowborder" valign="top" width="9.739026097390262%"><p>否</p> </td> <td class="cellrowborder" valign="top" width="19.928007199280074%"><p>否</p> </td> <td class="cellrowborder" valign="top" width="7.519248075192481%"><p>是</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="18.4981501849815%"><p>SwapFull</p> </td> <td class="cellrowborder" valign="top" width="20.16798320167983%"><p>Swap交换空间接近占满，可能存在个别进程内存泄漏，或者是后台进程个数太多</p> </td> <td class="cellrowborder" valign="top" width="24.147585241475852%"><p>尝试降低应用自身的内存占用，以减少被整机查杀策略选中的概率</p> </td> <td class="cellrowborder" valign="top" width="9.739026097390262%"><p>否</p> </td> <td class="cellrowborder" valign="top" width="19.928007199280074%"><p>否</p> </td> <td class="cellrowborder" valign="top" width="7.519248075192481%"><p>否</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="18.4981501849815%"><p>ResourceLeak(IonLeak)</p> </td> <td class="cellrowborder" valign="top" width="20.16798320167983%"><p>应用占用的ION内存超标</p> </td> <td class="cellrowborder" valign="top" width="24.147585241475852%"><p>尝试通过HiAppEvent订阅RESOURCE_OVERLIMIT获取更多的ION内存日志，找到泄漏点后，降低应用自身的ION内存占用，一般来说是Image组件或者Pixmap泄漏导致</p> </td> <td class="cellrowborder" valign="top" width="9.739026097390262%"><p>是</p> </td> <td class="cellrowborder" valign="top" width="19.928007199280074%"><p>是</p> <p>（RESOURCE_OVERLIMIT）</p> </td> <td class="cellrowborder" valign="top" width="7.519248075192481%"><p>是</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="18.4981501849815%"><p>ResourceLeak(GpuRsLeak)</p> </td> <td class="cellrowborder" valign="top" width="20.16798320167983%"><p>应用的ArkUI组件在render_service服务进程占用的GPU内存超标</p> </td> <td class="cellrowborder" valign="top" width="24.147585241475852%"><p>尝试降低应用ArkUI组件的GPU内存占用</p> </td> <td class="cellrowborder" valign="top" width="9.739026097390262%"><p>是</p> </td> <td class="cellrowborder" valign="top" width="19.928007199280074%"><p>否</p> </td> <td class="cellrowborder" valign="top" width="7.519248075192481%"><p>是</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="18.4981501849815%"><p>ResourceLeak(GpuLeak)</p> </td> <td class="cellrowborder" valign="top" width="20.16798320167983%"><p>应用在本进程内占用的GPU内存（即自渲染产生的GPU内存）超标</p> </td> <td class="cellrowborder" valign="top" width="24.147585241475852%"><p>尝试通过HiAppEvent订阅RESOURCE_OVERLIMIT获取更多的GPU内存日志，找到泄漏点后，降低应用自渲染（使用XComponent组件）的GPU内存占用</p> </td> <td class="cellrowborder" valign="top" width="9.739026097390262%"><p>是</p> </td> <td class="cellrowborder" valign="top" width="19.928007199280074%"><p>是</p> <p>（RESOURCE_OVERLIMIT）</p> </td> <td class="cellrowborder" valign="top" width="7.519248075192481%"><p>是</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="18.4981501849815%"><p>ResourceLeak(AshmemLeak)</p> </td> <td class="cellrowborder" valign="top" width="20.16798320167983%"><p>应用占用的ashmem内存超标</p> </td> <td class="cellrowborder" valign="top" width="24.147585241475852%"><p>尝试通过HiAppEvent订阅RESOURCE_OVERLIMIT获取更多的ashmem内存日志，找到泄漏点后，降低应用自身的ashmem内存占用，一般来说是Image组件或者Pixmap泄漏导致</p> </td> <td class="cellrowborder" valign="top" width="9.739026097390262%"><p>是</p> </td> <td class="cellrowborder" valign="top" width="19.928007199280074%"><p>是</p> <p>（RESOURCE_OVERLIMIT）</p> </td> <td class="cellrowborder" valign="top" width="7.519248075192481%"><p>是</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="18.4981501849815%"><p>IllegalAudioRendererBySuspend</p> </td> <td class="cellrowborder" valign="top" width="20.16798320167983%"><p>未申请合理的后台任务，但是后台有大量音频播放</p> </td> <td class="cellrowborder" valign="top" width="24.147585241475852%"><p>应用退至后台时，应避免不必要的后台音频播放，或者合理使用后台任务，具体参考<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/background-task-kit" target="_blank">后台任务开发服务</a></p> </td> <td class="cellrowborder" valign="top" width="9.739026097390262%"><p>是</p> </td> <td class="cellrowborder" valign="top" width="19.928007199280074%"><p>否</p> </td> <td class="cellrowborder" valign="top" width="7.519248075192481%"><p>否</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="18.4981501849815%"><p>PowerSaveClean</p> </td> <td class="cellrowborder" valign="top" width="20.16798320167983%"><p>整机切换到省电模式或应急模式</p> </td> <td class="cellrowborder" valign="top" width="24.147585241475852%"><p>无需处理</p> </td> <td class="cellrowborder" valign="top" width="9.739026097390262%"><p>否</p> </td> <td class="cellrowborder" valign="top" width="19.928007199280074%"><p>否</p> </td> <td class="cellrowborder" valign="top" width="7.519248075192481%"><p>否</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="18.4981501849815%"><p>RssThresholdKiller</p> </td> <td class="cellrowborder" valign="top" width="20.16798320167983%"><p>应用的RSS内存超一定阈值</p> </td> <td class="cellrowborder" valign="top" width="24.147585241475852%"><p>尝试降低应用自身的内存占用，避免出现RSS内存超过阈值的情况</p> </td> <td class="cellrowborder" valign="top" width="9.739026097390262%"><p>是</p> </td> <td class="cellrowborder" valign="top" width="19.928007199280074%"><p>否</p> </td> <td class="cellrowborder" valign="top" width="7.519248075192481%"><p>是</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="18.4981501849815%"><p>OomKiller</p> </td> <td class="cellrowborder" valign="top" width="20.16798320167983%"><p>整机低内存触发了内核按一定策略进行应用查杀</p> </td> <td class="cellrowborder" valign="top" width="24.147585241475852%"><p>尝试降低应用自身的内存占用，以减少被整机查杀策略选中的概率</p> </td> <td class="cellrowborder" valign="top" width="9.739026097390262%"><p>否</p> </td> <td class="cellrowborder" valign="top" width="19.928007199280074%"><p>否</p> </td> <td class="cellrowborder" valign="top" width="7.519248075192481%"><p>是</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="18.4981501849815%"><p>CpaKiller</p> </td> <td class="cellrowborder" valign="top" width="20.16798320167983%"><p>DRM(Digital Right Management)业务申请内存但是内存不足时，会按照一定策略查杀进程以回收内存</p> </td> <td class="cellrowborder" valign="top" width="24.147585241475852%"><p>尝试降低应用自身的内存占用，以减少被整机查杀策略选中的概率</p> </td> <td class="cellrowborder" valign="top" width="9.739026097390262%"><p>否</p> </td> <td class="cellrowborder" valign="top" width="19.928007199280074%"><p>否</p> </td> <td class="cellrowborder" valign="top" width="7.519248075192481%"><p>是</p> </td> </tr>  </tbody></table></div> </div> </li></ol> </div> </div> <div></div></div>