<h1 _ngcontent-hyr-c119="" class="doc-title ng-star-inserted" title="性能分析简介"> 性能分析简介 </h1>

<div _ngcontent-hyr-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;"> <div><div class="tiledSection"><h2 id="section0761240112711">概述<i class="anchor-icon anchor-icon-link" anchorid="section0761240112711" tips="复制节点链接"></i></h2><p>性能优化是指改进应用程序运行速度、资源利用效率和响应时间的系统性工作。通过优化可提升应用性能和稳定性。在数字化时代，随着应用程序的复杂性和规模不断增加，调优变得尤为重要。有效调优不仅能使应用程序更高效地运行，还能提高稳定性，提升效率，减少资源浪费，从而改善用户体验。因此，开发人员了解调优方法和常用工具至关重要。</p> <p>调优过程包括现场复现、问题分析、确定解决方案和性能测试这几个关键步骤。现场复现是在具体环境中重现问题，以便更好地分析和解决。问题分析阶段深入分析应用程序的性能瓶颈和问题根源，为后续优化提供指导。确定解决方案是根据问题分析结果，制定具体的优化方案和措施。性能测试是验证调优效果的关键步骤，通过测试优化后的应用程序，评估改进效果。</p> <p>为了有效进行调优工作，需要借助常用的工具。例如，性能分析工具DevEco Profiler可以监测应用的性能指标、录制Trace记录。开发者可以通过分析Trace数据，发现代码中的性能瓶颈，进而优化性能。</p> <p>本文将介绍调优方法和常用工具，帮助开发者分析和解决应用程序性能问题，提升用户体验，确保应用程序高效稳定运行。</p> <p>在日常开发中，需要关注的指标有完成时延、点击响应时延、滑动响应时延等，具体需要关注的指标可以参考<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-smooth-application-design" target="_blank">《性能体验设计》</a>。</p> </div> <div class="tiledSection"><h2 id="section87919464276">调优分析步骤<i class="anchor-icon anchor-icon-link" anchorid="section87919464276" tips="复制节点链接"></i></h2><p>调优分析方法在应用程序优化中起着关键作用，帮助开发人员识别问题、定位瓶颈并改进系统性能。具体调优分析方法如下：</p> <ol><li><span>现场复现是调优分析的第一步。开发人员通过复现报错、卡顿等问题，确认问题现象和性能瓶颈，更好地理解和定位问题，为后续分析提供信息。</span></li><li><span>问题分析是调优过程中的关键步骤。确认问题现象后，参考相关可观测性数据，深入分析和诊断应用程序的问题。通过系统性分析，定位问题根源，为后续优化工作奠定基础。</span></li><li><span>确定解决方案：在问题分析阶段确定问题根源后，开发人员需制定具体的解决方案。这包括回归代码，结合业务场景和API，找出合适的优化方案。</span></li><li><span>性能测试：这是验证调优效果的最后一步。测试优化后的应用程序，确保性能提升有效。性能测试帮助评估改进效果，发现潜在问题，进一步优化应用性能。</span></li></ol> <p>调优分析是应用程序优化的关键步骤。通过现场复现、问题分析、确定解决方案和性能测试，开发人员可以识别并解决应用性能问题，提升应用程序的效率和稳定性。</p> </div> <div class="tiledSection"><h2 id="section115899571278">常见工具<i class="anchor-icon anchor-icon-link" anchorid="section115899571278" tips="复制节点链接"></i></h2></div> <div class="tiledSection"><h3 id="section2012922312284" class="firsth2">DevEco Profiler<i class="anchor-icon anchor-icon-link" anchorid="section2012922312284" tips="复制节点链接"></i></h3><p>性能调优工具能帮助开发者识别应用中的性能问题。DevEco Studio提供了多种常用的性能调优工具，具体如下：</p> <ul><li><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-insight-session-launch" target="_blank">启动分析工具Launch Profiler</a>： 分析启动过程中各阶段的性能问题。Launch主要用于分析应用或服务的启动耗时，分析启动周期各阶段的耗时情况、核心线程的运行情况等，协助开发者识别启动缓慢的原因。</li><li><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-insight-session-frame" target="_blank">帧率分析工具Frame Profiler</a>： 用于深度分析应用或服务卡顿丢帧的原因。Frame用于录制GPU数据信息，录制完成的子泳道对应录制过程中各个进程的帧数据，主要用于深度分析应用或服务卡顿丢帧的原因。Frame会对Trace进行录制和解析，进而可以分析应用运行的性能及其瓶颈，最终得出优化方案，关于Trace的详细介绍可参考<a href="/consumer/cn/doc/best-practices/bpta-optimization-overview#section085643405116">Trace打点信息说明</a>。</li><li><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-insight-session-time" target="_blank">耗时分析工具Time Profiler</a>： 在应用/服务运行时，展示热点区域内基于 CPU 和进程耗时分析的调用栈情况。Time可在应用/服务运行时，展示热点区域内基于CPU和进程耗时分析的调用栈情况，并提供跳转至相关代码的能力，使开发者更便捷地进行代码优化。</li><li><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-insight-session-allocations" target="_blank">内存分析工具Allocation Profiler</a>： 实时监测应用或服务内存使用情况。开发者可以使用Allocation内存分析器，识别可能会导致应用卡顿、内存泄漏、内存抖动的问题。</li><li><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-insight-session-snapshot" target="_blank">内存快照Snapshot Profiler</a>： 用于分析应用程序内存使用情况。内存快照（Snapshot）是一种用于分析应用程序内存使用情况的工具，通过记录应用程序在运行时的内存快照，可以快速查看应用程序在某一时刻的内存占用情况以及内存占用详情。</li><li><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-insight-session-cpu" target="_blank">应用性能分析工具CPU Profiler</a>： 该工具可以监测应用的CPU使用情况，为开发者提供性能采样分析手段，可在不插桩的情况下获取调用栈上各层函数的执行时间，并展示在时间轴上。</li><li><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-profiler-arkweb" target="_blank">ArkWeb分析工具</a>：DevEco Profiler提供ArkWeb分析模板，可以结合ArkWeb执行流程的关键trace点来定位问题发生的阶段。</li><li><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-profiler-network" target="_blank">Network分析工具</a>：DevEco Profiler提供Network模板，帮助用户在应用运行过程中查看http协议栈网络信息，包括请求分段耗时以及请求具体内容，方便对网络问题进行调优。</li></ul> <p>其他常见的性能调优工具，包括<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/hidumper" target="_blank">HiDumper</a>、<a href="https://gitcode.com/openharmony-sig/smartperf" target="_blank">SmartPerf</a>。</p> <ul><li>性能优化工具HiDumper：HiDumper是为开发和测试人员提供的系统信息获取工具，帮助分析和定位问题。在应用开发过程中，可以使用HiDumper命令行工具获取UI界面组件树信息，配合ArkUI Inspector等图形化工具定位布局性能问题。此外，还可以使用该命令行工具获取内存和CPU使用情况等系统数据，评估应用性能。</li><li>性能功耗调优工具SmartPerf：SmartPerf是一款用于深入挖掘和细粒度展示数据的性能功耗调优工具。它可以采集CPU调度、频点、进程线程时间片、堆内存、帧率等数据，并通过泳道图清晰地呈现给开发者。同时，SmartPerf通过GUI以可视化的方式进行分析。目前，该工具为开发者提供了五个分析模板：帧率分析、CPU/线程调度分析、应用启动分析、TaskPool分析和动效分析。<p><strong>注意点</strong></p> <p>Profiler工具不支持模拟器进行调优。</p> </li></ul> </div> <div class="tiledSection"><h3 id="section1465143164111">ArkUI Inspector<i class="anchor-icon anchor-icon-link" anchorid="section1465143164111" tips="复制节点链接"></i></h3><p><strong>介绍</strong></p> <p>开发者可以使用<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-previewer-inspector" target="_blank">Inspector双向预览</a>，在DevEco Studio上查看应用在真机上的组件布局，并通过查看多次操作后的界面状态，快速分析定位状态变量、组件嵌套层次、UI界面布局存在的问题等。</p> <p><strong>使用方法</strong></p> <p>详细使用指导见：</p> <p><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-arkui-inspector" target="_blank">布局分析</a></p> </div> <div class="tiledSection"><h2 id="section085643405116">Trace打点信息说明<i class="anchor-icon anchor-icon-link" anchorid="section085643405116" tips="复制节点链接"></i></h2><p>HarmonyOS的DFX子系统提供了为应用框架以及系统底座核心模块的性能打点能力，每一处打点即是一个Trace，其上附带了记录执行时间、运行时格式化数据、进程或线程信息等。开发者可以使用DevEco Studio的Frame对Trace进行解析，并在其绘制的泳道图中识别关键渲染流程。</p> </div> <div class="tiledSection"><h3 id="section13319134113204" class="firsth2">线程状态转化流程<i class="anchor-icon anchor-icon-link" anchorid="section13319134113204" tips="复制节点链接"></i></h3><p>在HarmonyOS中，Trace记录的线程状态主要分为运行中（Running）、可运行（Runnable）、休眠中（Sleep）、IO阻塞下不可中断的睡眠态（Uninterruptible Sleep - IO）、不可中断的睡眠态（Uninterruptible Sleep - non IO）。其状态转化图如下：</p> <div class="fignone"><span class="figcap"><b>图1 </b>线程状态转化图</span><p><span><img originheight="586" originwidth="777" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163359.41154418283614926568541160282768:50001231000000:2800:12C27A718EF62D71FB63F9C0CB5F354CDF186F9D4D716FF0F2E394D2E818D2D2.png" width="777" height="586"></span></p> </div> </div> <div class="tiledSection"><h3 id="section743617229013">通过Trace点位信息识别线程状态<i class="anchor-icon anchor-icon-link" anchorid="section743617229013" tips="复制节点链接"></i></h3><p>Trace 会用不同的颜色来标识不同的线程状态，在每个方法上面都会有对应的线程状态来标识目前线程所处的状态，通过查看线程状态可以分析出当前的性能瓶颈。</p> <p><strong>（1）运行中（Running）</strong></p> <p><span><img height="395.3558" originheight="650" originwidth="1312" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163359.91927785850876632490594677927804:50001231000000:2800:DE5C26D2E6CE8E9EA0094E77633A80FD76AE10D7F4F93B9783AA48DF2005FE10.png" title="点击放大" width="798"></span></p> <p>运行中（Running）表示处于该状态的线程才可能在CPU上运行。同一时刻可能有多个线程处于可执行状态，这些线程的task_struct结构被放入对应CPU的可执行队列中，每个线程最多出现在一个CPU的可执行队列中。调度器从各个CPU的可执行队列中选择一个线程在该CPU上运行。</p> <p><strong>（2）可运行（Runnable）</strong></p> <p><span><img height="374.9004" originheight="420" originwidth="894" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163359.78082925574789994383234666298217:50001231000000:2800:3D073405466D8610B0E97E5F6F9DB7FE01792D24A002D077CF15769E039061F5.png" title="点击放大" width="798"></span></p> <p>可运行（Runnable）表示线程可以运行但当前未被调度，在等待CPU。Runnable状态持续时间越长，说明CPU调度越忙，未能及时处理该任务。</p> <p><strong>（3）休眠中（Sleep）</strong></p> <p><span><img height="451.5616" originheight="524" originwidth="926" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163359.96176288079383218392161107750586:50001231000000:2800:6DD3AEAC7650C3904A17F033AC1B556405887423F3E411C19AF31564CFDE57EA.png" title="点击放大" width="798"></span></p> <p>休眠中（Sleep）表示线程没有工作，可能是因为在互斥锁上被阻塞，或在等待某些操作返回，通常是在等待事件驱动。</p> <p><strong>（4）IO阻塞下不可中断的睡眠态（Uninterruptible Sleep - IO）</strong></p> <p><span><img height="316.54" originheight="428" originwidth="1079" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163359.89027255954913550878558763543275:50001231000000:2800:E8C6609E84B3F0F8B06F435F72547DC8275398759B97699BA6C7483F412769B1.png" title="点击放大" width="798"></span></p> <p>IO阻塞下不可中断的睡眠态（Uninterruptible Sleep - IO）表示线程在I/O上被阻塞或等待磁盘操作完成。当系统处于低内存状态时，申请内存的时候可能会触发page fault，从而导致有大量的不可中断的睡眠态出现。在Linux系统的page cache链表中，有时会出现一些还没准备好的page(即还没把磁盘中的内容完全地读出来) ，而正好此时用户在访问这个page时就会出现page fault。</p> <p><strong>（5）不可中断的睡眠态（Uninterruptible Sleep - non IO）</strong></p> <p><span><img height="486.10170000000005" originheight="586" originwidth="962" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163359.37143213322283392561349855559596:50001231000000:2800:485DC0DF60392C787EC4227C5E7B70D3075EF034A361347DBE3AE31E14AF477F.png" title="点击放大" width="798"></span></p> <p>不可中断的睡眠态（Uninterruptible Sleep - non IO）表示线程在其他内核操作（如内存管理）上被阻塞。线程陷入内核态，有时是正常现象，有时则需要进一步分析。</p> </div> <div class="tiledSection"><h3 id="section1625893416218">渲染流程<i class="anchor-icon anchor-icon-link" anchorid="section1625893416218" tips="复制节点链接"></i></h3><p>在HarmonyOS中，图形系统采用统一渲染模式，遵循典型流水线模式。以60Hz刷新率为例，每个Vsync周期为16.7ms；90Hz时，每个Vsync周期为11.1ms；120Hz时，每个Vsync周期为8.3ms。</p> <div class="fignone"><span class="figcap"><b>图2 </b>90Hz刷新率渲染流程</span><br><span><img height="159.4382172143975" originheight="309" originwidth="1783" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163359.59979174379438758602728500826802:50001231000000:2800:6485FA025E0E71B212AE2711117D1A5A9A62EE79F7AE6849345BE76C22DCAAF3.png" title="点击放大" width="920"></span></div> <p>在整个渲染流程中，应用侧首先响应消费者的屏幕点击等输入事件，处理完成后提交给Render Service。Render Service协调GPU等资源处理，最终将图像送到屏幕上显示。</p> <ol><li>应用侧（App）处理用户的屏幕点击等输入事件，生成界面描述的数据结构。该数据结构包含UI元素的位置、大小、资源、绘制指令和动效属性。</li><li>Render Service（渲染服务部件）是图形栈中负责界面内容绘制的模块，主要职责是对接ArkUI框架，支撑ArkUI应用的界面显示，包括控件、动效等UI元素。Render Service 的 RenderThread 线程在 Vsync 信号下触发 UI 绘制，绘制过程包含三个阶段：动效、描画和提交。</li><li>Display是显示屏幕的抽象概念，可以是实际的物理屏也可以是虚拟屏。<p>其中应用侧的渲染流程如下图所示。了解ArkUI的渲染流程有助于定位应用侧的卡顿问题出现在哪个环节。</p> </li></ol> <div class="fignone"><span class="figcap"><b>图3 </b>ArkUI渲染管线结构与Frame Insight性能打点</span></div> <p><span><img height="232.41500000000002" originheight="433" originwidth="1714" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163359.25946421682030358402382813781198:50001231000000:2800:5DCD98476510EEC3AEEA08B1EF98E8B9D517212308C0C9FDC876A5ECD689B1C2.png" title="点击放大" width="920"></span></p> <ul><li>Animation：动画阶段，在动画过程中会修改相应的FrameNode节点触发脏区标记，在特定场景下会执行用户侧ets代码实现自定义动画；</li><li>Events：事件处理阶段，比如手势事件处理。在手势处理过程中也会修改FrameNode节点触发脏区标记，在特定场景下会执行用户侧ets代码实现自定义事件；</li><li>UpdateUI：自定义组件（@Component）在首次创建挂载或状态变量变更时会标记为需要重建状态。在下一次Vsync信号到来时，执行重建流程，生成相应的组件树结构和属性样式修改任务。</li><li>Measure：布局包装器执行相关的大小测算任务。</li><li>Layout：布局包装器执行相关的布局任务。</li><li>Render：绘制任务包装器执行相关的绘制任务，执行完成后会标记请求刷新RSNode绘制</li><li>SendMessage：请求更新界面绘制。</li></ul> <p>在整个处理流程中，应用侧和Render Service侧都可能出现卡顿，导致最终用户观察到丢帧。这两种情况分别称为AppDeadlineMissed和RenderDeadlineMissed。AppDeadlineMissed通常是由于应用逻辑处理代码不够高效导致的，而RenderDeadlineMissed则可能是因为界面结构过于复杂或GPU负载过大等原因引起的。这两个故障模型通过Frame模板可以直观地查看。相应的故障模型如下图所示。</p> <div class="fignone"><span class="figcap"><b>图4 </b>应用卡顿导致丢帧的故障模型</span><br><span><img height="168.77700000000002" originheight="309" originwidth="1461" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163400.78273242324482124922523736660526:50001231000000:2800:BE310FD374186FDCBCB1BEE8DE7CB8C2CA4FC237A4F646ADBF17012BEF387208.png" title="点击放大" width="798"></span></div> <div class="fignone"><span class="figcap"><b>图5 </b>Render Service卡顿导致丢帧的故障模型</span><br><span><img height="169.704675" originheight="309" originwidth="1462" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163400.75539938265320253540140473529561:50001231000000:2800:E07B07999D30FB33499365317FEFD8D3C5D97FADE81CF448A6A98C84E43BCE95.png" title="点击放大" width="802.9875000000001"></span></div> </div> <div class="tiledSection"><h3 id="section37510377239">通过Trace识别关键渲染流程<i class="anchor-icon anchor-icon-link" anchorid="section37510377239" tips="复制节点链接"></i></h3><p>一帧的渲染流程中的UI后端引擎的常用Trace的含义如下图所示：</p> <div class="fignone"><span class="figcap"><b>图6 </b>UI后端引擎渲染Trace泳道图</span><p><span><img height="203.86050000000003" originheight="468" originwidth="2112" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163400.05652698640299094944267066408609:50001231000000:2800:0CD2F3D1AF3305F0E5C72BBBB1B3FF4D4B41CBEA691EB88986DFBB764FDBDA5E.png" title="点击放大" width="920"></span></p> </div> <p>各部分介绍见下表：</p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><caption><b>表1 </b>常见Trace说明表</caption><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.10.5.2.5.1.1" valign="top" width="6.856695072974828%"><p>序号</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.10.5.2.5.1.2" valign="top" width="23.988637476736216%"><p>Trace</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.10.5.2.5.1.3" valign="top" width="26.848858850034286%"><p>参数说明</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.10.5.2.5.1.4" valign="top" width="42.30580860025468%"><p>描述</p> </th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="6.856695072974828%"><p>1</p> </td> <td class="cellrowborder" valign="top" width="23.988637476736216%"><p>OnVsyncEvent now:%" PRIu64 "</p> </td> <td class="cellrowborder" valign="top" width="26.848858850034286%"><p>当前时间戳--纳秒级</p> </td> <td class="cellrowborder" valign="top" width="42.30580860025468%"><p>收到Vsync信号，渲染流程开始</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="6.856695072974828%"><p>2</p> </td> <td class="cellrowborder" valign="top" width="23.988637476736216%"><p>FlushVsync</p> </td> <td class="cellrowborder" valign="top" width="26.848858850034286%">&nbsp;&nbsp;</td> <td class="cellrowborder" valign="top" width="42.30580860025468%"><p>刷新视图同步事件，包括记录帧信息、刷新任务、绘制渲染上下文、处理用户输入</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="6.856695072974828%"><p>3</p> </td> <td class="cellrowborder" valign="top" width="23.988637476736216%"><p>UITaskScheduler::FlushTask</p> </td> <td class="cellrowborder" valign="top" width="26.848858850034286%">&nbsp;&nbsp;</td> <td class="cellrowborder" valign="top" width="42.30580860025468%"><p>刷新UI界面，包括布局、渲染和动画等</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="6.856695072974828%"><p>4</p> </td> <td class="cellrowborder" valign="top" width="23.988637476736216%"><p>FlushMessages</p> </td> <td class="cellrowborder" valign="top" width="26.848858850034286%">&nbsp;&nbsp;</td> <td class="cellrowborder" valign="top" width="42.30580860025468%"><p>发送消息通知图形侧进行渲染</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="6.856695072974828%"><p>5</p> </td> <td class="cellrowborder" valign="top" width="23.988637476736216%"><p>FlushLayoutTask</p> </td> <td class="cellrowborder" valign="top" width="26.848858850034286%">&nbsp;&nbsp;</td> <td class="cellrowborder" valign="top" width="42.30580860025468%"><p>执行布局任务</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="6.856695072974828%"><p>6</p> </td> <td class="cellrowborder" valign="top" width="23.988637476736216%"><p>FlushRenderTask %zu</p> </td> <td class="cellrowborder" valign="top" width="26.848858850034286%"><p>当前页面上的需要渲染的节点的数量</p> </td> <td class="cellrowborder" valign="top" width="42.30580860025468%"><p>总渲染任务执行</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="6.856695072974828%"><p>7</p> </td> <td class="cellrowborder" valign="top" width="23.988637476736216%"><p>Layout</p> </td> <td class="cellrowborder" valign="top" width="26.848858850034286%">&nbsp;&nbsp;</td> <td class="cellrowborder" valign="top" width="42.30580860025468%"><p>节点布局</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="6.856695072974828%"><p>8</p> </td> <td class="cellrowborder" valign="top" width="23.988637476736216%"><p>FrameNode::RenderTask</p> </td> <td class="cellrowborder" valign="top" width="26.848858850034286%">&nbsp;&nbsp;</td> <td class="cellrowborder" valign="top" width="42.30580860025468%"><p>单个渲染任务执行</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="6.856695072974828%"><p>9</p> </td> <td class="cellrowborder" valign="top" width="23.988637476736216%"><p>ListLayoutAlgorithm::MeasureListItem:%d</p> </td> <td class="cellrowborder" valign="top" width="26.848858850034286%"><p>当前列表项索引</p> </td> <td class="cellrowborder" valign="top" width="42.30580860025468%"><p>计算列表项的布局尺寸</p> </td> </tr>  </tbody></table></div> </div> <p>图形图像子系统中的Render Service负责界面内容的绘制，处理各应用提交的统一渲染任务，将不同应用的图层合并并送显。每个Vsync周期，Render Service首先处理应用提交的指令，包括渲染树节点的新增、删除和修改，然后进行动画计算和遮挡计算，以更新统一渲染树。接下来，对渲染树执行绘制，预处理每个节点，计算绝对位置和脏区信息，针对脏区进行绘制。优先使用硬件合成器绘制，无法合成时交由GPU执行重绘，所有结果存入屏幕缓冲区，最后提交送显并展示。</p> <p>Vsync信号刷新时的Trace泳道图如下所示。</p> <div class="fignone"><span class="figcap"><b>图7 </b>RS侧渲染Trace泳道图</span></div> <p><span><img height="214.843" originheight="489" originwidth="2094" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163400.25523558985180381314741752633492:50001231000000:2800:3094B38516750C17CA4E6FF45D5A5AEB3E6B77105CB980074D9B7EF7B222BC41.png" title="点击放大" width="920"></span></p> <p>各部分介绍如下表：</p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><caption><b>表2 </b>Render Service侧渲染Trace说明表</caption><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.10.11.2.4.1.1" valign="top" width="5.404040404040404%"><p>序号</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.10.11.2.4.1.2" valign="top" width="47.90909090909091%"><p>Trace</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.10.11.2.4.1.3" valign="top" width="46.686868686868685%"><p>描述</p> </th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="5.404040404040404%"><p>1</p> </td> <td class="cellrowborder" valign="top" width="47.90909090909091%"><p>RSMainThread::DoComposition</p> </td> <td class="cellrowborder" valign="top" width="46.686868686868685%"><p>合成渲染树上各节点图层</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="5.404040404040404%"><p>2</p> </td> <td class="cellrowborder" valign="top" width="47.90909090909091%"><p>RSMainThread::ProcessCommand</p> </td> <td class="cellrowborder" valign="top" width="46.686868686868685%"><p>处理应用侧指令</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="5.404040404040404%"><p>3</p> </td> <td class="cellrowborder" valign="top" width="47.90909090909091%"><p>Animate</p> </td> <td class="cellrowborder" valign="top" width="46.686868686868685%"><p>动画处理</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="5.404040404040404%"><p>4</p> </td> <td class="cellrowborder" valign="top" width="47.90909090909091%"><p>ProcessDisplayRenderNode[x]</p> </td> <td class="cellrowborder" valign="top" width="46.686868686868685%"><p>单个显示器画面的绘制流程</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="5.404040404040404%"><p>5</p> </td> <td class="cellrowborder" valign="top" width="47.90909090909091%"><p>Repaint</p> </td> <td class="cellrowborder" valign="top" width="46.686868686868685%"><p>硬件合成器绘制</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="5.404040404040404%"><p>6</p> </td> <td class="cellrowborder" valign="top" width="47.90909090909091%"><p>RenderFrame</p> </td> <td class="cellrowborder" valign="top" width="46.686868686868685%"><p>GPU执行绘制</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="5.404040404040404%"><p>7</p> </td> <td class="cellrowborder" valign="top" width="47.90909090909091%"><p>SwapBuffers</p> </td> <td class="cellrowborder" valign="top" width="46.686868686868685%"><p>刷新屏幕缓冲区</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="5.404040404040404%"><p>8</p> </td> <td class="cellrowborder" valign="top" width="47.90909090909091%"><p>Commit</p> </td> <td class="cellrowborder" valign="top" width="46.686868686868685%"><p>绘制结果提交上屏</p> </td> </tr>  </tbody></table></div> </div> </div> <div class="tiledSection"><h3 id="section1588117331934">通过Trace识别懒加载渲染流程<i class="anchor-icon anchor-icon-link" anchorid="section1588117331934" tips="复制节点链接"></i></h3><p>懒加载使用LazyForEach实现。LazyForEach 从提供的数据源中按需迭代数据，并在每次迭代过程中创建相应组件。当LazyForEach在滚动容器中使用时，框架会根据滚动容器的可视区域按需创建组件。当组件滑出可视区域时，框架会销毁组件以降低内存占用。</p> <p>下图展示了懒加载过程中一帧的Trace泳道图。</p> <p><span><img height="147.3495" originheight="349" originwidth="2179" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163400.82083141607975284348492530498872:50001231000000:2800:9EEF250D16FA00C3A4B54FDC1A98CB8B0F4E24C5BD951AF41980C84484036CF0.png" title="点击放大" width="920"></span></p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.11.5.1.5.1.1" valign="top" width="6.7685375648937205%"><p>序号</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.11.5.1.5.1.2" valign="top" width="28.925457929278085%"><p>Trace</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.11.5.1.5.1.3" valign="top" width="32.324419629738465%"><p>参数说明</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.11.5.1.5.1.4" valign="top" width="31.98158487608972%"><p>描述</p> </th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="6.7685375648937205%"><p>1</p> </td> <td class="cellrowborder" valign="top" width="28.925457929278085%"><p>OnIdle, targettime:%" PRId64 "</p> </td> <td class="cellrowborder" valign="top" width="32.324419629738465%"><p>时间戳，在这个时间之前完成该任务</p> </td> <td class="cellrowborder" valign="top" width="31.98158487608972%"><p>在idle事件循环中，框架会检查是否有新的事件需要处理。如果有新的事件，任务调度器会被加入到UI线程中，并执行预测任务。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="6.7685375648937205%"><p>2</p> </td> <td class="cellrowborder" valign="top" width="28.925457929278085%"><p>Builder:BuildLazyItem [%d]</p> </td> <td class="cellrowborder" valign="top" width="32.324419629738465%"><p>需创建的项目索引</p> </td> <td class="cellrowborder" valign="top" width="31.98158487608972%"><p>在需要时创建项，并将其缓存。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="6.7685375648937205%"><p>3</p> </td> <td class="cellrowborder" valign="top" width="28.925457929278085%"><p>CustomNode:BuildRecycle %s</p> </td> <td class="cellrowborder" valign="top" width="32.324419629738465%"><p>JS视图名称</p> </td> <td class="cellrowborder" valign="top" width="31.98158487608972%"><p>触发重用渲染</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="6.7685375648937205%"><p>4</p> </td> <td class="cellrowborder" valign="top" width="28.925457929278085%"><p>ExecuteJS</p> </td> <td class="cellrowborder" valign="top" width="32.324419629738465%">&nbsp;&nbsp;</td> <td class="cellrowborder" valign="top" width="31.98158487608972%"><p>执行JS代码操作。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="6.7685375648937205%"><p>5</p> </td> <td class="cellrowborder" valign="top" width="28.925457929278085%"><p>List predict</p> </td> <td class="cellrowborder" valign="top" width="32.324419629738465%">&nbsp;&nbsp;</td> <td class="cellrowborder" valign="top" width="31.98158487608972%"><p>添加预测布局任务操作。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="6.7685375648937205%"><p>6</p> </td> <td class="cellrowborder" valign="top" width="28.925457929278085%"><p>Layout</p> </td> <td class="cellrowborder" valign="top" width="32.324419629738465%">&nbsp;&nbsp;</td> <td class="cellrowborder" valign="top" width="31.98158487608972%"><p>完成当前帧节点的布局。</p> </td> </tr>  </tbody></table></div> </div> </div> <div class="tiledSection"><h3 id="section553130162512">添加自定义Trace信息<i class="anchor-icon anchor-icon-link" anchorid="section553130162512" tips="复制节点链接"></i></h3><p>开发者可以根据业务需求，使用HiTraceMeter进行自定义Trace打点跟踪，具体使用细节可参考<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/hitracemeter-guidelines-arkts" target="_blank">《使用HiTraceMeter跟踪性能（ArkTS/JS）》</a>和<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/hitracemeter-guidelines-ndk" target="_blank">《使用HiTraceMeter跟踪性能（C/C++）》</a>。</p> <p>添加自定义Trace后，可在SmartPerf-Host调试工具上查看。自定义Trace将以独立泳道的形式呈现在对应进程下。下图展示了两条泳道，使用了startTrace和finishTrace方法，表示程序运行过程中指定标签从调用startTrace到调用finishTrace的耗时统计。图中记录了CUSTOM_TRACE_TAG_1和CUSTOM_TRACE_TAG_2两个标签的耗时统计。</p> <p>自定义Trace示例：</p> <p><span><img height="94.7093" originheight="127" originwidth="1070" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163400.57355509886736043594581523969659:50001231000000:2800:301F6D5D8F9828B20A994FBB09528834517E25DB34E1A402C683D94D98B227BE.png" title="点击放大" width="798"></span></p> <p>自定义状态值示例：</p> <p><span><img height="107.2778" originheight="146" originwidth="1086" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163400.56173055033336022234730722603279:50001231000000:2800:23E1DB6D96C6F88A0DAEB7206597D5D02D479E4FCEA441221ED7573F088815E7.png" title="点击放大" width="798"></span></p> </div> </div> <div></div></div>