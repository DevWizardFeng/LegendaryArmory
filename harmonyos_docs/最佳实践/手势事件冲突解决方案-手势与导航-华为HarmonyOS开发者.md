<h1 _ngcontent-jev-c119="" class="doc-title ng-star-inserted" title="手势事件冲突解决方案"> 手势事件冲突解决方案 </h1>

<div _ngcontent-jev-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;"> <div><div class="tiledSection"><h2 id="section1481110518309">概述<i class="anchor-icon anchor-icon-link" anchorid="section1481110518309" tips="复制节点链接"></i></h2><p>在复杂的应用界面中，多个组件嵌套时同时绑定手势事件，或者同一个组件同时绑定多个手势，都有可能导致手势事件产生冲突，达不到用户的预期效果。</p> <p>本文从事件响应的机制入手，介绍手势触发的基本流程，以及如何响应手势事件，了解背后的执行原理，并用来解决冲突问题等。主要包括以下内容：</p> <ul><li>事件响应链收集</li><li>手势响应优先级</li><li>手势响应控制</li><li>常见手势冲突问题</li></ul> </div> <div class="tiledSection"><h2 id="section2407326173013">事件响应链收集<i class="anchor-icon anchor-icon-link" anchorid="section2407326173013" tips="复制节点链接"></i></h2><p>在HarmonyOS开发中，<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-touch" target="_blank">触摸事件</a>（onTouch事件）是用户与设备交互的基础，是所有手势事件组成的基础，有Down，Move，Up，Cancel四种<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-appendix-enums#touchtype" target="_blank">触摸事件的类型</a>。手势均由触摸事件组成，例如，点击为Down+Up，滑动为Down+一系列Move+Up。</p> <p>触摸事件的分发由触摸测试（TouchTest）结果决定，其结果会直接决定哪些控件的事件加入事件响应链（事件响应成员组成的链表），并最终按照响应链顺序判定是否消费。因此了解触摸事件的响应链收集过程，有助于开发者处理手势事件冲突问题。</p> <p>ArkUI事件响应链收集，根据右子树（按组件布局的先后层级）优先的后序遍历流程。下面通过一个示例来介绍响应链收集的流程，示例伪代码如下：</p> <div class="screenLinkPre"><div _ngcontent-jev-c106="" class="highlight-div"><div _ngcontent-jev-c106="" class="highlight-div-header"><div _ngcontent-jev-c106="" class="highlight-div-header-left"><div _ngcontent-jev-c106="" class="handle-button expand-button"><div _ngcontent-jev-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-jev-c106="" class="highlight-div-header-right"><div _ngcontent-jev-c106="" class="handle-button ai-button"></div><div _ngcontent-jev-c106="" class="handle-button line-button"><div _ngcontent-jev-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-jev-c106="" class="handle-button theme-button"><div _ngcontent-jev-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-jev-c106="" class="handle-button copy-button"><div _ngcontent-jev-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-jev-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-scss" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/GesturesConfictPractice/entry/src/main/ets/pages/TestCode.ets#L8-L18" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-built_in">build</span>() {</li><li>  <span class="hljs-built_in">StackA</span>() {</li><li>    <span class="hljs-built_in">ComponentB</span>() {</li><li>      <span class="hljs-built_in">ComponentC</span>()</li><li>    }</li><li>
</li><li>    <span class="hljs-built_in">ComponentD</span>() {</li><li>      <span class="hljs-built_in">ComponentE</span>()</li><li>    }</li><li>  }</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/GesturesConfictPractice/entry/src/main/ets/pages/TestCode.ets#L8-L18" target="_blank">TestCode.ets</a></div></div></div></div> <p>其中A是最外层组件，B和D是A的子组件，C是B的子组件，E是D的子组件。界面效果示例以及组件树结构图如下：</p> <p><span><img height="288.0248" originheight="560" originwidth="1086" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211162944.85422891593051008795388910574218:50001231000000:2800:10E506D3079B441EA1332E388B01B2E4C833EF427F4E27D3A22411F12578A3FC.png" title="点击放大" width="558.6"></span></p> <p>用户触摸的动作如果发生在组件C上，事件响应链收集的流程如下，根据右子树（按组件布局的先后层级）优先的后序遍历流程，因为触摸点不在右边的树上，所以事件会从左边树的C节点开始往上传，触摸事件（onTouch事件）是冒泡事件默认会向上一直传递下去，直到被消费或者丢弃，允许多个组件同时触发。最终收集到的响应链是C-&gt;B-&gt;A。</p> <p><span><img height="285.5111" originheight="585" originwidth="1090" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211162944.21629031713813099958509358129570:50001231000000:2800:3082826EA21A5AB65BEB416E9ED98378C72284610CF5ECCFEEED1BFBBDB87D81.png" title="点击放大" width="558.6"></span></p> <p>用户触摸的动作如果发生在组件E上，事件响应链收集的流程如下，根据右子树优先的后序遍历流程，所以事件会从右边树的D节点开始往上传。虽然触摸点在组件D和组件B的交集上，但组件D的<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-hit-test-behavior" target="_blank">hitTestBehavior</a>属性默认为HitTestMode.Default，D组件收集到事件后会阻塞兄弟节点（组件B），所以没有收集组件A的左子树，最终收集到的响应链是E-&gt;D-&gt;A。</p> <p><span><img height="279.5527" originheight="567" originwidth="1079" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211162944.54720286944653173946979969513070:50001231000000:2800:8C5ADB2E0702AAB51E52BB666A96EFB04CC1E8C55C603DF1CE62395CF53F88C1.png" title="点击放大" width="558.6"></span></p> <p>上面介绍的事件响应链是系统默认的行为，如果需要改变响应的成员，比如触摸组件E的时候，希望把事件传递给B，该怎么实现呢？开发者可以通过设置D组件的hitTestMode属性为HitTestMode.None或者HitTestMode.Transparent来实现，比如设置为HitTestMode.Transparent，那么组件D自身进行触摸测试，同时不阻塞兄弟及父组件。最终收集到的响应链是E-&gt;D-&gt;B-&gt;A。</p> <p><span><img height="283.3033" originheight="567" originwidth="1118" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211162944.38206296907058840992622783568109:50001231000000:2800:615B0262C340DB7E6E8D3E48F5F0DBA31BD23DDE7FA9549B4D260890F01B827C.png" title="点击放大" width="558.6"></span></p> <p>又例如触摸E组件的时候，只希望E响应触摸事件，不让其它组件响应触摸事件。可以通过<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-events-touch#touchevent对象说明" target="_blank">stopPropagation</a>来阻止事件冒泡，阻止触摸事件往上传递；也可以通过设置E组件的hitTestMode属性为HitTestMode.Block来实现，那么最终收集到的响应链成员只有组件E。</p> <p><span><img height="294.5418" originheight="570" originwidth="1081" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211162944.42240032201263506484919910607598:50001231000000:2800:92487C43598E21EBD322824E2CF7052E8A0CE4F56A6C5C7AF7A73B692951067F.png" title="点击放大" width="558.6"></span></p> <p>除了hitTestMode和stopPropagation，影响事件响应链的更多因素可以参考：<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-hit-test-behavior" target="_blank">触摸测试控制</a>。</p> </div> <div class="tiledSection"><h2 id="section1355191323110">手势响应<i class="anchor-icon anchor-icon-link" anchorid="section1355191323110" tips="复制节点链接"></i></h2><p>前面根据事件响应链收集，确定了响应链成员和事件响应的顺序。然而往往在处理一些业务的时候，需要给组件/不同组件添加更多的手势和事件，比如onClick、API手势gesture 等等，那么哪个事件会得到响应呢？这就需要了解手势响应的优先级了，本节将主要介绍手势的优先级和手势的控制。</p> </div> <div class="tiledSection"><h3 id="section45621638193111" class="firsth2">手势响应优先级<i class="anchor-icon anchor-icon-link" anchorid="section45621638193111" tips="复制节点链接"></i></h3><p>手势按是否为系统手势，可以分为以下两类：</p> <ul><li>系统手势：系统控件默认实现的手势（系统内置手势），即调用某些通用事件内置的手势，比如拖拽，onClick；比如bindMenu内置的点击事件，bindContextMenu内置的长按手势。</li><li>自定义手势：通过绑定手势API，例如使用gesture声明的事件回调，绑定长按手势事件方法。</li></ul> <p>除了触摸事件（onTouch事件）外的所有手势与事件，均是通过基础手势或者组合手势实现的。例如，拖拽事件是由长按手势和滑动手势组成的一个顺序手势。</p> <p>在默认情况下，这些手势为非冒泡事件，当父组件和子组件绑定同类型的手势时，父子组件绑定的手势事件会发生竞争，子组件会优先识别绑定的手势。</p> <p>因此，除非显式声明允许多个手势同时成功，否则同一时间只会有一个手势响应。</p> <ol><li>当父子组件均绑定同一类手势时，子组件优先于父组件触发。</li><li>当同一个组件同时绑定多个手势时，先达到手势触发条件的手势优先触发。</li><li>当同一个组件绑定相同事件类型的系统手势和自定义手势时，系统手势会优先响应。比如自定义手势TapGesture和系统手势onClick都是单击事件，但是会优先响应onClick事件。</li></ol> <div class="fignone"><span class="figcap"><b>图1 </b>手势响应优先级（从左至右，优先级由高到低）</span></div> <p><span><img height="375.054015" originheight="477" originwidth="647" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211162944.65640749423639657355028787401097:50001231000000:2800:8C926676DD8FFBCFB170BA851E950F3C43AFC20D17F28B0DD8842157B9A27D04.png" title="点击放大" width="508.725"></span></p> </div> <div class="tiledSection"><h3 id="section23479595317">手势响应控制<i class="anchor-icon anchor-icon-link" anchorid="section23479595317" tips="复制节点链接"></i></h3><p>上面介绍了手势默认的优先级顺序，在父子组件嵌套时，父子组件均绑定了手势或事件，或者同一个组件同时绑定多个手势时，根据业务逻辑可能需要对手势是否需要响应、分发给谁响应、响应的顺序等做出控制。那么有哪些控制手段呢？下面列举了一些手势响应的控制方法。</p> <p>1 手势绑定</p> <p><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-gesture-events-binding" target="_blank"><strong>绑定手势方法</strong></a></p> <p>设置绑定手势的方法可以实现在多层级场景下，当父组件与子组件绑定了相同的手势时，设置不同的绑定手势方法有不同的响应优先级。手势绑定支持常规手势绑定方法（gesture）、带优先级手势绑定方法（priorityGesture）、并行手势绑定方法（parallelGesture）。</p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.5.6.1.6.1.1" valign="top" width="13.91860813918608%"><p>绑定手势方法</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.5.6.1.6.1.2" valign="top" width="45.33546645335467%"><p>功能规格</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.5.6.1.6.1.3" valign="top" width="14.1985801419858%"><p>配参1</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.5.6.1.6.1.4" valign="top" width="12.90870912908709%"><p>配参2</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.5.6.1.6.1.5" valign="top" width="13.638636136386362%"><p>约束</p> </th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="13.91860813918608%"><p>gesture</p> </td> <td class="cellrowborder" valign="top" width="45.33546645335467%"><p>绑定手势事件，父子组件交叠区域均绑定，响应子组件</p> </td> <td class="cellrowborder" valign="top" width="14.1985801419858%"><p>GestureType</p> </td> <td class="cellrowborder" valign="top" width="12.90870912908709%"><p>GestureMask</p> </td> <td class="cellrowborder" valign="top" width="13.638636136386362%"><p>与通用事件抢占</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="13.91860813918608%"><p>priorityGesture</p> </td> <td class="cellrowborder" valign="top" width="45.33546645335467%"><p>当父组件配置priorityGesture时，优先识别父组件priorityGesture绑定的手势。</p> </td> <td class="cellrowborder" valign="top" width="14.1985801419858%"><p>GestureType</p> </td> <td class="cellrowborder" valign="top" width="12.90870912908709%"><p>GestureMask</p> </td> <td class="cellrowborder" valign="top" width="13.638636136386362%"><p>与通用事件抢占</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="13.91860813918608%"><p>parallelGesture</p> </td> <td class="cellrowborder" valign="top" width="45.33546645335467%"><p>父组件绑定parallelGesture时，父子组件相同的手势事件都可以触发</p> </td> <td class="cellrowborder" valign="top" width="14.1985801419858%"><p>GestureType</p> </td> <td class="cellrowborder" valign="top" width="12.90870912908709%"><p>GestureMask</p> </td> <td class="cellrowborder" valign="top" width="13.638636136386362%"><p>无</p> </td> </tr>  </tbody></table></div> </div> <p>前面讲到的手势的优先级是默认的，在加入了priorityGesture和parallelGesture绑定方法后，手势的响应顺序如下图所示：</p> <div class="fignone"><span class="figcap"><b>图2 </b>手势响应优先级（从左至右，优先级由高到低）</span></div> <p><span><img height="367.63860000000005" originheight="765" originwidth="1107" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211162944.85156197960862337297788352936983:50001231000000:2800:FB4E0624895B03701F1E645A928084D7C1758EAE0A47DACB01E5A5E90812CF47.png" title="点击放大" width="532"></span></p> <p></p> <p><strong>GestureMask枚举说明</strong></p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.5.12.1.3.1.1" valign="top" width="50%"><p>名称</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.5.12.1.3.1.2" valign="top" width="50%"><p>描述</p> </th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="50%"><p>Normal</p> </td> <td class="cellrowborder" valign="top" width="50%"><p>不屏蔽子组件的手势，按照默认手势识别顺序进行识别。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="50%"><p>IgnoreInternal</p> </td> <td class="cellrowborder" valign="top" width="50%"><p>屏蔽子组件的手势，包括子组件上的系统内置的手势，如子组件为List组件时，内置的滑动手势同样会被屏蔽。 若父子组件区域存在部分重叠，则只会屏蔽父子组件重叠的部分。</p> </td> </tr>  </tbody></table></div> </div> <p><strong>不同手势绑定配参方案规格</strong></p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.5.14.1.6.1.1" valign="top" width="20%"><p>父手势</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.5.14.1.6.1.2" valign="top" width="20%"><p>子手势</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.5.14.1.6.1.3" valign="top" width="20%"><p>GestureMask（父）</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.5.14.1.6.1.4" valign="top" width="20%"><p>交叠区域相同事件响应方</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.5.14.1.6.1.5" valign="top" width="20%"><p>交叠区域不同事件响应方</p> </th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="20%"><p>gesture</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>gesture</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>default</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>子组件</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>各自响应</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="20%"><p>gesture</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>gesture</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>IgnoreInternal</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>父组件</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>父组件</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="20%"><p>priorityGesture</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>gesture</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>default</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>父组件</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>各自响应</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="20%"><p>priorityGesture</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>gesture</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>IgnoreInternal</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>父组件</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>父组件</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="20%"><p>parallelGesture</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>gesture</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>default</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>各自响应</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>各自响应</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="20%"><p>parallelGesture</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>gesture</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>IgnoreInternal</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>父组件</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>父组件</p> </td> </tr>  </tbody></table></div> </div> <p><strong><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-gesture-events-combined-gestures" target="_blank">组合手势</a>（GestureGroup）</strong></p> <p>手势组合是指多种手势组合为复合手势，通过GestureGroup属性，可以给同一个组件添加多个手势，支持连续识别、并行识别和互斥识别模式。开发者可以根据业务需求，选择合适的组合模式。</p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.5.17.1.5.1.1" valign="top" width="25%"><p>接口</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.5.17.1.5.1.2" valign="top" width="25%"><p>可选模式</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.5.17.1.5.1.3" valign="top" width="25%"><p>描述</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.5.17.1.5.1.4" valign="top" width="25%"><p>注册事件</p> </th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="25%"><p>GestureGroup</p> </td> <td class="cellrowborder" valign="top" width="25%"><p>Sequence</p> </td> <td class="cellrowborder" valign="top" width="25%"><p>手势顺序队列，需要按预定的手势组顺序执行，有一个失败则全部失败</p> </td> <td class="cellrowborder" valign="top" width="25%"><p>onCancel</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="25%"><p>GestureGroup</p> </td> <td class="cellrowborder" valign="top" width="25%"><p>Parallel</p> </td> <td class="cellrowborder" valign="top" width="25%"><p>手势组合，直到所有已识别的手势执行完</p> </td> <td class="cellrowborder" valign="top" width="25%"><p>无</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="25%"><p>GestureGroup</p> </td> <td class="cellrowborder" valign="top" width="25%"><p>Exclusive</p> </td> <td class="cellrowborder" valign="top" width="25%"><p>互斥识别，成功完成一个手势，则完成手势任务</p> </td> <td class="cellrowborder" valign="top" width="25%"><p>无</p> </td> </tr>  </tbody></table></div> </div> <p>2 <a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-monopolize-events" target="_blank">事件独占控制</a></p> <p>通过monopolizeEvents属性设置组件是否独占事件，事件范围包括组件自带的事件和开发者自定义的点击、触摸、手势事件。<span style="color: rgb(75,75,75);">先响应事件的控件作为第一响应者，</span><span style="color: rgb(64,64,64);">在手指离开屏幕前其他组件不会响应任何事件。</span></p> <p>在一个窗口内，设置了独占控制的组件上的事件如果首先响应，则本次交互只允许此组件上设置的事件响应，窗口内其他组件上的事件不会响应。</p> <p>如果开发者通过<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-gesture-settings#parallelgesture" target="_blank">parallelGesture</a>绑定了与子组件同时触发的手势，如<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-gestures-pangesture" target="_blank">PanGesture</a>，子组件设置了独占控制且首个响应事件，则父组件的手势不会响应。</p> <p>3 <a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-gesture-customize-judge" target="_blank">自定义手势判定</a></p> <p>为组件提供自定义手势判定能力。开发者可根据需要，在手势识别期间，根据自己的业务逻辑来决定是否响应手势。使用<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-gesture-customize-judge#ongesturejudgebegin" target="_blank">onGestureJudgeBegin</a>方法对手势进行判定，开发者可以根据自身业务逻辑，选择是否响应自定义手势。</p> <p>4 <a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-gesture-blocking-enhancement" target="_blank">手势拦截增强</a></p> <p>为组件提供手势拦截能力。开发者可根据需要，将系统内置手势和响应链上更高优先级的手势做并行化处理，并可以动态控制手势事件的触发。</p> <p>5 <a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-touch-target" target="_blank">responseRegion</a>和<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-hit-test-behavior" target="_blank">hitTestBehavior</a></p> <p><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-interaction-basic-principles#触摸测试" target="_blank">触摸测试</a>同样也可能会影响到手势的响应流程。例如responseRegion属性和hitTestBehavior属性可以控制Touch事件的分发，从而可以影响到onTouch事件和手势的响应。而绑定手势方法属性可以控制手势的竞争从而影响手势的响应，但不会影响到onTouch事件。</p> <p>6 ArkUI组件自身的属性控制手势响应</p> <p>ArkUI组件自身的属性，也可以对手势事件的响应做出控制。例如Grid、List、Scroll、Swiper、WaterFlow等滚动容器组件提供了nestedScroll属性，来解决和父组件的嵌套滚动的冲突问题；例如Swiper组件的<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-swiper#disableswipe8" target="_blank">disableSwipe</a>可以设置禁用组件滑动切换的功能；又例如List组件可以通过设置<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-list#enablescrollinteraction10" target="_blank">enableScrollInteraction</a>属性来设置是否支持手势滚动列表。</p> </div> <div class="tiledSection"><h2 id="section64941224332">常见手势冲突问题<i class="anchor-icon anchor-icon-link" anchorid="section64941224332" tips="复制节点链接"></i></h2><p>前面列举了一些常用的手势响应的控制方法，接下来我们通过这些方法来解决以下一些常见的手势响应冲突问题。</p> </div> <div class="tiledSection"><h3 id="section067562063312" class="firsth2">滚动容器嵌套滚动容器事件冲突<i class="anchor-icon anchor-icon-link" anchorid="section067562063312" tips="复制节点链接"></i></h3><p>1 Scroll组件嵌套List组件滑动事件冲<strong>突</strong></p> <p>Scroll组件嵌套List组件，子组件List组件的滑动手势优先级高于父组件Scroll的滑动手势，所以当List列表滚动时，不会响应Scroll组件的滚动事件，List不会和Scroll一起滚动。如果需要List和Scroll组件同步滚动可以使用nestedScroll属性来解决，设置向前向后两个方向上的嵌套滚动模式，实现与父组件的滚动联动。</p> <p>使用nestedScroll属性设置List组件的嵌套滚动方式，NestedScrollMode设置成SELF_FIRST时，List组件滚动到页面边缘后，父组件继续滚动。NestedScrollMode设置为PARENT_FIRST时，父组件先滚动，滚动至边缘后通知List组件继续滚动。示例代码如下：</p> <div class="screenLinkPre"><div _ngcontent-jev-c106="" class="highlight-div"><div _ngcontent-jev-c106="" class="highlight-div-header"><div _ngcontent-jev-c106="" class="highlight-div-header-left"><div _ngcontent-jev-c106="" class="handle-button expand-button"><div _ngcontent-jev-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-jev-c106="" class="highlight-div-header-right"><div _ngcontent-jev-c106="" class="handle-button ai-button"></div><div _ngcontent-jev-c106="" class="handle-button line-button"><div _ngcontent-jev-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-jev-c106="" class="handle-button theme-button"><div _ngcontent-jev-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-jev-c106="" class="handle-button copy-button"><div _ngcontent-jev-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-jev-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-cangjie" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/GesturesConfictPractice/entry/src/main/ets/pages/GesturesConflictScene1.ets#L17-L50" data-highlighted="yes"><ol class="linenums"><li>@<span class="hljs-title function_">Entry</span></li><li>@<span class="hljs-title function_">Component</span></li><li><span class="hljs-keyword">struct</span> <span class="hljs-title class_">GesturesConflictScene1</span> {</li><li>  <span class="hljs-title function_">build</span>() {</li><li>    <span class="hljs-title function_">Scroll</span>() {</li><li>      <span class="hljs-title function_">Column</span>() {</li><li>        <span class="hljs-title function_">Column</span>()</li><li>          .<span class="hljs-title function_">height</span>(<span class="hljs-string">'30%'</span>)</li><li>          .<span class="hljs-title function_">width</span>(<span class="hljs-string">'100%'</span>)</li><li>          .<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-variable">Color</span>.<span class="hljs-variable">Blue</span>)</li><li>        <span class="hljs-title function_">List</span>() {</li><li>          <span class="hljs-title function_">ForEach</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>], (<span class="hljs-variable">item</span>: <span class="hljs-title class_">string</span>) =&gt; {</li><li>            <span class="hljs-title function_">ListItem</span>() {</li><li>              <span class="hljs-title function_">Text</span>(<span class="hljs-variable">item</span>.<span class="hljs-title function_">toString</span>())</li><li>                .<span class="hljs-title function_">height</span>(<span class="hljs-number">300</span>)</li><li>                .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">50</span>)</li><li>                .<span class="hljs-title function_">fontWeight</span>(<span class="hljs-variable">FontWeight</span>.<span class="hljs-variable">Bold</span>)</li><li>            }</li><li>          }, (<span class="hljs-variable">item</span>: <span class="hljs-title class_">number</span>) =&gt; <span class="hljs-variable">item</span>.<span class="hljs-title function_">toString</span>())</li><li>        }</li><li>        .<span class="hljs-title function_">edgeEffect</span>(<span class="hljs-variable">EdgeEffect</span>.<span class="hljs-variable">None</span>)</li><li>        .<span class="hljs-title function_">nestedScroll</span>({</li><li>          <span class="hljs-variable">scrollForward</span>: <span class="hljs-title class_">NestedScrollMode</span>.<span class="hljs-title class_">PARENT_FIRST</span>,</li><li>          <span class="hljs-variable">scrollBackward</span>: <span class="hljs-title class_">NestedScrollMode</span>.<span class="hljs-title class_">SELF_FIRST</span></li><li>        })</li><li>        .<span class="hljs-title function_">height</span>(<span class="hljs-string">'100%'</span>)</li><li>        .<span class="hljs-title function_">width</span>(<span class="hljs-string">'100%'</span>)</li><li>      }</li><li>    }</li><li>    .<span class="hljs-title function_">height</span>(<span class="hljs-string">'100%'</span>)</li><li>    .<span class="hljs-title function_">width</span>(<span class="hljs-string">'100%'</span>)</li><li>  }</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/GesturesConfictPractice/entry/src/main/ets/pages/GesturesConflictScene1.ets#L17-L50" target="_blank">GesturesConflictScene1.ets</a></div></div></div></div> <p>2 List、Scroller等滚动容器嵌套Web组件，滑动事件冲突</p> <p>比如List组件嵌套Web组件，当Web加载的网页中也包含滚动视图的时候，这时候上下滚动Web组件，不能和List列表整体一起滑动。这是因为Web的滑动事件和List组件的冲突，如果想让Web随List一起整体滚动，解决方案和前面的例子一样，给Web组件添加nestedScroll属性。</p> <div class="screenLinkPre"><div _ngcontent-jev-c106="" class="highlight-div"><div _ngcontent-jev-c106="" class="highlight-div-header"><div _ngcontent-jev-c106="" class="highlight-div-header-left"><div _ngcontent-jev-c106="" class="handle-button expand-button"><div _ngcontent-jev-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-jev-c106="" class="highlight-div-header-right"><div _ngcontent-jev-c106="" class="handle-button ai-button"></div><div _ngcontent-jev-c106="" class="handle-button line-button"><div _ngcontent-jev-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-jev-c106="" class="handle-button theme-button"><div _ngcontent-jev-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-jev-c106="" class="handle-button copy-button"><div _ngcontent-jev-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-jev-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-cangjie" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/GesturesConfictPractice/entry/src/main/ets/pages/TestCode.ets#L28-L36" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-title function_">Web</span>(</li><li>  <span class="hljs-comment">// ...</span></li><li>)</li><li>  .<span class="hljs-title function_">nestedScroll</span>({</li><li>    <span class="hljs-variable">scrollForward</span>: <span class="hljs-title class_">NestedScrollMode</span>.<span class="hljs-title class_">PARENT_FIRST</span>,</li><li>    <span class="hljs-variable">scrollBackward</span>: <span class="hljs-title class_">NestedScrollMode</span>.<span class="hljs-title class_">SELF_FIRST</span></li><li>  })</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/GesturesConfictPractice/entry/src/main/ets/pages/TestCode.ets#L28-L36" target="_blank">TestCode.ets</a></div></div></div></div> <p>具体实现可以参考：<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/web-nested-scrolling" target="_blank">Web组件嵌套滚动</a>。</p> </div> <div class="tiledSection"><h3 id="section9426114410339">使用组合手势同时绑定多个同类型手势冲突<i class="anchor-icon anchor-icon-link" anchorid="section9426114410339" tips="复制节点链接"></i></h3><p>例如给组件同时设置单击和双击的点击手势TapGesture，按如下方式设置发现双击手势失效了，这是因为在互斥识别的组合手势中，手势会按声明的顺序进行识别，若有一个手势识别成功，则结束手势识别。因为单击手势放在了前面，所以当双击的时候会优先识别了单击手势，单击成功后后面的双击回调就不会执行了。</p> <div class="screenLinkPre"><div _ngcontent-jev-c106="" class="highlight-div"><div _ngcontent-jev-c106="" class="highlight-div-header"><div _ngcontent-jev-c106="" class="highlight-div-header-left"><div _ngcontent-jev-c106="" class="handle-button expand-button"><div _ngcontent-jev-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-jev-c106="" class="highlight-div-header-right"><div _ngcontent-jev-c106="" class="handle-button ai-button"></div><div _ngcontent-jev-c106="" class="handle-button line-button"><div _ngcontent-jev-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-jev-c106="" class="handle-button theme-button"><div _ngcontent-jev-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-jev-c106="" class="handle-button copy-button"><div _ngcontent-jev-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-jev-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-less" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/GesturesConfictPractice/entry/src/main/ets/pages/GesturesConflictScene2.ets#L17-L48" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-variable">@Entry</span></li><li><span class="hljs-variable">@Component</span></li><li>struct GesturesConflictScene2 {</li><li>  <span class="hljs-variable">@State</span> <span class="hljs-attribute">count1</span>: number = <span class="hljs-number">0</span>;</li><li>  <span class="hljs-variable">@State</span> <span class="hljs-attribute">count2</span>: number = <span class="hljs-number">0</span>;</li><li>
</li><li>  <span class="hljs-selector-tag">build</span>() {</li><li>    <span class="hljs-selector-tag">Column</span>() {</li><li>      <span class="hljs-selector-tag">Text</span>(<span class="hljs-string">'Exclusive gesture\n'</span> + <span class="hljs-string">'tapGesture count is 1:'</span> + this.count1 + <span class="hljs-string">'\ntapGesture count is 2:'</span> + this.count2 +</li><li>        <span class="hljs-string">'\n'</span>)</li><li>        <span class="hljs-selector-class">.fontSize</span>(<span class="hljs-number">28</span>)</li><li>    }</li><li>    <span class="hljs-selector-class">.height</span>(<span class="hljs-number">200</span>)</li><li>    <span class="hljs-selector-class">.width</span>(<span class="hljs-string">'100%'</span>)</li><li>    <span class="hljs-comment">// The following gestures are mutually exclusive. After the gesture is successfully recognized, the gesture cannot be recognized by double-clicking</span></li><li>    <span class="hljs-selector-class">.gesture</span>(</li><li>      <span class="hljs-built_in">GestureGroup</span>(GestureMode.Exclusive,</li><li>        <span class="hljs-built_in">TapGesture</span>({ <span class="hljs-attribute">count</span>: <span class="hljs-number">1</span> })</li><li>          .<span class="hljs-built_in">onAction</span>(() =&gt; {</li><li>            this.count1++;</li><li>          }),</li><li>        <span class="hljs-built_in">TapGesture</span>({ <span class="hljs-attribute">count</span>: <span class="hljs-number">2</span> })</li><li>          .<span class="hljs-built_in">onAction</span>(() =&gt; {</li><li>            this.count2++;</li><li>          })</li><li>      )</li><li>    )</li><li>  }</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/GesturesConfictPractice/entry/src/main/ets/pages/GesturesConflictScene2.ets#L17-L48" target="_blank">GesturesConflictScene2.ets</a></div></div></div></div> <p>可以设置手势为并行识别来解决，设置对应的GestureMode为Parallel：</p> <div class="screenLinkPre"><div _ngcontent-jev-c106="" class="highlight-div"><div _ngcontent-jev-c106="" class="highlight-div-header"><div _ngcontent-jev-c106="" class="highlight-div-header-left"><div _ngcontent-jev-c106="" class="handle-button expand-button"><div _ngcontent-jev-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-jev-c106="" class="highlight-div-header-right"><div _ngcontent-jev-c106="" class="handle-button ai-button"></div><div _ngcontent-jev-c106="" class="handle-button line-button"><div _ngcontent-jev-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-jev-c106="" class="handle-button theme-button"><div _ngcontent-jev-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-jev-c106="" class="handle-button copy-button"><div _ngcontent-jev-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-jev-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-less" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/GesturesConfictPractice/entry/src/main/ets/pages/GesturesConflictScene2A.ets#L31-L42" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-selector-class">.gesture</span>(</li><li>  <span class="hljs-built_in">GestureGroup</span>(GestureMode.Parallel,</li><li>    <span class="hljs-built_in">TapGesture</span>({ <span class="hljs-attribute">count</span>: <span class="hljs-number">2</span> })</li><li>      .<span class="hljs-built_in">onAction</span>(() =&gt; {</li><li>        this.count2++;</li><li>      }),</li><li>    <span class="hljs-built_in">TapGesture</span>({ <span class="hljs-attribute">count</span>: <span class="hljs-number">1</span> })</li><li>      .<span class="hljs-built_in">onAction</span>(() =&gt; {</li><li>        this.count1++;</li><li>      })</li><li>  )</li><li>)</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/GesturesConfictPractice/entry/src/main/ets/pages/GesturesConflictScene2A.ets#L31-L42" target="_blank">GesturesConflictScene2A.ets</a></div></div></div></div> </div> <div class="tiledSection"><h3 id="section12601118143411">系统手势和自定义手势之间冲突<i class="anchor-icon anchor-icon-link" anchorid="section12601118143411" tips="复制节点链接"></i></h3><p>对于一般同类型的手势，系统手势优先于自定义手势执行，可以通过priorityGesture或者parallelGesture的方式来绑定自定义手势<strong>，</strong>例如下面这个示例<strong>：</strong></p> <p>图片长按手势响应失败或冲突，在Image控件上添加长按手势后，长按图片无法响应对应方法，而是图片放大的动画，示例代码如下：</p> <div class="screenLinkPre"><div _ngcontent-jev-c106="" class="highlight-div"><div _ngcontent-jev-c106="" class="highlight-div-header"><div _ngcontent-jev-c106="" class="highlight-div-header-left"><div _ngcontent-jev-c106="" class="handle-button expand-button"><div _ngcontent-jev-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-jev-c106="" class="highlight-div-header-right"><div _ngcontent-jev-c106="" class="handle-button ai-button"></div><div _ngcontent-jev-c106="" class="handle-button line-button"><div _ngcontent-jev-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-jev-c106="" class="handle-button theme-button"><div _ngcontent-jev-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-jev-c106="" class="handle-button copy-button"><div _ngcontent-jev-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-jev-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-less" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/GesturesConfictPractice/entry/src/main/ets/pages/GesturesConflictScene3.ets#L18-L47" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-variable">@Entry</span></li><li><span class="hljs-variable">@Component</span></li><li>struct GesturesConflictScene3 {</li><li>  <span class="hljs-variable">@State</span> <span class="hljs-attribute">message</span>: string = <span class="hljs-string">'Hello World'</span>;</li><li>
</li><li>  <span class="hljs-selector-tag">build</span>() {</li><li>    <span class="hljs-selector-tag">Row</span>() {</li><li>      <span class="hljs-selector-tag">Column</span>() {</li><li>        <span class="hljs-selector-tag">Text</span>(this.message)</li><li>          <span class="hljs-selector-class">.fontSize</span>(<span class="hljs-number">50</span>)</li><li>          <span class="hljs-selector-class">.fontWeight</span>(FontWeight.Bold)</li><li>        <span class="hljs-selector-tag">Image</span>($<span class="hljs-built_in">r</span>(<span class="hljs-string">'app.media.startIcon'</span>))</li><li>          <span class="hljs-selector-class">.margin</span>({ <span class="hljs-attribute">top</span>: <span class="hljs-number">100</span> })</li><li>          <span class="hljs-selector-class">.width</span>(<span class="hljs-number">360</span>)</li><li>          <span class="hljs-selector-class">.height</span>(<span class="hljs-number">360</span>)</li><li>          <span class="hljs-selector-class">.gesture</span>(</li><li>            <span class="hljs-built_in">LongPressGesture</span>({ <span class="hljs-attribute">repeat</span>: true })</li><li>              .<span class="hljs-built_in">onAction</span>((<span class="hljs-attribute">event</span>: GestureEvent) =&gt; {</li><li>              })<span class="hljs-comment">// The long press action ends</span></li><li>              .<span class="hljs-built_in">onActionEnd</span>(() =&gt; {</li><li>                this.<span class="hljs-built_in">getUIContext</span>().<span class="hljs-built_in">getPromptAction</span>().<span class="hljs-built_in">showToast</span>({ <span class="hljs-attribute">message</span>: <span class="hljs-string">'Long Press'</span> });</li><li>              })</li><li>          )</li><li>      }</li><li>      .<span class="hljs-built_in">width</span>(<span class="hljs-string">'100%'</span>)</li><li>    }</li><li>    .<span class="hljs-built_in">height</span>(<span class="hljs-string">'100%'</span>)</li><li>  }</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/GesturesConfictPractice/entry/src/main/ets/pages/GesturesConflictScene3.ets#L18-L47" target="_blank">GesturesConflictScene3.ets</a></div></div></div></div> <p>这是因为Image组件内置的长按动画和用户自定义的长按手势LongPressGesture冲突了。可以使用priorityGesture绑定手势的方式替代gesture的方式，这样就会只响应自定义手势LongPressGesture了。如果需要两者都执行可以使用parallelGesture的绑定方式。</p> <div class="screenLinkPre"><div _ngcontent-jev-c106="" class="highlight-div"><div _ngcontent-jev-c106="" class="highlight-div-header"><div _ngcontent-jev-c106="" class="highlight-div-header-left"><div _ngcontent-jev-c106="" class="handle-button expand-button"><div _ngcontent-jev-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-jev-c106="" class="highlight-div-header-right"><div _ngcontent-jev-c106="" class="handle-button ai-button"></div><div _ngcontent-jev-c106="" class="handle-button line-button"><div _ngcontent-jev-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-jev-c106="" class="handle-button theme-button"><div _ngcontent-jev-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-jev-c106="" class="handle-button copy-button"><div _ngcontent-jev-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-jev-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-less" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/GesturesConfictPractice/entry/src/main/ets/pages/GesturesConflictScene3A.ets#L32-L39" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-selector-class">.priorityGesture</span>(</li><li>  <span class="hljs-built_in">LongPressGesture</span>({ <span class="hljs-attribute">repeat</span>: true })</li><li>    .<span class="hljs-built_in">onAction</span>((<span class="hljs-attribute">event</span>: GestureEvent) =&gt; {</li><li>    })</li><li>    .<span class="hljs-built_in">onActionEnd</span>(() =&gt; {</li><li>      this.<span class="hljs-built_in">getUIContext</span>().<span class="hljs-built_in">getPromptAction</span>().<span class="hljs-built_in">showToast</span>({ <span class="hljs-attribute">message</span>: <span class="hljs-string">'Long Press'</span> });</li><li>    })</li><li>  )</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/GesturesConfictPractice/entry/src/main/ets/pages/GesturesConflictScene3A.ets#L32-L39" target="_blank">GesturesConflictScene3A.ets</a></div></div></div></div> </div> <div class="tiledSection"><h3 id="section10694115010342">手势事件透传<i class="anchor-icon anchor-icon-link" anchorid="section10694115010342" tips="复制节点链接"></i></h3><p>和触摸事件一样，手势事件也可以通过hitTestBehavior属性来进行透传，例如下面这个示例，上层的Column组件设置hitTestBehavior属性为hitTestMode.none后，可以将滑动手势SwipeGesture透传给被覆盖的Column组件。hitTestMode.none：自身不接收事件，但不会阻塞兄弟组件和子组件继续做触摸测试。</p> <div class="screenLinkPre"><div _ngcontent-jev-c106="" class="highlight-div"><div _ngcontent-jev-c106="" class="highlight-div-header"><div _ngcontent-jev-c106="" class="highlight-div-header-left"><div _ngcontent-jev-c106="" class="handle-button expand-button"><div _ngcontent-jev-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-jev-c106="" class="highlight-div-header-right"><div _ngcontent-jev-c106="" class="handle-button ai-button"></div><div _ngcontent-jev-c106="" class="handle-button line-button"><div _ngcontent-jev-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-jev-c106="" class="handle-button theme-button"><div _ngcontent-jev-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-jev-c106="" class="handle-button copy-button"><div _ngcontent-jev-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-jev-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-less" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/GesturesConfictPractice/entry/src/main/ets/pages/GesturesConflictScene4.ets#L17-L44" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-variable">@Entry</span></li><li><span class="hljs-variable">@Component</span></li><li>struct GesturesConflictScene4 {</li><li>  <span class="hljs-selector-tag">build</span>() {</li><li>    <span class="hljs-selector-tag">Stack</span>() {</li><li>      <span class="hljs-selector-tag">Column</span>()<span class="hljs-comment">// The bottom column</span></li><li>        <span class="hljs-selector-class">.width</span>(<span class="hljs-string">'100%'</span>)</li><li>        <span class="hljs-selector-class">.height</span>(<span class="hljs-string">'100%'</span>)</li><li>        <span class="hljs-selector-class">.backgroundColor</span>(Color.Black)</li><li>        <span class="hljs-selector-class">.gesture</span>(</li><li>          <span class="hljs-built_in">SwipeGesture</span>({ <span class="hljs-attribute">direction</span>: SwipeDirection.Horizontal })<span class="hljs-comment">//水平方向滑动手势</span></li><li>            .<span class="hljs-built_in">onAction</span>((event) =&gt; {</li><li>              if (event) {</li><li>                console.<span class="hljs-built_in">info</span>(<span class="hljs-string">'Column SwipeGesture'</span>);</li><li>              }</li><li>            })</li><li>        )</li><li>      <span class="hljs-selector-tag">Column</span>()<span class="hljs-comment">// The upper-level column</span></li><li>        <span class="hljs-selector-class">.width</span>(<span class="hljs-number">300</span>)</li><li>        <span class="hljs-selector-class">.height</span>(<span class="hljs-number">100</span>)</li><li>        <span class="hljs-selector-class">.backgroundColor</span>(Color.Red)</li><li>        <span class="hljs-selector-class">.hitTestBehavior</span>(HitTestMode.None)</li><li>    }</li><li>    <span class="hljs-selector-class">.width</span>(<span class="hljs-number">300</span>)</li><li>    <span class="hljs-selector-class">.height</span>(<span class="hljs-number">300</span>)</li><li>  }</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/GesturesConfictPractice/entry/src/main/ets/pages/GesturesConflictScene4.ets#L17-L44" target="_blank">GesturesConflictScene4.ets</a></div></div></div></div> </div> <div class="tiledSection"><h3 id="section10131171943513">多点触控场景下手势冲突<i class="anchor-icon anchor-icon-link" anchorid="section10131171943513" tips="复制节点链接"></i></h3><p>当一个页面中有多个组件可以响应手势事件，在多个手指触控的情况下，多个组件可能会同时响应手势事件，从而导致业务异常。ArkUI提供了手势独占的属性<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-monopolize-events#monopolizeevents" target="_blank">monopolizeEvents</a>，设置需要单独响应事件的组件的monopolizeEvents属性为true，可以解决这一问题。</p> <p>例如下面这个示例，给按钮Button1设置了.monopolizeEvents(true)之后，当手指首先触摸在Button1之后，在手指离开之前，其它组件的手势和事件都不会触发。</p> <div class="screenLinkPre"><div _ngcontent-jev-c106="" class="highlight-div"><div _ngcontent-jev-c106="" class="highlight-div-header"><div _ngcontent-jev-c106="" class="highlight-div-header-left"><div _ngcontent-jev-c106="" class="handle-button expand-button"><div _ngcontent-jev-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-jev-c106="" class="highlight-div-header-right"><div _ngcontent-jev-c106="" class="handle-button ai-button"></div><div _ngcontent-jev-c106="" class="handle-button line-button"><div _ngcontent-jev-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-jev-c106="" class="handle-button theme-button"><div _ngcontent-jev-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-jev-c106="" class="handle-button copy-button"><div _ngcontent-jev-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-jev-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-less" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/GesturesConfictPractice/entry/src/main/ets/pages/GesturesConflictScene5.ets#L17-L53" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-variable">@Entry</span></li><li><span class="hljs-variable">@Component</span></li><li>struct GesturesConflictScene5 {</li><li>  <span class="hljs-variable">@State</span> <span class="hljs-attribute">message</span>: string = <span class="hljs-string">'Hello World'</span>;</li><li>
</li><li>  <span class="hljs-selector-tag">build</span>() {</li><li>    <span class="hljs-selector-tag">Column</span>() {</li><li>      <span class="hljs-selector-tag">Row</span>({ space: 20 }) {</li><li>        <span class="hljs-selector-tag">Button</span>(<span class="hljs-string">'Button1'</span>)</li><li>          <span class="hljs-selector-class">.width</span>(<span class="hljs-number">100</span>)</li><li>          <span class="hljs-selector-class">.height</span>(<span class="hljs-number">40</span>)</li><li>          <span class="hljs-selector-class">.monopolizeEvents</span>(true)</li><li>        <span class="hljs-selector-tag">Button</span>(<span class="hljs-string">'Button2'</span>)</li><li>          <span class="hljs-selector-class">.width</span>(<span class="hljs-number">200</span>)</li><li>          <span class="hljs-selector-class">.height</span>(<span class="hljs-number">50</span>)</li><li>          <span class="hljs-selector-class">.onClick</span>(() =&gt; {</li><li>            <span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.info</span>(<span class="hljs-string">'GesturesConflictScene5 Button2 click'</span>);</li><li>          })</li><li>      }</li><li>      <span class="hljs-selector-class">.margin</span>(<span class="hljs-number">20</span>)</li><li>
</li><li>      <span class="hljs-selector-tag">Text</span>(this.message)</li><li>        <span class="hljs-selector-class">.margin</span>(<span class="hljs-number">15</span>)</li><li>    }</li><li>    <span class="hljs-selector-class">.width</span>(<span class="hljs-string">'100%'</span>)</li><li>    <span class="hljs-selector-class">.onDragStart</span>(() =&gt; {</li><li>      <span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.info</span>(<span class="hljs-string">'GesturesConflictScene5 Drag start.'</span>);</li><li>    })</li><li>    <span class="hljs-selector-class">.gesture</span>(</li><li>      <span class="hljs-built_in">TapGesture</span>({ <span class="hljs-attribute">count</span>: <span class="hljs-number">1</span> })</li><li>        .<span class="hljs-built_in">onAction</span>(() =&gt; {</li><li>          console.<span class="hljs-built_in">info</span>(<span class="hljs-string">'GesturesConflictScene5 TapGesture onAction.'</span>);</li><li>        }),</li><li>    )</li><li>  }</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/GesturesConfictPractice/entry/src/main/ets/pages/GesturesConflictScene5.ets#L17-L53" target="_blank">GesturesConflictScene5.ets</a></div></div></div></div> </div> <div class="tiledSection"><h3 id="section1034513423354">动态控制自定义手势是否响应<i class="anchor-icon anchor-icon-link" anchorid="section1034513423354" tips="复制节点链接"></i></h3><p>在手势识别期间，开发者决定是否响应手势，例如下面的示例代码，通过<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-gesture-customize-judge#ongesturejudgebegin" target="_blank">onGestureJudgeBegin</a>回调方法在手势识别期间进行判定，当手势为GestureType.DRAG的时候，不响应该手势，所以会使定义的onDragStart事件失效。</p> <div class="screenLinkPre"><div _ngcontent-jev-c106="" class="highlight-div"><div _ngcontent-jev-c106="" class="highlight-div-header"><div _ngcontent-jev-c106="" class="highlight-div-header-left"><div _ngcontent-jev-c106="" class="handle-button expand-button"><div _ngcontent-jev-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-jev-c106="" class="highlight-div-header-right"><div _ngcontent-jev-c106="" class="handle-button ai-button"></div><div _ngcontent-jev-c106="" class="handle-button line-button"><div _ngcontent-jev-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-jev-c106="" class="handle-button theme-button"><div _ngcontent-jev-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-jev-c106="" class="handle-button copy-button"><div _ngcontent-jev-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-jev-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-typescript" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/GesturesConfictPractice/entry/src/main/ets/pages/GesturesConflictScene6.ets#L17-L52" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-meta">@Entry</span></li><li><span class="hljs-meta">@Component</span></li><li>struct <span class="hljs-title class_">GesturesConflictScene6</span> {</li><li>  <span class="hljs-meta">@State</span> <span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">'Hello World'</span>;</li><li>
</li><li>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) {</li><li>    <span class="hljs-title class_">Column</span>()</li><li>      .<span class="hljs-title function_">width</span>(<span class="hljs-string">'100%'</span>)</li><li>      .<span class="hljs-title function_">height</span>(<span class="hljs-number">200</span>)</li><li>      .<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-title class_">Color</span>.<span class="hljs-property">Brown</span>)</li><li>      .<span class="hljs-title function_">onDragStart</span>(<span class="hljs-function">() =&gt;</span> {</li><li>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">'GesturesConflictScene6 Drag start.'</span>);</li><li>      })</li><li>      .<span class="hljs-title function_">gesture</span>(</li><li>        <span class="hljs-title class_">TapGesture</span>({ <span class="hljs-attr">count</span>: <span class="hljs-number">1</span> })</li><li>          .<span class="hljs-title function_">tag</span>(<span class="hljs-string">'tap1'</span>)</li><li>          .<span class="hljs-title function_">onAction</span>(<span class="hljs-function">() =&gt;</span> {</li><li>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">'GesturesConflictScene6 TapGesture onAction.'</span>);</li><li>          }),</li><li>      )</li><li>      .<span class="hljs-title function_">onGestureJudgeBegin</span>(<span class="hljs-function">(<span class="hljs-params">gestureInfo: GestureInfo, event: BaseGestureEvent</span>) =&gt;</span> {</li><li>        <span class="hljs-keyword">if</span> (gestureInfo.<span class="hljs-property">type</span> === <span class="hljs-title class_">GestureControl</span>.<span class="hljs-property">GestureType</span>.<span class="hljs-property">LONG_PRESS_GESTURE</span>) {</li><li>          <span class="hljs-keyword">let</span> longPressEvent = event <span class="hljs-keyword">as</span> <span class="hljs-title class_">LongPressGestureEvent</span>;</li><li>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">'GesturesConflictScene6: '</span> + longPressEvent.<span class="hljs-property">repeat</span>);</li><li>        }</li><li>        <span class="hljs-keyword">if</span> (gestureInfo.<span class="hljs-property">type</span> === <span class="hljs-title class_">GestureControl</span>.<span class="hljs-property">GestureType</span>.<span class="hljs-property">DRAG</span>) {</li><li>          <span class="hljs-comment">// Returning to the REJECT will fail the drag gesture</span></li><li>          <span class="hljs-keyword">return</span> <span class="hljs-title class_">GestureJudgeResult</span>.<span class="hljs-property">REJECT</span>;</li><li>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (gestureInfo.<span class="hljs-property">tag</span> === <span class="hljs-string">'tap1'</span> &amp;&amp; event.<span class="hljs-property">pressure</span> &gt; <span class="hljs-number">10</span>) {</li><li>          <span class="hljs-keyword">return</span> <span class="hljs-title class_">GestureJudgeResult</span>.<span class="hljs-property">CONTINUE</span></li><li>        }</li><li>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">GestureJudgeResult</span>.<span class="hljs-property">CONTINUE</span>;</li><li>      })</li><li>  }</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/GesturesConfictPractice/entry/src/main/ets/pages/GesturesConflictScene6.ets#L17-L52" target="_blank">GesturesConflictScene6.ets</a></div></div></div></div> </div> <div class="tiledSection"><h3 id="section1857645711352">父组件如何管理子组件手势<i class="anchor-icon anchor-icon-link" anchorid="section1857645711352" tips="复制节点链接"></i></h3><p>父子组件嵌套滚动发生手势冲突，父组件有机制可以干预子组件的手势响应。下面例子介绍了如何使用<strong><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-gesture-blocking-enhancement" target="_blank">手势拦截增强</a></strong>，在外层Scroll组件的<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-gesture-blocking-enhancement#shouldbuiltinrecognizerparallelwith" target="_blank">shouldBuiltInRecognizerParallelWith</a>和<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-gesture-blocking-enhancement#ongesturerecognizerjudgebegin" target="_blank">onGestureRecognizerJudgeBegin</a>回调中，动态控制内外层Scroll手势事件的滚动。</p> <p>1 首先在父组件Scroll的shouldBuiltInRecognizerParallelWith方法中收集需做并行处理的手势。下面示例代码中收集到了子组件的手势识别器childRecognizer，使其和父组件的手势识别器currentRecognizer并行处理。</p> <p>2 调用onGestureRecognizerJudgeBegin方法，判断滚动组件是否滑动到顶部或者底部，做业务逻辑处理，通过动态控制手势识别器是否可用，来决定并行处理器的childRecognizer和currentRecognizer是否可用。</p> <div class="screenLinkPre"><div _ngcontent-jev-c106="" class="highlight-div"><div _ngcontent-jev-c106="" class="highlight-div-header"><div _ngcontent-jev-c106="" class="highlight-div-header-left"><div _ngcontent-jev-c106="" class="handle-button expand-button"><div _ngcontent-jev-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-jev-c106="" class="highlight-div-header-right"><div _ngcontent-jev-c106="" class="handle-button ai-button"></div><div _ngcontent-jev-c106="" class="handle-button line-button"><div _ngcontent-jev-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-jev-c106="" class="handle-button theme-button"><div _ngcontent-jev-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-jev-c106="" class="handle-button copy-button"><div _ngcontent-jev-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-jev-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-typescript" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/GesturesConfictPractice/entry/src/main/ets/pages/GesturesConflictScene7.ets#L17-L133" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-meta">@Entry</span></li><li><span class="hljs-meta">@Component</span></li><li>struct <span class="hljs-title class_">GesturesConflictScene7</span> {</li><li>  <span class="hljs-attr">scroller</span>: <span class="hljs-title class_">Scroller</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scroller</span>();</li><li>  <span class="hljs-attr">scroller2</span>: <span class="hljs-title class_">Scroller</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scroller</span>();</li><li>  <span class="hljs-keyword">private</span> <span class="hljs-attr">arr</span>: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>];</li><li>  <span class="hljs-keyword">private</span> <span class="hljs-attr">childRecognizer</span>: <span class="hljs-title class_">GestureRecognizer</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GestureRecognizer</span>();</li><li>  <span class="hljs-keyword">private</span> <span class="hljs-attr">currentRecognizer</span>: <span class="hljs-title class_">GestureRecognizer</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GestureRecognizer</span>();</li><li>
</li><li>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) {</li><li>    <span class="hljs-title class_">Stack</span>({ <span class="hljs-attr">alignContent</span>: <span class="hljs-title class_">Alignment</span>.<span class="hljs-property">TopStart</span> }) {</li><li>      <span class="hljs-title class_">Scroll</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">scroller</span>) { <span class="hljs-comment">// External rolling container</span></li><li>        <span class="hljs-title class_">Column</span>() {</li><li>          <span class="hljs-title class_">Text</span>(<span class="hljs-string">'Scroll Area'</span>)</li><li>            .<span class="hljs-title function_">width</span>(<span class="hljs-string">'100%'</span>)</li><li>            .<span class="hljs-title function_">height</span>(<span class="hljs-number">150</span>)</li><li>            .<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-number">0xFFFFFF</span>)</li><li>            .<span class="hljs-title function_">borderRadius</span>(<span class="hljs-number">15</span>)</li><li>            .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">16</span>)</li><li>            .<span class="hljs-title function_">textAlign</span>(<span class="hljs-title class_">TextAlign</span>.<span class="hljs-property">Center</span>)</li><li>            .<span class="hljs-title function_">margin</span>({ <span class="hljs-attr">top</span>: <span class="hljs-number">10</span> })</li><li>          <span class="hljs-title class_">Scroll</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">scroller2</span>) { <span class="hljs-comment">// internal rolling container</span></li><li>            <span class="hljs-title class_">Column</span>() {</li><li>              <span class="hljs-title class_">Text</span>(<span class="hljs-string">'Scroll Area2'</span>)</li><li>                .<span class="hljs-title function_">width</span>(<span class="hljs-string">'100%'</span>)</li><li>                .<span class="hljs-title function_">height</span>(<span class="hljs-number">150</span>)</li><li>                .<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-number">0xFFFFFF</span>)</li><li>                .<span class="hljs-title function_">borderRadius</span>(<span class="hljs-number">15</span>)</li><li>                .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">16</span>)</li><li>                .<span class="hljs-title function_">textAlign</span>(<span class="hljs-title class_">TextAlign</span>.<span class="hljs-property">Center</span>)</li><li>                .<span class="hljs-title function_">margin</span>({ <span class="hljs-attr">top</span>: <span class="hljs-number">10</span> })</li><li>              <span class="hljs-title class_">Column</span>() {</li><li>                <span class="hljs-title class_">ForEach</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">arr</span>, <span class="hljs-function">(<span class="hljs-params">item: <span class="hljs-built_in">number</span></span>) =&gt;</span> {</li><li>                  <span class="hljs-title class_">Text</span>(item.<span class="hljs-title function_">toString</span>())</li><li>                    .<span class="hljs-title function_">width</span>(<span class="hljs-string">'100%'</span>)</li><li>                    .<span class="hljs-title function_">height</span>(<span class="hljs-number">200</span>)</li><li>                    .<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-number">0xFFFFFF</span>)</li><li>                    .<span class="hljs-title function_">borderRadius</span>(<span class="hljs-number">15</span>)</li><li>                    .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">20</span>)</li><li>                    .<span class="hljs-title function_">textAlign</span>(<span class="hljs-title class_">TextAlign</span>.<span class="hljs-property">Center</span>)</li><li>                    .<span class="hljs-title function_">margin</span>({ <span class="hljs-attr">top</span>: <span class="hljs-number">10</span> })</li><li>                }, <span class="hljs-function">(<span class="hljs-params">item: <span class="hljs-built_in">string</span></span>) =&gt;</span> item)</li><li>              }</li><li>              .<span class="hljs-title function_">width</span>(<span class="hljs-string">'100%'</span>)</li><li>            }</li><li>          }</li><li>          .<span class="hljs-title function_">id</span>(<span class="hljs-string">'innerScroll'</span>)</li><li>          .<span class="hljs-title function_">scrollBar</span>(<span class="hljs-title class_">BarState</span>.<span class="hljs-property">Off</span>) <span class="hljs-comment">// The scroll bar is always displayed</span></li><li>          .<span class="hljs-title function_">width</span>(<span class="hljs-string">'100%'</span>)</li><li>          .<span class="hljs-title function_">height</span>(<span class="hljs-number">800</span>)</li><li>        }.<span class="hljs-title function_">width</span>(<span class="hljs-string">'100%'</span>)</li><li>      }</li><li>      .<span class="hljs-title function_">id</span>(<span class="hljs-string">'outerScroll'</span>)</li><li>      .<span class="hljs-title function_">height</span>(<span class="hljs-number">600</span>)</li><li>      .<span class="hljs-title function_">scrollBar</span>(<span class="hljs-title class_">BarState</span>.<span class="hljs-property">Off</span>) <span class="hljs-comment">// The scroll bar is always displayed</span></li><li>      .<span class="hljs-title function_">shouldBuiltInRecognizerParallelWith</span>(<span class="hljs-function">(<span class="hljs-params">current: GestureRecognizer, others: <span class="hljs-built_in">Array</span>&lt;GestureRecognizer&gt;</span>) =&gt;</span> {</li><li>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; others.<span class="hljs-property">length</span>; i++) {</li><li>          <span class="hljs-keyword">let</span> target = others[i].<span class="hljs-title function_">getEventTargetInfo</span>();</li><li>          <span class="hljs-keyword">if</span> (target) {</li><li>            <span class="hljs-keyword">if</span> (target.<span class="hljs-title function_">getId</span>() === <span class="hljs-string">'innerScroll'</span> &amp;&amp; others[i].<span class="hljs-title function_">isBuiltIn</span>() &amp;&amp;</li><li>              others[i].<span class="hljs-title function_">getType</span>() === <span class="hljs-title class_">GestureControl</span>.<span class="hljs-property">GestureType</span>.<span class="hljs-property">PAN_GESTURE</span>) { <span class="hljs-comment">// Find the recognizer that will form the parallel gesture</span></li><li>              <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentRecognizer</span> = current; <span class="hljs-comment">// Save the recognizer of the current component</span></li><li>              <span class="hljs-variable language_">this</span>.<span class="hljs-property">childRecognizer</span> = others[i]; <span class="hljs-comment">// Save the recognizer that will form the parallel gesture</span></li><li>              <span class="hljs-keyword">return</span> others[i]; <span class="hljs-comment">// Return the recognizer that will form the parallel gesture</span></li><li>            }</li><li>          }</li><li>        }</li><li>        <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;</li><li>      })</li><li>      .<span class="hljs-title function_">onGestureRecognizerJudgeBegin</span>(<span class="hljs-function">(<span class="hljs-params">event: BaseGestureEvent, current: GestureRecognizer,</span></span></li><li><span class="hljs-function">        others: <span class="hljs-built_in">Array</span>&lt;GestureRecognizer&gt;</span>) =&gt; { <span class="hljs-comment">// When the recognizer is about to succeed, set the recognizer enabling status according to the current component status</span></li><li>        <span class="hljs-keyword">if</span> (current) {</li><li>          <span class="hljs-keyword">let</span> target = current.<span class="hljs-title function_">getEventTargetInfo</span>();</li><li>          <span class="hljs-keyword">if</span> (target) {</li><li>            <span class="hljs-keyword">if</span> (target.<span class="hljs-title function_">getId</span>() === <span class="hljs-string">'outerScroll'</span> &amp;&amp; current.<span class="hljs-title function_">isBuiltIn</span>() &amp;&amp;</li><li>              current.<span class="hljs-title function_">getType</span>() === <span class="hljs-title class_">GestureControl</span>.<span class="hljs-property">GestureType</span>.<span class="hljs-property">PAN_GESTURE</span>) {</li><li>              <span class="hljs-keyword">if</span> (others) {</li><li>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; others.<span class="hljs-property">length</span>; i++) {</li><li>                  <span class="hljs-keyword">let</span> target = others[i].<span class="hljs-title function_">getEventTargetInfo</span>() <span class="hljs-keyword">as</span> <span class="hljs-title class_">ScrollableTargetInfo</span>;</li><li>                    <span class="hljs-keyword">if</span> (target <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">ScrollableTargetInfo</span> &amp;&amp; target.<span class="hljs-title function_">getId</span>() == <span class="hljs-string">'innerScroll'</span>) { <span class="hljs-comment">// Find the corresponding parallel recognizer on the response chain</span></li><li>                    <span class="hljs-keyword">let</span> panEvent = event <span class="hljs-keyword">as</span> <span class="hljs-title class_">PanGestureEvent</span>;</li><li>                    <span class="hljs-keyword">if</span> (target.<span class="hljs-title function_">isEnd</span>()) { <span class="hljs-comment">// isEnd returns whether the current rolling container component is at the bottom of the dynamic control status of the recognizer based on the current component status and movement direction</span></li><li>                      <span class="hljs-keyword">if</span> (panEvent &amp;&amp; panEvent.<span class="hljs-property">offsetY</span> &lt; <span class="hljs-number">0</span>) {</li><li>                        <span class="hljs-variable language_">this</span>.<span class="hljs-property">childRecognizer</span>.<span class="hljs-title function_">setEnabled</span>(<span class="hljs-literal">false</span>) <span class="hljs-comment">// When it's the end, pull up</span></li><li>                        <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentRecognizer</span>.<span class="hljs-title function_">setEnabled</span>(<span class="hljs-literal">true</span>)</li><li>                      } <span class="hljs-keyword">else</span> {</li><li>                        <span class="hljs-variable language_">this</span>.<span class="hljs-property">childRecognizer</span>.<span class="hljs-title function_">setEnabled</span>(<span class="hljs-literal">true</span>)</li><li>                        <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentRecognizer</span>.<span class="hljs-title function_">setEnabled</span>(<span class="hljs-literal">false</span>)</li><li>                      }</li><li>                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target.<span class="hljs-title function_">isBegin</span>()) {</li><li>                      <span class="hljs-keyword">if</span> (panEvent.<span class="hljs-property">offsetY</span> &gt; <span class="hljs-number">0</span>) { <span class="hljs-comment">// Pull down at the beginning</span></li><li>                        <span class="hljs-variable language_">this</span>.<span class="hljs-property">childRecognizer</span>.<span class="hljs-title function_">setEnabled</span>(<span class="hljs-literal">false</span>)</li><li>                        <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentRecognizer</span>.<span class="hljs-title function_">setEnabled</span>(<span class="hljs-literal">true</span>)</li><li>                      } <span class="hljs-keyword">else</span> {</li><li>                        <span class="hljs-variable language_">this</span>.<span class="hljs-property">childRecognizer</span>.<span class="hljs-title function_">setEnabled</span>(<span class="hljs-literal">true</span>)</li><li>                        <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentRecognizer</span>.<span class="hljs-title function_">setEnabled</span>(<span class="hljs-literal">false</span>)</li><li>                      }</li><li>                    } <span class="hljs-keyword">else</span> {</li><li>                      <span class="hljs-variable language_">this</span>.<span class="hljs-property">childRecognizer</span>.<span class="hljs-title function_">setEnabled</span>(<span class="hljs-literal">true</span>)</li><li>                      <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentRecognizer</span>.<span class="hljs-title function_">setEnabled</span>(<span class="hljs-literal">false</span>)</li><li>                    }</li><li>                  }</li><li>                }</li><li>              }</li><li>            }</li><li>          }</li><li>        }</li><li>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">GestureJudgeResult</span>.<span class="hljs-property">CONTINUE</span>;</li><li>      })</li><li>    }</li><li>    .<span class="hljs-title function_">width</span>(<span class="hljs-string">'100%'</span>)</li><li>    .<span class="hljs-title function_">height</span>(<span class="hljs-string">'100%'</span>)</li><li>    .<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-number">0xF1F3F5</span>)</li><li>    .<span class="hljs-title function_">padding</span>(<span class="hljs-number">12</span>)</li><li>  }</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/GesturesConfictPractice/entry/src/main/ets/pages/GesturesConflictScene7.ets#L17-L133" target="_blank">GesturesConflictScene7.ets</a></div></div></div></div> </div> <div class="tiledSection"><h2 id="section177242114365">总结<i class="anchor-icon anchor-icon-link" anchorid="section177242114365" tips="复制节点链接"></i></h2><p>手势冲突在界面开发中往往不可避免，特别是在复杂的应用界面中。针对不同的冲突场景和手势交互需求，需要选择合适的解决方案。可以参考前面介绍的影响触摸测试因素，以及手势响应控制里面的方法，进行尝试。</p> <ul><li>Grid、List、Scroll、Swiper、WaterFlow等滚动容器的嵌套，可以尝试使用nestedScroll属性来解决视图滚动冲突的问题。</li><li>对于单个组件组合手势的使用产生的冲突，以及自定义手势和系统手势冲突，可以尝试使用组合手势中的<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-gesture-events-combined-gestures#顺序识别" target="_blank">顺序识别</a>、<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-gesture-events-combined-gestures#并行识别" target="_blank">并行识别</a>和<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-gesture-events-combined-gestures#互斥识别" target="_blank">互斥识别</a>来解决。</li><li>对于多层组件手势响应冲突，可以参考<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-gesture-events-multi-level-gesture" target="_blank">多层级手势事件</a>。</li><li>如果需要将系统手势和比其优先级高的手势做并行化处理，并可以动态控制手势事件的触发，可以参考<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-gesture-blocking-enhancement" target="_blank">手势拦截增强</a>。</li><li>如果只是需要动态控制自定义手势是否响应，可以参考<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-gesture-customize-judge" target="_blank">自定义手势判定</a>。</li><li>对于多点触控产生的手势冲突可以参考<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-monopolize-events" target="_blank">事件独占控制</a>。</li></ul> <p>希望通过对本篇文章的阅读，能帮助您解决常见的一些手势事件冲突问题。</p> </div> <div class="tiledSection"><h2 id="section1078520389541">示例代码<i class="anchor-icon anchor-icon-link" anchorid="section1078520389541" tips="复制节点链接"></i></h2><ul><li><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/tree/master/GesturesConfictPractice" target="_blank">手势事件冲突解决方案</a></li></ul> </div> </div></div>