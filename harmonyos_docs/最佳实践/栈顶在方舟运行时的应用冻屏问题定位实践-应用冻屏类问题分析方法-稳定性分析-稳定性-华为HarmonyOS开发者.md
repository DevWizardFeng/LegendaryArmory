<h1 _ngcontent-xgn-c119="" class="doc-title ng-star-inserted" title="栈顶在方舟运行时的应用冻屏问题定位实践"> 栈顶在方舟运行时的应用冻屏问题定位实践 </h1>

<div _ngcontent-xgn-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;"> <div><div class="tiledSection"><h2 id="section1994564815714">概述<i class="anchor-icon anchor-icon-link" anchorid="section1994564815714" tips="复制节点链接"></i></h2></div> <p>本文旨在指导HarmonyOS应用开发者如何定位定界栈顶在方舟运行时（libark_jsruntime.so、libace_napi.z.so）的应用冻屏（AppFreeze）问题。</p> <p>关于应用冻屏（AppFreeze）问题的基本检测原理可先阅读<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-app-freeze-way">应用冻屏问题排查方法</a>。</p> <div class="tiledSection"><h2 id="section15473181255818">定位思路<i class="anchor-icon anchor-icon-link" anchorid="section15473181255818" tips="复制节点链接"></i></h2></div> <p>定位应用冻屏（AppFreeze）问题常用“三板斧”可归纳为：看freeze栈、看trace、看日志。</p> <div class="tiledSection"><h3 id="section1734111632914" class="firsth2">一板斧：看freeze栈<i class="anchor-icon anchor-icon-link" anchorid="section1734111632914" tips="复制节点链接"></i></h3></div> <p>目前应用冻屏（AppFreeze）检测会从以下维度检测，HarmonyOS应用开发者了解其原理对定位和分析应用冻屏（AppFreeze）问题非常有帮助。</p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.8.1.3.1.1" valign="top" width="50%"><p><strong>问题故障类型</strong></p> </th> <th align="left" class="cellrowborder" id="mcps1.3.8.1.3.1.2" valign="top" width="50%"><p><strong>说明</strong></p> </th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="50%"><p>THREAD_BLOCK_6S</p> </td> <td class="cellrowborder" valign="top" width="50%"><p>应用主线程卡死超时。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="50%"><p>APP_INPUT_BLOCK</p> </td> <td class="cellrowborder" valign="top" width="50%"><p>用户输入响应超时。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="50%"><p>LIFECYCLE_TIMEOUT</p> </td> <td class="cellrowborder" valign="top" width="50%"><p>Ability生命周期切换超时。</p> </td> </tr>  </tbody></table></div> </div> <p>其中THREAD_BLOCK_6S（应用主线程卡死超时）最终表现在libark_jsruntime.so栈顶的应用冻屏（AppFreeze）问题比较多。</p> <p>出现该类问题表示当前应用主线程有卡死或者执行任务过多的情况，影响任务执行的流畅度和体验。</p> <p>该事件的检测原理是：应用的watchdog线程定期向主线程插入判活检测，并在自己线程插入超时上报机制。当判活检测超过3s没有被执行，会上报THREAD_BLOCK_3S警告事件；超过6s依然没有被执行，会上报THREAD_BLOCK_6S主线程卡死事件。两个事件匹配生成THREAD_BLOCK的应用冻屏日志。问题发生时会生成freeze堆栈，包括warning栈（3s）与error栈（6s）。</p> <p>通过分析freeze堆栈可得到如下信息：</p> <ol><li>通过解析栈顶代码行，可以知道应用所有线程3S和6S正在执行的代码逻辑。</li><li>如果3S和6S的栈不一致，则说明3S和6S间程序仍在执行业务代码，线程未卡死，那么就需要考虑是否是应用执行的任务太重导致的线程繁忙，这个可以通过trace和log做进一步确认。</li><li>如果3S和6S的栈相同，可以看主线程和其他线程是否有相互持锁导致的死锁问题。</li><li>还可以根据调用栈查看是否有长耗时的函数调用，如DumpHeapSnapshot、RegExpExecutor::Execute等典型耗时函数。</li></ol> <div class="tiledSection"><h3 id="section7874113020296">二板斧：看trace<i class="anchor-icon anchor-icon-link" anchorid="section7874113020296" tips="复制节点链接"></i></h3></div> <p>通过freeze的栈只能看到3S和6S的瞬时栈（有的freeze甚至只有6S的瞬时栈），如果想要知道应用freeze前的6S时间内整个应用进程的状态，在应用开发态中通过看trace进一步分析。查看freeze前的trace，可以重点关注以下信息：</p> <ol><li>主线程是否有大段空白，如果有大段空白，则说明主线程在持锁等待，可以进一步看主线程在等待谁唤醒。</li><li>主线程是否有某个函数调用耗时太长，如果有某个函数执行耗时过长（如超过3S），则可以分析为产生freeze的根因，需要进行优化。</li><li>主线程是否有某个函数频繁调用，如果有某个函数频繁调用，则可能是不合理的for循环逻辑导致。</li><li>主线程是否频繁触发GC，如果有频繁GC触发，则可能是应用有内存泄漏，需要排查内存泄漏问题。</li><li>主线程是否有大段runnable，如果有，则说明有调度问题，需要确认是否是应用高优先级任务过多，或者找调度域协助定位。</li><li>主线程是否有大段的Uninterruptible sleep，如果有，则说明有D状态问题，需要分析D状态问题发生原因。</li></ol> <div class="tiledSection"><h3 id="section1382094252919">三板斧：看日志<i class="anchor-icon anchor-icon-link" anchorid="section1382094252919" tips="复制节点链接"></i></h3></div> <p>有时会遇到通过Freeze栈和trace仍无法定界的情况（如对应时间点trace丢失或者trace中看不到在执行什么代码逻辑），这个时候就需要借助freeze前的日志信息做进一步定位。查看freeze前的日志，重点关注以下信息：</p> <ol><li>freeze前主线程是否仍有频繁的业务日志打印，如果有，则很有可能是业务繁忙导致，需要根据打印的日志信息找到对应代码逻辑进行优化。</li><li>如果freeze前打印的日志很少，则重点看最后几条日志信息，找到对应代码排查是否有死锁或者函数执行时间长的问题。</li></ol> <div class="tiledSection"><h2 id="section1796411165918">问题分类<i class="anchor-icon anchor-icon-link" anchorid="section1796411165918" tips="复制节点链接"></i></h2></div> <p><span><img originheight="723" originwidth="1180" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163454.80399782102744472364964976238484:50001231000000:2800:24D36963195F5EAB4DFFDEF3070512E845F2BA6A69A7ADBA894A242487DB16C2.png" width="920" height="563.6949152542373"></span></p> <p>总结栈顶在方舟的应用冻屏（AppFreeze）问题根因以及每种问题的典型特征，归纳如下：</p> <div class="tiledSection"><h3 id="section1699914012816" class="firsth2">应用问题<i class="anchor-icon anchor-icon-link" anchorid="section1699914012816" tips="复制节点链接"></i></h3><ol><li>应用代码逻辑复杂，执行时间长导致freeze，问题典型特征如下：<ol><li>除去jsruntime的栈顶后，freeze栈3S和6S执行的应用JS代码相同，则很可能是应用在执行耗时函数导致超时（详见案例一）</li><li>trace显示应用主线程频繁调用某个应用接口（详见案例二）</li><li>trace显示应用主线程调用某个应用接口耗时长（详见案例三）</li><li>freeze前日志中有关键应用日志打印（详见案例四）</li></ol> </li><li>应用内存泄漏导致频繁GC或触发OOM dump，问题典型特征如下：<ol><li>trace上看到频繁触发GC（详见案例五）</li><li>OOM触发Dump，Freeze栈上显示调用DumpHeapSnapshot接口（详见案例六）</li></ol> </li><li>高优先级任务太多，问题典型特征如下：<ol><li>freeze文件任务队列中VIP Priority Event+Immediate Priority Event+High Priority Event的任务数总量相加超过400（详见案例七）</li><li>栈顶为2帧napi+4 帧libruntime，前两帧反编译后是IsValidScriptBuffer和RunScriptBuffer（详见案例七）</li></ol> </li><li>死锁问题，堆栈显示持锁和wait的都是应用的so库，问题典型特征如下：<ol><li>3S和6S的栈相同</li><li>主线程在wait，其他线程持锁不释放</li></ol> </li></ol> </div> <div class="tiledSection"><h3 id="section162711718192814">调度问题<i class="anchor-icon anchor-icon-link" anchorid="section162711718192814" tips="复制节点链接"></i></h3></div> <p>因为线程优先级低，调度不到CPU资源，应用进程一直处于runnable状态，最终导致应用冻屏（AppFreeze），问题典型特征如下：</p> <ul><li>从trace上看，主线程CPU大段runnable状态（详见案例九）</li><li>主线程sleep等待子线程唤醒，子线程大段runnable</li></ul> <div class="tiledSection"><h3 id="section12575183712285">系统库问题<i class="anchor-icon anchor-icon-link" anchorid="section12575183712285" tips="复制节点链接"></i></h3></div> <ol><li>系统库代码逻辑复杂，执行时间长导致freeze，问题典型特征如下：<ol><li>除去jsruntime的栈顶后，freeze栈3S和6S执行的系统库代码相同（详见案例十）</li><li>trace显示应用主线程频繁调用某个系统库接口</li><li>trace显示应用主线程调用某个系统库接口耗时长</li><li>freeze前日志中有关键系统库日志打印</li></ol> </li><li>死锁问题，堆栈显示持锁和wait的都是系统库so，问题典型特征如下：<ol><li>3S和6S的栈相同</li><li>主线程在wait，其他线程持锁不释放（详见案例十一）</li></ol> </li></ol> <div class="tiledSection"><h3 id="section0934175016283">IO问题<i class="anchor-icon anchor-icon-link" anchorid="section0934175016283" tips="复制节点链接"></i></h3></div> <p>读写问题导致的D状态问题，典型特征如下：</p> <ul><li>主线程大段Uninterruptible sleep状态（详见案例十二）</li><li>主线程sleep等待子线程唤醒，子线程大段Uninterruptible sleep</li></ul> <div class="tiledSection"><h2 id="section2690181616593">典型案例分析<i class="anchor-icon anchor-icon-link" anchorid="section2690181616593" tips="复制节点链接"></i></h2></div> <div class="tiledSection"><h3 id="section14247630123710" class="firsth2">应用问题案例分析<i class="anchor-icon anchor-icon-link" anchorid="section14247630123710" tips="复制节点链接"></i></h3></div> <p><strong>案例一：3S和6S调用的应用JS代码相同</strong></p> <p>下面是某应用一个应用冻屏（AppFreeze）问题3S和6S的调用栈，栈顶都是JSStableArray::IndexOfBigInt，这是一个Builtins接口，流程中没有加锁，因此排除死锁的问题。可以看到，除去jsruntime的栈顶，3S和6S执行的应用代码行都是同一行:LeakXXXModel.ts:440:1，怀疑应用有循环调用导致的线程繁忙问题，经确认，根因为对应应用代码中有个很大的for循环执行耗时长，代码优化后得以解决。</p> <p>3S栈：</p> <p><span><img originheight="294" originwidth="1251" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163454.84709016110701315989298374946921:50001231000000:2800:BC869619CF0928352E438B7DE27F02C5D25AAFBB9A557DB6BA0AD7555D31AF17.png" width="920" height="216.21103117505996"></span>6S栈：</p> <p><span><img originheight="331" originwidth="1171" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163454.48851537568438291983025261117853:50001231000000:2800:F4208A8D579B869814A7EF3BD8401737EAAE03E597C82629A598879DFDB82784.png" width="920" height="260.05123825789923"></span></p> <p>解决方案：下面是应用findXXXList接口的伪代码示例，该接口的功能是返回[start,end]区间中缺失消息组成的列表，当indexList很大时，循环遍历查找将非常耗时，可能造成应用appfreeze。伙伴侧的规避方案是设置一个定时器做超时检测，当for循环代码执行超时后则直接跳出循环，避免发生应用冻屏（AppFreeze）。</p> <div _ngcontent-xgn-c106="" class="highlight-div"><div _ngcontent-xgn-c106="" class="highlight-div-header"><div _ngcontent-xgn-c106="" class="highlight-div-header-left"><div _ngcontent-xgn-c106="" class="handle-button expand-button"><div _ngcontent-xgn-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-xgn-c106="" class="highlight-div-header-right"><div _ngcontent-xgn-c106="" class="handle-button ai-button"></div><div _ngcontent-xgn-c106="" class="handle-button line-button"><div _ngcontent-xgn-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-xgn-c106="" class="handle-button theme-button"><div _ngcontent-xgn-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-xgn-c106="" class="handle-button copy-button"><div _ngcontent-xgn-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-xgn-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-typescript" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> <span class="hljs-title function_">findXXXList</span>(<span class="hljs-params">indexList, start, end</span>) {</li><li>    <span class="hljs-keyword">let</span> needBreak = <span class="hljs-literal">false</span>;</li><li>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {</li><li>        needBreak = <span class="hljs-literal">true</span>;</li><li>    }, <span class="hljs-number">100</span>); <span class="hljs-comment">// 定时器</span></li><li>    <span class="hljs-keyword">while</span> (start &lt;= end) {</li><li>        <span class="hljs-comment">// do some thing</span></li><li>        start++;</li><li>        <span class="hljs-keyword">if</span> (needBreak) {</li><li>            <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 超时退出</span></li><li>        }</li><li>    }</li><li>}</li></ol></pre></div></div> <p><strong>案例二：应用主线程频繁调用某个应用接口</strong></p> <p>该案例主线程的trace如下，从trace可以看出，应用在频繁调用某个接口。打开其中一小段发现是在频繁调用反序列化接口，每段反序列化的时间1us以上。反序列化接口在应用跨线程传输数据时调用，如调用Work的PostMessage接口或TaskPool的execute接口。由此可确认，该freeze问题发生的根因是应用频繁跨线程传输数据导致。</p> <p><span><img height="74.45674794452553" originheight="146" originwidth="1804" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163454.69337498800895401222090827519122:50001231000000:2800:35656BFBBDA93D396E390AE439BCED1D19FEA8B45C0169F43AA0AB6C7111F81A.png" title="点击放大" width="920"></span></p> <p><span><img originheight="59" originwidth="308" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163454.24588925873676102763100577372073:50001231000000:2800:025F4CC689EB8F410C3EE1686293F3AED5DB1A6BFACEADFD57BA8837B2F35157.png" width="308" height="59"></span></p> <p><span><img originheight="430" originwidth="956" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163454.50167579591845124076397343522201:50001231000000:2800:CC306B586264C64541B004F5FD89CD5CC9E012A686ED607BB7A79782594477F5.png" width="920" height="413.8075313807531"></span></p> <p>解决方案：减少同一时间段频繁跨线程传输数据的操作。</p> <p><strong>案例三：应用主线程调用某个耗时长接口</strong></p> <p>该案例应用freeze堆栈栈顶在执行正则操作，从trace中可以看出，主线程一直在执行正则匹配导致超时freeze。</p> <p><span><img height="214.66641186489966" originheight="413" originwidth="1770" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163454.13736274116551377091749150559174:50001231000000:2800:FB487E78C3C8B55359FD65704750CF4882E177212390C377D47A718D400EFC47.png" title="点击放大" width="920"></span><span><img height="229.4472370900867" originheight="415" originwidth="1664" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163454.17090881079994932089180407235316:50001231000000:2800:BC91544B355DBC72A9285AB21078F333E91EA6EB17C549386E4001ED4AFC2E8F.png" title="点击放大" width="920"></span>解决方案：</p> <ol><li>优化正则匹配的逻辑，避免超长字符串的正则匹配；</li><li>将耗时操作放到taskpool线程执行，不阻塞主线程。</li></ol> <p><strong>案例四：freeze前关键应用日志打印</strong></p> <p>下面是一个服务类进程的卡死问题，该问题通过freeze栈和trace均无法完成问题定界，最终通过日志才分析出问题根因。</p> <p>结合trace分析：trace中显示的是GC的循环调用，但每次GC在running中的占比并不高，也符合GC调用的规律，因此确认不是GC的问题。可能是未插桩的running状态导致未响应，无法进一步定位问题。</p> <p><span><img originheight="245" originwidth="1366" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163454.22026249256293945171910566533891:50001231000000:2800:1EAC99EC079546CC631E22E3F6416A08DFFD4F31D5EB88BEBFB1B4B38B9B3809.png" width="920" height="165.0073206442167"></span><span><img originheight="125" originwidth="843" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163455.42280538088892570262070094978663:50001231000000:2800:4F9FC1132D3796CF527E80FC68CAAAD78762A57EB942DFDB84374A0AEA7BD1F8.png" width="843" height="125"></span></p> <p>此时结合HiLog日志分析，HiLog搜索崩溃线程28040，崩溃时间点在06:44:16，卡了6s。推测大概是在06:44:10附近出现问题。</p> <p>进一步观察HiLog日志发现，应用一直在调用融合搜索FusionSearch，和应用对齐后，确认问题是应用循环调用FusionSearch接口导致。</p> <p><span><img originheight="546" originwidth="1146" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163455.80951755700914754167590279503209:50001231000000:2800:62F6A50739EB0A401B13A53323B6B413239947FB7587E0A560F9BE9355B5C310.png" width="920" height="438.32460732984293"></span><strong>案例五：应用内存泄漏导致频繁GC</strong></p> <p>该案例的trace如下，可以看到主线程一直在触发GC，几乎沾满了整个线程。在应用内存正常时（远小于应用js内存上限），每次GC后都会根据存活对象大小适当提升GC的阈值，从而防止频繁的GC触发。而当应用发生内存泄漏时，应用占用的js内存可能一直处于OOM的边缘，GC阈值调整的空间则非常有限（GC阈值不能超过js内存上限），可能就会出现频繁GC的现象。</p> <p><span><img originheight="543" originwidth="1387" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163455.32511584216139214175103727365772:50001231000000:2800:E5355DF8753DA9E2FE9A432DB52C9E8F4ECF3167E312B09BC059E445EA240DFD.png" width="920" height="360.1730353280461"></span>为了进一步验证上述猜想，结合GC日志做进一步分析。从日志可以看出，应用分配的ArrayBuffer内存已经达到1.4G，且GC仍无法释放，再加上NativeBindingSize，总的内存大小已经接近3G。根据虚拟机的GC内存触发策略，当Native内存超过2G后，每次分配都会尝试去触发GC。</p> <p><span><img originheight="486" originwidth="1176" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163455.18952165707917908395568268144317:50001231000000:2800:86D09E9DEAD70FA400C74AE187ABD456AC784D66D4B5442E59A9FFCC19DA9D0C.png" width="920" height="380.2040816326531"></span>解决方案：通过上面分析，该问题实际就由freeze问题转换成了内存泄漏问题。应用内存泄漏一般可以分为两种：一种是js内存泄漏，另一种是Native内存泄漏。对于js内存泄漏，可以同HeapSnapshot工具生成内存快照，辅助问题定位，参考文档<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-insight-session-snapshot" target="_blank">ArkTS内存泄漏分析：Snapshot分析</a>。对于Native内存泄漏，DevEco Profiler提供了基础的内存场景分析Allocation，参考文档<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-insight-session-allocations" target="_blank">Native内存泄漏分析：Allocation分析</a>。</p> <p><strong>案例六：应用内存泄漏触发OOM Dump</strong></p> <p>该问题的典型freeze栈如下，其中有一个js线程（主线程或taskpool、worker线程）触发了OOM的dump，堆栈显示调用DumpHeapSnapshotBeforeOOM接口。该问题发生的原因是某个js线程的虚拟机内存超过了设定的上限（主线程448MB，worker、taskpool线程768MB），这种一般是应用内存泄漏导致，解决方案同案例五。</p> <p><span><img originheight="502" originwidth="1176" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163455.85097458023705429876166244011699:50001231000000:2800:2D0780879989BE4EFE124A8BE6D4CE9BF6D310195DA9AE89146C495A42A8D692.png" width="920" height="392.72108843537416"></span><strong>案例七：高优先级任务过多</strong></p> <p>原理：</p> <p>在每个freeze文件中都会有任务队列的dump信息；高级别优先级别的任务会抢占低级别优先级任务的队列资源，以保证高优先级任务能够尽早被执行；</p> <p>THREAD_BLOCK_6S的检测机制为watchdog向主线程队列中每隔3s抛一个watchdog的任务（Timer），这些任务必须要在被抛出的3s内被主线程执行到；</p> <p>因为watchdog的任务是高优先级任务（High Priority Event），所以如果任务队列中VIP Priority Event + Immediate Priority Event + High Priority Event的任务总量过多，就会容易发生watchdog定时任务无法及时被执行，从而导致出现appfreeze；</p> <p>特征：</p> <p>一般来说，这三者的任务数总量相加超过400，应用就有发生freeze的风险，需要应用侧进行整改，减少高优先级任务数量</p> <p><span><img originheight="286" originwidth="1558" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163455.80255741455915508464698619011167:50001231000000:2800:8731C6E0BBED87EEC3D0997E3FDBC25871C910AFE3781454D00A6CC556D3F139.png" width="920" height="168.8831835686778"></span>High Priority Event的数量过多</p> <p><span><img originheight="230" originwidth="1555" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163455.61204162083298088982695192081920:50001231000000:2800:5093CD11A95C5DFDCD937E6AF49873E816EB540423B221979C4811762D1A9207.png" width="920" height="136.07717041800643"></span>Immediate Priority Event的数量过多。</p> <p><strong>案例八：加密应用</strong></p> <p>原理：主线程等解密的秘钥一直等不到，导致长时间sleep后卡死。</p> <p>特征：这类问题只通过栈就可以确定，00 帧到 20 帧基本完全一致，01、02 帧反编译后是IsValidScriptBuffer和RunScriptBuffer</p> <p>解决方案：一般由加密应用hdc install安装方式引起，从应用市场重新安装即可解决</p> <p><span><img originheight="495" originwidth="1046" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163455.24300406800150513549960971114792:50001231000000:2800:BBB2686DA847D49D7F19D736C2FB59DEA413B9936159308F47413675B15EC13D.png" width="920" height="435.3728489483747"></span></p> <p><span><img originheight="424" originwidth="1348" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163455.95029007853142397942991788956353:50001231000000:2800:47136C177EA28B9093AECEFAF29FACEE3DD0DB981EDDAE49AA16D890C9423349.png" width="920" height="289.37685459940656"></span>后续观察kernel stack，发现代码逻辑进入内核的代码，且等锁。</p> <div class="tiledSection"><h3 id="section5746182420489">调度问题案例分析<i class="anchor-icon anchor-icon-link" anchorid="section5746182420489" tips="复制节点链接"></i></h3></div> <p><strong>案例九：整机CPU负载高导致后台应用GC线程调度不到资源</strong></p> <p>调度问题的典型特征是trace中freeze前有大段的runnable状态。下图是hiviewx应用appfreeze问题的trace，从trace中可以看出，问题发生前应用的所有线程都处于调度不到的状态，而此时主线程正好在触发方舟虚拟机的GC，因此freeze栈顶会挂在方舟的GC里。</p> <p><span><img originheight="515" originwidth="1442" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163455.50887358227052783161773700888324:50001231000000:2800:6E7857BB657026C70E3FA2B8AD5A357703ADA277E48FB9C6315448CA81FA8C60.png" width="920" height="328.5714285714286"></span>进一步分析日志，发现此时整机CPU负载达到60%以上，而hiviewx为后台应用，且GC线程本身优先级较低，在高负载场景下，无法调度到CPU资源，导致执行超时。</p> <p><span><img height="63.25954392523365" originheight="120" originwidth="1745" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163455.95530232919833672953223054504107:50001231000000:2800:84D71B35AC78658C667DB465003EDC84C2ACBEA865A79E6D1CD90AEB310ECCA4.png" title="点击放大" width="920"></span></p> <p>解决方案：该问题GC触发的原因是虚拟机判断进程处于空闲场景触发的IdleGC，对于CPU高负载场景，可以选择不触发IdleGC。判定空闲场景通知做GC任务前，先获取当前的cpu使用率，高于50%的cpu使用率就放弃当次任务通知。</p> <p><span><img originheight="383" originwidth="794" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163455.99061044051973737548633905354937:50001231000000:2800:7E2E16C5BA7FC00019BE5AD9D90D4F282A4553D342B044F88FB4CD857DB7F0AC.png" width="794" height="383"></span></p> <div class="tiledSection"><h3 id="section205311041134815">系统库问题案例分析<i class="anchor-icon anchor-icon-link" anchorid="section205311041134815" tips="复制节点链接"></i></h3></div> <p><strong>案例十：除去jsruntime的栈顶后，freeze栈3S和6S执行的系统库代码相同</strong></p> <p>问题背景：</p> <p>Beta用户使用网页在线表格编辑突然卡死，表格点击没反应。</p> <p>定位过程：</p> <p>根据问题单发现，beta用户只提供了AppFreeze和HiLog，没有日志，最好的分析方法是看trace，但崩溃点trace缺失，只能结合AppFreeze和HiLog分析。</p> <p>3S栈：</p> <p><span><img originheight="334" originwidth="1019" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163455.00735312286862521345274251941413:50001231000000:2800:7D8044AE78DD514FF0B39D474D0727B6682CFD27353A13B86098716157CA6070.png" width="920" height="301.55053974484787"></span></p> <p>6S栈：</p> <p><span><img originheight="440" originwidth="1127" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163456.29943840895151105001461918240050:50001231000000:2800:E4A5B3501A96874A8372B9411138EAB6F8C53B7A7A5774C674FFF6F2058B5A0F.png" width="920" height="359.18367346938777"></span>从3s和6s栈可以看出，栈顶都是在libark_jsruntime.so但栈顶不同。由于无法提供trace，只能根据堆栈和日志分析。</p> <p>通过继续查看堆栈可以发现libark_jsruntime.so下面的调用栈3S和6S是相同的，然后跳过libark_jsruntime.so，发现下面在调arkui的深拷贝(getDeepCopyOfObjectRecursive);</p> <p>然后再看对应时间点得日志，可以看到在appfreeze之前的一段时间一直在做GC操作，这说明是应用一直在执行JS逻辑，再结合崩溃栈看，应用是在做一个很大的对象的深拷贝，导致耗时产生了appfreeze。</p> <p><span><img originheight="997" originwidth="1679" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163456.75802074429859723958613661640632:50001231000000:2800:93DB6375424407A1CE2BC9AFCCC0E1DDDF4294A94E1E92DDE5377E31130B5CAB.png" width="920" height="546.3013698630136"></span>分析出结论后，需找ArkUI和应用确认，ArkUI那边的结论与分析结果相同，推断应用应该是用@prop修饰了一个很大的对象，导致深拷贝时耗时；</p> <p>然后找应用确认，应用确认是使用了@prop修饰了大对象，根据arkui的建议进行整改。</p> <p>解决方案：用@prop修饰子组件时，当父组件刷新时子组件对象会进行深拷贝，当子组件很复杂时可能导致拷贝超时，应用排查后改用@ObjectLink修饰，避免深拷贝的开销。</p> <p><strong>案例十一：系统库死锁导致freeze冻屏</strong></p> <p>问题背景：</p> <p>华为视频应用发生freeze，3S和6S栈显示主线程一直在wait。</p> <p>3S栈</p> <p><span><img originheight="245" originwidth="1168" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163456.05721461469736698533727282954560:50001231000000:2800:415F7B06BCD2D580B19C532FE6C8CF13159B8849F8E5F871EA6C2E8003D79D8D.png" width="920" height="192.97945205479454"></span>6S栈</p> <p><span><img originheight="241" originwidth="1143" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163456.70376394253365142980615324820448:50001231000000:2800:08EC63381B8059C72675E6E55F413C771B3A90015C814F023030B54424CEF22D.png" width="920" height="193.98075240594923"></span>定位过程：</p> <p>主线程3S和6S栈相同且一直显示在wait，这种问题一般发生在主线程需要等待其他线程唤醒，而其他线程发生死锁，导致主线程一直wait不到，最终产生冻屏。因此，首先需要确认主线程在等什么线程唤醒，然后再去看对应线程是否存在死锁问题。对于该问题场景，主线程是在UpdateState，说明有其他线程发起了SuspendAll任务去触发SharedGC，而SharedGC又需要等所有线程都走到Suspend状态，初步怀疑是有其他work/taskpool线程发生死锁，导致无法走到Suspend状态。查看堆栈中其他线程的状态，发现18544线程持锁发起了SuspendAll(AllocateWithExpand接口中持有了allocateLock_)，而18545线程调用TryAllocate接口又会等allocateLock_锁，从而导致死锁。</p> <p><span><img height="415.9723152266253" originheight="822" originwidth="1818" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163456.93934811717853743530855046485381:50001231000000:2800:73670D1E1E4D264885ABFE2875CDBFCAA471D86C8E1522952AAD34FF77ED2D09.png" title="点击放大" width="920"></span><span><img originheight="459" originwidth="914" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163456.89177738850542034772027238103780:50001231000000:2800:27F4CF55386D7FE595F2662E566D343927DDFC229B44D20D5177D11E58756D75.png" width="914" height="459"></span></p> <p>解决方案：开发者在写多线程代码时，一定要管理好锁的状态，防止不同线程间发生死锁。对于上述案例，修改方案是不要在持锁状态下发起SuspendAll，修改如下：</p> <p><span><img originheight="537" originwidth="1572" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163456.64858487944562930800406738196505:50001231000000:2800:389B99EF5787595CF20920A8F4FFB9737EB5B663593E6FD25EE6381A4BA46DF1.png" width="920" height="314.2748091603053"></span></p> <div class="tiledSection"><h3 id="section94461123124911">IO问题案例分析<i class="anchor-icon anchor-icon-link" anchorid="section94461123124911" tips="复制节点链接"></i></h3></div> <p><strong>案例十二：读写交替场景频繁写入影响读的性能</strong></p> <p>问题背景：应用启动时发生freeze卡死，瞬时栈:</p> <p><span><img originheight="257" originwidth="1178" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163456.53462180920427934215311199797651:50001231000000:2800:A20DA5D0A7F73187C52770A0AF32B03CF8EC5316397C01EF45E208504BA9D100.png" width="920" height="200.71307300509338"></span>定位过程：</p> <p>瞬时栈相关调用为vm加载abc接口。</p> <p>通过trace信息看到主线程主要耗时在IO操作：</p> <p><span><img originheight="308" originwidth="1178" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163456.45176428438509563114976629444188:50001231000000:2800:A551E79F1B9B7353FC6FA5142DF124CD1A0726F6DF6803A69B9A18322508AE01.png" width="920" height="240.5432937181664"></span><span><img originheight="419" originwidth="1095" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163456.56109676076901548163418436049132:50001231000000:2800:E83BC0D4C3BF997D07F0A06583AA90F3F985D5F313A31CAB6FB0B371350995A0.png" width="920" height="352.0365296803653"></span></p> <p>分析方法</p> <p>lO行为判断不要完全通过trace上的显示io/non-io，要通过唤醒关系来判断，如果Uninterruptible sleep的后面一个runnable，trace上显示是udk-irq线程唤醒，则是IO行为。trace上显示fsverity、fsignature、hmfs_txn，都会与IO行为相关，只是在IO行为上叠加了校验等行为，IO行为分析方向：</p> <p>当前版本已经切换较多文件系统，涉及到IO的线程可能比之前更多，但是唤醒关系上最终都会收敛到udk-irq线程</p> <ul><li>erofs_unzipd - 只读文件系统，IO磁盘读取解压线程</li><li>fsverity_rt/fsignature_rt - 首次IO磁盘读文件校验权限</li><li>hmfs_txn - data目录hmfs IO相关</li></ul> <p>可以看出问题场景IO整体性能差，写入量较大，导致器件频繁gc，降低了器件的IO带宽。同时是读写交替的场景，写入会影响读取的性能，导致部分读IO性能下降。</p> <p>经过分析问题读写场景，后台有BMS进行安装，安装过程中需拷贝三次hap，IO量大，导致读IO性能下降，产生freeze。</p> <p>解决方案：在原本的应用安装流程中，会经历三次hap包的拷贝，导致IO写入量很大，包管理子系统最终的优化方案是优化最后一次hap包拷贝的耗时，将copy该成rename。</p> <p><span><img height="131.67000000000002" originheight="385" originwidth="1528" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163456.38495052368788659592285213402671:50001231000000:2800:FB1C235BD847D17E171E111748848F38C8DC451D3C5A83B7AFE60340E9B711AC.png" title="点击放大" width="523.6875"></span></p> <p>安装流程</p> <ol><li>应用市场线程从网络下载应用hap包，先保存在tmp文件中，共2.6G。</li><li>下载完毕后将tmp文件rename为entry.hap，此步无IO。</li><li>应用市场线程调用BMS的StreamInstall接口，将hap包写入el1的stream_install文件夹中（正常从应用市场目录拷贝到bms的目录），共2.6G。</li><li>foundation的BMS线程将hap从stream_install复制到security_stream_install中（因为安全问题，步骤3的fd返回给应用市场客户端会有被纂改的风险，额外拷贝一次安全目录），共2.6G。</li><li>installs线程从hap包中解压名种so文件，共300M。</li><li>installs线程从security_stream_install文件夹将entry.hap复制到应用沙箱中，共2.6G。</li><li>安装完成后先后删除el1两文件夹中的hap、应用市场沙箱中的hap。</li></ol> <div class="tiledSection"><h2 id="section9167104875910">小结<i class="anchor-icon anchor-icon-link" anchorid="section9167104875910" tips="复制节点链接"></i></h2></div> <p>对于Freeze冻屏问题，需要结合freeze栈、trace、log三方面信息进行准备定位定界。需要提取出典型问题特征，根据这些特征初步定位是应用自身问题、系统库问题、调度问题还是IO问题，再进一步判断是代码逻辑复杂、接口调用频繁还是死锁等问题，最后针对问题根因确认解决方案。</p> </div> <div></div></div>