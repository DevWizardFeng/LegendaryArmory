<h1 _ngcontent-hjc-c119="" class="doc-title ng-star-inserted" title="模块化设计"> 模块化设计 </h1>

<div _ngcontent-hjc-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;"> <div><div class="tiledSection"><h2 id="section9761182222417">模块化设计理念<i class="anchor-icon anchor-icon-link" anchorid="section9761182222417" tips="复制节点链接"></i></h2><p>在大型软件工程中，一般会伴随多团队参与开发。各团队之间以弱耦合方式交互，通过契约化接口定义业务之间的交互，确保各团队业务独立发展，互不影响，实现快速迭代演进。业务模块化是现代软件工程的核心原则之一，通过将大型复杂系统拆解为更小、更易管理和理解的功能模块，提高系统的可维护性和可扩展性。每个功能模块都是独立单元，具有清晰定义的接口和职责，能够与其他模块交互以完成复杂任务。</p> </div> <p>在HarmonyOS应用开发中，模块化既是设计原则，也是开发实践。该原则要求将应用程序拆分为多个功能模块，每个模块负责特定功能或特性。这些模块可以独立开发、编译和部署，也可以在不同设备上灵活组合和调用。</p> <div class="tiledSection"><h2 id="section11283442122812">应用程序包结构概念<i class="anchor-icon anchor-icon-link" anchorid="section11283442122812" tips="复制节点链接"></i></h2><p>在进行模块化设计时，需要考虑HarmonyOS的应用包结构选型，HarmonyOS的应用包结构用于定义应用的组织方式。通过开发态、编译态、发布态阶段的应用程序包形态，可以了解不同包类型的具体使用场景及规则。详细请参见<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/application-package-structure-stage" target="_blank">Stage模型应用程序包结构</a>。</p> </div> <div class="tiledSection"><h2 id="section591504125510">UIAbility应用组件设计<i class="anchor-icon anchor-icon-link" anchorid="section591504125510" tips="复制节点链接"></i></h2><p>HarmonyOS应用的业务逻辑需要通过<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/uiability-overview" target="_blank">UIAbility组件</a>承载，根据业务设备以及业务诉求不同，需要考虑UIAbility组件的选择以及设计。在多设备的背景下，应用的形态不一定是传统移动设备上的单任务单窗口形式，在一些场景下，多任务多窗口的形态可以让用户获得更好的用户体验，提升使用效率。</p> <p>例如在手机设备上：</p> <ul><li>笔记应用，可让用户将信息从笔记的一页复制到另一页。</li><li>文档编辑应用，可让用户同时打开编辑多个文档，可让用户将内容从一个文档复制或移动到另一个文档。</li><li>导航/打车应用，可以让导航后台运行，回到主页查找新的位置信息或其它信息。</li><li>购物类临时客服界面，可让用户通过任务管理快速从商品浏览页切换回到客服会话界面，避免用户一层层打开查找。</li><li>在应用支付/登录页面，用户可以切换到其他页面查找并复制相关信息。</li></ul> <p>在大屏设备上，应用内的多个任务可以以多窗口的形式存在，用户可以并行操作应用的不同功能。</p> <ul><li>视频播放器应用，可让用户在观看播放内容的同时浏览其他可能感兴趣的视频列表。</li><li>电子邮件应用，可让用户在撰写电子邮件的同时查看收到的邮件列表。</li><li>地址簿应用，可让用户并排比较多个人员的联系信息。</li><li>阅读应用，可让用户在查阅所有标题概要后，打开多篇文章供稍后阅读。</li></ul> <p>对于这种类似独立应用的任务，每个任务对应一个UIAbility组件实例，每个任务可以单独显示一个窗口。用户可以在同一应用的不同任务间切换，就像单独的应用一样。在大屏设备上，可以独立移动、调整大小、显示和隐藏应用窗口。所以在进行功能设计时，需考虑应用是否支持多任务多窗口，这影响整体工程模块化结构。</p> <ul><li>对于单Ability的情况，可以对应单窗口类型应用、通过多实例实现的多任务应用，或通过指定实例实现的多任务应用。例如，普通游戏应用建议采用单HAP来承载UIAbility。</li><li>对于多Ability有两种情况：<ul><li>对于多窗口类型的应用，每个窗口对应不同的功能，通过不同的UIAbility承载。如上述例子中导航/打车应用中，导航功能界面和主页属于不同的功能，并且作为两个任务呈现给用户。可以将该模块作为Feature类型的HAP承载相应的UIAbility组件。</li><li>对于应用的拓展功能，如卡片和分享业务，这些功能不会作为单独的任务和窗口形态运行。由于这些功能相对独立，并且由系统提供的独立<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/extensionability-overview" target="_blank">ExtensionAbility</a>承载，从更好地拆分业务的角度考虑，建议通过Feature类型的HAP承载单独的ExtensionAbility组件。</li></ul> </li></ul> </div> <div class="tiledSection"><h2 id="section162192817358">应用模块化选型<i class="anchor-icon anchor-icon-link" anchorid="section162192817358" tips="复制节点链接"></i></h2><p>应用架构旨在实现业务服务，从技术角度思考业务实现方式；工程模块化模型则基于技术架构，对代码工程进行模块化选型，需要考虑技术如何在代码工程中落地，只有代码工程模型的技术选型合理了，才能在包体积、性能、产品部署等取得一个最优的综合表现。</p> <p>业务通常分为多个模块，例如某购物软件，包含主页导航、商品详情、购物车、支付、订单、个人信息等模块。技术架构上，这些业务模块表现为高内聚低耦合的模块（Module）。在代码工程模块化的技术选型中，由于Entry类型的HAP是工程默认存在的且不能存在多个，所以主要考虑的模块类型有：Feature类型的HAP模块、HAR模块和HSP模块。</p> <p>在技术架构中选择代码模块类型时，需要根据业务特性和模块功能等多方面因素综合评估。基于常见的应用模块化模型，以下是几种实际业务中可能遇到的情况：</p> <ol><li><a href="/consumer/cn/doc/best-practices/bpta-modular-design#section72105319817">共享模块</a>：某个功能模块（业务模块或者能力模块）需要在多个应用之间共享其代码逻辑和资源。</li><li><a href="/consumer/cn/doc/best-practices/bpta-modular-design#section28312051291">按需加载模块</a>：某个功能模块，使用时由用户决定安装时机，动态从应用市场下载安装使用。</li><li><a href="/consumer/cn/doc/best-practices/bpta-modular-design#section9492615385">多HAP/HSP引用相同HAR包的影响</a>：从性能角度出发，需要减少多HAP/HSP对相同HAR包的引用。</li></ol> </div> <div class="tiledSection"><h3 id="section72105319817" class="firsth2">共享模块<i class="anchor-icon anchor-icon-link" anchorid="section72105319817" tips="复制节点链接"></i></h3><p>对于大型软件，不同业务和基础能力由多个团队开发，各团队之间需要代码仓隔离。如果某个或若干个HAR工程模块由某个团队负责，又想代码仓隔离，可以在独立工程中开发这些HAR，并通过公司私有的OHPM仓发布和集成编译产物。如下图所示。</p> <div class="fignone"><span class="figcap"><b>图1 </b>多工程合作模式</span><br><span><img height="252.6468" originheight="760" originwidth="1607" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211162857.06910937548115993487131247871848:50001231000000:2800:7DD54DF23DA6BBB9C1C02EB11CBD698C1219133D2B0E2AE4F3A59C07F15C75FA.png" title="点击放大" width="532"></span></div> <p>这部分可以发布到OHPM仓的模块，叫做共享模块，可以将公共能力共享给多个应用使用，如公司内部多个应用使用某个公共能力网络库；或者也可以将该公共能力封装成库贡献给社区，给其他应用集成使用，这样的话这个模块也只能是HAR模块。</p> </div> <div class="tiledSection"><h3 id="section28312051291">按需加载模块<i class="anchor-icon anchor-icon-link" anchorid="section28312051291" tips="复制节点链接"></i></h3><p>随着应用业务的扩展，应用为用户提供的功能不断增加。然而，不是所有功能都是用户频繁使用的。根据用户运营报告的分析，对于月活跃度较低的功能，可以将其设计为按需加载模块。用户首次从应用市场安装时，只会下载不包含按需加载模块的内容。当用户需要使用特定功能时，可以选择下载并安装相应的功能模块。</p> <p>按需加载模块有以下好处：</p> <ul><li>减少包体积：用户从应用市场首次下载的应用不包含按需加载模块，用户看到的包体积减少，从而减少了用户下载和安装时间，减少了用户等待时间。</li><li>减少系统资源：应用安装之后所占用的空间也变少（节省ROM空间），应用启动时加载的特性少了（节省了RAM空间）。</li><li>架构演进：定义为按需加载的特性明确，模块间耦合关系清晰，有利于应用架构演进。</li></ul> <p>如果某个特性做成了按需加载模块，该模块可以设计为Feature类型的HAP或者HSP，HAP和HSP都可以实现按需加载，区别在于Feature类型的HAP可以包含UIAbility组件，结合前面的<a href="/consumer/cn/doc/best-practices/bpta-modular-design#section591504125510">UIAbility应用组件设计</a>以及业务是否需要按需加载，从整体上可以划分两个大的场景如下：</p> <ul><li>单HAP场景：如果只包含一个UIAbility组件（包括UIAbility多实例/指定实例），无需使用ExtensionAbility组件，优先采用单HAP（Entry类型的HAP）来实现应用开发，其中根据是否需要实现按需加载的来决定选择HSP或者HAR作为模块。</li><li>多HAP场景：要实现多任务承载多个UIAbility组件以及使用ExtensionAbility组件实现扩展功能，可以采用多HAP（即一个Entry类型的HAP和多个Feature类型的HAP）来开发应用。每个HAP包含一个UIAbility组件或一个ExtensionAbility组件。在多HAP情况下，根据是否具有公共能力选择模块类型。</li></ul> <p>应用组件的设计决定了模块化设计是采用单HAP工程还是多HAP工程。设计初期需考虑应用的任务形态，以确定合适的模块化结构。</p> </div> <div class="tiledSection"><h3 id="section9492615385">多HAP/HSP引用相同HAR包的影响<i class="anchor-icon anchor-icon-link" anchorid="section9492615385" tips="复制节点链接"></i></h3><p>在应用开发的过程中，可以使用<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/in-app-hsp" target="_blank">HSP</a>或<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/har-package" target="_blank">HAR</a>的共享包方式将同类的模块进行整合，用于实现多个模块或多个工程间共享ArkUI组件、资源等相关代码。</p> <p>在多HAP/HSP引用相同HAR包时，由于共享包的动态和静态差异，HAR包中的单例可能失效，影响应用冷启动性能。</p> <div class="fignone"><span class="figcap"><b>图2 </b>HAP包和HSP包分别引用相同HAR包</span><br><span><img height="172.9133" originheight="777" originwidth="2403" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211162857.16806867192336449283646085487128:50001231000000:2800:40715C80E855DC5EBAA0289AC09F2C3C8C10972DCE83CA540A9A18EEB8B0D9E6.png" title="点击放大" width="532"></span></div> <p>如上图所示，工程内包含三个模块：HAP包作为应用主入口模块，HSP包作为应用主界面显示模块，HAR_COMMON集成了所有通用工具类，其中funcResult是func方法的执行结果。</p> <p>当HAP和HSP模块同时引用HAR_COMMON模块时，会破坏HAR的单例模式。因此，HAP和HSP模块在使用HAR_COMMON中的funcResult时，会导致func方法在两个模块加载时各执行一次，从而增加文件的执行时间。</p> <p>仅从性能角度考虑，可以采用以下方式进行修改，以缩短冷启动阶段的耗时。</p> <div class="fignone"><span class="figcap"><b>图3 </b>切换为HAP包和HAR包分别引用相同HAR包</span><br><span><img height="172.9133" originheight="777" originwidth="2403" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211162857.35662184845450072000014294013036:50001231000000:2800:E3A1D22C55A28E09147DC4FF0EF8F44FDA748097226DD53C36927CDB3C5C3E8F.png" title="点击放大" width="532"></span></div> <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"><ul><li>在多HAP/HSP引用相同HAR包的情况下，如果HSP包和HAR包均能满足业务需求，建议将HSP包改为HAR包。</li><li>若使用的HSP为<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/integrated-hsp" target="_blank">集成态HSP</a>，可跳过该优化方案。</li></ul> </div></div></div> <ol><li>在被引用HAR_COMMON包中写入功能示例。<div class="screenLinkPre"><div _ngcontent-hjc-c106="" class="highlight-div"><div _ngcontent-hjc-c106="" class="highlight-div-header"><div _ngcontent-hjc-c106="" class="highlight-div-header-left"><div _ngcontent-hjc-c106="" class="handle-button expand-button"><div _ngcontent-hjc-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-hjc-c106="" class="highlight-div-header-right"><div _ngcontent-hjc-c106="" class="handle-button ai-button"></div><div _ngcontent-hjc-c106="" class="handle-button line-button"><div _ngcontent-hjc-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-hjc-c106="" class="handle-button theme-button"><div _ngcontent-hjc-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-hjc-c106="" class="handle-button copy-button"><div _ngcontent-hjc-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-hjc-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-javascript" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/HapAndHarDependHar/har_common/src/main/ets/utils/Utils.ets#L21-L32" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// har_common/src/main/ets/utils/Utils.ets</span></li><li><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">LARGE_NUMBER</span> = <span class="hljs-number">100000000</span>;</li><li>
</li><li><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params"></span>): number {</li><li>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;</li><li>  <span class="hljs-keyword">while</span> (count &lt; <span class="hljs-variable constant_">LARGE_NUMBER</span>) {</li><li>    count++;</li><li>  }</li><li>  <span class="hljs-keyword">return</span> count;</li><li>}</li><li>
</li><li><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> funcResult = <span class="hljs-title function_">func</span>();</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/HapAndHarDependHar/har_common/src/main/ets/utils/Utils.ets#L21-L32" target="_blank">Utils.ets</a></div></div></div></div> </li><li>分别通过使用HSP包和HAR包来引用该HAR_COMMON包中的功能进行性能对比实验。<ul><li>使用HAP包和HSP包引用该HAR_COMMON包中的功能。<p>HAP包引用HAR_COMMON包中的功能。</p> <div class="screenLinkPre"><div _ngcontent-hjc-c106="" class="highlight-div"><div _ngcontent-hjc-c106="" class="highlight-div-header"><div _ngcontent-hjc-c106="" class="highlight-div-header-left"><div _ngcontent-hjc-c106="" class="handle-button expand-button"><div _ngcontent-hjc-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-hjc-c106="" class="highlight-div-header-right"><div _ngcontent-hjc-c106="" class="handle-button ai-button"></div><div _ngcontent-hjc-c106="" class="handle-button line-button"><div _ngcontent-hjc-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-hjc-c106="" class="handle-button theme-button"><div _ngcontent-hjc-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-hjc-c106="" class="handle-button copy-button"><div _ngcontent-hjc-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-hjc-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-javascript" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/HapAndHarDependHar/entry/src/main/ets/pages/Index.ets#L21-L23" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// entry/src/main/ets/pages/Index.ets</span></li><li><span class="hljs-keyword">import</span> { <span class="hljs-title class_">MainPage</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'har_library'</span>;</li><li><span class="hljs-keyword">import</span> { funcResult } <span class="hljs-keyword">from</span> <span class="hljs-string">'har_common'</span>;</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/HapAndHarDependHar/entry/src/main/ets/pages/Index.ets#L21-L23" target="_blank">Index.ets</a></div></div></div></div> <div class="p">HSP包引用HAR_COMMON包中的功能。<div class="screenLinkPre"><div _ngcontent-hjc-c106="" class="highlight-div"><div _ngcontent-hjc-c106="" class="highlight-div-header"><div _ngcontent-hjc-c106="" class="highlight-div-header-left"><div _ngcontent-hjc-c106="" class="handle-button expand-button"><div _ngcontent-hjc-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-hjc-c106="" class="highlight-div-header-right"><div _ngcontent-hjc-c106="" class="handle-button ai-button"></div><div _ngcontent-hjc-c106="" class="handle-button line-button"><div _ngcontent-hjc-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-hjc-c106="" class="handle-button theme-button"><div _ngcontent-hjc-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-hjc-c106="" class="handle-button copy-button"><div _ngcontent-hjc-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-hjc-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-javascript" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/HapAndHarDependHar/har_library/src/main/ets/components/mainpage/MainPage.ets#L21-L22" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// har_library/src/main/ets/pages/MainPage.ets</span></li><li><span class="hljs-keyword">import</span> { funcResult } <span class="hljs-keyword">from</span> <span class="hljs-string">'har_common'</span>;</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/HapAndHarDependHar/har_library/src/main/ets/components/mainpage/MainPage.ets#L21-L22" target="_blank">MainPage.ets</a></div></div></div></div> </div> </li><li>使用HAP包和HAR包引用该HAR_COMMON包中的功能。<p>HAP包引用HAR_COMMON包中的功能。</p> <div class="screenLinkPre"><div _ngcontent-hjc-c106="" class="highlight-div"><div _ngcontent-hjc-c106="" class="highlight-div-header"><div _ngcontent-hjc-c106="" class="highlight-div-header-left"><div _ngcontent-hjc-c106="" class="handle-button expand-button"><div _ngcontent-hjc-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-hjc-c106="" class="highlight-div-header-right"><div _ngcontent-hjc-c106="" class="handle-button ai-button"></div><div _ngcontent-hjc-c106="" class="handle-button line-button"><div _ngcontent-hjc-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-hjc-c106="" class="handle-button theme-button"><div _ngcontent-hjc-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-hjc-c106="" class="handle-button copy-button"><div _ngcontent-hjc-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-hjc-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-javascript" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/HapAndHarDependHar/entry/src/main/ets/pages/Index.ets#L21-L23" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// entry/src/main/ets/pages/Index.ets</span></li><li><span class="hljs-keyword">import</span> { <span class="hljs-title class_">MainPage</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'har_library'</span>;</li><li><span class="hljs-keyword">import</span> { funcResult } <span class="hljs-keyword">from</span> <span class="hljs-string">'har_common'</span>;</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/HapAndHarDependHar/entry/src/main/ets/pages/Index.ets#L21-L23" target="_blank">Index.ets</a></div></div></div></div> <div class="p">HAR包引用HAR_COMMON包中的功能。<div class="screenLinkPre"><div _ngcontent-hjc-c106="" class="highlight-div"><div _ngcontent-hjc-c106="" class="highlight-div-header"><div _ngcontent-hjc-c106="" class="highlight-div-header-left"><div _ngcontent-hjc-c106="" class="handle-button expand-button"><div _ngcontent-hjc-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-hjc-c106="" class="highlight-div-header-right"><div _ngcontent-hjc-c106="" class="handle-button ai-button"></div><div _ngcontent-hjc-c106="" class="handle-button line-button"><div _ngcontent-hjc-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-hjc-c106="" class="handle-button theme-button"><div _ngcontent-hjc-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-hjc-c106="" class="handle-button copy-button"><div _ngcontent-hjc-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-hjc-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-javascript" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/HapAndHarDependHar/har_library/src/main/ets/components/mainpage/MainPage.ets#L21-L22" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// har_library/src/main/ets/pages/MainPage.ets</span></li><li><span class="hljs-keyword">import</span> { funcResult } <span class="hljs-keyword">from</span> <span class="hljs-string">'har_common'</span>;</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/HapAndHarDependHar/har_library/src/main/ets/components/mainpage/MainPage.ets#L21-L22" target="_blank">MainPage.ets</a></div></div></div></div> </div> </li></ul> </li></ol> <p>使用<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-insight-session-launch" target="_blank">Launch模板</a>，对优化前后启动性能进行对比分析。</p> <p>分析阶段的起点为启动Ability（即H:void OHOS::AppExecFwk::MainThread::HandleLaunchAbility的开始点），阶段终点为应用第一次接到vsync（即H:ReceiveVsync dataCount:24Bytes now:timestamp expectedEnd:timestamp vsyncId:int的开始点）。</p> <div class="fignone"><span class="figcap"><b>图4 </b>优化前，使用HSP包</span><p><span><img height="148.2418" originheight="295" originwidth="1588" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211162857.20088068195200494872067010115116:50001231000000:2800:333F09E4648D5F5747A9B655710F86FCDB3F5E0D57511309321049C5A00B4DE1.png" title="点击放大" width="798"></span></p> </div> <div class="fignone"><span class="figcap"><b>图5 </b>优化后，使用HAR代替HSP</span><p><span><img height="161.3689" originheight="311" originwidth="1538" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211162858.99735180510603991449407645240960:50001231000000:2800:AC5664F6F4DC791C877574B2F4EA824E97344E809F1F81786BDF7627E80C93D5.png" title="点击放大" width="798"></span></p> </div> <p>优化前后的对比数据如下：</p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.8.16.1.3.1.1" valign="top" width="50%"><p>方案</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.8.16.1.3.1.2" valign="top" width="50%"><p>阶段时长(毫秒)</p> </th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="50%"><p>（优化前）使用HSP包</p> </td> <td class="cellrowborder" valign="top" width="50%"><p>3125</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="50%"><p>（优化后）使用HAR代替HSP</p> </td> <td class="cellrowborder" valign="top" width="50%"><p>853.9</p> </td> </tr>  </tbody></table></div> </div> <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"><p>上述示例为凸显出差异，func执行函数循环次数为100000000，开发者实际修改后收益需根据实际情况测试。</p> </div></div></div> <p>测试数据表明，将HSP替换为HAR包后，应用启动耗时明显缩短。</p> </div> <div class="tiledSection"><h2 id="section161201458513">单HAP工程<i class="anchor-icon anchor-icon-link" anchorid="section161201458513" tips="复制节点链接"></i></h2><p>对于单窗口应用的APP工程，其仅包含一个Entry类型的HAP。划分的模块则根据是否有按需加载的需求，来考虑采用HAR模块和HSP模块。</p> </div> <div class="tiledSection"><h3 id="section8276151619319" class="firsth2">不包含按需加载模块<i class="anchor-icon anchor-icon-link" anchorid="section8276151619319" tips="复制节点链接"></i></h3><p>对于不需要按需加载且仅包含一个Entry类型的HAP的App，可以直接全部采用HAR进行开发设计。如下图所示：</p> <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"><p>这里提到的“仅有一个HAP”是指一种设备类型仅包含一个HAP，而不是指.app文件包中仅有一个HAP。.app文件包可以包含其他设备的HAP包，例如手表和大屏设备的HAP包，以支持多设备分发。</p> </div></div></div> <div class="fignone"><span class="figcap"><b>图6 </b>非按需加载工程模型</span><br><span><img height="355.28290000000004" originheight="945" originwidth="1418" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211162858.23795246655996375337376440237368:50001231000000:2800:843E6D8BC9A0F4ED4EFAC9D9DC59BF0960F3287BAD0B9DE0874FB44B9C1C17BD.png" title="点击放大" width="532"></span></div> <p>上图工程架构中，除了产品模块层中与设备相关的HAP外，其他模块均为HAR。这些被依赖的HAR最终都会被编译进HAP中。</p> <p>设计成HAR包有以下优点：</p> <ol><li>全部编译进HAP，无额外的HSP，节省HSP的安装和加载成本。</li><li>HAR在编译进HAP时，可以利用ArkTS的语言特性和编译器功能，做类型推断和编译优化。</li><li>代码工程架构简单，后续演进较为灵活。</li></ol> </div> <div class="tiledSection"><h3 id="section1079344610211">包含按需加载模块<i class="anchor-icon anchor-icon-link" anchorid="section1079344610211" tips="复制节点链接"></i></h3><p>在单HAP工程中实现按需加载功能时，对应的组件需采用HSP作为按需加载模块。HAR是静态共享库，若多个HAP或HSP依赖同一份HAR，该HAR在应用内会被重复存储。HSP是动态共享库，其安装和加载会有性能损失，过多的HSP可能影响安装效率和App启动性能。需考虑App占用空间是否受限及启动性能的敏感度，根据业务需求在App Size与启动性能之间做好平衡。</p> <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"><p>这里提到的App Size指用户安装按需加载模块后，应用的整体大小。</p> </div></div></div> <p><strong>App Size优先</strong></p> <p>对于App Size优先的，可以考虑将公共依赖的模块封装在一个HSP模块壳中，如下图所示：</p> <div class="fignone"><span class="figcap"><b>图7 </b>公共依赖模块通过HSP模块壳承载</span><br><span><img height="441.4935" originheight="2275" originwidth="1973" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211162858.00476427502427246402526604743338:50001231000000:2800:A598A0DA0478BB05C281E3AAE568926C39C2C89FEE021CFF849F1D61A2FDCA09.png" title="点击放大" width="383.04"></span></div> <p>hap_A依赖于独有的共享库har_A，同时需要依赖于har_C和har_D；而按需加载模块hsp_B依赖于独有的共享库har_B，同时需要依赖于har_C和har_D。</p> <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"><p>这里的共享库har_A、har_B、har_C、har_D不一定本地工程，有可能是从ohpm仓上依赖下载的。</p> </div></div></div> <p>因为har_C和har_D同时被hap_A和hsp_B工程所依赖，所以为了节省App Size，可以将其封装到名为“common_hsp”的Module中，对外暴露har_C和har_D的接口，将har_C和har_D打包到common_hsp中，最后让hap_A和hsp_B依赖于common_hsp工程。common_hsp工程是无实际意义的，它仅是一个“模块壳”，是为了最小化App Size而存在的。</p> <p><strong>性能优先</strong></p> <p>对于性能优先的，则不需要再封装一个公共的HSP模块，直接依赖公共HAR包：</p> <div class="fignone"><span class="figcap"><b>图8 </b>公共依赖模块使用HAR模块承载</span><br><span><img height="399.6916" originheight="2059" originwidth="1973" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211162858.43494013439757348081867790268389:50001231000000:2800:D995F4D28226C7BA01A49CD054C23C6B004B59AFA0F06C023852791F4E9EAC1C.png" title="点击放大" width="383.04"></span></div> <p>因为公共HSP包需要安装和加载，所以会有一些性能损耗。对于启动性能敏感型的应用，则将hap_A和hsp_B直接依赖于har_C和har_D。最终编译产物里面有2个，hap_A.hap和hsp_B.hsp，但是这两个编译产物里面均会包含har_C和har_D，App Size会比采用公共HSP模型大。</p> </div> <div class="tiledSection"><h2 id="section1260019161216">多HAP工程<i class="anchor-icon anchor-icon-link" anchorid="section1260019161216" tips="复制节点链接"></i></h2><p>对于同一个设备类型，如果要实现不同的独立功能模块，并且相对独立，以及具有单独的入口的功能特性，建议做成一个独立特性的HAP，按需下载安装。此时一个App包中，就会有多个HAP包，其中有且仅有一个Entry类型的HAP，其他的均是Feature类型的HAP。多HAP之间业务独立，但是可能会有业务能力共享，所以在进行模块化设计时，需要根据是否具有公共能力来进行选择。</p> </div> <div class="tiledSection"><h3 id="section64326249113" class="firsth2">包含公共能力模块<i class="anchor-icon anchor-icon-link" anchorid="section64326249113" tips="复制节点链接"></i></h3><p>对于具备公共能力模块的工程，和上述HAP+HSP组合是类似的，需要考虑在App Size与启动性能之间做平衡。</p> <p><strong>性能优先</strong></p> <p>一般多HAP应用架构普适性采用以下模型，除了产品组件中存在HAP包之外，其余的均是HAR包，如下图所示：</p> <div class="fignone"><span class="figcap"><b>图9 </b>多HAP工程模块示意图</span><br><span><img height="335.8915" originheight="1006" originwidth="2238" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211162858.72154372795598376074688174559395:50001231000000:2800:9548C74E761AC38E3343E8C0C5756904738A844C9A72C53BBDC5D26B684CBED6.png" title="点击放大" width="744.8000000000001"></span></div> <p>编译产物中，多个HAP之间存在相同的HAR包（如har_2、har_3、har_C、har_D、har_E）。这种情况下，App Size可能会增大。如果App Size不是应用的瓶颈，或者HAR包的大小较小，对App Size的影响可控，可以采用这种模型，从而减少动态加载的性能损耗。</p> <p><strong>App Size 优先</strong></p> <p>上述问题的本质在于如何在HAP和HSP之间分布HAR包，以最小化App的大小并减少HAR的重复编译和打包。主要思路是将公共能力模块封装为公共HSP，从而最小化App Size。如下图所示：</p> <div class="fignone"><span class="figcap"><b>图10 </b>多HAP工程模块示意图</span><br><span><img height="388.90530000000007" originheight="2291" originwidth="4393" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211162858.45770293682391383524540585136078:50001231000000:2800:322A627D6E3C595466CAF4F535B3752C34BF50AE67DA966DEC5239E22EBCDE15.png" title="点击放大" width="744.8000000000001"></span></div> <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"><p>需要注意，在应用间共享的HAR包，原则上是不允许依赖HSP包，因为HSP包是专属于应用，和bundleName进行了绑定，一旦HAR包依赖于应用内HSP，该HAR包就丢失了共享性，无法再给其他应用共享。</p> </div></div></div> <p>如上图所示，有3个HAP包（1个entry和2个feature），将公共的HAR包封装到HSP工程中，例如common_wrap_hsp和feature_wrap_hsp。这两个HSP从严格意义上讲，不能称为模块，仅称为模块壳，用于合理放置模块在编译产物中的位置，不具备模块功能，不能共享，仅能在App应用内使用，依赖这些模块壳的模块也无法在应用间共享。</p> <p>上述的模型通过HSP将HAR包合理分配到编译产物中，确保每个HAR包在App编译产物中仅出现一次，从而减小App Size。模块壳数量不宜过多，否则可能影响安装速度和启动性能。</p> <p>这两种模型都是理想模型，业务模型通常是两者的平衡态或组合。例如，某个共享库代码和资源较少，占用空间较小，如打印日志模块。将该模块编译进所有编译产物中，App Size增加较少，同时性能较好。</p> </div> <div class="tiledSection"><h3 id="section159889245016">不包含公共能力模块<i class="anchor-icon anchor-icon-link" anchorid="section159889245016" tips="复制节点链接"></i></h3><p>这种应用较少，即使有的话也是一些规模较小的应用，可以参考单HAP的场景。</p> </div> <div class="tiledSection"><h2 id="section147042331915">总结<i class="anchor-icon anchor-icon-link" anchorid="section147042331915" tips="复制节点链接"></i></h2><p>应用开发者需根据技术架构选择适合的工程模块化模型。工程模块化模型需根据业务和技术架构演进而演进。根据诉求在HAP、HAR和HSP中选择使用。</p> </div> <p>对于具备独立运行和安装的模块只能选择HAP包，并将其作为Feature类型的HAP存在于App中；对于不具备独立特性部分，用户使用频率较少的模块，将其做成HSP按需加载模块存在于App中。对于需要共享的模块，只能采用HAR包，将其通过OHPM仓共享给其他工程使用。而HAR是静态共享库，在多HAP或者按需加载场景下，在编译后可能会在物理上存在多份，所以需要合理采用公共HSP模块壳，使App Size最小化。</p> </div></div>