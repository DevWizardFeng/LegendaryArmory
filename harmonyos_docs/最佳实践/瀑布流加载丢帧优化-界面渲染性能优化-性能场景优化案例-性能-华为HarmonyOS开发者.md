<h1 _ngcontent-stb-c119="" class="doc-title ng-star-inserted" title="瀑布流加载丢帧优化"> 瀑布流加载丢帧优化 </h1>

<div _ngcontent-stb-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;">   <div>    <div class="tiledSection">     <h2 id="section088318458314">概述<i class="anchor-icon anchor-icon-link" anchorid="section088318458314" tips="复制节点链接"></i></h2>          <p>瀑布流是应用开发中常见的场景。它通过容器布局规则将元素排列为多列不对齐的界面，内容像瀑布一样从上而下倾泻。瀑布流适用于展示图片资讯、购物商品、直播视频等多种数据。当瀑布流上下滑动时，无限加载特性使其能展示大量数据；不同大小的子元素会带来测量和绘制的性能消耗。</p>     <p></p>     <p>在瀑布流的高频场景中，性能优化是关键，包括加快渲染速度、提升滑动帧率、降低内存占用等，从而显著提升应用流畅度和用户体验。对于希望快速实现的开发者，可使用ScrollComponents库直接创建流畅滑动的瀑布流，该库内置组件复用、懒加载、复用池共享等优化能力，并支持预创建和预加载，大幅减少开发者的性能调优成本，具体实现细节和最佳实践可参考<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-waterflow-based-on-scrollcomponents" target="_blank">《基于ScrollComponents实现瀑布流》</a>。</p>     <p>本文将介绍懒加载、数据缓存、组件复用、无限滑动、固定宽高场景优化瀑布流滑动。</p>    </div>    <div class="tiledSection">     <h2 id="section125201667329">懒加载<i class="anchor-icon anchor-icon-link" anchorid="section125201667329" tips="复制节点链接"></i></h2>          <p><span style="color: rgb(36,41,46);">先看一下组件示例代码中瀑布流的基本用法：</span></p>     <div class="screenLinkPre"><div _ngcontent-stb-c106="" class="highlight-div"><div _ngcontent-stb-c106="" class="highlight-div-header"><div _ngcontent-stb-c106="" class="highlight-div-header-left"><div _ngcontent-stb-c106="" class="handle-button expand-button"><div _ngcontent-stb-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-stb-c106="" class="highlight-div-header-right"><div _ngcontent-stb-c106="" class="handle-button ai-button"></div><div _ngcontent-stb-c106="" class="handle-button line-button"><div _ngcontent-stb-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-stb-c106="" class="handle-button theme-button"><div _ngcontent-stb-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-stb-c106="" class="handle-button copy-button"><div _ngcontent-stb-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-stb-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-typescript" codehub="https://gitee.com/harmonyos_samples/PageSlip/blob/master/entry/src/main/ets/pages/WaterFlowPage.ets#L76-L101" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) {</li><li>  <span class="hljs-title class_">Column</span>({ <span class="hljs-attr">space</span>: <span class="hljs-number">2</span> }) {</li><li>    <span class="hljs-title class_">WaterFlow</span>({ <span class="hljs-attr">footer</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">itemFoot</span>() }) {</li><li>      <span class="hljs-title class_">LazyForEach</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">dataSource</span>, <span class="hljs-function">(<span class="hljs-params">item: <span class="hljs-built_in">number</span></span>) =&gt;</span> {</li><li>        <span class="hljs-title class_">FlowItem</span>() {</li><li>          <span class="hljs-title class_">Column</span>() {</li><li>            <span class="hljs-title class_">Text</span>(<span class="hljs-string">"N"</span> + item).<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">12</span>).<span class="hljs-title function_">height</span>(<span class="hljs-string">'16'</span>)</li><li>            <span class="hljs-title class_">Image</span>(<span class="hljs-string">'res/waterFlowTest('</span> + item % <span class="hljs-number">5</span> + <span class="hljs-string">').jpg'</span>)</li><li>              .<span class="hljs-title function_">objectFit</span>(<span class="hljs-title class_">ImageFit</span>.<span class="hljs-property">Fill</span>)</li><li>              .<span class="hljs-title function_">width</span>(<span class="hljs-string">'100%'</span>)</li><li>              .<span class="hljs-title function_">layoutWeight</span>(<span class="hljs-number">1</span>)</li><li>          }</li><li>        }</li><li>        .<span class="hljs-title function_">width</span>(<span class="hljs-string">'100%'</span>)</li><li>        .<span class="hljs-title function_">height</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">itemHeightArray</span>[item % <span class="hljs-number">100</span>])</li><li>        .<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">colors</span>[item % <span class="hljs-number">5</span>])</li><li>      }, <span class="hljs-function">(<span class="hljs-params">item: <span class="hljs-built_in">string</span></span>) =&gt;</span> item)</li><li>    }</li><li>    .<span class="hljs-title function_">columnsTemplate</span>(<span class="hljs-string">"1fr 1fr"</span>)</li><li>    .<span class="hljs-title function_">columnsGap</span>(<span class="hljs-number">10</span>)</li><li>    .<span class="hljs-title function_">rowsGap</span>(<span class="hljs-number">5</span>)</li><li>    .<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-number">0xFAEEE0</span>)</li><li>    .<span class="hljs-title function_">width</span>(<span class="hljs-string">'100%'</span>)</li><li>    .<span class="hljs-title function_">height</span>(<span class="hljs-string">'100%'</span>)</li><li>  }</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/PageSlip/blob/master/entry/src/main/ets/pages/WaterFlowPage.ets#L76-L101" target="_blank">WaterFlowPage.ets</a></div></div></div></div>     <p>示例代码使用LazyForEach进行数据懒加载，WaterFlow布局按需创建FlowItem组件，并在FlowItem滑出可视区域时回收，以降低内存占用。</p>     <p>瀑布流的开发，也属于长列表加载的一种场景，其LazyForEach懒加载原理及性能分析可参考：<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-best-practices-long-list#section182645364229">懒加载</a></p>    </div>    <div class="tiledSection">     <h2 id="section178181135145016">缓存数据项<i class="anchor-icon anchor-icon-link" anchorid="section178181135145016" tips="复制节点链接"></i></h2>          <p>通过设置cachedCount参数，可以指定LazyForEach懒加载组件的缓存数量。设置cachedCount后，除了屏幕内显示的Item组件外，还会预先缓存屏幕可视区外指定数量的数据。当一个屏幕的数据加载完成后，再次向下滑动时，会先加载上一次请求的数据，加载完成后，再加载本次请求的数据。</p>     <p>详细原理及性能分析参考：<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-best-practices-long-list#section11667144010222">缓存列表项</a></p>    </div>    <div class="tiledSection">     <h2 id="section189041489339">组件复用<i class="anchor-icon anchor-icon-link" anchorid="section189041489339" tips="复制节点链接"></i></h2>          <p></p>     <p>滑动场景中，FlowItem及其子组件频繁创建和销毁。将FlowItem中的组件封装成自定义组件，并使用@Reusable装饰器修饰，以减少ArkUI框架内部反复创建销毁节点的开销。</p>     <p>@Reusable装饰器实现的组件复用仅限于父组件内。 若要支持全局范围的组件复用，可以使用全局组件复用池的第三方库。</p>     <p>组件复用详细原理及性能分析参考：<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-best-practices-long-list#section36781044162218">组件复用</a></p>     <p>全局组件复用池三方库：<a href="https://ohpm.openharmony.cn/#/cn/detail/@hadss%2Fnodepool" target="_blank">nodepool</a></p>    </div>    <div class="tiledSection">     <h2 id="section12893102412329">无限滑动<i class="anchor-icon anchor-icon-link" anchorid="section12893102412329" tips="复制节点链接"></i></h2>         </div>    <p>在实际开发中，瀑布流布局的数据不会一次性全部加载，而是每次加载固定数量的数据。当应用滑动时，会继续加载数据。在滑动过程中加载新数据时，结合懒加载和缓存列表项，可以确保缓存中的数据及时补充，从而用户在滑动时不会感觉到数据加载，实现无限滑动的效果（具体效果参见实践总结章节）。由于数据提前加载，避免了在同一时刻创建大量组件，减少了丢帧的情况。</p>    <p>在对应场景下，需通过事件加载数据以实现无限滑动。例如：使用瀑布流触底方法（onReachEnd）和瀑布流组件滑动索引变化事件（onScrollIndex）。</p>    <ul>     <li>在onReachEnd加载数据时，应用会在数据源中的所有数据渲染完毕后加载新数据。这会导致明显的加载动画出现，用户需要等待新数据加载完成才能继续浏览瀑布流。</li>     <li>在onScrollIndex回调中加载数据时，当瀑布流组件滑动导致可视区索引变化时，需要限制加载数据的条件。例如，当当前可视区最后一个组件的索引加20等于数据源数量时，才加载数据。这样可以避免每次索引变化时都加载数据。建议在onScrollIndex回调中进行操作，使瀑布流在未到达底部时就开始加载数据，从而提升用户体验，使用户感知不到数据加载过程。</li>    </ul>    <p>相关流程如下：</p>    <p><strong>瀑布流组件加载流程图</strong></p>    <p><span><img originheight="688" originwidth="971" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163433.95711423756574387292943165591065:50001231000000:2800:7F1B8FCB1B3AB3FD703DDFBD4A9DCA4AB8BCF3E45FF43358451B24885BFC1224.png" width="920" height="651.8640576725026"></span></p>    <p>示例如下：</p>    <div class="screenLinkPre"><div _ngcontent-stb-c106="" class="highlight-div"><div _ngcontent-stb-c106="" class="highlight-div-header"><div _ngcontent-stb-c106="" class="highlight-div-header-left"><div _ngcontent-stb-c106="" class="handle-button expand-button"><div _ngcontent-stb-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-stb-c106="" class="highlight-div-header-right"><div _ngcontent-stb-c106="" class="handle-button ai-button"></div><div _ngcontent-stb-c106="" class="handle-button line-button"><div _ngcontent-stb-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-stb-c106="" class="handle-button theme-button"><div _ngcontent-stb-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-stb-c106="" class="handle-button copy-button"><div _ngcontent-stb-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-stb-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-kotlin" codehub="https://gitee.com/harmonyos_samples/PageSlip/blob/master/entry/src/main/ets/view/WaterFlowView.ets#L115-L202" data-highlighted="yes"><ol class="linenums"><li>WaterFlow({ footer: <span class="hljs-keyword">this</span>.footStyle, scroller: <span class="hljs-keyword">this</span>.waterFlowScroller }) {</li><li>  LazyForEach(<span class="hljs-keyword">this</span>.waterFlowListData.getData(), (item: WaterFlowData, index: number) =&gt; {</li><li>    FlowItem() {</li><li>      <span class="hljs-comment">// ...</span></li><li>    }</li><li>    .height(item.waterFlowHead.height / item.waterFlowHead.width * <span class="hljs-keyword">this</span>.waterFlowItemWidth +</li><li>    <span class="hljs-keyword">this</span>.getTitleHeight(item.waterFlowDescription.title))</li><li>    .backgroundColor(Color.White)</li><li>    <span class="hljs-comment">// ...</span></li><li>  }, (item: WaterFlowData) =&gt; {</li><li>    <span class="hljs-keyword">return</span> item.waterFlowDescription.index.toString();</li><li>  });</li><li>}</li><li>.flingSpeedLimit(<span class="hljs-number">4800</span>)</li><li>.onReachEnd(() =&gt; {</li><li>  <span class="hljs-keyword">this</span>.listenNetworkEvent();</li><li>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.waterFlowListData.dataSource.totalCount() &lt; CommonConstants.WATER_FLOW_MAX_COUNT) {</li><li>    <span class="hljs-comment">// There are only 500 analog data, so the limit here is pageNo less than 25</span></li><li>    <span class="hljs-keyword">this</span>.pageNo = <span class="hljs-keyword">this</span>.pageNo + <span class="hljs-number">1</span> &gt; <span class="hljs-number">25</span> ? <span class="hljs-keyword">this</span>.pageNo - <span class="hljs-number">24</span> : <span class="hljs-keyword">this</span>.pageNo + <span class="hljs-number">1</span>;</li><li>    <span class="hljs-keyword">this</span>.waterFlowListData.addData(CommonConstants.MOCK_INTERFACE_WATER_FLOW_FILE_NAME, <span class="hljs-keyword">this</span>.pageNo,</li><li>      <span class="hljs-keyword">this</span>.pageSize);</li><li>  }</li><li>  <span class="hljs-keyword">this</span>.listDataCount = <span class="hljs-keyword">this</span>.waterFlowListData.dataSource.totalCount();</li><li>})</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/PageSlip/blob/master/entry/src/main/ets/view/WaterFlowView.ets#L115-L202" target="_blank">WaterFlowView.ets</a></div></div></div></div>    <div class="tiledSection">     <h2 id="section044033194113">固定宽高<i class="anchor-icon anchor-icon-link" anchorid="section044033194113" tips="复制节点链接"></i></h2>         </div>    <p>与长列表不同，瀑布流布局中各个卡片的高度是不同的，这就对瀑布流布局绘制提出了新的挑战。瀑布流的卡片高度是由瀑布流卡片自适应瀑布流的宽度得到的，因此卡片的高度无法直接指定。这就会使卡片渲染以后得到的高度与占位符的高度不一致，从而造成卡片的闪烁效果。</p>    <p>固定宽高后，UI描述时可指定组件宽高。组件宽高固定时，布局阶段不参与测量，节点保存大小信息。瀑布流内容多时，避免整体测算，性能提升。</p>    <p>Image组件异步加载，提前设定FlowItem高度，避免图片加载后高度变化触发布局刷新。</p>    <p>详细内容请参考：<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-improve-layout-performance#section151587885316">利用布局边界减少布局计算</a></p>    <div class="fignone">     <span class="figcap"><b>图1 </b>瀑布流页面卡片宽高计算逻辑示意图</span>     <p><span><img height="546.8428" originheight="1026" originwidth="496" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163433.31292960557196028575917443924097:50001231000000:2800:D945ED6B5702E778E031B0968C470A768031D3ACFFF343D5EC7688D261C98CB8.png" title="点击放大" width="266"></span></p>    </div>    <p>如上图所示，两列瀑布流卡片的宽度 = （屏幕宽度 - 2 * 组件外边距（margin） - 瀑布流组件内边距（gap））/ 2。</p>    <p>瀑布流卡片中图片的高度imageHeight = 图片原始高度 / 图片原始宽度 * 瀑布流卡片宽度。</p>    <p>瀑布流卡片中描述性的高度titleHeight根据标题长度不同需设置不同的高度，其计算逻辑如下代码所示：</p>    <div class="screenLinkPre"><div _ngcontent-stb-c106="" class="highlight-div"><div _ngcontent-stb-c106="" class="highlight-div-header"><div _ngcontent-stb-c106="" class="highlight-div-header-left"><div _ngcontent-stb-c106="" class="handle-button expand-button"><div _ngcontent-stb-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-stb-c106="" class="highlight-div-header-right"><div _ngcontent-stb-c106="" class="handle-button ai-button"></div><div _ngcontent-stb-c106="" class="handle-button line-button"><div _ngcontent-stb-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-stb-c106="" class="handle-button theme-button"><div _ngcontent-stb-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-stb-c106="" class="handle-button copy-button"><div _ngcontent-stb-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-stb-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-cangjie" codehub="https://gitee.com/harmonyos_samples/PageSlip/blob/master/entry/src/main/ets/view/WaterFlowView.ets#L89-L96" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-title function_">getTitleHeight</span>(<span class="hljs-variable">title</span>: <span class="hljs-title class_">string</span>) {</li><li>  <span class="hljs-keyword">let</span> <span class="hljs-variable">textWidth</span>: <span class="hljs-title class_">number</span> = <span class="hljs-keyword">this</span>.<span class="hljs-title function_">getUIContext</span>().<span class="hljs-title function_">getMeasureUtils</span>().<span class="hljs-title function_">measureText</span>({</li><li>    <span class="hljs-variable">textContent</span>: <span class="hljs-title class_">title</span>,</li><li>    <span class="hljs-variable">fontSize</span>: <span class="hljs-number">14</span></li><li>  });</li><li>  <span class="hljs-keyword">return</span> <span class="hljs-variable">textWidth</span> &gt; (<span class="hljs-keyword">this</span>.<span class="hljs-variable">waterFlowItemWidth</span> - <span class="hljs-variable">CommonConstants</span>.<span class="hljs-variable">DESCRIPTION_MARGIN_LEFT</span> * <span class="hljs-number">2</span>) ?</li><li>  <span class="hljs-variable">CommonConstants</span>.<span class="hljs-variable">DESCRIPTION_THREE_LINES_HEIGHT</span> : <span class="hljs-title class_">CommonConstants</span>.<span class="hljs-title class_">DESCRIPTION_TWO_LINES_HEIGHT</span>;</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/PageSlip/blob/master/entry/src/main/ets/view/WaterFlowView.ets#L89-L96" target="_blank">WaterFlowView.ets</a></div></div></div></div>    <p>瀑布流卡片的高度 = imageHeight + titleHeight。</p>    <div class="tiledSection">     <h2 id="section31841838151014">实践总结<i class="anchor-icon anchor-icon-link" anchorid="section31841838151014" tips="复制节点链接"></i></h2>         </div>    <p>本文通过瀑布流案例，使用部分优化手段，实现页面流畅滑动。页面包含SearchBar、Swiper、WaterFlow和底部导航栏。顶部功能区由Swiper嵌套Grid组件实现，瀑布流使用WaterFlow组件，FlowItem内容包括图文、视频、直播卡片，复用相同UI结构，避免无用层级嵌套。</p>    <p><strong>整体效果图</strong></p>    <p><span><img height="546.8428" originheight="1026" originwidth="496" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163433.15487299266136427732660335546672:50001231000000:2800:A526FC21EDFD11498C45220727F7E7D76E75C2A0CA6CCAE2E926BA792037994D.png" title="点击放大" width="266"></span></p>    <p>下表为通过网络请求500条数据加载渲染，测试获得的数据（数据测试方式采用技术从左向右累加测试的）：</p>    <div class="tablenoborder">     <div class="tbBox"><table class="layoutFixed idpTab">      <caption>       <b>表1 </b>500条数据加载性能优化对比      </caption>      <thead>       <tr>        <th align="left" class="cellrowborder" id="mcps1.3.30.2.7.1.1" valign="top" width="16.666666666666664%">         <p><strong>性能指标</strong></p></th>        <th align="left" class="cellrowborder" id="mcps1.3.30.2.7.1.2" valign="top" width="16.666666666666664%">         <p><strong>ForEach</strong></p></th>        <th align="left" class="cellrowborder" id="mcps1.3.30.2.7.1.3" valign="top" width="16.666666666666664%">         <p><strong>LazyForEach</strong></p></th>        <th align="left" class="cellrowborder" id="mcps1.3.30.2.7.1.4" valign="top" width="16.666666666666664%">         <p><strong>缓存数据项</strong></p></th>        <th align="left" class="cellrowborder" id="mcps1.3.30.2.7.1.5" valign="top" width="16.666666666666664%">         <p><strong>组件复用</strong></p></th>        <th align="left" class="cellrowborder" id="mcps1.3.30.2.7.1.6" valign="top" width="16.666666666666664%">         <p><strong>固定宽高</strong></p></th>       </tr>      </thead>             <tbody><tr>        <td class="cellrowborder" valign="top" width="16.666666666666664%">         <p>首次渲染时间</p></td>        <td class="cellrowborder" valign="top" width="16.666666666666664%">         <p>1346ms</p></td>        <td class="cellrowborder" valign="top" width="16.666666666666664%">         <p>756ms</p></td>        <td class="cellrowborder" valign="top" width="16.666666666666664%">         <p>752ms</p></td>        <td class="cellrowborder" valign="top" width="16.666666666666664%">         <p>760ms</p></td>        <td class="cellrowborder" valign="top" width="16.666666666666664%">         <p>761ms</p></td>       </tr>       <tr>        <td class="cellrowborder" valign="top" width="16.666666666666664%">         <p>丢帧率</p></td>        <td class="cellrowborder" valign="top" width="16.666666666666664%">         <p>2.20%</p></td>        <td class="cellrowborder" valign="top" width="16.666666666666664%">         <p>1.00%</p></td>        <td class="cellrowborder" valign="top" width="16.666666666666664%">         <p>0.50%</p></td>        <td class="cellrowborder" valign="top" width="16.666666666666664%">         <p>0.2%</p></td>        <td class="cellrowborder" valign="top" width="16.666666666666664%">         <p>0.00%</p></td>       </tr>       <tr>        <td class="cellrowborder" valign="top" width="16.666666666666664%">         <p>独占内存</p></td>        <td class="cellrowborder" valign="top" width="16.666666666666664%">         <p>485M</p></td>        <td class="cellrowborder" valign="top" width="16.666666666666664%">         <p>122M</p></td>        <td class="cellrowborder" valign="top" width="16.666666666666664%">         <p>136.6M</p></td>        <td class="cellrowborder" valign="top" width="16.666666666666664%">         <p>106.8M</p></td>        <td class="cellrowborder" valign="top" width="16.666666666666664%">         <p>103.3M</p></td>       </tr>           </tbody></table></div>    </div>    <p>从测试结果可以看出，使用LazyForEach懒加载后，相关指标显著提升，尤其是在内存使用和首次渲染时间方面。其他优化方法可以进一步减少滑动过程中的丢帧率，从而优化交互体验。缓存数据项会影响首次渲染时间，因为缓存的数据未在首屏展示，但需要加载额外的数据，导致内存使用增加。由于UI组件的复用，内存使用显著减少。</p>    <p></p>    <p>对于瀑布流性能优化方式，与长列表优化类似，都可以使用懒加载、缓存列表项、动态预加载、组件复用、布局优化等方式优化性能。固定宽高作为瀑布流特有的优化性能手段能够进一步提升瀑布流的性能，同时可以避免新加载元素瞬间刷新带来的"闪烁"问题。在滑动过程中加载数据，可以避免同一时间创建大量组件而导致丢帧的情况。相应技术总结见下表：</p>    <div class="tablenoborder">     <div class="tbBox"><table class="layoutFixed idpTab">      <caption>       <b>表2 </b>瀑布流性能优化方法总结      </caption>      <thead>       <tr>        <th align="left" class="cellrowborder" id="mcps1.3.34.2.4.1.1" valign="top" width="13.09130913091309%">         <p>技术名称</p></th>        <th align="left" class="cellrowborder" id="mcps1.3.34.2.4.1.2" valign="top" width="53.57535753575357%">         <p>适用场景</p></th>        <th align="left" class="cellrowborder" id="mcps1.3.34.2.4.1.3" valign="top" width="33.33333333333333%">         <p>参考文章</p></th>       </tr>      </thead>             <tbody><tr>        <td class="cellrowborder" valign="top" width="13.09130913091309%">         <p>懒加载</p></td>        <td class="cellrowborder" valign="top" width="53.57535753575357%">         <p>适用于瀑布流场景，解决一次性加载并渲染大量数据造成的性能瓶颈。</p></td>        <td class="cellrowborder" valign="top" width="33.33333333333333%">         <p><a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-best-practices-long-list">长列表加载性能优化</a>、</p>         <p><a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-lazyforeach-optimization">使用懒加载优化性能</a>、</p>         <p><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-lazyforeach" target="_blank">数据懒加载</a></p></td>       </tr>       <tr>        <td class="cellrowborder" valign="top" width="13.09130913091309%">         <p>缓存列表项</p></td>        <td class="cellrowborder" valign="top" width="53.57535753575357%">         <p>适用于加载列表项数据请求耗时的场景。比如，瀑布流列表中含有短视频、高清图片等数据量比较大的资源。</p></td>        <td class="cellrowborder" valign="top" width="33.33333333333333%">         <p><a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-best-practices-long-list">长列表加载性能优化</a></p></td>       </tr>       <tr>        <td class="cellrowborder" valign="top" width="13.09130913091309%">         <p>组件复用</p></td>        <td class="cellrowborder" valign="top" width="53.57535753575357%">         <p>适用于瀑布流中存在大量结构相同的组件频繁创建与销毁导致性能瓶颈的场景。</p></td>        <td class="cellrowborder" valign="top" width="33.33333333333333%">         <p><a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-component-reuse">组件复用最佳实践</a></p></td>       </tr>       <tr>        <td class="cellrowborder" valign="top" width="13.09130913091309%">         <p>固定宽高</p></td>        <td class="cellrowborder" valign="top" width="53.57535753575357%">         <p>适用于瀑布流页面组件高度不一的场景。</p></td>        <td class="cellrowborder" valign="top" width="33.33333333333333%">         <p><a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-improve-layout-performance#section151587885316">利用布局边界减少布局计算</a></p></td>       </tr>       <tr>        <td class="cellrowborder" valign="top" width="13.09130913091309%">         <p>布局优化</p></td>        <td class="cellrowborder" valign="top" width="53.57535753575357%">         <p>错误的布局方式可能会导致组件树和嵌套层数过多，在创建和布局绘制阶段产生较大的性能开销，所以可以通过布局优化提升性能。</p></td>        <td class="cellrowborder" valign="top" width="33.33333333333333%">         <p><a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-improve-layout-performance">合理使用布局</a></p></td>       </tr>       <tr>        <td class="cellrowborder" valign="top" width="13.09130913091309%">         <p>状态管理</p></td>        <td class="cellrowborder" valign="top" width="53.57535753575357%">         <p>在ArkUI的开发过程中，如果没有选择合适的装饰器或合理的控制状态更新范围，会导致非必要的UI视图刷新，造成性能浪费。</p></td>        <td class="cellrowborder" valign="top" width="33.33333333333333%">         <p><a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-status-management">状态管理最佳实践</a></p></td>       </tr>           </tbody></table></div>    </div>    <div class="tiledSection">     <h2 id="section67166537327">示例代码<i class="anchor-icon anchor-icon-link" anchorid="section67166537327" tips="复制节点链接"></i></h2>         </div>    <ul>     <li><a href="https://gitee.com/harmonyos_samples/PageSlip" target="_blank">PageSlip</a></li>    </ul>   </div>   <div></div></div>