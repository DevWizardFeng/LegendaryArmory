<h1 _ngcontent-fwj-c119="" class="doc-title ng-star-inserted" title="点击完成时延分析"> 点击完成时延分析 </h1>

<div _ngcontent-fwj-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;"> <div><div class="tiledSection"><h2 id="section131521247089">完成时延优化概述<i class="anchor-icon anchor-icon-link" anchorid="section131521247089" tips="复制节点链接"></i></h2><p>在移动终端应用开发中，完成时延指用户从输入触控指令到界面完全刷新结束并达到可以阅读的稳定状态所用时间。点击完成时延分为页面内跳转和页面间跳转两种类型。完成时延在用户体验设计中至关重要，直接影响用户对产品的满意度和使用体验。完成时延反映了用户对响应速度的整体感受，影响触控交互的及时性和愉悦性。如图一所示，点击完成时延包含点击响应时延。有关响应时延阶段的优化分析，请参考<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-click-to-click-response-optimization" target="_blank">《点击响应时延分析》</a>。</p> <p>在一定时延水平以上，完成时延越短越好，但在达到一定阈值后，用户的流畅体验不会继续提升。建议应用或元服务内点击操作完成时延≤900ms。更多体验建议，请参考指南<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/performance-delay" target="_blank">《时延体验建议》</a>。本文将介绍相关分析工具、点击完成时延问题定位流程及常见问题根因分析。</p> <div class="fignone"><span class="figcap"><b>图1 </b>点击完成起止点示意图</span></div> <p><span><img height="519.8438000000001" originheight="957" originwidth="1466" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163401.43000497325732990718734993137829:50001231000000:2800:B1BA4C60AD59CF897D6CF96DF0FD8670D7214378ECFBBA38C1AAB5511FE4213D.png" title="点击放大" width="798"></span></p> <div class="fignone"><span class="figcap"><b>图2 </b>页面转场过程解析</span><br><span><img height="257.6" originheight="1234" originwidth="4400" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163401.93454970551966658520728218383553:50001231000000:2800:CD7C4DCB456FE8283891B62D6BBE1BE4282443E016C7D0B46E7C1296735C4D63.png" title="点击放大" width="920"></span></div> </div> <div class="tiledSection"><h2 id="section8778443101712">完成时延检测工具<i class="anchor-icon anchor-icon-link" anchorid="section8778443101712" tips="复制节点链接"></i></h2><p>影响点击完成性能的因素很多，使用DevEco Studio集成的分析工具，可以收集系统数据，自动执行重复任务，建立统一优化标准和流程，减少个人差异和误操作的可能性，帮助开发者了解性能瓶颈和优化潜力。分析优化过程中，可能用到以下工具中的一个或多个。</p> <ul><li><a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-performance-detection#section135451444171">AppAnalyzer</a>：是DevEco Studio提供的检测评分工具，用于测试和诊断HarmonyOS应用或元服务的质量，快速提供诊断结果和改进建议。当前支持的测试类型包括兼容性、性能、UX测试和最佳实践。点击完成时延是性能测试中的一项检测规则，开发者可以使用该工具检测响应性能。<p>具体使用可参考<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-performance-detection#section135451444171">《AppAnalyzer》</a>。</p> </li><li><a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-optimization-overview#section1465143164111">ArkUI Inspector</a>：是DevEco Studio中提供用于检查UI的工具，开发者可以借助它预览真机或模拟器中的UI效果，快速定位布局层级问题，也可以观察组件属性、不同组件之间的关系等。<p>具体使用可参考<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-optimization-overview#section1465143164111">《ArkUI Inspector》</a>。</p> </li><li><a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-performance-detection#section3783182023119">DevEco Testing</a>：DevEco Testing是一款专项集成测试工具，提供了多项测试能力。旨在帮助开发者高效完成应用的功能、兼容性、性能和稳定性测试，确保应用质量。<p>具体使用可参考<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-performance-detection#section3783182023119">《DevEco Testing》</a>。</p> </li><li><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-insight-session-frame" target="_blank">Profiler Frame</a>：性能调优深入分析工具，支持冷启动、卡顿丢帧、状态变量、并行化、网络耗时、ArkWeb、内存优化等场景化调优能力。其中Frame分析可以帮助开发者深度分析性能问题，通过录制应用运行过程中的关键数据，从而识别卡顿丢帧、耗时长等问题的原因所在。<p>具体使用可参考<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-optimization-overview#section2012922312284">《DevEco Profiler》</a>。</p> </li></ul> </div> <div class="tiledSection"><h2 id="section9648201192218">问题定位流程<i class="anchor-icon anchor-icon-link" anchorid="section9648201192218" tips="复制节点链接"></i></h2></div> <p>定位点击完成时延高耗时的简易流程如下图所示。</p> <div class="fignone"><span class="figcap"><b>图3 </b>问题定位流程图</span></div> <p><span><img height="554.6499" originheight="764" originwidth="1161" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163402.77900215655745823365172848022358:50001231000000:2800:1BA5BECE463411901F6E90BEF756E0AF5D11B5503CF7BB9C6BFB7EC52786568F.png" title="点击放大" width="842.8875"></span></p> <p>如上图所示，分析点击完成时延问题通常需要以下步骤：</p> <ol><li>性能体检：使用性能检测工具AppAnalyzer检测和诊断应用是否存在性能问题。</li><li>确定完成时延：根据性能检测工具AppAnalyzer检测结果，确定完成时延的耗时，判断是否符合<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/performance-delay" target="_blank">《时延体验建议》</a>中的规范。</li><li>抓取Trace信息：使用性能分析工具DevEco Profiler抓取Trace，并确定Trace图中的起止点。</li><li>分析问题：结合关键泳道Trace信息以及ArkUI Inspector布局分析工具来定位具体问题。</li></ol> <div class="tiledSection"><h2 id="section5352205892313">使用AppAnalyzer工具检测和分析<i class="anchor-icon anchor-icon-link" anchorid="section5352205892313" tips="复制节点链接"></i></h2></div> <p>在应用开发中，UI线程应用自身方法执行耗时、网络请求响应耗时、UI组件自身创建耗时等，都会导致应用点击完成时延受到影响，合理优化代码逻辑可以提升应用点击完成时延速度，提升用户体验。开发者可以通过<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-app-analyzer" target="_blank">AppAnalyzer</a>对应用点击完成时延进行检测，并优化检测报告中存在的点击完成时延未达标的问题。</p> <p>使用AppAnalyzer工具检测点击完成时延步骤如下。</p> <ol><li><span>在DevEco Studio中启动AppAnalyzer工具，详细参见<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-performance-detection#section135451444171">AppAnalyzer</a>。</span></li><li><span>点击“手动性能页面间转场体检”按钮启动检测。</span><p></p><p><span><img height="411.1429" originheight="711" originwidth="920" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163402.88326038525477883477753635105575:50001231000000:2800:5B3FA246C05128DF51F373D520585DB62A7EF9ED44259A0343C3EE2A820F9F09.png" title="点击放大" width="532"></span></p> <p></p></li><li><span>开发者需根据提示，在应用中找到待检测页面，点击工具中的开始按钮，然后在应用中手动执行转场，操作后点击停止完成本次检测。</span><p></p><p><span><img height="315.21000000000004" originheight="645" originwidth="1069" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163402.45982891972637139808966639897545:50001231000000:2800:0AFCE9FAC318021046CB487A16F56EDEF83629C71AC44E4A83231FBD713A8D11.png" title="点击放大" width="523.6875"></span></p> <p></p></li><li><span>检测结果分析，点击完成时延应小于或等于900ms。如果存在大于900ms的点击完成时延，判断为存在性能问题。</span><p></p><p><span><img originheight="379" originwidth="553" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163402.04288717174362465292326291625868:50001231000000:2800:389FABB9414377CDE0388A3EF9F69D48C03C6BFEA2C81B9A10377A80627980FE.png" width="553" height="379"></span></p> <p></p></li></ol> <p>检测出的点击完成时延报告中，可能会存在以下五种影响性能的故障原因。</p> <ul><li>UI线程应用自身方法耗时长</li><li>UI线程应用自定义组件创建耗时长</li><li>网络请求耗时长</li><li>主线程长时间被阻塞</li><li>图片大纹理</li></ul> <div class="tiledSection"><h3 id="section108231237132610" class="firsth2">UI线程应用自身方法耗时长<i class="anchor-icon anchor-icon-link" anchorid="section108231237132610" tips="复制节点链接"></i></h3><ol><li><span>获得检测结果后，点击详情报告中的“点击完成时延”，可以查看UI线程应用自身方法耗时长的检测结果。</span><p></p><p><span><img height="359.7988571428571" originheight="474" originwidth="1212" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163402.80718653706381491801211482038079:50001231000000:2800:2D4DE5141FC0422C27020CE35D2AC78D195BAF85E7898FA8DD62208DD1381402.png" title="点击放大" width="920"></span></p> <p>检测结果中，可以根据方法总耗时的大小来判断该方法是否为耗时方法。如上图中，aboutToAppear[PageJumpSceneUseCase3.ets, 29]表示PageJumpSceneUseCase3.ets页面中的aboutToAppear()方法，其执行耗时较长。</p> <p></p></li><li><span>点击方法名，可跳转定位至PageJumpSceneUseCase3.ets页面中的耗时方法处。</span></li><li><span>aboutToAppear()中调用了如下方法。</span><p></p><div _ngcontent-fwj-c106="" class="highlight-div"><div _ngcontent-fwj-c106="" class="highlight-div-header"><div _ngcontent-fwj-c106="" class="highlight-div-header-left"><div _ngcontent-fwj-c106="" class="handle-button expand-button"><div _ngcontent-fwj-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-fwj-c106="" class="highlight-div-header-right"><div _ngcontent-fwj-c106="" class="handle-button ai-button"></div><div _ngcontent-fwj-c106="" class="handle-button line-button"><div _ngcontent-fwj-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-fwj-c106="" class="handle-button theme-button"><div _ngcontent-fwj-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-fwj-c106="" class="handle-button copy-button"><div _ngcontent-fwj-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-fwj-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-javascript" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fun1</span>(<span class="hljs-params"></span>) {</li><li>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>; index &lt; <span class="hljs-number">906666</span>; index++) {</li><li>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">debug</span>(<span class="hljs-string">'fun1 index:'</span> + index);</li><li>  }</li><li>}</li></ol></pre></div></div> <p>由于在该方法中执行了模拟长耗时的for循环代码，导致该方法在检测中总耗时过长。</p> <p></p></li><li><span>点击优化建议下的跳转链接<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-zhenlv#section117831333645" target="_blank">分析UI主线程高耗时函数</a>，即可获取相应的优化建议。</span></li></ol> </div> <div class="tiledSection"><h3 id="section14943183982712">UI线程应用自定义组件创建耗时长<i class="anchor-icon anchor-icon-link" anchorid="section14943183982712" tips="复制节点链接"></i></h3><ol><li><span>获得检测结果。点击详情报告中的“点击完成时延”，可以查看UI线程应用自定义组件创建耗时检测结果。</span><p></p><p><span><img height="170.461844" originheight="379" originwidth="2000" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163402.28431389687271528652542455815012:50001231000000:2800:12CBD1D5EF322CD0064F145CBC0679EE8342FDC9518835F140EF71EDF803F9B3.png" title="点击放大" width="899.745"></span></p> <p>检测结果中，可以根据总耗时列来判断自定义组件创建是否耗时。上图中，TestResponseLatency组件创建总耗时40.933ms，耗时过长。如下图，TextItem在页面中自定义组件被创建多次，导致创建耗时过长。</p> <div _ngcontent-fwj-c106="" class="highlight-div"><div _ngcontent-fwj-c106="" class="highlight-div-header"><div _ngcontent-fwj-c106="" class="highlight-div-header-left"><div _ngcontent-fwj-c106="" class="handle-button expand-button"><div _ngcontent-fwj-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-fwj-c106="" class="highlight-div-header-right"><div _ngcontent-fwj-c106="" class="handle-button ai-button"></div><div _ngcontent-fwj-c106="" class="handle-button line-button"><div _ngcontent-fwj-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-fwj-c106="" class="handle-button theme-button"><div _ngcontent-fwj-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-fwj-c106="" class="handle-button copy-button"><div _ngcontent-fwj-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-fwj-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-less" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-variable">@Entry</span></li><li><span class="hljs-variable">@Component</span></li><li>struct TestResponseLatency {</li><li>  <span class="hljs-variable">@State</span> <span class="hljs-attribute">arr</span>:string[] = []</li><li>
</li><li>  <span class="hljs-built_in">aboutToAppear</span>(): void {</li><li>    <span class="hljs-selector-tag">this</span><span class="hljs-selector-class">.arr</span><span class="hljs-selector-class">.push</span>(...<span class="hljs-built_in">GetData</span>());</li><li>  }</li><li>
</li><li>  <span class="hljs-selector-tag">build</span>() {</li><li>    <span class="hljs-selector-tag">Flex</span>() {</li><li>      <span class="hljs-selector-tag">Column</span>() {</li><li>        <span class="hljs-selector-tag">Flex</span>() {</li><li>          <span class="hljs-selector-tag">ForEach</span>(this.arr, (<span class="hljs-attribute">item</span>: string, <span class="hljs-attribute">index</span>: number) =&gt; {</li><li>            <span class="hljs-selector-tag">TextItem2</span>({ item: item, index: index })</li><li>          })</li><li>        }</li><li>      }</li><li>    }</li><li>    <span class="hljs-selector-class">.height</span>(<span class="hljs-string">'100%'</span>)</li><li>    <span class="hljs-selector-class">.width</span>(<span class="hljs-string">'100%'</span>)</li><li>  }</li><li>}</li></ol></pre></div></div> <p></p></li><li><span>点击源文件定位到创建耗时的UI组件，根据提供的可能故障原因，对UI组件进行相应的优化，还可参考静态检测结果中的优化建议，来对组件创建耗时进行优化。</span><p></p><p><span><img height="344.0668571428572" originheight="748" originwidth="2000" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163402.38694536214555489639977652374569:50001231000000:2800:916A45C52BF5ED4EAA153AF74A97BC30913DC8CBF79B9F213CF6F842F10DE43F.png" title="点击放大" width="920"></span></p> <p></p></li></ol> </div> <div class="tiledSection"><h3 id="section15263133682812">网络请求耗时长<i class="anchor-icon anchor-icon-link" anchorid="section15263133682812" tips="复制节点链接"></i></h3><ol><li><span>获得检测结果后，点击详情报告中的“点击完成时延”，可以查看网络请求耗时的检测结果。</span></li><li><span>根据检测结果中的请求耗时和点击离手到请求发起间隔可进行如下判断。</span><p></p><ul><li>网络请求本身耗时长<p><span><img height="416.9834285714286" originheight="616" originwidth="1359" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163402.79336186874213040065547180513250:50001231000000:2800:9C4C5670FC294CE9DA6CAF5CBFC03F9A50C11353D7C759CB89540A11F9620F10.png" title="点击放大" width="920"></span></p> <p>网络请求本身是否耗时可通过检测结果中的请求耗时时长来进行判断，时间越长，则网络请求本身耗时越久。详细分析请参考：<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-profiler-network" target="_blank">网络诊断：Network分析</a>。</p> <p>网络请求本身耗时长，可对该URL请求进行预连接和预解析来优化网络传输速度，提前完成DNS查询和TCP/TLS握手，即在应用启动或空闲时提前建立并维护一个持久的连接池；还可以使用CDN来优化网络传输速度，将静态资源部署到CDN上。</p> </li><li>网络请求发起太晚<p><span><img height="172.00057142857145" originheight="255" originwidth="1364" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163402.69573954737632573977957985563346:50001231000000:2800:9B2BA1C1C73B164CD43275E4C36BD6B8A84FCC35167810AE100985B81AACF71E.png" title="点击放大" width="920"></span></p> <p>点击离手到请求发起间隔则表示用户进行点击操作后，到真正向服务器发起网络请求的那一刻止，这中间所经过的时间。可通过检测结果中的点击离手到请求发起间隔时长来进行判断，时间越长，则表示网络请求发起的越晚。可通过提前发起网络请求，来进行优化。可参考：<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-application-cold-start-optimization#section199911250658">网络请求提前发送</a>。</p> </li></ul> <p></p></li></ol> <p>如果开发者既无法优化网络请求本身耗时，也无法将网络请求提前发起，可以考虑提前将网络请求数据缓存，下次发起请求的时候直接加载缓存数据，再通过发送网络请求二刷刷新数据。</p> </div> <div class="tiledSection"><h3 id="section73671398291">主线程长时间被阻塞<i class="anchor-icon anchor-icon-link" anchorid="section73671398291" tips="复制节点链接"></i></h3><ol><li><span>获得检测结果。点击详情报告中的“阻塞主线程的任务”，可以查看主线程长时间被阻塞的检测结果。</span><p></p><p><span><img height="664.3714285714286" originheight="985" originwidth="1364" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163402.73944816260212619272625636011822:50001231000000:2800:18B80A4DC0577CB6C35DDC8766C40A89019E8F85620E2E7A28E4AF15660AEE53.png" title="点击放大" width="920"></span></p> <p>通过关键线程识别技术，体检工具能够基于唤醒关系算法精确构建线程间依赖链路，同时结合传统调度分析方法，全面检测可能阻塞主线程的子线程任务。检测结果中，可以根据实际空闲时间判断主线程是否长时间被阻塞：空闲时间越长，则阻塞时间可能越久。通过识别并定位阻塞主线程的关键任务，可以快速找到对应的耗时代码位置。任务耗时代表诊断出的阻塞主线程任务本身的执行时长；主线程等待耗时表示任务结束点到主线程上一个 Running 结束点之间的时间，用于衡量该耗时任务对主线程造成的阻塞程度。</p> <p></p></li><li><span>可能存在以下5种诊断结果。</span><p></p><ul><li>子线程中耗时函数执行<p>点击子线程中函数执行链接，跳转至子线程中耗时函数执行的源码，可发现主线程中的UI刷新需要等待子线程任务执行完成。</p> <div _ngcontent-fwj-c106="" class="highlight-div"><div _ngcontent-fwj-c106="" class="highlight-div-header"><div _ngcontent-fwj-c106="" class="highlight-div-header-left"><div _ngcontent-fwj-c106="" class="handle-button expand-button"><div _ngcontent-fwj-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-fwj-c106="" class="highlight-div-header-right"><div _ngcontent-fwj-c106="" class="handle-button ai-button"></div><div _ngcontent-fwj-c106="" class="handle-button line-button"><div _ngcontent-fwj-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-fwj-c106="" class="handle-button theme-button"><div _ngcontent-fwj-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-fwj-c106="" class="handle-button copy-button"><div _ngcontent-fwj-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-fwj-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-javascript" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">const</span> task = <span class="hljs-keyword">new</span> taskpool.<span class="hljs-title class_">Task</span>(blockFunc, <span class="hljs-number">1350</span>);</li><li>taskpool.<span class="hljs-title function_">execute</span>(task).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {</li><li>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">isShow</span> = <span class="hljs-literal">true</span>;</li><li>  hiTraceMeter.<span class="hljs-title function_">finishTrace</span>(<span class="hljs-string">'loadSyncTask'</span>, <span class="hljs-number">902</span>);</li><li>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">cost</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>() - <span class="hljs-variable language_">this</span>.<span class="hljs-property">timestamps</span>;</li><li>})</li></ol></pre></div></div> <p>应避免子线程执行的函数阻塞主线程，优化建议可参考解决指导中分析高耗时函数的内容。</p> </li><li>网络请求耗时过长<p>可参考<strong>网络请求耗时长</strong>中的优化建议。</p> </li><li>系统接口请求耗时长<p>点击系统接口链接，跳转至系统接口请求耗时长的代码部分。比如获取位置信息接口中，页面上位置信息刷新依赖于接口的返回结果。当系统接口响应较慢时，会导致主线程阻塞。</p> <div _ngcontent-fwj-c106="" class="highlight-div"><div _ngcontent-fwj-c106="" class="highlight-div-header"><div _ngcontent-fwj-c106="" class="highlight-div-header-left"><div _ngcontent-fwj-c106="" class="handle-button expand-button"><div _ngcontent-fwj-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-fwj-c106="" class="highlight-div-header-right"><div _ngcontent-fwj-c106="" class="handle-button ai-button"></div><div _ngcontent-fwj-c106="" class="handle-button line-button"><div _ngcontent-fwj-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-fwj-c106="" class="handle-button theme-button"><div _ngcontent-fwj-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-fwj-c106="" class="handle-button copy-button"><div _ngcontent-fwj-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-fwj-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-cangjie" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-title function_">getCurrentLocationInfo</span>() {</li><li>  <span class="hljs-variable">hiTraceMeter</span>.<span class="hljs-title function_">startTrace</span>(<span class="hljs-string">'Napi'</span>, <span class="hljs-number">1001</span>);</li><li>  <span class="hljs-keyword">const</span> <span class="hljs-variable">requestInfo</span>: <span class="hljs-title class_">geoLocationManager</span>.<span class="hljs-title class_">LocationRequest</span> = {</li><li>    <span class="hljs-string">"priority"</span>: <span class="hljs-title class_">geoLocationManager</span>.<span class="hljs-title class_">LocationRequestPriority</span>.<span class="hljs-title class_">FIRST_FIX</span>,</li><li>    <span class="hljs-string">'scenario'</span>: <span class="hljs-title class_">geoLocationManager</span>.<span class="hljs-title class_">LocationRequestScenario</span>.<span class="hljs-title class_">UNSET</span>,</li><li>    <span class="hljs-string">'timeInterval'</span>: <span class="hljs-number">1</span>,</li><li>    <span class="hljs-string">'distanceInterval'</span>: <span class="hljs-number">0</span>,</li><li>    <span class="hljs-string">'maxAccuracy'</span>: <span class="hljs-number">0</span></li><li>  };</li><li>  <span class="hljs-keyword">try</span> {</li><li>    <span class="hljs-variable">geoLocationManager</span>.<span class="hljs-title function_">getCurrentLocation</span>(<span class="hljs-variable">requestInfo</span>)</li><li>      .<span class="hljs-title function_">then</span>((<span class="hljs-variable">location</span>: <span class="hljs-title class_">geoLocationManager</span>.<span class="hljs-title class_">Location</span>) =&gt; {</li><li>        <span class="hljs-keyword">this</span>.<span class="hljs-variable">loadMsg</span> = <span class="hljs-variable">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-variable">location</span>);</li><li>        <span class="hljs-keyword">this</span>.<span class="hljs-variable">isShow</span> = <span class="hljs-keyword">true</span>;</li><li>        <span class="hljs-variable">promptAction</span>.<span class="hljs-title function_">showToast</span>({ <span class="hljs-variable">message</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title class_">stringify</span>(<span class="hljs-title class_">location</span>) });</li><li>        <span class="hljs-variable">hiTraceMeter</span>.<span class="hljs-title function_">finishTrace</span>(<span class="hljs-string">'Napi'</span>, <span class="hljs-number">1001</span>);</li><li>      })</li><li>      .<span class="hljs-keyword">catch</span>((<span class="hljs-variable">err</span>: <span class="hljs-title class_">BusinessError</span>&lt;<span class="hljs-title class_">ESObject</span>&gt;) =&gt; {</li><li>        <span class="hljs-variable">console</span>.<span class="hljs-title function_">error</span>(`<span class="hljs-variable">Failed</span> <span class="hljs-variable">to</span> <span class="hljs-variable">get</span> <span class="hljs-variable">current</span> <span class="hljs-variable">location</span>. <span class="hljs-variable">Code</span> <span class="hljs-keyword">is</span> ${<span class="hljs-variable">err</span>.<span class="hljs-variable">code</span>}, <span class="hljs-variable">message</span> <span class="hljs-keyword">is</span> ${<span class="hljs-variable">err</span>.<span class="hljs-variable">message</span>}`);</li><li>      });</li><li>  } <span class="hljs-keyword">catch</span> (<span class="hljs-variable">err</span>) {</li><li>    <span class="hljs-variable">console</span>.<span class="hljs-title function_">error</span>(`<span class="hljs-variable">Failed</span> <span class="hljs-variable">to</span> <span class="hljs-variable">get</span> <span class="hljs-variable">current</span> <span class="hljs-variable">location</span>. <span class="hljs-variable">Code</span> <span class="hljs-keyword">is</span> ${<span class="hljs-variable">err</span>.<span class="hljs-variable">code</span>}, <span class="hljs-variable">message</span> <span class="hljs-keyword">is</span> ${<span class="hljs-variable">err</span>.<span class="hljs-variable">message</span>}`);</li><li>  }</li><li>}</li></ol></pre></div></div> <p>应避免系统接口串行发起请求，优化建议可参考解决指导中并发能力增强的内容。</p> </li><li>主线程在等待setTimeout<p>点击主线程在等待setTimeout链接，跳转至setTimeout函数代码，可发现主线程中的UI刷新需要等待setTimeout执行完成。</p> <div _ngcontent-fwj-c106="" class="highlight-div"><div _ngcontent-fwj-c106="" class="highlight-div-header"><div _ngcontent-fwj-c106="" class="highlight-div-header-left"><div _ngcontent-fwj-c106="" class="handle-button expand-button"><div _ngcontent-fwj-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-fwj-c106="" class="highlight-div-header-right"><div _ngcontent-fwj-c106="" class="handle-button ai-button"></div><div _ngcontent-fwj-c106="" class="handle-button line-button"><div _ngcontent-fwj-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-fwj-c106="" class="handle-button theme-button"><div _ngcontent-fwj-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-fwj-c106="" class="handle-button copy-button"><div _ngcontent-fwj-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-fwj-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-javascript" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {</li><li>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">isShowFirst</span> = <span class="hljs-literal">true</span>;</li><li>  hiTraceMeter.<span class="hljs-title function_">finishTrace</span>(<span class="hljs-string">'setTimeout'</span>, <span class="hljs-number">903</span>);</li><li>}, <span class="hljs-number">500</span>);</li></ol></pre></div></div> <p>应避免在主线程中使用setTimeout函数等待时间过长，或是减小setTimeout的延时时间。</p> </li><li><a href="/consumer/cn/doc/best-practices/bpta-click-to-complete-delay-analysis#section1563932810516">存在大量等待时间无法诊断</a></li></ul> <p></p></li><li><span>可参考优化建议中的文章，来对主线程长时间被阻塞导致完成时延不达标的问题进行优化。</span><p></p><p><span><img originheight="90" originwidth="506" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163402.71251446866783064719939500690156:50001231000000:2800:688F26EE0859B5698021F25A9F9A51D2C3EAFEE6A87468223A7B2B253DDC8475.png" width="506" height="90"></span></p> <p></p></li></ol> </div> <div class="tiledSection"><h3 id="section1426221783118">图片大纹理<i class="anchor-icon anchor-icon-link" anchorid="section1426221783118" tips="复制节点链接"></i></h3><ol><li><span>获得检测结果。点击详情报告中的“点击完成时延”，可以查看图片大纹理的检测结果。</span><p></p><p><span><img height="437.4205714285714" originheight="620" originwidth="1304" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163402.90622050542727751930019432758258:50001231000000:2800:8B7631CFEC14C883108A1FDA241AAC4F5FF764CD5063D6DEB62214F437021A26.png" title="点击放大" width="920"></span></p> <p>检测结果中，可以根据超出尺寸占比来判断是否需要优化。</p> <p></p></li><li><span>可通过图片组件所在源码文件进行定位，找到包含图片的源码文件。检测结果可以看出，源图尺寸与目标尺寸不同，超出尺寸占比较大。建议源图尺寸不要超过目标尺寸大小的10%。</span></li><li><span>不同图片种类会有不同的优化建议，可根据优化建议进行相应的修改。</span></li></ol> </div> <div class="tiledSection"><h2 id="section15694191153318">使用Profiler进行完成时延关键Trace分析<i class="anchor-icon anchor-icon-link" anchorid="section15694191153318" tips="复制节点链接"></i></h2><p>通过关键泳道可以分析关键Trace，它通过对Trace进行逻辑分组，可以快速聚焦关键问题。</p> </div> <div class="tiledSection"><h3 id="section331751319345" class="firsth2">关键泳道简介<i class="anchor-icon anchor-icon-link" anchorid="section331751319345" tips="复制节点链接"></i></h3><p>关键泳道可从函数调用耗时、转场页面绘制耗时和转场动画时延三个角度进行分析。接下来，将依据这三个角度对关键泳道进行详细介绍。</p> <ul><li>函数调用耗时分析：<p>ArkTS Callstack：提供ArkTS侧的方法调用栈信息，用于分析ArkTS代码执行和性能瓶颈；</p> <p>Callstack：提供Native侧的方法调用栈信息，用于分析Native层面性能问题；</p> </li><li>转场页面绘制耗时分析：<p>Frame：提供应用主线程的帧渲染信息，帮助识别未按时渲染的帧及其原因；</p> <p>ArkUI Component：提供ArkUI组件的创建、布局、渲染等详细信息，帮助识别耗时较长的组件；</p> </li><li>转场动画时延分析：<p>H:Animator：提供动画执行过程中的详细信息，帮助识别转场动画是否耗时较长；</p> <p>关键Trace说明如下</p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.21.3.3.3.1.5.1.1" valign="top" width="10%"><p>序号</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.21.3.3.3.1.5.1.2" valign="top" width="15%"><p>泳道</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.21.3.3.3.1.5.1.3" valign="top" width="20%"><p>Trace点</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.21.3.3.3.1.5.1.4" valign="top" width="55.00000000000001%"><p>描述</p> </th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="10%"><p>1</p> </td> <td class="cellrowborder" valign="top" width="15%"><p>应用线程</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>ReceiveVsync</p> </td> <td class="cellrowborder" valign="top" width="55.00000000000001%"><p>接受Vsync信号</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="10%"><p>2</p> </td> <td class="cellrowborder" valign="top" width="15%"><p>应用线程</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>OnvsyncEvent</p> </td> <td class="cellrowborder" valign="top" width="55.00000000000001%"><p>收到Vsync信号，渲染流程开始</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="10%"><p>3</p> </td> <td class="cellrowborder" valign="top" width="15%"><p>应用线程</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>FlushVsync</p> </td> <td class="cellrowborder" valign="top" width="55.00000000000001%"><p>刷新视图同步事件，包括记录帧信息、刷新任务、绘制上下文、处理用户输入</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="10%"><p>4</p> </td> <td class="cellrowborder" valign="top" width="15%"><p>应用线程</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>FlushDirtyNodeUpdate</p> </td> <td class="cellrowborder" valign="top" width="55.00000000000001%"><p>标脏组件刷新。页面刷新渲染的时候要尽量减少刷新的组件数量。当状态变量改变后，会先对状态变量相关的组件进行标脏，然后对这些组件重新测量和布局，最后再进行渲染</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="10%"><p>5</p> </td> <td class="cellrowborder" valign="top" width="15%"><p>应用线程</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>JSAnimation</p> </td> <td class="cellrowborder" valign="top" width="55.00000000000001%"><p>显示动画，动画会影响组件加载完成时延</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="10%"><p>6</p> </td> <td class="cellrowborder" valign="top" width="15%"><p>应用线程</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>FlushLayoutTask</p> </td> <td class="cellrowborder" valign="top" width="55.00000000000001%"><p>执行布局任务。在此阶段会对组件做布局测算，如果层级较深或者组件较多会影响性能</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="10%"><p>7</p> </td> <td class="cellrowborder" valign="top" width="15%"><p>应用线程</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>FlushMessages</p> </td> <td class="cellrowborder" valign="top" width="55.00000000000001%"><p>发送消息通知图形侧进行渲染</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="10%"><p>8</p> </td> <td class="cellrowborder" valign="top" width="15%"><p>应用线程</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>aboutToBeDeleted</p> </td> <td class="cellrowborder" valign="top" width="55.00000000000001%"><p>自定义组件生命周期函数，组件析构时出现，在未使用复用机制时，FlushDirtyNodeUpdate和LazyForEach predict下会析构组件，导致刷新时组件重复创建</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="10%"><p>9</p> </td> <td class="cellrowborder" valign="top" width="15%"><p>应用进程</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>SendCommands</p> </td> <td class="cellrowborder" valign="top" width="55.00000000000001%"><p>应用UI提交到Render Service</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="10%"><p>10</p> </td> <td class="cellrowborder" valign="top" width="15%"><p>ArkTS Callstack</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>createHttp</p> </td> <td class="cellrowborder" valign="top" width="55.00000000000001%"><p>创建网络请求</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="10%"><p>11</p> </td> <td class="cellrowborder" valign="top" width="15%"><p>ArkTS Callstack</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>request</p> </td> <td class="cellrowborder" valign="top" width="55.00000000000001%"><p>发送网络请求</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="10%"><p>12</p> </td> <td class="cellrowborder" valign="top" width="15%"><p>ArkTS Callstack</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>parse</p> </td> <td class="cellrowborder" valign="top" width="55.00000000000001%"><p>解析数据</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="10%"><p>13</p> </td> <td class="cellrowborder" valign="top" width="15%"><p>ArkTS Callstack</p> </td> <td class="cellrowborder" valign="top" width="20%"><p>off</p> </td> <td class="cellrowborder" valign="top" width="55.00000000000001%"><p>取消订阅</p> </td> </tr>  </tbody></table></div> </div> </li></ul> </div> <div class="tiledSection"><h3 id="section15773124683414">确定起止点<i class="anchor-icon anchor-icon-link" anchorid="section15773124683414" tips="复制节点链接"></i></h3><p>开发者可以使用录屏辅助测试，通过录屏分析工具确定点击完成时延的起止点，从而判断是否存在需要优化的时延问题。</p> <p>DevEco Profiler工具分使用方式可以参考<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-insight-session-frame" target="_blank">Frame分析</a>。下面介绍如何使用DevEco Profiler工具确定点击完成时延Trace的起止点。</p> <ol><li><span>搜索"H:DispatchTouchEvent"标签，找到type=1的那个DispatchTouchEvent，就是点击离手起点，将该时间戳设为起点。</span><p></p><div class="fignone"><span class="figcap"><b>图4 </b>确认Trace起点</span><br><span><img height="248.82550000000003" originheight="401" originwidth="1478" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163403.09369581027023310504651084344730:50001231000000:2800:4B31BBEAAA290E3DD84036B6D37CAC90F3EC0BF8E664A0EBAF0138A59A3FE938.png" title="点击放大" width="920"></span></div> <p></p></li><li><span>点击操作完成时延的终点位置在泳道图中没有明确的Trace点，需要通过录屏工具计算出完成时延的耗时时间。从起点往后拉相同的时间找到终点位置。</span><p></p><div class="fignone"><span class="figcap"><b>图5 </b>确认Trace终点</span><br><span><img height="229.56300000000005" originheight="379" originwidth="1509" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163403.66292090921134489474796568771491:50001231000000:2800:9BA47663B7346DD3988E71CAE67330949AC0D8DC2D1852346338B95097087FC1.png" title="点击放大" width="920"></span></div> <p></p></li><li><span>使用Profiler工具标记Trace起点与终点。</span></li></ol> </div> <div class="tiledSection"><h3 id="section4517142153513">ArkTS Callstack泳道分析ArkTS侧耗时函数<i class="anchor-icon anchor-icon-link" anchorid="section4517142153513" tips="复制节点链接"></i></h3><p>在ArkTS Callstack子泳道中，ArkVM是需要优先查看耗时情况的泳道，可以观察ArkTS侧方法的耗时。优先分析耗时最长的调用栈（program除外，program表示程序执行进入纯Native代码阶段，该阶段无ArkTS代码执行，也无ArkTS调用Native或Native调用ArkTS的情况，需要切换到Callstack泳道查看具体的调用栈信息，通常难以通过这里分析出有效信息）。逐级展开，可以看到具体耗时的文件。基于 <a href="https://gitee.com/harmonyos_samples/hmosworld" target="_blank">“HMOS世界”</a>切换tab页场景，抓取Trace信息。</p> <div class="fignone"><span class="figcap"><b>图6 </b>ArkTS Callstack泳道图</span><br><span><img height="329.45200000000006" originheight="549" originwidth="1533" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163403.27048210057223144720995765472345:50001231000000:2800:12BE2356B7BCE7342625481FCB575852E636627AA0260A22B9DB88535A6B7DFE.png" title="点击放大" width="920"></span></div> <p>观察发现MainPage文件中匿名函数耗时350ms，展开该节点。</p> <div class="fignone"><span class="figcap"><b>图7 </b>ArkTS Callstack泳道耗时函数详情</span><br><span><img height="494.16650000000004" originheight="838" originwidth="1556" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163403.96402325756206676970452077477655:50001231000000:2800:FA32C6251E36FAA96D7993B7BF20B4CE58748C3F2D29C01E42EB9F3506908D38.png" title="点击放大" width="920"></span></div> <p>展开节点后发现函数调用链中AudioPlayerService中getInstance函数调用耗时327ms，接下来定位源代码。</p> <div class="screenLinkPre"><div _ngcontent-fwj-c106="" class="highlight-div"><div _ngcontent-fwj-c106="" class="highlight-div-header"><div _ngcontent-fwj-c106="" class="highlight-div-header-left"><div _ngcontent-fwj-c106="" class="handle-button expand-button"><div _ngcontent-fwj-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-fwj-c106="" class="highlight-div-header-right"><div _ngcontent-fwj-c106="" class="handle-button ai-button"></div><div _ngcontent-fwj-c106="" class="handle-button line-button"><div _ngcontent-fwj-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-fwj-c106="" class="handle-button theme-button"><div _ngcontent-fwj-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-fwj-c106="" class="handle-button copy-button"><div _ngcontent-fwj-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-fwj-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-less" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/PerformanceAnalysis/BptaDelayAnalysis/entry/src/main/ets/pages/MainPage.ets#L30-L68" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// products\phone\src\main\ets\pages\MainPage.ets</span></li><li><span class="hljs-selector-tag">Tabs</span>({ index: this.currentIndex }) {</li><li>  <span class="hljs-comment">// ...</span></li><li>}</li><li>.<span class="hljs-built_in">layoutWeight</span>(<span class="hljs-number">1</span>)</li><li>.<span class="hljs-built_in">scrollable</span>(false)</li><li>.<span class="hljs-built_in">onChange</span>((index) =&gt; {</li><li>  this.currentIndex = index;</li><li>  ContinueModel.<span class="hljs-built_in">getInstance</span>().data.mainTabIndex = index;</li><li>  if (AppStorage.<span class="hljs-built_in">get</span>(<span class="hljs-string">'audioPlayerStatus'</span>) !== AudioPlayerStatus.IDLE) {</li><li>    AudioPlayerService.<span class="hljs-built_in">getInstance</span>().<span class="hljs-built_in">stop</span>().<span class="hljs-built_in">then</span>(() =&gt; {</li><li>      AudioPlayerService.<span class="hljs-built_in">destroy</span>();</li><li>    });</li><li>  }</li><li>})</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/PerformanceAnalysis/BptaDelayAnalysis/entry/src/main/ets/pages/MainPage.ets#L30-L68" target="_blank">MainPage.ets</a></div></div></div></div> <p>AudioPlayerService.ets相关代码如下</p> <div class="screenLinkPre"><div _ngcontent-fwj-c106="" class="highlight-div"><div _ngcontent-fwj-c106="" class="highlight-div-header"><div _ngcontent-fwj-c106="" class="highlight-div-header-left"><div _ngcontent-fwj-c106="" class="handle-button expand-button"><div _ngcontent-fwj-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-fwj-c106="" class="highlight-div-header-right"><div _ngcontent-fwj-c106="" class="handle-button ai-button"></div><div _ngcontent-fwj-c106="" class="handle-button line-button"><div _ngcontent-fwj-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-fwj-c106="" class="handle-button theme-button"><div _ngcontent-fwj-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-fwj-c106="" class="handle-button copy-button"><div _ngcontent-fwj-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-fwj-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-csharp" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/PerformanceAnalysis/BptaDelayAnalysis/entry/src/main/ets/components/AudioPlayerService.ets#L17-L61" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// commons\audioplayer\src\main\ets\service\AudioPlayerService.ets</span></li><li>export <span class="hljs-keyword">class</span> <span class="hljs-title">AudioPlayerService</span> {</li><li>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> instance: AudioPlayerService | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;</li><li>  <span class="hljs-comment">// ...</span></li><li>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title">getInstance</span>(): AudioPlayerService</span> {</li><li>    <span class="hljs-keyword">if</span> (!AudioPlayerService.instance) {</li><li>      AudioPlayerService.instance = <span class="hljs-keyword">new</span> AudioPlayerService();</li><li>    }</li><li>    <span class="hljs-keyword">return</span> AudioPlayerService.instance;</li><li>  }</li><li>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title">destroy</span>(): <span class="hljs-keyword">void</span></span> {</li><li>    <span class="hljs-keyword">if</span> (AudioPlayerService.isInstanceNotNull()) {</li><li>      AudioPlayerService.getInstance().releaseAudioPlayer();</li><li>      AudioPlayerService.instance = <span class="hljs-literal">null</span>;</li><li>    }</li><li>  }</li><li>  <span class="hljs-comment">// ...</span></li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/PerformanceAnalysis/BptaDelayAnalysis/entry/src/main/ets/components/AudioPlayerService.ets#L17-L61" target="_blank">AudioPlayerService.ets</a></div></div></div></div> <p>观察源代码发现AudioPlayerService调用getInstance创建单例对象耗费大量时间，随即又调用destroy方法销毁对象。优化方式如下：获取单例对象前，先判断单例对象是否被实例化，若没有实例化则直接跳过获取与销毁，避免实例对象的无效创建与销毁，参考如下代码。</p> <div class="screenLinkPre"><div _ngcontent-fwj-c106="" class="highlight-div"><div _ngcontent-fwj-c106="" class="highlight-div-header"><div _ngcontent-fwj-c106="" class="highlight-div-header-left"><div _ngcontent-fwj-c106="" class="handle-button expand-button"><div _ngcontent-fwj-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-fwj-c106="" class="highlight-div-header-right"><div _ngcontent-fwj-c106="" class="handle-button ai-button"></div><div _ngcontent-fwj-c106="" class="handle-button line-button"><div _ngcontent-fwj-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-fwj-c106="" class="handle-button theme-button"><div _ngcontent-fwj-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-fwj-c106="" class="handle-button copy-button"><div _ngcontent-fwj-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-fwj-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-less" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/PerformanceAnalysis/BptaDelayAnalysis/entry/src/main/ets/pages/MainPage.ets#L30-L68" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// products\phone\src\main\ets\pages\MainPage.ets</span></li><li><span class="hljs-selector-tag">Tabs</span>({ index: this.currentIndex }) {</li><li>  <span class="hljs-comment">// ...</span></li><li>}</li><li>.<span class="hljs-built_in">layoutWeight</span>(<span class="hljs-number">1</span>)</li><li>.<span class="hljs-built_in">scrollable</span>(false)</li><li>.<span class="hljs-built_in">onChange</span>((index) =&gt; {</li><li>  this.currentIndex = index;</li><li>  ContinueModel.<span class="hljs-built_in">getInstance</span>().data.mainTabIndex = index;</li><li>  if (AppStorage.<span class="hljs-built_in">get</span>(<span class="hljs-string">'audioPlayerStatus'</span>) !== AudioPlayerStatus.IDLE) {</li><li>    AudioPlayerService.<span class="hljs-built_in">getInstance</span>().<span class="hljs-built_in">stop</span>().<span class="hljs-built_in">then</span>(() =&gt; {</li><li>      AudioPlayerService.<span class="hljs-built_in">destroy</span>();</li><li>    });</li><li>  }</li><li>})</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/PerformanceAnalysis/BptaDelayAnalysis/entry/src/main/ets/pages/MainPage.ets#L30-L68" target="_blank">MainPage.ets</a></div></div></div></div> <p>优化后AudioPlayerService.ets代码如下：</p> <div class="screenLinkPre"><div _ngcontent-fwj-c106="" class="highlight-div"><div _ngcontent-fwj-c106="" class="highlight-div-header"><div _ngcontent-fwj-c106="" class="highlight-div-header-left"><div _ngcontent-fwj-c106="" class="handle-button expand-button"><div _ngcontent-fwj-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-fwj-c106="" class="highlight-div-header-right"><div _ngcontent-fwj-c106="" class="handle-button ai-button"></div><div _ngcontent-fwj-c106="" class="handle-button line-button"><div _ngcontent-fwj-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-fwj-c106="" class="handle-button theme-button"><div _ngcontent-fwj-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-fwj-c106="" class="handle-button copy-button"><div _ngcontent-fwj-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-fwj-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-csharp" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/PerformanceAnalysis/BptaDelayAnalysis/entry/src/main/ets/components/AudioPlayerService.ets#L18-L62" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// commons\audioplayer\src\main\ets\service\AudioPlayerService.ets</span></li><li>export <span class="hljs-keyword">class</span> <span class="hljs-title">AudioPlayerService</span> {</li><li>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> instance: AudioPlayerService | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;</li><li>  <span class="hljs-comment">// ...</span></li><li>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title">getInstance</span>(): AudioPlayerService</span> {</li><li>    <span class="hljs-keyword">if</span> (!AudioPlayerService.instance) {</li><li>      AudioPlayerService.instance = <span class="hljs-keyword">new</span> AudioPlayerService();</li><li>    }</li><li>    <span class="hljs-keyword">return</span> AudioPlayerService.instance;</li><li>  }</li><li>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title">destroy</span>(): <span class="hljs-keyword">void</span></span> {</li><li>    <span class="hljs-keyword">if</span> (AudioPlayerService.isInstanceNotNull()) {</li><li>      AudioPlayerService.getInstance().releaseAudioPlayer();</li><li>      AudioPlayerService.instance = <span class="hljs-literal">null</span>;</li><li>    }</li><li>  }</li><li>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title">isInstanceNotNull</span>(): boolean</span> {</li><li>    <span class="hljs-keyword">return</span> AudioPlayerService.instance !== <span class="hljs-literal">null</span>;</li><li>  }</li><li>  <span class="hljs-comment">// ...</span></li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/PerformanceAnalysis/BptaDelayAnalysis/entry/src/main/ets/components/AudioPlayerService.ets#L18-L62" target="_blank">AudioPlayerService.ets</a></div></div></div></div> </div> <div class="tiledSection"><h3 id="section16557114623519">Frame主线程泳道分析异常<i class="anchor-icon anchor-icon-link" anchorid="section16557114623519" tips="复制节点链接"></i></h3><p>查看Frame泳道中的应用主线程子泳道，观察app侧帧数据。如果在这个泳道中出现红色帧，通常表示该帧的渲染时间超过了预期，这可能是一个性能异常的指示。</p> <p>如下图所示的第145帧</p> <div class="fignone"><span class="figcap"><b>图8 </b>超长帧Trace信息</span><br><span><img height="415.311" originheight="702" originwidth="1551" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163403.97247634978986942142984096139779:50001231000000:2800:B908B9CBE697991E707C6096E903DA4C65FD987ED9E327F46E17666B2D29294D.png" title="点击放大" width="920"></span></div> <p>每帧的预期耗时（ms） = 1000ms / 帧率。如上图所示，选中超长帧后，可以看到该帧的预期耗时Expected Duration为 8ms 330μs，说明帧率是 120。实际耗时为 92ms 571μs，远超预期耗时，因此被识别为超长帧。超长帧的长时间渲染会直接影响用户体验，导致点击完成时延不达标。</p> <p>通过上图发现卡顿期间存在较长的ExecuteJS调用，需要查看具体的调用栈。观察ArkTS Callstack泳道无异常后，接下来查看Callstack泳道的函数栈。</p> <p>关于首帧渲染的特别说明：页面跳转后，由于需要重新加载和渲染新的UI元素，首帧渲染时间往往较长，可能无法达到目标帧率下的预期耗时。因此，性能分析中首帧出现红色（即超出合理预期时间）是较为常见现象，不一定表示存在严重性能问题。但仍需关注首帧渲染时间，必要时进行优化。</p> </div> <div class="tiledSection"><h3 id="section55891052173517">Callstack泳道分析Native侧耗时函数<i class="anchor-icon anchor-icon-link" anchorid="section55891052173517" tips="复制节点链接"></i></h3><p>Callstack泳道，该泳道显示Native函数调用泳道，也可以看到Native函数调用栈以及各函数的耗时情况，重点关注主线程和有内容的WorkerThread子泳道。</p> <div class="p">下图展示了超长帧案例中Callstack的主线程子泳道。<div class="fignone"><span class="figcap"><b>图9 </b>Callstack主线程泳道图</span><br><span><img height="467.88900000000007" originheight="794" originwidth="1561" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163403.55187742054121017352734110506624:50001231000000:2800:C774ECFE26F7775B44E98102F61BC29A9DBFF92298E01A59772475063E335211.png" title="点击放大" width="920"></span></div> </div> <p>滑动查看右侧权重最高的函数调用栈，定位到MainPage.ets文件第203行代码为主要耗时原因。</p> </div> <div class="tiledSection"><h3 id="section16492165373810">ArkUI Component泳道分析组件绘制耗时<i class="anchor-icon anchor-icon-link" anchorid="section16492165373810" tips="复制节点链接"></i></h3><p>ArkUI Component泳道记录了自定义组件以及系统组件的绘制次数、耗时等信息，重点关注相对于其他组件耗时比较久的组件。</p> <div class="fignone"><span class="figcap"><b>图10 </b>ArkUI Component泳道泳道图</span><br><span><img height="382.0185" originheight="650" originwidth="1561" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163403.06552992490467445816271619943602:50001231000000:2800:269BE55DF046FE844CC6F31204A21428D8003F9FCA22BF4ABA46F7FDAE87F63C.png" title="点击放大" width="920"></span></div> <p>然后可以在详情（Details）中使用下图中被框选的按钮过滤目标组件，查看组件在刷新过程中不同阶段的耗时情况。结合函数调用栈和ArkUI Inspector工具，定位目标组件绘制耗时过长的具体原因。</p> <div class="fignone"><span class="figcap"><b>图11 </b>ArkUI Component泳道图Details信息</span><br><span><img height="275.13750000000005" originheight="368" originwidth="1224" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163403.04735811555461759560048419264872:50001231000000:2800:1BDA4244F959103348E6ABB9F804BBC3D2662E980F012DC0925003B707907492.png" title="点击放大" width="920"></span></div> </div> <div class="tiledSection"><h3 id="section1534025817382">H:Animator泳道分析动画时长<i class="anchor-icon anchor-icon-link" anchorid="section1534025817382" tips="复制节点链接"></i></h3><p>在页面切换过程中，如果存在加载的 loading 动画，出于用户体验考虑，可将动画停止与网络请求的完成相关联。例如，展示“加载中”状态，直到数据加载完成。通过 H:Animator 泳道，可以观察到动画的耗时。</p> <div class="fignone"><span class="figcap"><b>图12 </b>H:Animator 泳道图</span><br><span><img height="213.78500000000003" originheight="365" originwidth="1564" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163403.41976542303781175121257663743356:50001231000000:2800:F5112227FE79C2E56327A9FBB3287E266127D0495E33AB3F6BC05FDB41116F6C.png" title="点击放大" width="920"></span></div> </div> <div class="tiledSection"><h2 id="section159662855717">完成时延解决方案<i class="anchor-icon anchor-icon-link" anchorid="section159662855717" tips="复制节点链接"></i></h2></div> <div class="tiledSection"><h3 id="section1677412499286" class="firsth2">UI线程应用自身方法耗时长影响页面首次加载时延<i class="anchor-icon anchor-icon-link" anchorid="section1677412499286" tips="复制节点链接"></i></h3><p>当UI线程应用自身方法耗时过长时，会影响页面首次加载时延。AppAnalyzer提供了场景化体验检测，能帮助检测出耗时函数，协助开发者快速定位到问题点，并提供相应的优化建议。UI线程应用自身方法耗时长可参考<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-zhenlv#section117831333645" target="_blank">分析耗时函数的callstack</a>中的解决方案进行相应的代码优化。</p> </div> <div class="tiledSection"><h3 id="section375382219020">网络请求耗时<i class="anchor-icon anchor-icon-link" anchorid="section375382219020" tips="复制节点链接"></i></h3><p>在附带网络请求的页面跳转场景中，完成时延较长的绝大多数原因在于网络数据的HTTP请求时间较长。由于网络请求从操作系统侧发起和控制，并且网络环境存在不可控性，因此很难在业务逻辑代码中优化请求速度。因此，提前发起请求就显得尤为重要。通常可以从以下两个方面进行优化：</p> <p><strong>避免在异步函数中发起网络请求</strong></p> <p>由于ArkTS单线程EventLoop特性，异步调用的执行时机会被延迟到同步逻辑之后。如果将Http请求接口放在异步函数中，网络请求可能会被UI绘制阻塞，等待第一帧UI绘制结束才开始。如果页面首帧较复杂，这会导致网络请求的延迟时间显著增加。</p> <p><span><img height="548.4925000000001" originheight="1866" originwidth="3120" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163403.29849727357687454726477949405779:50001231000000:2800:B7F67BCCC9BD3FCDEE96BD45D90EEA0538233D04B4A0C1DAF1C506ADCA9662BA.png" title="点击放大" width="920"></span></p> <p><strong>避免在页面子组件中发起网络请求</strong></p> <p>由于ArkUI组件的创建基于组件树结构，存在先后顺序。如果在页面的某一子组件中发起网络请求，该请求需要等待前面的组件创建完成。如果前面的组件创建耗时较长，会导致该请求被严重阻塞。</p> <p>如下图情况，应用页面结构分为Header和Tabs两部分，如果将Tabs内容数据的Http请求放在Tabs组件中发起，由于Tabs组件在UI结构上依赖Header部分，则需要先创建Header，同时又因为Header内容的渲染也依赖网络请求，所以最终导致Tabs的数据请求严重延后。</p> <p><span><img height="566.0185" originheight="1925" originwidth="3120" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163403.72195907192436629133618468393265:50001231000000:2800:E75B8D43C8703AC3E11F36602ED51B827F2F7986CEE7610269AB634F8CEBA388.png" title="点击放大" width="920"></span></p> </div> <div class="tiledSection"><h3 id="section486611519017">动画时延耗时<i class="anchor-icon anchor-icon-link" anchorid="section486611519017" tips="复制节点链接"></i></h3><p>页面转场动画对提升用户体验至关重要。动画时延过长会显著影响用户的点击完成时延。动画完成时间直接关系到用户何时可以开始与应用交互。动画时延的主要原因是动画时长设置过长。</p> <p>常见的页面转场动画时长参数有：</p> <ol><li><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-tabs" target="_blank">Tabs</a>组件设置TabContent切换动画时长，即<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-tabs#animationduration" target="_blank">animationDuration</a>属性。</li><li><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-swiper" target="_blank">Swiper</a>组件设置子组件切换动画时长，即<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-swiper#duration" target="_blank">duration</a>属性。</li><li>页面间转场（<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-page-transition-animation" target="_blank">pageTransition</a>）设置转场动画时长，即<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-page-transition-animation#pagetransitionoptions对象说明" target="_blank">PageTransitionOptions</a>对象中的duration字段。</li></ol> <p>使用Tabs组件进行页面切换时，当不设置BottomTabBarStyle时默认<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-tabs#animationduration" target="_blank">animationDuration</a>属性有300ms的动画时长，当该属性值设置过长时会导致完成时延变大。接下来将该属性值分别设置为100ms与1000ms来探究animationDuration属性对完成时延的影响。</p> <p>实验一：设置animationDuration为100ms</p> <div class="screenLinkPre"><div _ngcontent-fwj-c106="" class="highlight-div"><div _ngcontent-fwj-c106="" class="highlight-div-header"><div _ngcontent-fwj-c106="" class="highlight-div-header-left"><div _ngcontent-fwj-c106="" class="handle-button expand-button"><div _ngcontent-fwj-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-fwj-c106="" class="highlight-div-header-right"><div _ngcontent-fwj-c106="" class="handle-button ai-button"></div><div _ngcontent-fwj-c106="" class="handle-button line-button"><div _ngcontent-fwj-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-fwj-c106="" class="handle-button theme-button"><div _ngcontent-fwj-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-fwj-c106="" class="handle-button copy-button"><div _ngcontent-fwj-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-fwj-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-cangjie" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/PerformanceAnalysis/BptaDelayAnalysis/entry/src/main/ets/pages/page1.ets#L21-L76" data-highlighted="yes"><ol class="linenums"><li>@<span class="hljs-title function_">Entry</span></li><li>@<span class="hljs-title function_">Component</span></li><li><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TabsPositiveExample</span> {</li><li>  @<span class="hljs-title function_">State</span> <span class="hljs-variable">currentIndex</span>: <span class="hljs-title class_">number</span> = <span class="hljs-number">0</span>;</li><li>  <span class="hljs-keyword">private</span> <span class="hljs-variable">controller</span>: <span class="hljs-title class_">TabsController</span> = <span class="hljs-variable">new</span> <span class="hljs-title function_">TabsController</span>();</li><li>  <span class="hljs-keyword">private</span> <span class="hljs-variable">list</span>: <span class="hljs-title class_">string</span>[] = [<span class="hljs-string">'green'</span>, <span class="hljs-string">'blue'</span>, <span class="hljs-string">'yellow'</span>, <span class="hljs-string">'pink'</span>];</li><li>
</li><li>  @<span class="hljs-title function_">Builder</span></li><li>  <span class="hljs-title function_">customContent</span>(<span class="hljs-variable">color</span>: <span class="hljs-title class_">Color</span>) {</li><li>    <span class="hljs-title function_">Column</span>()</li><li>      .<span class="hljs-title function_">width</span>(<span class="hljs-string">'100%'</span>)</li><li>      .<span class="hljs-title function_">height</span>(<span class="hljs-string">'100%'</span>)</li><li>      .<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-variable">color</span>)</li><li>  }</li><li>
</li><li>  <span class="hljs-title function_">build</span>() {</li><li>    <span class="hljs-title function_">Column</span>() {</li><li>      <span class="hljs-title function_">Row</span>({ <span class="hljs-variable">space</span>: <span class="hljs-number">10</span> }) {</li><li>        <span class="hljs-title function_">ForEach</span>(<span class="hljs-keyword">this</span>.<span class="hljs-variable">list</span>, (<span class="hljs-variable">item</span>: <span class="hljs-title class_">string</span>, <span class="hljs-variable">index</span>: <span class="hljs-title class_">number</span>) =&gt; {</li><li>          <span class="hljs-title function_">Text</span>(<span class="hljs-variable">item</span>)</li><li>            .<span class="hljs-title function_">textAlign</span>(<span class="hljs-variable">TextAlign</span>.<span class="hljs-variable">Center</span>)</li><li>            .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">16</span>)</li><li>            .<span class="hljs-title function_">height</span>(<span class="hljs-number">32</span>)</li><li>            .<span class="hljs-title function_">layoutWeight</span>(<span class="hljs-number">1</span>)</li><li>            .<span class="hljs-title function_">fontColor</span>(<span class="hljs-keyword">this</span>.<span class="hljs-variable">currentIndex</span> === <span class="hljs-variable">index</span> ? <span class="hljs-variable">Color</span>.<span class="hljs-variable">White</span> : <span class="hljs-title class_">Color</span>.<span class="hljs-title class_">Black</span>)</li><li>            .<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-keyword">this</span>.<span class="hljs-variable">currentIndex</span> === <span class="hljs-variable">index</span> ? <span class="hljs-variable">Color</span>.<span class="hljs-variable">Blue</span> : <span class="hljs-string">'#f2f2f2'</span>)</li><li>            .<span class="hljs-title function_">borderRadius</span>(<span class="hljs-number">16</span>)</li><li>            .<span class="hljs-title function_">onClick</span>(() =&gt; {</li><li>              <span class="hljs-keyword">this</span>.<span class="hljs-variable">currentIndex</span> = <span class="hljs-variable">index</span>;</li><li>              <span class="hljs-keyword">this</span>.<span class="hljs-variable">controller</span>.<span class="hljs-title function_">changeIndex</span>(<span class="hljs-variable">index</span>);</li><li>            })</li><li>        }, (<span class="hljs-variable">item</span>: <span class="hljs-title class_">string</span>, <span class="hljs-variable">index</span>: <span class="hljs-title class_">number</span>) =&gt; <span class="hljs-variable">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-variable">item</span>) + <span class="hljs-variable">index</span>)</li><li>      }</li><li>      .<span class="hljs-title function_">margin</span>(<span class="hljs-number">10</span>)</li><li>      <span class="hljs-title function_">Tabs</span>({ <span class="hljs-variable">barPosition</span>: <span class="hljs-title class_">BarPosition</span>.<span class="hljs-title class_">Start</span>, <span class="hljs-variable">controller</span>: <span class="hljs-keyword">this</span>.<span class="hljs-title class_">controller</span> }) {</li><li>        <span class="hljs-title function_">TabContent</span>() {</li><li>          <span class="hljs-keyword">this</span>.<span class="hljs-title function_">customContent</span>(<span class="hljs-variable">Color</span>.<span class="hljs-variable">Green</span>)</li><li>        }</li><li>        <span class="hljs-title function_">TabContent</span>() {</li><li>          <span class="hljs-keyword">this</span>.<span class="hljs-title function_">customContent</span>(<span class="hljs-variable">Color</span>.<span class="hljs-variable">Blue</span>)</li><li>        }</li><li>        <span class="hljs-title function_">TabContent</span>() {</li><li>          <span class="hljs-keyword">this</span>.<span class="hljs-title function_">customContent</span>(<span class="hljs-variable">Color</span>.<span class="hljs-variable">Yellow</span>)</li><li>        }</li><li>        <span class="hljs-title function_">TabContent</span>() {</li><li>          <span class="hljs-keyword">this</span>.<span class="hljs-title function_">customContent</span>(<span class="hljs-variable">Color</span>.<span class="hljs-variable">Pink</span>)</li><li>        }</li><li>      }</li><li>      .<span class="hljs-title function_">animationDuration</span>(<span class="hljs-number">100</span>)</li><li>      .<span class="hljs-title function_">layoutWeight</span>(<span class="hljs-number">1</span>)</li><li>      .<span class="hljs-title function_">barHeight</span>(<span class="hljs-number">0</span>)</li><li>      .<span class="hljs-title function_">scrollable</span>(<span class="hljs-keyword">false</span>)</li><li>    }</li><li>    .<span class="hljs-title function_">width</span>(<span class="hljs-string">'100%'</span>)</li><li>  }</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/PerformanceAnalysis/BptaDelayAnalysis/entry/src/main/ets/pages/page1.ets#L21-L76" target="_blank">page1.ets</a></div></div></div></div> <p><span><img height="387.2855" originheight="924" originwidth="2195" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163403.52699057253655672486614363796504:50001231000000:2800:649DA76D558A1FBEE9C12A1DE0051B1D5F1BBA91ED66DCD1E9B6D3CC8D9B7EA0.png" title="点击放大" width="920"></span></p> <div class="p">实验二：设置animationDuration为1000ms<div class="screenLinkPre"><div _ngcontent-fwj-c106="" class="highlight-div"><div _ngcontent-fwj-c106="" class="highlight-div-header"><div _ngcontent-fwj-c106="" class="highlight-div-header-left"><div _ngcontent-fwj-c106="" class="handle-button expand-button"><div _ngcontent-fwj-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-fwj-c106="" class="highlight-div-header-right"><div _ngcontent-fwj-c106="" class="handle-button ai-button"></div><div _ngcontent-fwj-c106="" class="handle-button line-button"><div _ngcontent-fwj-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-fwj-c106="" class="handle-button theme-button"><div _ngcontent-fwj-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-fwj-c106="" class="handle-button copy-button"><div _ngcontent-fwj-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-fwj-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-scss" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/PerformanceAnalysis/BptaDelayAnalysis/entry/src/main/ets/pages/page2.ets#L17-L36" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">@Entry</span></li><li><span class="hljs-keyword">@Component</span></li><li>struct TabsNegativeExample {</li><li>  <span class="hljs-comment">// ...</span></li><li>  private controller: TabsController = new <span class="hljs-built_in">TabsController</span>();</li><li>  <span class="hljs-comment">// ...</span></li><li>  <span class="hljs-built_in">build</span>() {</li><li>    <span class="hljs-built_in">Column</span>() {</li><li>      <span class="hljs-comment">// ...</span></li><li>      <span class="hljs-built_in">Tabs</span>({ barPosition: BarPosition.Start, controller: this.controller }) {</li><li>        <span class="hljs-comment">// ...</span></li><li>      }</li><li>      <span class="hljs-selector-class">.barHeight</span>(<span class="hljs-number">0</span>)</li><li>      <span class="hljs-selector-class">.layoutWeight</span>(<span class="hljs-number">1</span>)</li><li>      <span class="hljs-selector-class">.animationDuration</span>(<span class="hljs-number">1000</span>)</li><li>      <span class="hljs-selector-class">.scrollable</span>(false)</li><li>    }</li><li>    <span class="hljs-selector-class">.width</span>('<span class="hljs-number">100%</span>')</li><li>  }</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/PerformanceAnalysis/BptaDelayAnalysis/entry/src/main/ets/pages/page2.ets#L17-L36" target="_blank">page2.ets</a></div></div></div></div> </div> <p><span><img height="387.458" originheight="924" originwidth="2194" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163404.08094299213828471319715338322702:50001231000000:2800:C1225CAA5E721B0223C01A554E6DD672A81974CB9352DCFD21A1E2FD7830FDE7.png" title="点击放大" width="920"></span></p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><caption><b>表1 </b>运行效果图</caption><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.31.11.2.3.1.1" valign="top" width="50%"><p>设置animationDuration为100ms</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.31.11.2.3.1.2" valign="top" width="50%"><p>设置animationDuration为1000ms</p> </th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="50%"><p><span><img height="549.2900000000001" originheight="1080" originwidth="523" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163404.88642955089264805028723648349305:50001231000000:2800:5B4DE09ECA6D3B68095EEB04D30C362C59C0D244C124ACBA2B6AD92BD01954FD.gif" title="点击放大" width="266"></span></p> </td> <td class="cellrowborder" valign="top" width="50%"><p><span><img height="549.2900000000001" originheight="1080" originwidth="523" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163404.56282728546417362770208583284464:50001231000000:2800:B6F874539D0934CB1FAD42DD89C8CCE2984E6D63B314ED1CE20992910D733998.gif" title="点击放大" width="266"></span></p> </td> </tr>  </tbody></table></div> </div>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><caption><b>表2 </b>animationDuration属性值对比</caption><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.31.12.2.3.1.1" valign="top" width="50%"><p>animationDuration属性值</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.31.12.2.3.1.2" valign="top" width="50%"><p>完成时延</p> </th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="50%"><p>100ms</p> </td> <td class="cellrowborder" valign="top" width="50%"><p>99ms39μs</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="50%"><p>1000ms</p> </td> <td class="cellrowborder" valign="top" width="50%"><p>1s7ms693μs</p> </td> </tr>  </tbody></table></div> </div> <p>上述示例通过减少animationDuration属性的数值，可以减小Tabs组件切换动画的完成时延。不设置BottomTabBarStyle样式时，动画时长默认为300ms。开发者可根据实际业务场景适当降低动画时长，以提高应用性能。</p> </div> <div class="tiledSection"><h3 id="section17275715501">UI组件优化<i class="anchor-icon anchor-icon-link" anchorid="section17275715501" tips="复制节点链接"></i></h3><p>转场新页面的组件过于复杂、布局不合理以及资源全量加载等会影响页面首次加载时延，可以采取如下方法进行性能优化：</p> <ul><li>UI优化：可以通过减少嵌套层级、减少渲染时间、使用缓存动效、LazyForEach懒加载、动态import等方式进行优化。相关原理介绍以及场景案例，请参考<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-click-to-click-response-optimization#section1497610408322" target="_blank">《点击响应时延分析-UI优化》</a>。</li><li>全局自定义组件复用：使用自定义组件复用池，实现跨页面的组件复用，实现思路以及场景案例，请参考<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-component-reuse" target="_blank">组件复用</a>。</li><li>预创建组件：使用组件预创建，可以利用动画执行过程空闲时间进行组件预创建和属性设置。相关原理介绍以及场景案例，请参考<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-ui-dynamic-operations" target="_blank">《声明式UI中实现组件动态创建》</a>。</li></ul> </div> <div class="tiledSection"><h2 id="section1449011518512">实践案例<i class="anchor-icon anchor-icon-link" anchorid="section1449011518512" tips="复制节点链接"></i></h2></div> <div class="tiledSection"><h3 id="section1563932810516" class="firsth2">存在大量等待时间无法诊断<i class="anchor-icon anchor-icon-link" anchorid="section1563932810516" tips="复制节点链接"></i></h3><p>在主线程长时间被阻塞的检测结果中，点击“存在大量等待时间无法诊断，请您确认”，打开Profiler工具，加载完成trace数据后，会框选主线程运行空闲的区域。</p> <p><span><img height="71.52442289039766" originheight="96" originwidth="1306" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163404.15576691041087778736858406482449:50001231000000:2800:26D731AC8032FF700AEAAC2D906F10C82459A1DF77A87102ECD0424EB5FAEB86.png" title="点击放大" width="920"></span></p> <p>可以看到框选的397ms中，主线程主要处于空闲状态。放大该选中区域，并从框选的范围内，从后往前找Running前面的Runnable，点击查看Runnable详情。</p> <p><span><img height="423.90252100000004" originheight="558" originwidth="969" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163404.47239995674939546001611093824479:50001231000000:2800:517F0CA279F181EA1BD9F7809E9E9CBA46AFE6EE814B2314666946EF79B3011D.png" title="点击放大" width="736.1550000000001"></span></p> <p>通过Runnable详情中的WakeUP From Tid，可以看到是VSyncGenerator唤醒的主线程。</p> <p><span><img height="417.6791850000001" originheight="541" originwidth="947" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163404.10818010298328592695835187825303:50001231000000:2800:A2278C79AA6172E5EA2FE93C4A4C88AF6943435518C577DA9D32C563BEF54D4C.png" title="点击放大" width="731.1675"></span></p> <p>点击该线程名后面的跳转按钮，跳转到VSyncGenerator线程的Running详情。</p> <p><span><img height="464.777145" originheight="554" originwidth="862" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163404.09232693988187034130827759095920:50001231000000:2800:6B881AE207B2A1293218639E9EEFE2A58E1864F2C289067248C152CB229DC38A.png" title="点击放大" width="723.1875"></span></p> <p>放大该区域，并点击该Running前面的Runnable，可看到详情中没有WakeUP From Tid，表示该线程此刻Running不是被其他线程唤醒的，且上一个状态是Sleeping，说明这条唤醒链路就断了。若该链路断掉，则需要回到主线程运行空闲的区域中，从后往前，继续上述查找步骤。</p> <p><span><img height="345.16386100000005" originheight="515" originwidth="1076" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163404.07632129068182161599424717837142:50001231000000:2800:A392ECC70A54B7549127612D79951FA18B600D761A0292295679B9C4E2A7C7A2.png" title="点击放大" width="721.1925"></span></p> <p>再次点击“存在大量等待时间无法诊断，请您确认”，回到主线程的空闲范围内，从后往前，继续找到上一个Running前面的Runnable，查看详情。</p> <p><span><img height="385.81305" originheight="546" originwidth="1022" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163404.18505102340658402617607679273317:50001231000000:2800:FD9BB098B4E6419965554C7D0418AB16D778DB6C6D58EAD06EB8EB1B9406DF57.png" title="点击放大" width="722.19"></span></p> <p>通过WakeUP From Tid，可以看到是OS_FRRT_2_1线程唤醒的主线程，点击后面的跳转按钮，跳转到对应线程的运行泳道。</p> <p><span><img height="438.42918000000003" originheight="581" originwidth="957" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163404.83782207975864069313034322469755:50001231000000:2800:36B88990F01E35C5D78C80E6FF9F1AFB8A83583ECEB34B82B0100526446D1858.png" title="点击放大" width="722.19"></span></p> <p>可以看到上一个状态是Runnable（Preempted），可能是CPU的时间片调度用完了，可继续查看该状态的前一个线程状态是否为Running。如果是，则缩小该区域，观察该线程是否连续在Running，并找到连续Running的开始时间。</p> <p><span><img height="431.35397900000004" originheight="598" originwidth="997" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163404.19440181473832256798071259058393:50001231000000:2800:94D92979144499A881BDD27395A2660265C5D37F956F06B6F41D80D64FCD7823.png" title="点击放大" width="719.1975"></span></p> <p>通过连续Running的开始时间的第一个Running前面的Runnable，继续找线程唤醒关系。</p> <p><span><img height="418.68160600000004" originheight="584" originwidth="999" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163404.43305427523660628376846436547933:50001231000000:2800:31B03BE790948282D4AA7298FC20EEE0859BB04AEF49DBA3F597B3DA50E5817F.png" title="点击放大" width="716.205"></span></p> <p>查看Runnable详情中的WakeUP From Tid，可发现此刻Running的线程是主线程的唤醒的，将该子线程泳道收藏，并通过跳转按钮找到主线程唤醒该子线程的位置。<span><img height="247.79496000000003" originheight="373" originwidth="1069" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163405.87303024399111405928764337817173:50001231000000:2800:4D8C8F94731A61396549F096024C367260422610BFD85A0AAB5FB1D068CD0AAF.png" title="点击放大" width="710.22"></span></p> <p>可以看到该空闲时间段，主要是在等待子线程OS_FFRT线程执行耗时任务导致，需要开发者判断主线程是否依赖子线程的返回，如果主线程依赖子线程返回，需要优化子线程的函数耗时，或者将耗时任务提前执行。</p> </div> </div> <div></div></div>