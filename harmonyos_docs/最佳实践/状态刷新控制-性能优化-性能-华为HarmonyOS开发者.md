<h1 _ngcontent-ejw-c119="" class="doc-title ng-star-inserted" title="状态刷新控制"> 状态刷新控制 </h1>

<div _ngcontent-ejw-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;">   <div>    <p>在声明式UI编程范式中，UI是应用程序状态的函数，应用程序状态的修改会更新相应的UI界面。ArkUI采用了<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-mvvm" target="_blank">MVVM</a>模式，其中ViewModel将数据与视图绑定在一起，更新数据的时候直接更新视图。如下图所示：</p>    <div class="fignone">     <span class="figcap"><b>图1 </b>ArkUI的MVVM模式</span>    </div>    <p><span><img height="70.8225" originheight="127" originwidth="937" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163408.38974189384215701843961715094010:50001231000000:2800:2A9793BB37F99F7A5377BBA88C7379194B77529BEE21C6B5575C8B2AB9529EB4.png" title="点击放大" width="523.6875"></span></p>    <p>ArkUI提供了一系列装饰器实现ViewModel的能力，如<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-prop" target="_blank">@Prop</a>、<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-link" target="_blank">@Link</a>、<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-provide-and-consume" target="_blank">@Provide</a>、<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-localstorage" target="_blank">LocalStorage</a>等。当自定义组件内变量被装饰器装饰时变为状态变量，状态变量的改变会引起UI的渲染刷新。</p>    <div class="tiledSection">     <h2 id="section185157383443">避免不必要的状态变量使用<i class="anchor-icon anchor-icon-link" anchorid="section185157383443" tips="复制节点链接"></i></h2>          <ul>      <li>状态变量的管理有一定的开销，应在合理场景使用，普通的变量用状态变量标记可能会导致性能劣化，应删除冗余的状态变量标记。</li>      <li>通过使用临时变量的计算代替直接操作状态变量，可以使ArkUI仅在最后一次状态变量变更时查询并渲染组件，建议使用临时变量替换状态变量，减少不必要的行为，从而提高应用性能。</li>     </ul>     <p>具体参考<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-status-management#section2674939304">避免不必要的状态变量的使用</a>。</p>    </div>    <div class="tiledSection">     <h2 id="section980095211115">最小化状态共享范围<i class="anchor-icon anchor-icon-link" anchorid="section980095211115" tips="复制节点链接"></i></h2>          <ul>      <li>状态变量使用范围不当，可能会带来<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-redundancy-refresh-guide">冗余刷新</a>的性能问题。</li>      <li>在没有强烈的业务需求下，尽可能按照状态需要共享的最小范围选择合适的装饰器实现<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-status-management#section3584536184117">最小化状态共享范围</a>。应用开发过程中，按照组件颗粒度，状态一般分为组件内独享的状态和组件间需要共享的状态。</li>     </ul>    </div>    <div class="tiledSection">     <h2 id="section177535181111">减少不必要的参数层层传递<i class="anchor-icon anchor-icon-link" anchorid="section177535181111" tips="复制节点链接"></i></h2>          <p>当共享状态的组件间层级相差较大时，会出现状态层层传递的现象。对于状态传递过程中途经的全部组件，都需要增加入参接收该状态再将状态传递给子组件，因此应<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-status-management#section1024883517476">减少不必要的参数层层传递</a>并<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-status-management#section1619611428482">按照状态复杂度选择装饰器</a>。</p>    </div>    <div class="tiledSection">     <h2 id="section192031839111715">精细化拆分复杂状态<i class="anchor-icon anchor-icon-link" anchorid="section192031839111715" tips="复制节点链接"></i></h2>          <p>对于AppStorage的使用，由于其作用范围最广，开发者为了方便开发容易将各种状态存入其中以达到共享的目的，这通常会造成大量的性能损失。具体的精细化拆分复杂操作案例请参阅<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-status-management#section5929038204918">精细化拆分复杂状态</a>。</p>    </div>    <div class="tiledSection">     <h2 id="section217910449270">集中化状态修改逻辑<i class="anchor-icon anchor-icon-link" anchorid="section217910449270" tips="复制节点链接"></i></h2>          <p>当多个子组件修改状态的逻辑基本相同时，建议将状态的修改集中到单个函数中，以提升逻辑的可复用性、代码的可维护性和可测试性。具体的集中化状态修改逻辑案例请参阅<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-status-management#section17423111515506">集中化状态修改逻辑</a>。</p>    </div>    <div class="tiledSection">     <h2 id="section206178298316">使用监听和订阅精准控制组件刷新<i class="anchor-icon anchor-icon-link" anchorid="section206178298316" tips="复制节点链接"></i></h2>          <p>在多个组件依赖同一数据源时，直接关联数据源会导致每次数据源变化都刷新所有组件。为精准控制组件刷新，可采取以下策略：</p>     <ul>      <li>在组件中<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-status-management#section117631443131915">使用 @Watch 装饰器监听数据源</a>，当数据变化时执行业务逻辑，确保只有满足条件的组件进行刷新。</li>      <li>当组件关系复杂或跨越层级过多时，推荐使用<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-inner-application-eventhub" target="_blank">EventHub</a>或者<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-emitter" target="_blank">Emitter</a>实现<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-status-management#section26916161205">自定义事件发布订阅</a>。当数据源改变时发布事件，依赖该数据源的组件通过订阅事件来获取数据源的改变，完成业务逻辑的处理，从而实现组件的精准刷新。</li>     </ul>    </div>   </div>   <div></div></div>