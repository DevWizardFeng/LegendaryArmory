<h1 _ngcontent-nok-c119="" class="doc-title ng-star-inserted" title="获取进程内存信息"> 获取进程内存信息 </h1>

<div _ngcontent-nok-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;"> <div><div class="tiledSection"><h2 id="section1566505918395">通过HiDumper查看内存信息<i class="anchor-icon anchor-icon-link" anchorid="section1566505918395" tips="复制节点链接"></i></h2><p>开发者可以通过以下步骤，获取到当前应用的内存信息。</p> <ol><li><span>打开示例应用，运行 hdc shell "hidumper -s WindowManagerService -a '-a'"获取到当前应用的pid。</span><p></p><p><span><img height="161.86100000000002" originheight="286" originwidth="1410" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163419.99379309326562675219339682033705:50001231000000:2800:E2054486C4BA48473B6BA1BAEF71597870DC5BB0DE6F50F751AD635FBF50351A.png" title="点击放大" width="798"></span></p> <p></p></li><li><span>输入 hdc shell "hidumper --mem [Pid]" ，并将命令中的 [Pid] 换成当前应用的Pid，就可以获取到示例应用的内存信息了</span></li></ol> <p>一般情况下，开发者只需要关注PSS （Proportional Set Size，实际使用物理内存）Total一列的数据，即示例应用实际使用的物理内存。如下图所示，应用总共占用了26279KB的内存，主要包括ArkTS Heap（ArkTS堆内存）的4712KB以及Native Heap的13164KB。</p> <p><span><img height="295.4728" originheight="528" originwidth="1426" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163420.81895626142694082108597452267016:50001231000000:2800:786F42CD0B9B4C1C3B633F9446FBFD9EFCFD5F51A4E4A4887DABD866B58B1625.png" title="点击放大" width="798"></span></p> </div> <div class="tiledSection"><h2 id="section1239181020268">通过代码获取应用内存信息<i class="anchor-icon anchor-icon-link" anchorid="section1239181020268" tips="复制节点链接"></i></h2><p>开发者可使用<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-hidebug" target="_blank">@ohos.hidebug (Debug调试)</a>接口获取应用进程的内存信息，使用指导详见<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/hidebug-guidelines#获取内存信息" target="_blank">获取内存信息</a>。</p> </div> <div class="tiledSection"><h2 id="section483194634212">使用onMemoryLevel()监听内存变化<i class="anchor-icon anchor-icon-link" anchorid="section483194634212" tips="复制节点链接"></i></h2><p>onMemoryLevel()是HarmonyOS提供监听系统内存变化的接口，开发者可以通过onMemoryLevel()监听内存变化，从而调整应用的内存。onMemoryLevel()回调包括三种方式，分别为<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-ability-abilitystage#abilitystage" target="_blank">AbilityStage</a>、<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-ability-ability#abilityonmemorylevel" target="_blank">UIAbility</a>、<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-app-ability-environmentcallback" target="_blank">EnvironmentCallback</a>。</p> <ul><li>AbilityStage：当HAP中的代码首次被加载到进程中的时候，系统会先创建AbilityStage实例，系统决定调整内存时，再回调AbilityStage实例的onMemoryLevel()方法。</li></ul> <ul><li>UIAbility：Ability是UIAbility的基类，在Ability中，提供系统内存变化的回调方法。</li><li>EnvironmentCallback：EnvironmentCallback模块提供应用上下文ApplicationContext对系统环境变化监听回调的能力。</li></ul> <p>MemoryLevel分为MEMORY_LEVEL_MODERATE、MEMORY_LEVEL_LOW和MEMORY_LEVEL_CRITICAL三种。其中，MEMORY_LEVEL_MODERATE代表当前系统内存压力适中，应用可以正常运行而不会受到太大影响，MEMORY_LEVEL_LOW代表当前系统的内存已经比较低了，应用应该释放不必要的内存资源，避免造成系统卡顿，MEMORY_LEVEL_CRITICAL代表当前所剩的系统内存非常紧张，应用应该尽可能释放更多的资源，以确保系统的稳定性和性能。开发人员应该根据不同的内存级别来采取相应的措施，如释放资源、优化内存使用等，以确保应用在不同内存状态下都能正常运行。MemoryLevel具体等级定义如下所示：</p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><caption><b>表1 </b>onMemoryLevel等级定义</caption><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.3.6.2.4.1.1" valign="top" width="18.161816181618164%"><p>等级</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.3.6.2.4.1.2" valign="top" width="17.241724172417243%"><p>值</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.3.6.2.4.1.3" valign="top" width="64.5964596459646%"><p>说明</p> </th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="18.161816181618164%"><p>MEMORY_LEVEL_MODERATE</p> </td> <td class="cellrowborder" valign="top" width="17.241724172417243%"><p>0</p> </td> <td class="cellrowborder" valign="top" width="64.5964596459646%"><p>系统内存适中。系统可能会开始根据LRU缓存规则杀死进程。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="18.161816181618164%"><p>MEMORY_LEVEL_LOW</p> </td> <td class="cellrowborder" valign="top" width="17.241724172417243%"><p>1</p> </td> <td class="cellrowborder" valign="top" width="64.5964596459646%"><p>系统内存比较低。此时应该去释放掉一些不必要的资源以提升系统的性能。</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="18.161816181618164%"><p>MEMORY_LEVEL_CRITICAL</p> </td> <td class="cellrowborder" valign="top" width="17.241724172417243%"><p>2</p> </td> <td class="cellrowborder" valign="top" width="64.5964596459646%"><p>系统内存很低。此时应当尽可能地去释放任何不必要的资源，因为系统可能会杀掉所有缓存中的进程，并且开始杀掉应当保持运行的进程，比如后台运行的服务。</p> </td> </tr>  </tbody></table></div> </div> <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"><p>后台已冻结的应用，AbilityStage、UIAbility、EnvironmentCallback的onMemoryLevel都不可以进行回调。</p> </div></div></div> </div> </div> <div></div></div>