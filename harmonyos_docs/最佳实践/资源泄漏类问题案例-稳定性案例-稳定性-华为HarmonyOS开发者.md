<h1 _ngcontent-tia-c119="" class="doc-title ng-star-inserted" title="资源泄漏类问题案例"> 资源泄漏类问题案例 </h1>

<div _ngcontent-tia-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;"> <div><p>本文按照<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-leak-way">资源泄漏分析方法</a>的流程展开，以实际案例的形式指导开发者如何从泄漏维测日志出发，分析、定位具体泄漏点。开发者可阅读<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/resource-leak-guidelines" target="_blank">资源泄漏检测</a>了解系统检测资源泄漏问题的机制与日志规格。</p> <div class="tiledSection"><h2 id="section433214716396">内存泄漏-JS内存泄漏类案例<i class="anchor-icon anchor-icon-link" anchorid="section433214716396" tips="复制节点链接"></i></h2></div> <div class="tiledSection"><h3 id="section2536151419459" class="firsth2">概述<i class="anchor-icon anchor-icon-link" anchorid="section2536151419459" tips="复制节点链接"></i></h3><p>该类问题的典型特征是ArkTS层代码编写不规范，如组件未释放等，持续泄漏后会导致应用闪退。</p> </div> <div class="tiledSection"><h3 id="section17538102654510">问题现象<i class="anchor-icon anchor-icon-link" anchorid="section17538102654510" tips="复制节点链接"></i></h3><p>应用卡顿甚至发生闪退。</p> </div> <div class="tiledSection"><h3 id="section15220183694512">问题代码<i class="anchor-icon anchor-icon-link" anchorid="section15220183694512" tips="复制节点链接"></i></h3><p>代码中定时器没有增加停止逻辑导致组件一直没有释放，出现泄漏。</p> <p><span><img originheight="344" originwidth="616" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163449.52944799915129829258124047030254:50001231000000:2800:2C4CC25F630B35CA78EF8C8CD4CCA0A4288624D2CB71E0A0DE08542A144F6ED2.png" width="616" height="344"></span></p> </div> <div class="tiledSection"><h3 id="section164454094518">分析思路<i class="anchor-icon anchor-icon-link" anchorid="section164454094518" tips="复制节点链接"></i></h3><p>详见<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-leak-way#section1183695881312">JS泄漏问题分析方法</a>。</p> </div> <div class="tiledSection"><h3 id="section4243145194514">分析步骤<i class="anchor-icon anchor-icon-link" anchorid="section4243145194514" tips="复制节点链接"></i></h3><p>某应用AppIconCalendar对象大量泄漏触发虚拟机OOM，打开heapdump，按照RetainedSize排序后发现AppIconCalendarEvent.ts18对象存在307.54MB，该对象及其引用的内存占用81%内存<strong>。</strong></p> <p><span><img height="216.09268312070267" originheight="470" originwidth="2001" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163449.95857081729865419770707065392539:50001231000000:2800:92A603A315ECB7A131F524053887F1A57BF63867092B532C53D80E29CCF3F4BA.png" title="点击放大" width="920"></span></p> <p>结合代码分析<strong>：</strong>这两个定时器没有停止逻辑导致组件对象一直未析构。</p> </div> <div class="tiledSection"><h3 id="section191975920450">修复方法<i class="anchor-icon anchor-icon-link" anchorid="section191975920450" tips="复制节点链接"></i></h3><p>使用定时器组件销毁时调用clearTimeout和clearInterval，否则对象无法析构。</p> </div> <div class="tiledSection"><h2 id="section10929163884819">内存泄漏-native jemalloc泄漏类案例<i class="anchor-icon anchor-icon-link" anchorid="section10929163884819" tips="复制节点链接"></i></h2></div> <div class="tiledSection"><h3 id="section188638519492" class="firsth2">概述<i class="anchor-icon anchor-icon-link" anchorid="section188638519492" tips="复制节点链接"></i></h3><p>该类问题的典型特征是申请堆内存后没有释放，导致堆内存不断膨胀。</p> </div> <div class="tiledSection"><h3 id="section14267101511498">问题现象<i class="anchor-icon anchor-icon-link" anchorid="section14267101511498" tips="复制节点链接"></i></h3><p>某应用进程内存持续泄漏上报内存泄漏事件，泄漏严重的进程系统会进行查杀管控，用户体验为应用冷启或应用闪退。</p> </div> <div class="tiledSection"><h3 id="section524492744913">问题代码<i class="anchor-icon anchor-icon-link" anchorid="section524492744913" tips="复制节点链接"></i></h3><div class="screenLinkPre"><div _ngcontent-tia-c106="" class="highlight-div"><div _ngcontent-tia-c106="" class="highlight-div-header"><div _ngcontent-tia-c106="" class="highlight-div-header-left"><div _ngcontent-tia-c106="" class="handle-button expand-button"><div _ngcontent-tia-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-tia-c106="" class="highlight-div-header-right"><div _ngcontent-tia-c106="" class="handle-button ai-button"></div><div _ngcontent-tia-c106="" class="handle-button line-button"><div _ngcontent-tia-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-tia-c106="" class="handle-button theme-button"><div _ngcontent-tia-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-tia-c106="" class="handle-button copy-button"><div _ngcontent-tia-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-tia-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-cpp" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/MemoryDetection/entry/src/main/cpp/resource_leak.cpp#L203-L217" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DemoCase</span><span class="hljs-params">(<span class="hljs-type">int</span> length)</span></span></li><li><span class="hljs-function"></span>{</li><li>    <span class="hljs-comment">// ...</span></li><li>    <span class="hljs-type">int</span> bitmapLength = inShapeFromImage[<span class="hljs-number">0</span>] * inShapeForImage[<span class="hljs-number">1</span>];</li><li>    <span class="hljs-keyword">auto</span> bitmapBuffer = <span class="hljs-keyword">new</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>[bitmapLength];</li><li>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; ++i) {</li><li>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">CheckBuffer</span>(bitmapBuffer)) {</li><li>            <span class="hljs-built_in">free</span>(bitmapBuffer);</li><li>            bitmapBuffer = <span class="hljs-literal">nullptr</span>;</li><li>            <span class="hljs-keyword">return</span>;</li><li>        }</li><li>    }</li><li>    <span class="hljs-comment">// ...</span></li><li>    <span class="hljs-keyword">delete</span>[] bitmapBuffer;</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/MemoryDetection/entry/src/main/cpp/resource_leak.cpp#L203-L217" target="_blank">resource_leak.cpp</a></div></div></div></div> </div> <div class="tiledSection"><h3 id="section17842124084912">分析思路<i class="anchor-icon anchor-icon-link" anchorid="section17842124084912" tips="复制节点链接"></i></h3><p>详见<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-leak-way#section1658571616574">Native泄漏问题分析方法</a>。</p> </div> <div class="tiledSection"><h3 id="section43791357144916">分析步骤<i class="anchor-icon anchor-icon-link" anchorid="section43791357144916" tips="复制节点链接"></i></h3><ol><li>某应用发生PSS泄漏，分析采样文件，发现峰值内存TopPssMemory为2.9GB左右，且内存一直增长。<p><span><img originheight="266" originwidth="1528" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163449.82994824771287349138864372704123:50001231000000:2800:13F3197E6A16ABCCC05B48E9E6A1ED523A58BFE9D5BD99D5A050E73D9883654E.png" width="920" height="160.15706806282722"></span></p> </li><li>分析smaps日志，发现本例当前应用jemalloc大小2.6GB（Pss 1.5GB + SwapPss 1.1GB），占总内存的90%+，因此怀疑堆内存泄漏。<p><span><img originheight="194" originwidth="1511" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163449.40281132435714678934435024397674:50001231000000:2800:E359030C9A011DAD56E6E2A0472E0680463B8B2F9A7D089B0B9D753A138C0B07.png" width="920" height="118.12045003309066"></span></p> </li><li>按照<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-leak-way">资源泄漏类问题分析方法</a>基于NMD和profiler继续分析：<p>观察NMD信息发现，size=12582912字节的内存块占用最多（allocated值最大），优先怀疑该内存块。</p> <p><span><img originheight="116" originwidth="549" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163449.19926243897478405454680414732282:50001231000000:2800:8A5866FB0441FD8C3245601867C4F33ED89BDE89E70CB0ABCDD3E79F1DAEDF06.png" width="549" height="116"></span></p> </li><li>分析profiler日志：<ul><li>方法一：将获取到的profiler文件导入DevEco Studio  Profiler插件中进行分析，通过将profile框选All Heap，解析profiler，选择Created &amp; Existing，内存块会按照占用比例排序，此处展开的栈中，存在内存占用比例为98%的可疑点，展开可疑点发现其中大头是“operator new(unsigned long)”申请了89次。此时，将步骤3中NMD找到的size=12582912字节的内存块乘以89再对齐是GB单位，大小恰好是1.04G左右，由此可确认进程的真正泄漏点。<p><span><img height="228.6344528710726" originheight="548" originwidth="2205" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163449.26204775424825055146414434155942:50001231000000:2800:D68284AD24D2AC54D816E9F069F4C8F66E9F2C14FF7BAC7B7E9EEC047EA3EB2F.png" title="点击放大" width="920"></span></p> </li><li>方法二：本地搭建<a href="https://gitcode.com/openharmony-sig/smartperf" target="_blank">Smartperf</a>环境，并导入profiler日志进行解析，框选All Heap，解析profiler，选择Created &amp; Existing，在搜索框中搜索12582912字节，并查看调用栈，确认泄漏点。<p><span><img originheight="315" originwidth="2553" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163449.29945515406144493285205670166347:50001231000000:2800:9793F2810AC718B5B2C135EC409A9DF4FBBCB054466A7B6846E7CFB38E54C7B7.png" width="920" height="113.5135135135135"></span></p> </li></ul> </li><li>分析代码：bitmapBuffer new后只在异常分支释放了内存，主分支未释放。</li></ol> </div> <div class="tiledSection"><h3 id="section436342875019">修复方法<i class="anchor-icon anchor-icon-link" anchorid="section436342875019" tips="复制节点链接"></i></h3><p>通过new等方式申请的内存使用完成后需要及时释放掉。</p> </div> <div class="tiledSection"><h2 id="section189600384502">内存泄漏-内核内存泄漏类案例<i class="anchor-icon anchor-icon-link" anchorid="section189600384502" tips="复制节点链接"></i></h2></div> <div class="tiledSection"><h3 id="section161102514507" class="firsth2">概述<i class="anchor-icon anchor-icon-link" anchorid="section161102514507" tips="复制节点链接"></i></h3><p>该类问题的典型特征是申请了ashmem、ION、GPU等内核类内存，但是未释放导致的内存膨胀。</p> </div> <div class="tiledSection"><h3 id="section849817584503">问题现象<i class="anchor-icon anchor-icon-link" anchorid="section849817584503" tips="复制节点链接"></i></h3><p>轻微泄漏可能不会造成用户的体验问题，但是该类内存发生严重泄漏后，可能会导致整机低内存，进而出现整机稳定性问题。</p> </div> <div class="tiledSection"><h3 id="section14107725120">分析思路<i class="anchor-icon anchor-icon-link" anchorid="section14107725120" tips="复制节点链接"></i></h3><p>详见<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-leak-way#section5493141412410">ION泄漏分析方法</a>。</p> </div> <div class="tiledSection"><h3 id="section1895192412513">分析步骤<i class="anchor-icon anchor-icon-link" anchorid="section1895192412513" tips="复制节点链接"></i></h3><ol><li>分析sample文件，可确认整机ION内存在16:37-16:52期间内存波动较明显。<p><span><img originheight="268" originwidth="601" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163449.24854127705507145294569425620170:50001231000000:2800:96EFB116D486D225C6E144CEA3F1137F9CD08096C650D2690B46AE91ED52793F.png" width="601" height="268"></span></p> </li><li>根据memleak-kernel-[module]-0-[timestamp].txt中ION节点信息，看到上报进程process7的ION内存占用3.3G，基本可以确定第一步中的内存增长时间段就是process7进程泄漏时间段。<p><span><img originheight="106" originwidth="484" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163449.45998611122055484683844714452906:50001231000000:2800:932C2793578936C7E40962598B70E1C5A57B963955FE792A34ACED0D43CFAA0A.png" width="484" height="106"></span></p> </li><li>进一步查看process7进程详细ION内存信息，主要是192512000和48128000 bytes大小的内存块占用，再结合内存增长时间段的日志，以及这些buffer都设定了pixelmap name，确认是ImageEditorCallback存在ION泄漏。<p><span><img originheight="536" originwidth="1525" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163449.63200752452090555831494906002818:50001231000000:2800:DF962189039B24576976882F33527BA6B67B4B0875755F683ED6ADD36489BFDC.png" width="920" height="323.35737704918034"></span></p> </li><li>根据pixelmap name已确定创建pixelmap的位置（由于开发者已通过<a href="https://gitee.com/openharmony/docs/blob/c897489afd3a7403adfff79f20b8596ca05f7bcf/zh-cn/application-dev/reference/apis-image-kit/js-apis-image.md#setmemorynamesync13" target="_blank">setMemoryNameSync</a>接口接入能力，所以能快速定位到pixelmap创建位置），查看相关代码确认问题根因：创建pixelmap后未关闭句柄。</li></ol> </div> <div class="tiledSection"><h3 id="section1590693613523">修复方法<i class="anchor-icon anchor-icon-link" anchorid="section1590693613523" tips="复制节点链接"></i></h3><ol><li>使用image等组件申请pixmap，需严格关注对象的生命周期，在使用结束后直接使用release或destroy等API接口释放，而非依赖于GC回收。</li><li>尽量使用缩略图加载，而非原图加载。</li></ol> </div> <div class="tiledSection"><h3 id="section33741558115218">建议与总结<i class="anchor-icon anchor-icon-link" anchorid="section33741558115218" tips="复制节点链接"></i></h3><p>详见<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-leak-opt#section12687113513352">ashmem/ION泄漏问题优化建议</a>。</p> </div> <div class="tiledSection"><h2 id="section5313162915382">句柄泄漏-文件句柄泄漏案例<i class="anchor-icon anchor-icon-link" anchorid="section5313162915382" tips="复制节点链接"></i></h2></div> <div class="tiledSection"><h3 id="section1011016312539" class="firsth2">概述<i class="anchor-icon anchor-icon-link" anchorid="section1011016312539" tips="复制节点链接"></i></h3><p>该类型问题的典型特征为打开了数量较多的文件句柄，但是没有关闭。</p> </div> <div class="tiledSection"><h3 id="section1825011380538">问题现象<i class="anchor-icon anchor-icon-link" anchorid="section1825011380538" tips="复制节点链接"></i></h3><p>上报句柄泄漏事件，无体验类影响。</p> </div> <div class="tiledSection"><h3 id="section103051052205310">分析思路<i class="anchor-icon anchor-icon-link" anchorid="section103051052205310" tips="复制节点链接"></i></h3><p>详见<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-leak-way#section9594173320417">句柄泄漏分析方法</a>。</p> </div> <div class="tiledSection"><h3 id="section566119916548">分析步骤<i class="anchor-icon anchor-icon-link" anchorid="section566119916548" tips="复制节点链接"></i></h3><p>某service上报句柄泄漏，/system/lib占用的so句柄个数超过5000。</p> <div _ngcontent-tia-c106="" class="highlight-div"><div _ngcontent-tia-c106="" class="highlight-div-header"><div _ngcontent-tia-c106="" class="highlight-div-header-left"><div _ngcontent-tia-c106="" class="handle-button expand-button"><div _ngcontent-tia-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-tia-c106="" class="highlight-div-header-right"><div _ngcontent-tia-c106="" class="handle-button ai-button"></div><div _ngcontent-tia-c106="" class="handle-button line-button"><div _ngcontent-tia-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-tia-c106="" class="handle-button theme-button"><div _ngcontent-tia-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-tia-c106="" class="handle-button copy-button"><div _ngcontent-tia-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-tia-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-bash" data-highlighted="yes"><ol class="linenums"><li>time: 2024/07/09 08:32:16</li><li>pid: 1386</li><li>process: XXX</li><li>leaked fd nums: 5022</li><li>FdCount    FileDescriptor</li><li>*****************************</li><li>Leaked fd Top 10:</li><li>179    /system/lib64/libinsightintent_common.z.so</li><li>179    /system/lib64/platformsdk/libzuri.z.so</li><li>179    /system/lib64/platformsdk/libpdfinner.z.so</li><li>179    /system/lib64/platformsdk/libwant.z.so</li><li>179    /system/lib64/platformsdk/libtokenid_sdk.z.so</li><li>179    /system/lib64/chipset-pub-sdk/libcrypto_openssl.z.so</li><li>179    /system/lib64/chipset-pub-sdk/libjsoncpp.z.so</li><li>179    /system/lib64/libai_datasync_innerapi.z.so</li><li>179    /system/lib64/libai_framework_innerapi.z.so</li><li>179    /system/lib64/libai_label_detect_innerapi.z.so</li><li>Top Dir Type 10:</li><li>5012    /system/lib</li><li>3    /dev/null</li><li>1    /dev/binder</li><li>1    /dev/kmsg</li><li>1    /dev/tty</li><li>1    /sys/kernel/debug/tracing/trace_marker</li><li>*****************************</li><li>LOGGER_MEMCHECK_FD_STACK_INFO</li><li>pid: 1386</li><li>get stack time: 2024/07/09 08:42:22</li><li>==============================FdTrack Stack==============================</li><li>Generated by HiviewDFX @OpenHarmony</li><li>==============================Sorted by num==============================</li><li>num 1134 bt [/system/lib64/libfdleak_tracker.so+0x20248] [/system/lib/ld-musl-aarch64.so.1+0x144dfc] [/system/lib/ld-musl-aarch64.so.1+0xba5b0] [/system/lib/ld-musl-aarch64.so.1+0xd1ac] [/system/lib/ld-musl-aarch64.so.1+0x7c30] [/system/lib/ld-musl-aarch64.so.1+0x48e8] [/system/lib/ld-musl-aarch64.so.1+0x62bc] [/system/lib64/platformsdk/libsamgr_common.z.so+0xdb88] [/system/lib64/platformsdk/libsamgr_common.z.so+0xde58] </li><li>num 42 bt [/system/lib64/libfdleak_tracker.so+0x20248] [/system/lib/ld-musl-aarch64.so.1+0x144dfc] [/system/lib/ld-musl-aarch64.so.1+0xba5b0] [/system/lib/ld-musl-aarch64.so.1+0xd1ac] [/system/lib/ld-musl-aarch64.so.1+0x7c30] [/system/lib/ld-musl-aarch64.so.1+0x6250] [/system/lib64/platformsdk/libsamgr_common.z.so+0xdb88] [/system/lib64/platformsdk/libsamgr_common.z.so+0xde58] [/system/lib64/platformsdk/libsystem_ability_fwk.z.so+0x127d0] </li><li>num 1 bt [/system/lib64/libfdleak_tracker.so+0x20248] [/system/lib/ld-musl-aarch64.so.1+0x144dfc] [/system/lib64/platformsdk/libfwmark_client.z.so+0x4208] [/system/lib64/chipset-pub-sdk/libhisysevent.z.so+0x13abc] [/system/lib64/chipset-pub-sdk/libhisysevent.z.so+0x13eec] [/system/lib64/chipset-pub-sdk/libhisysevent.z.so+0x7b08] [/system/lib64/platformsdk/libsamgr_common.z.so+0x26c38] [/system/lib64/platformsdk/libsamgr_common.z.so+0x26998] [/system/lib64/platformsdk/libsamgr_common.z.so+0x294ec] </li><li>END</li></ol></pre></div></div> <p>分析：</p> <ol><li>/system/lib句柄超过5000个，从Leaked fd Top 10信息可以看出都是so，推测为dlopen获取的句柄未释放。</li><li>根据“LOGGER_MEMCHECK_FD_STACK_INFO”下hook open等系统调用获取的调用栈，发现第一个栈在hook的10分钟内申请了1134次句柄，高度怀疑这个栈。</li><li>获取这些so的符号表（libfdleak_tracker.so是维测用的so，可忽略），通过<a href="https://llvm.org/docs/CommandGuide/llvm-symbolizer.html" target="_blank">addr2line</a>获取调用栈。</li><li>对应的代码调用顺序如下：<p><span><img originheight="196" originwidth="416" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163450.92424858054323355928013706048050:50001231000000:2800:A27917C3DE2609DF093CE894402CB2DD4BE09082ADF097C1BC9F26F7929C5261.png" width="416" height="196"></span></p> <p>dlopen获取的句柄的位置如下，fd存在saProfile，需要进一步查看saProfile的释放时机。</p> <p><span><img height="440.89500000000004" originheight="517" originwidth="613" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163450.24498141162168786133064483972157:50001231000000:2800:337E32B5D851BEA93B0B169FD8AA789F45D5F3A79BA0D00CEA1108617DDBCC32.png" title="点击放大" width="523.6875"></span></p> <p>搜索saProfile的释放位置，发现只有在ParseUtil对象析构时才会释放fd资源。</p> <p><span><img height="250.3725" originheight="468" originwidth="977" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163450.37201974318221477301654266158562:50001231000000:2800:3DDF69FCCB0209F02DB8622CE6511A9FF6B93C900E7E9F544C4F8167008085E9.png" title="点击放大" width="523.6875"></span></p> <p>找到调用者的位置，发现定义了一个类内的私有变量，而这个类的对象一直没析构，导致profileParser_一直没析构，从而导致fd资源一直未释放。</p> <p><span><img originheight="23" originwidth="319" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163450.58858893717813817092546839124954:50001231000000:2800:56D619BFC96AE3F6EEDF4B5EBF0BE8BC84AFA342F2D72A1D667FDC2EECAE0F43.png" width="319" height="23"></span></p> </li></ol> </div> <div class="tiledSection"><h3 id="section114011453135417">修复方法<i class="anchor-icon anchor-icon-link" anchorid="section114011453135417" tips="复制节点链接"></i></h3><p>将ParseUtil对象及时释放或将私有变量改成局部变量进行释放。</p> </div> <div class="tiledSection"><h3 id="section595710255519">建议与总结<i class="anchor-icon anchor-icon-link" anchorid="section595710255519" tips="复制节点链接"></i></h3><p>详见<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-leak-opt#section7375193133214">句柄泄漏问题优化建议</a>。</p> </div> <div class="tiledSection"><h2 id="section107128486383">线程泄漏案例<i class="anchor-icon anchor-icon-link" anchorid="section107128486383" tips="复制节点链接"></i></h2></div> <div class="tiledSection"><h3 id="section694334557" class="firsth2">概述<i class="anchor-icon anchor-icon-link" anchorid="section694334557" tips="复制节点链接"></i></h3><p>该类问题的典型特征是未考虑边界场景，导致一直频繁创建线程。</p> </div> <div class="tiledSection"><h3 id="section8681540165518">问题现象<i class="anchor-icon anchor-icon-link" anchorid="section8681540165518" tips="复制节点链接"></i></h3><p>上报线程泄漏事件，应用出现卡顿或卡死问题。</p> </div> <div class="tiledSection"><h3 id="section37053524550">分析思路<i class="anchor-icon anchor-icon-link" anchorid="section37053524550" tips="复制节点链接"></i></h3><p>详见<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-leak-way#section282262074411">线程泄漏分析方法</a>。</p> </div> <div class="tiledSection"><h3 id="section1034711145611">分析步骤<i class="anchor-icon anchor-icon-link" anchorid="section1034711145611" tips="复制节点链接"></i></h3><p><span style="color: rgb(0,38,84);">某应用</span>network和Network File Thread线程泄漏，运维态泄漏检测机制抓取的日志如下：</p> <div _ngcontent-tia-c106="" class="highlight-div"><div _ngcontent-tia-c106="" class="highlight-div-header"><div _ngcontent-tia-c106="" class="highlight-div-header-left"><div _ngcontent-tia-c106="" class="handle-button expand-button"><div _ngcontent-tia-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-tia-c106="" class="highlight-div-header-right"><div _ngcontent-tia-c106="" class="handle-button ai-button"></div><div _ngcontent-tia-c106="" class="handle-button line-button"><div _ngcontent-tia-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-tia-c106="" class="handle-button theme-button"><div _ngcontent-tia-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-tia-c106="" class="handle-button copy-button"><div _ngcontent-tia-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-tia-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-cangjie" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-variable">process</span>: <span class="hljs-title class_">某应用</span></li><li><span class="hljs-variable">summary</span>: <span class="hljs-number">826</span></li><li> </li><li><span class="hljs-variable">Top</span> <span class="hljs-number">10</span> <span class="hljs-variable">Thread</span> <span class="hljs-variable">Name</span>:</li><li><span class="hljs-number">309</span>  <span class="hljs-variable">network</span></li><li><span class="hljs-number">309</span>  <span class="hljs-variable">Network</span> <span class="hljs-variable">File</span> <span class="hljs-variable">Th</span></li><li>......</li><li>=================================</li></ol></pre></div></div> <ol><li>流水/故障日志分析<p>故障日志发现network和Network File Thread线程皆占用309个，流水日志发现一直在断网重连。</p> </li><li>结合业务代码分析<p>查看代码发现每个httpclient都会创建单独线程，流水日志中追踪该申请和释放日志。</p> </li><li>接口调用不匹配<p>发现业务需要主动调用releaseHttpClient才能释放线程，领域未感知。</p> </li></ol> </div> <div class="tiledSection"><h3 id="section1863517263565">修复方法<i class="anchor-icon anchor-icon-link" anchorid="section1863517263565" tips="复制节点链接"></i></h3><p>导入@ohos.net.http使用url请求能力的应用，一定要释放线程</p> <ol><li>HttpClient.getRequestSize()接口判断当前是否还有未结束的请求</li><li>HttpClient.releaseHttpClient()接口释放线程<p><span><img originheight="232" originwidth="778" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163450.39879794647510426766332699805256:50001231000000:2800:5E58172F58173ABE7C487BC63C50C3102A1D107467D38980D423852F2E41BCF1.png" width="778" height="232"></span></p> </li></ol> </div> <div class="tiledSection"><h3 id="section18750418570">建议与总结<i class="anchor-icon anchor-icon-link" anchorid="section18750418570" tips="复制节点链接"></i></h3><p>详见<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-leak-opt#section10137113593613">线程泄漏问题优化建议</a>。</p> </div> </div> <div></div></div>