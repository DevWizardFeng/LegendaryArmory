<h1 _ngcontent-jxj-c119="" class="doc-title ng-star-inserted" title="跨线程序列化耗时问题分析"> 跨线程序列化耗时问题分析 </h1>

<div _ngcontent-jxj-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;"> <div><div class="tiledSection"><h2 id="section7778181112816">概述<i class="anchor-icon anchor-icon-link" anchorid="section7778181112816" tips="复制节点链接"></i></h2><p>在应用开发中，涉及多线程并发场景时，开发者会频繁使用TaskPool/Worker的并发能力。对象和方法在跨线程传递时，需要进行序列化和反序列化。如果对象较大且结构复杂，序列化和反序列化的耗时会增加，影响应用的整体性能。开发者在分析性能问题时，无法感知系统是否触发了序列化或反序列化，也无法确认这些操作是否耗时。</p> </div> <p>为了帮助开发者识别代码中潜在的主线程序列化/反序列化耗时点，并推动开发者在跨线程传递对象时改用<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-sendable" target="_blank">Sendable</a>对象的方式，方舟调优和DevEco Studio联合开发并上线了应用主线程序列化/反序列化超时检测工具。该工具集成在<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-profiler" target="_blank">DevEco Profiler</a>中，并可在开发者进行应用调优录制时同步开启。开发者可以在录制结果中的<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-insight-session-frame#section8198654142516" target="_blank">Anomaly泳道</a>内查看到主线程序列化/反序列化超时的Tag点和相关超时信息，并通过与ArkTS Callstack泳道中当前调用栈的时间对齐，定位到序列化/反序列化耗时较长的代码，然后通过Sendable改造或者通信数据改造的方式（例如文件buffer改为文件path+偏移）进行优化，提升应用性能。</p> <div class="tiledSection"><h2 id="section5931165433711">工具介绍<i class="anchor-icon anchor-icon-link" anchorid="section5931165433711" tips="复制节点链接"></i></h2><p>DevEco Studio新增主线程序列化和反序列化检测能力，支持配置超时阈值。超过阈值的序列化和反序列化操作将在泳道中告警，并关联该时刻的调用栈信息，帮助开发者定位性能问题。</p> </div> <div class="tiledSection"><h3 id="section3755758162913" class="firsth2">功能说明<i class="anchor-icon anchor-icon-link" anchorid="section3755758162913" tips="复制节点链接"></i></h3><p>当前DevEco Profiler工具的序列化和反序列化检测包含三个子功能：</p> </div> <ol><li>支持配置序列化和反序列化的超时阈值。</li><li>通过泳道可以直观查看序列化和反序列化的执行耗时。</li><li>可以通过框选序列化或反序列化的执行耗时时间段，在ArkTS Callstack泳道中直观查看调用栈信息。</li></ol> <div class="tiledSection"><h3 id="section14752054165715">实现原理<i class="anchor-icon anchor-icon-link" anchorid="section14752054165715" tips="复制节点链接"></i></h3><div class="fignone"><span class="figcap"><b>图1 </b>主线程序列化/反序列化开销检测流程图</span></div> <p><span><img height="148.6275" originheight="241" originwidth="845" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163410.32333721843550678430059769156946:50001231000000:2800:EEC2847AD54EACA851462D36D05669DE8B7DFC4FB46E30E0633202E420E4D7D2.png" title="点击放大" width="523.6875"></span></p> </div> <p>超时检测的使能和关闭通过方舟Profiler提供的CDP协议控制，默认关闭。使用DevEco Profiler录制时会自动开启：</p> <p><strong>表1 </strong>超时检测使能和关闭协议</p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><tbody><tr><td class="cellrowborder" valign="top" width="33.333333333333336%"><p>协议名称</p> </td> <td class="cellrowborder" valign="top" width="33.333333333333336%"><p>传入参数</p> </td> <td class="cellrowborder" valign="top" width="33.333333333333336%"><p>协议说明</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="33.333333333333336%"><p>Profiler.enableSerializationTimeoutCheck</p> </td> <td class="cellrowborder" valign="top" width="33.333333333333336%"><p>threshold: int</p> </td> <td class="cellrowborder" valign="top" width="33.333333333333336%"><p>开启超时检测工具，并设置超时阈值（单位ms）</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="33.333333333333336%"><p>Profiler.disableSerializationTimeoutCheck</p> </td> <td class="cellrowborder" valign="top" width="33.333333333333336%"><p>/</p> </td> <td class="cellrowborder" valign="top" width="33.333333333333336%"><p>关闭超时检测工具</p> </td> </tr>  </tbody></table></div> </div> <p>当开启超时检测工具协议后，方舟Profiler会在录制时实时计算每次主线程调用序列化和反序列化接口进行操作的耗时，并与设定的超时阈值（默认为8ms）进行比较。如果耗时超过阈值，Profiler会生成一条超时信息，包含以下字段：</p> <p><strong>表2 </strong>超时信息所含字段</p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><tbody><tr><td class="cellrowborder" valign="top" width="33.333333333333336%"><p>字段名</p> </td> <td class="cellrowborder" valign="top" width="33.333333333333336%"><p>字段名称</p> </td> <td class="cellrowborder" valign="top" width="33.333333333333336%"><p>字段说明</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="33.333333333333336%"><p>tid</p> </td> <td class="cellrowborder" valign="top" width="33.333333333333336%"><p>线程id</p> </td> <td class="cellrowborder" valign="top" width="33.333333333333336%"><p>线程id，指示当前超时的线程</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="33.333333333333336%"><p>task</p> </td> <td class="cellrowborder" valign="top" width="33.333333333333336%"><p>操作类型</p> </td> <td class="cellrowborder" valign="top" width="33.333333333333336%"><p>serialization/deserialization</p> <p>标记当前操作为序列化或反序列化</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="33.333333333333336%"><p>startTime</p> </td> <td class="cellrowborder" valign="top" width="33.333333333333336%"><p>开始时间</p> </td> <td class="cellrowborder" valign="top" width="33.333333333333336%"><p>标记当前操作的开始时间</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="33.333333333333336%"><p>duration</p> </td> <td class="cellrowborder" valign="top" width="33.333333333333336%"><p>持续时间</p> </td> <td class="cellrowborder" valign="top" width="33.333333333333336%"><p>标记本次序列化/反序列化的实际耗时</p> </td> </tr>  </tbody></table></div> </div> <p>生成超时信息后，Profiler通过设置Trace接口将信息记录到Trace中，并标记Tag为Ark。这样，一条主线程程序序列化或反序列化超时的Trace信息就成功生成并记录。</p> <div class="tiledSection"><h3 id="section19481632193120">使用方法<i class="anchor-icon anchor-icon-link" anchorid="section19481632193120" tips="复制节点链接"></i></h3><p><strong>序列化/反序列化性能检测</strong></p> </div> <ol><li><span>打开DevEco Studio，确认设备已连接，待录制应用已安装。</span></li><li><span>启动应用，点击Profiler，选择Frame模板，选择当前应用进程，点击Create Session，然后开始录制Frame insight场景数据，录制过程中可正常操作应用。</span><p></p><div class="fignone"><span class="figcap"><b>图2 </b>录制Frame insight场景数据</span><br><span><img height="159.60000000000002" originheight="587" originwidth="1919" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163410.07876477863826210529879810881992:50001231000000:2800:92E7250D3AFE7552098C1098653123C8F1D78D0E0694C338D28D4B981CEBB85C.png" title="点击放大" width="523.6875"></span></div> <p></p></li><li><span>停止录制，待录制结果显示后，如有检测到主线程序列化和反序列化超时的情况，Anomaly泳道会显示序列化和反序列化耗时打点检测结果，提示信息包含线程id、startTime、duration、操作类型等。</span><p></p><div class="fignone"><span class="figcap"><b>图3 </b>主线程序列化/反序列化超时情况</span><br><span><img height="160.5975" originheight="589" originwidth="1919" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163410.07483726892752304904910929150671:50001231000000:2800:79A0E9350C439BA71D1B5B3CD6E44983F4F64B50E1B2825DFE68545A3ABFA0B7.png" title="点击放大" width="523.6875"></span></div> <p></p></li><li><span>框选这段序列化和反序列化超时时间段，点击ArkTS Callstack，会显示这段时间内的调用栈信息，通过查看其中的Symbol Name信息可以定位到当前耗时的调用栈，双击对应调用栈即可跳转到对应源码。</span><p></p><div class="fignone"><span class="figcap"><b>图4 </b>序列化/反序列化耗时阶段调用栈</span><br><span><img height="160.5975" originheight="591" originwidth="1919" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163410.11517373014495215351067072204479:50001231000000:2800:7ED86DD6125B7AF9AB60EE90072836C92738408C87F24E98625B27E1DA017A21.png" title="点击放大" width="523.6875"></span></div> <p></p></li><li><span>开发者通过上述第4步的方式可以更快定位序列化/反序列化耗时长的源代码，并参照Sendable改造或通信数据改造的方式进行优化，从而提升应用性能。</span></li></ol> <p><strong>序列化/反序列化阈值配置</strong></p> <ol><li><span>打开DevEco Studio，确认设备已连接，待录制应用已安装。</span></li><li><span>启动应用，点击Profiler，选择Frame模板，点击Anomaly泳道中的options，在弹出的输入框中输入超时检测阈值。</span><p></p><div class="fignone"><span class="figcap"><b>图5 </b>序列化、反序列化阈值配置</span><br><span><img height="158.60250000000002" originheight="583" originwidth="1915" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163410.70259520003089337412165160286168:50001231000000:2800:9647A04C16793FB9C75EFD463F423877331753C8379AA1BC23CCDBC3BC082DCA.png" title="点击放大" width="523.6875"></span></div> <p></p></li><li><span>参照上述序列化/反序列化性能检测步骤开始录制，此时新设置的超时阈值已经被成功设置和使用。</span></li></ol> <div class="tiledSection"><h2 id="section219918501333">案例分析<i class="anchor-icon anchor-icon-link" anchorid="section219918501333" tips="复制节点链接"></i></h2><p>在应用开发过程中，序列化/反序列化发生在跨并发实例传输大数据的场景。由于在此场景下，序列化/反序列化的时间开销会随着数据量线性增长，因此在传输大量数据时，序列化/反序列化的时间开销显著增加。特别是当序列化/反序列化发生在应用主线程时，会影响应用的整体运行性能和流畅度。</p> <p>Sendable对象通过引用传递的方式在不同的并发实例间传递，相比于序列化效率更高，可以更高效的进行跨实例的数据交互，解决跨并发实例传递大数据和跨并发实例传递含有成员方法的示例对象。下面以图书类应用将大量书本信息跨并发实例传递，存储进数据库的场景为例，介绍通过超时检测工具分析和定位序列化耗时点的过程，以及对该场景进行Sendable改造前后序列化耗时结果的分析对比。该案例主要由下列步骤组成：</p> </div> <ol><li>定义大量书本信息(示例中为5w个)；</li><li>组装书本信息的class实例；</li><li>通过taskpool跨并发实例传递，并进行相关数据库操作；</li></ol> <p>在常规情况下，单个图书信息会被定义成classBook。通过组装该实例填充数据，最后将包含所有Book实例的BookDBInfo对象通过taskpool传递给子线程。</p> <div class="screenLinkPre"><div _ngcontent-jxj-c106="" class="highlight-div"><div _ngcontent-jxj-c106="" class="highlight-div-header"><div _ngcontent-jxj-c106="" class="highlight-div-header-left"><div _ngcontent-jxj-c106="" class="handle-button expand-button"><div _ngcontent-jxj-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-jxj-c106="" class="highlight-div-header-right"><div _ngcontent-jxj-c106="" class="handle-button ai-button"></div><div _ngcontent-jxj-c106="" class="handle-button line-button"><div _ngcontent-jxj-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-jxj-c106="" class="handle-button theme-button"><div _ngcontent-jxj-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-jxj-c106="" class="handle-button copy-button"><div _ngcontent-jxj-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-jxj-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-cangjie" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/PerformanceAnalysis/CrossThreadSerializationDelay/entry/src/main/ets/pages/Index.ets#L21-L61" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">import</span> { <span class="hljs-variable">taskpool</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.ArkTS'</span>;</li><li><span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span> {</li><li>  <span class="hljs-variable">recordId_</span>: <span class="hljs-title class_">string</span> = <span class="hljs-string">''</span>;</li><li>  <span class="hljs-variable">title_</span>: <span class="hljs-title class_">string</span> = <span class="hljs-string">''</span>;</li><li>  <span class="hljs-variable">content_</span>: <span class="hljs-title class_">string</span> = <span class="hljs-string">''</span>;</li><li>  <span class="hljs-variable">authorList_</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">string</span>&gt; | <span class="hljs-title class_">null</span> = <span class="hljs-variable">null</span>;</li><li>  <span class="hljs-title function_">constructor</span>() {</li><li>    <span class="hljs-comment">// Initialize static information related to Book</span></li><li>    <span class="hljs-comment">// ...</span></li><li>  }</li><li>  <span class="hljs-comment">// omit other member methods</span></li><li>  <span class="hljs-comment">// ...</span></li><li>}</li><li><span class="hljs-keyword">class</span> <span class="hljs-title class_">BookDBInfo</span> {</li><li>  <span class="hljs-variable">dbName_</span>: <span class="hljs-title class_">string</span> = <span class="hljs-string">''</span>;</li><li>  <span class="hljs-variable">seq_</span>: <span class="hljs-title class_">number</span> = <span class="hljs-number">0</span>;</li><li>  <span class="hljs-variable">tableName_</span>: <span class="hljs-title class_">string</span> = <span class="hljs-string">''</span>;</li><li>  <span class="hljs-variable">books_</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">Book</span>&gt; | <span class="hljs-title class_">null</span> = <span class="hljs-variable">null</span>;</li><li>  <span class="hljs-title function_">constructor</span>(<span class="hljs-variable">dbName</span>: <span class="hljs-title class_">string</span>, <span class="hljs-variable">tableName</span>: <span class="hljs-title class_">string</span>) {</li><li>    <span class="hljs-keyword">this</span>.<span class="hljs-variable">dbName_</span> = <span class="hljs-variable">dbName</span>;</li><li>    <span class="hljs-keyword">this</span>.<span class="hljs-variable">tableName_</span> = <span class="hljs-variable">tableName</span>;</li><li>  }</li><li>}</li><li><span class="hljs-variable">function</span> <span class="hljs-title function_">prepareBooksInfo</span>() {</li><li>  <span class="hljs-keyword">let</span> <span class="hljs-variable">dbInfo</span> = <span class="hljs-variable">new</span> <span class="hljs-title function_">BookDBInfo</span>(<span class="hljs-string">'database1'</span>,<span class="hljs-string">'books'</span>);</li><li>  <span class="hljs-variable">dbInfo</span>.<span class="hljs-variable">books_</span> = <span class="hljs-variable">new</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">Book</span>&gt;();</li><li>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> <span class="hljs-variable">i</span> = <span class="hljs-number">0</span>; <span class="hljs-variable">i</span> &lt; <span class="hljs-number">50000</span>; <span class="hljs-title class_">i</span>++) {</li><li>    <span class="hljs-keyword">let</span> <span class="hljs-variable">book</span> = <span class="hljs-variable">new</span> <span class="hljs-title function_">Book</span>();</li><li>    <span class="hljs-variable">book</span>.<span class="hljs-variable">authorList_</span> = <span class="hljs-variable">new</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">string</span>&gt;();</li><li>    <span class="hljs-comment">// Assemble book information</span></li><li>    <span class="hljs-comment">// ...</span></li><li>    <span class="hljs-variable">dbInfo</span>.<span class="hljs-variable">books_</span>?.<span class="hljs-title function_">push</span>(<span class="hljs-variable">book</span>);</li><li>  }</li><li>  <span class="hljs-keyword">let</span> <span class="hljs-variable">res</span> = <span class="hljs-variable">taskpool</span>.<span class="hljs-title function_">execute</span>(<span class="hljs-variable">doDBOperations</span>, <span class="hljs-variable">dbInfo</span>); <span class="hljs-comment">// Passing across concurrent instances through taskpool</span></li><li>}</li><li>@<span class="hljs-title function_">Concurrent</span></li><li><span class="hljs-variable">function</span> <span class="hljs-title function_">doDBOperations</span>(<span class="hljs-variable">info</span> : <span class="hljs-title class_">BookDBInfo</span>) {</li><li>  <span class="hljs-comment">// Perform database-related operations</span></li><li>  <span class="hljs-comment">// ...</span></li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/PerformanceAnalysis/CrossThreadSerializationDelay/entry/src/main/ets/pages/Index.ets#L21-L61" target="_blank">Index.ets</a></div></div></div></div> <p>通过序列化超时检测工具检测后，在Anomaly泳道可以看到序列化耗时超出默认阈值（8ms），达到260ms。</p> <div class="fignone"><span class="figcap"><b>图6 </b>未使用Sendable时序列化耗时结果</span><br><span><img height="135.66" originheight="570" originwidth="2194" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163410.58996074671857681473118968184554:50001231000000:2800:07AD1088FCFFD704B366F55ACBBA121EA32DCF5BD2DE21DD133942B887BB9F1E.png" title="点击放大" width="523.6875"></span></div> <p>通过点击下方ArkTS Callstack泳道，选取这个序列化和反序列化超时发生的时间段后，可以通过下方的Callstack信息定位到此时正在执行Index.ts文件中的prepareBooksInfo()方法，由上方伪代码可知该方法内调用了taskpool.execute()方法，向子线程中传递对象dbInfo，触发了主线程序列化和反序列化过程。</p> <div class="fignone"><span class="figcap"><b>图7 </b>未使用Sendable时序列化超时阶段ArkTS Callstack调用栈</span><br><span><img height="135.66" originheight="569" originwidth="2193" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163410.01674475780919155092554859489720:50001231000000:2800:EF78FC36956F14B812D4566A9BD7AF47ECB0FF6C498107A7C66E30747F6A3640.png" title="点击放大" width="523.6875"></span></div> <p>为了解决该场景的序列化超时问题，将上述示例中dbInfo相关的class进行<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-sendable" target="_blank">Sendable改造</a>，将单个书本信息的类型定义为Sendable类型，并改造内部成员属性类型为Sendable类型。</p> <p>优化后，使用序列化超时检测工具再次检测录制，发现序列化耗时已小于默认阈值8ms，在Anomaly泳道中已无对应超时的Trace点。</p> <div class="fignone"><span class="figcap"><b>图8 </b>使用Sendable方式优化后序列化耗时</span><br><span><img height="163.59" originheight="689" originwidth="2197" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163410.25827451321379604854536582469364:50001231000000:2800:2A607EC7C2F66B2D73DD42C4F0503948636F5C5748559A161B82C8B037014C1D.png" title="点击放大" width="523.6875"></span></div> <p><strong>表3 </strong>序列化耗时对比</p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><tbody><tr><td class="cellrowborder" valign="top" width="50%"><p>实现方案</p> </td> <td class="cellrowborder" valign="top" width="50%"><p>耗时情况</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="50%"><p>未使用Sendable</p> </td> <td class="cellrowborder" valign="top" width="50%"><p>260ms</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="50%"><p>使用Sendable方式优化后</p> </td> <td class="cellrowborder" valign="top" width="50%"><p>&lt;8ms</p> </td> </tr>  </tbody></table></div> </div> <p>对比分析工具获取的优化前后序列化耗时，可以看出在跨线程传输大量数据时，使用Sendable引用传递方式能有效减少序列化耗时，提升应用性能。</p> <p>通过实践案例可以得出结论，使用序列化超时检测工具可以有效检测出应用主线程序列化/反序列化耗时较长的情况，帮助开发者定位序列化耗时点，并结合代码层面的改造，例如<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-sendable" target="_blank">Sendable改造</a>或者通信数据改造，解决应用跨线程序列化/反序列化耗时过久的性能问题。</p> </div> <div></div></div>