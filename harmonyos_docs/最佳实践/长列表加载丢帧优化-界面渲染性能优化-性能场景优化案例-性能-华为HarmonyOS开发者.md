<h1 _ngcontent-cql-c119="" class="doc-title ng-star-inserted" title="长列表加载丢帧优化"> 长列表加载丢帧优化 </h1>

<div _ngcontent-cql-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;">   <div>    <div class="tiledSection">     <h2 id="section5720231172219">概述<i class="anchor-icon anchor-icon-link" anchorid="section5720231172219" tips="复制节点链接"></i></h2>          <p>列表是应用开发中常见的一类场景，可以将信息整理成易于理解和操作的形式，便于用户查找和获取所需信息。应用程序中的列表场景包括新闻列表、购物车列表、各类排行榜等。随着信息数据的累积，特别是在新闻应用、购物应用和聊天应用中，列表数据可能达到上万条。针对这类大量数据加载的长列表应用，优化长列表性能非常重要。一个正确、高性能的长列表应用可以显著降低列表渲染时间、提升页面滑动帧率、减少应用内存占用，从而大幅提升用户体验。</p>     <p>对于希望快速实现高性能流畅滑动长列表的开发者，可以使用ScrollComponents库直接实现。该库内置了组件复用、列表项子组件组合复用、懒加载、复用池共享等优化功能，并支持预创建和预加载，大幅减少了开发者的性能调优成本。具体实现细节和最佳实践可参考《<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-list-based-on-scrollcomponents">基于ScrollComponents实现长列表</a>》。</p>     <p>针对长列表加载这一场景，本文将介绍5种优化手段，这些手段的使用可以优化列表渲染时间、页面滑动帧率和应用内存占用，从而提升性能和用户体验：</p>     <ul>      <li>懒加载：提供列表数据按需加载能力，解决一次性加载长列表数据耗时长、占用过多资源的问题，提升页面响应速度。</li>      <li>缓存列表项：提供屏幕外列表项长度的自定义调节功能，结合懒加载设置，预加载数据以提升列表滑动体验。</li>      <li>动态预加载：根据历史任务加载时间，动态调整屏幕外数据预取数量，结合懒加载设置，确保列表滑动时屏幕外数据实时更新，提高列表滑动体验。</li>      <li>组件复用：提供可复用组件对象的缓存资源池，通过重复使用缓存的组件对象，降低频繁创建和销毁的开销，提升组件渲染效率。</li>      <li>布局优化：使用扁平化布局方案，减少界面嵌套层级和组件数，避免过度绘制，提升页面渲染效率。</li>     </ul>     <p>下文将以 <a href="https://gitee.com/harmonyos_samples/hmosworld" target="_blank">“HMOS世界”</a>中首屏的长列表加载为例，通过5个测试来验证列表优化前后性能的收益，以证明这些优化手段的可行性。综合考虑业界共识指标和实际用户使用体验，测试将对比分析如下几个关键指标：</p>     <ul>      <li>完全显示所用时间（Time To Full Display， TTFD）：表示应用生成具有完整内容的第一帧所用时间，包括在第一帧之后异步加载的内容。本文测量的是不同数据量下长列表首次加载到屏幕上所用的时间。</li>      <li>丢帧率（Janky Frames）：表示一个时间周期内的丢帧比率。HarmonyOS系统要求每一帧在 11.1ms（90Hz刷新率）内绘制完成。如果页面未在 11.1ms内完成绘制，就会出现丢帧。用户仅在连续丢帧时才有明显感知。</li>      <li>独占内存（Unique Set Size，USS）：一个进程所占用的私有内存。当进程被销毁后，独占内存返回系统。内存泄漏时，独占内存是最佳观察数据。</li>     </ul>     <p>测试表明，使用LazyForEach懒加载技术后，与ForEach加载方式相比，在列表数据量较小（100条以内）且数据一次性全量加载不是性能瓶颈时，两者各项性能指标差异不大。但当列表数据量达到10000条时，ForEach的各项性能指标显著劣化，滑动会出现明显卡顿，甚至可能导致应用崩溃；而LazyForEach通过懒加载、缓存列表项和组件复用等技术，能够明显减少首屏完全显示所需时间，降低应用的独占内存，提高页面滑动帧率，从而带来更好的性能。具体对比效果如下所示：</p>     <div class="fignone">      <span class="figcap"><b>图1 </b>10000条数据量下ForEach和LazyForEach最佳实践启动对比</span>      <br><span><img height="340.14750000000004" originheight="914" originwidth="1407" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163430.83499215718991980256496081271425:50001231000000:2800:4F0E6D501E1CDC964FFF8C79FAB6F8D6DD59E8CB1407BFCCDCEE6BEA673A334B.gif" title="点击放大" width="523.6875"></span>      <p></p>     </div>     <div class="fignone">      <span class="figcap"><b>图2 </b>10000条数据量下ForEach和LazyForEach最佳实践滑动对比</span>      <br><span><img height="340.14750000000004" originheight="914" originwidth="1407" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163430.35617228414453643150145319845343:50001231000000:2800:C2E989CF6E96B465DD4F1AAE9C2B52449428E3C5669F37B3106C4D2862C980E2.gif" title="点击放大" width="523.6875"></span>      <p></p>     </div>    </div>    <div class="tiledSection">     <h2 id="section182645364229">懒加载<i class="anchor-icon anchor-icon-link" anchorid="section182645364229" tips="复制节点链接"></i></h2>         </div>    <div class="tiledSection">     <h3 id="section5957183117318" class="firsth2">原理介绍<i class="anchor-icon anchor-icon-link" anchorid="section5957183117318" tips="复制节点链接"></i></h3>         </div>    <p>HarmonyOS应用框架为容器类组件的数据加载和渲染提供了两种方式：</p>    <ul>     <li>方式一，循环渲染      <p>通过<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-foreach" target="_blank">循环渲染（ForEach）</a>从数组中获取数据，并为每个数据项创建相应的组件，可减少代码复杂度。</p>      <div _ngcontent-cql-c106="" class="highlight-div"><div _ngcontent-cql-c106="" class="highlight-div-header"><div _ngcontent-cql-c106="" class="highlight-div-header-left"><div _ngcontent-cql-c106="" class="handle-button expand-button"><div _ngcontent-cql-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-cql-c106="" class="highlight-div-header-right"><div _ngcontent-cql-c106="" class="handle-button ai-button"></div><div _ngcontent-cql-c106="" class="handle-button line-button"><div _ngcontent-cql-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-cql-c106="" class="handle-button theme-button"><div _ngcontent-cql-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-cql-c106="" class="handle-button copy-button"><div _ngcontent-cql-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-cql-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-typescript" data-highlighted="yes"><ol class="linenums"><li> <span class="hljs-title class_">ForEach</span>(</li><li>    <span class="hljs-attr">arr</span>: <span class="hljs-title class_">ESObject</span>[],</li><li>    <span class="hljs-attr">itemGenerator</span>: <span class="hljs-function">(<span class="hljs-params">item: ESObject, index?: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>,</li><li>    keyGenerator?: <span class="hljs-function">(<span class="hljs-params">item: ESObject, index?: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">string</span></li><li>  ){}</li></ol></pre></div></div></li>     <li>方式二，数据懒加载      <p>通过<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-lazyforeach" target="_blank">数据懒加载（LazyForEach）</a>从提供的数据源中按需迭代数据，并在每次迭代过程中创建相应的组件。</p>      <div _ngcontent-cql-c106="" class="highlight-div"><div _ngcontent-cql-c106="" class="highlight-div-header"><div _ngcontent-cql-c106="" class="highlight-div-header-left"><div _ngcontent-cql-c106="" class="handle-button expand-button"><div _ngcontent-cql-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-cql-c106="" class="highlight-div-header-right"><div _ngcontent-cql-c106="" class="handle-button ai-button"></div><div _ngcontent-cql-c106="" class="handle-button line-button"><div _ngcontent-cql-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-cql-c106="" class="handle-button theme-button"><div _ngcontent-cql-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-cql-c106="" class="handle-button copy-button"><div _ngcontent-cql-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-cql-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-cangjie" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IDataSource</span> {</li><li>  <span class="hljs-title function_">totalCount</span>(): <span class="hljs-title class_">number</span>;</li><li>  <span class="hljs-title function_">getData</span>(<span class="hljs-variable">index</span>: <span class="hljs-title class_">number</span>): <span class="hljs-title class_">ESObject</span>;</li><li>  <span class="hljs-title function_">registerDataChangeListener</span>(<span class="hljs-variable">listener</span>: <span class="hljs-title class_">DataChangeListener</span>): <span class="hljs-title class_">void</span>;</li><li>  <span class="hljs-title function_">unregisterDataChangeListener</span>(<span class="hljs-variable">listener</span>: <span class="hljs-title class_">DataChangeListener</span>): <span class="hljs-title class_">void</span>;</li><li>}</li><li>
</li><li><span class="hljs-keyword">interface</span> <span class="hljs-title class_">DataChangeListener</span> {</li><li>  <span class="hljs-title function_">onDataReloaded</span>(): <span class="hljs-title class_">void</span>;</li><li>  <span class="hljs-title function_">onDataAdd</span>(<span class="hljs-variable">index</span>: <span class="hljs-title class_">number</span>): <span class="hljs-title class_">void</span>;</li><li>  <span class="hljs-title function_">onDataMove</span>(<span class="hljs-keyword">from</span>: <span class="hljs-title class_">number</span>, <span class="hljs-variable">to</span>: <span class="hljs-title class_">number</span>): <span class="hljs-title class_">void</span>;</li><li>  <span class="hljs-title function_">onDataDelete</span>(<span class="hljs-variable">index</span>: <span class="hljs-title class_">number</span>): <span class="hljs-title class_">void</span>;</li><li>  <span class="hljs-title function_">onDataChange</span>(<span class="hljs-variable">index</span>: <span class="hljs-title class_">number</span>): <span class="hljs-title class_">void</span>;</li><li>}</li><li>
</li><li>  <span class="hljs-title function_">LazyForEach</span>(</li><li>    <span class="hljs-variable">dataSource</span>: <span class="hljs-title class_">IDataSource</span>,</li><li>    <span class="hljs-variable">itemGenerator</span>: (<span class="hljs-variable">item</span>: <span class="hljs-title class_">ESObject</span>) =&gt; <span class="hljs-variable">void</span>,</li><li>    <span class="hljs-variable">keyGenerator</span>?: (<span class="hljs-variable">item</span>: <span class="hljs-title class_">ESObject</span>) =&gt; <span class="hljs-variable">string</span></li><li>  ): <span class="hljs-title class_">void</span>{}</li></ol></pre></div></div></li>    </ul>    <div class="tiledSection">     <h3 id="section67338499325">ForEach<i class="anchor-icon anchor-icon-link" anchorid="section67338499325" tips="复制节点链接"></i></h3>          <p>ForEach循环渲染的过程：</p>     <ol>      <li><span>从列表数据源加载全量数据。</span></li>      <li><span>为列表数据的每个元素创建对应的组件，并挂载在组件树上。遍历列表元素时，每个元素都创建一个ListItem组件节点，并依次挂载在List组件树根节点上。</span></li>      <li><span>列表内容显示时，只渲染屏幕可视区内的ListItem组件。当可视区外的ListItem组件滑动进入屏幕内时，由于已完成数据加载和组件创建挂载，可直接渲染。</span></li>     </ol>     <p>其数据加载、组件树挂载和页面渲染的示意图如下所示：</p>     <div class="fignone">      <span class="figcap"><b>图3 </b>ForEach渲染过程示意图</span>      <br><span><img height="310.4486" originheight="440" originwidth="1131" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163431.62728466381629743184614494441376:50001231000000:2800:2D550DAF4B742493FEA0C7F29CD0CA97F5DA50C4C1F8838B228C3F48ED03BA8A.png" title="点击放大" width="798"></span>     </div>     <p>当列表数据量不大，一次性全量加载不会成为性能瓶颈时，可以直接使用ForEach。然而，当数据量较大且组件结构复杂时，ForEach会出现性能瓶颈。这是因为需要一次性加载所有列表数据，创建所有组件节点并完成组件树的构建，这在数据量大时会非常耗时，导致页面启动时间过长。此外，屏幕可视区外的组件虽然不会显示，但仍然会占用内存。在系统负载较高时，更容易出现性能问题，极端情况下可能导致应用异常退出。</p>     <p>为了解决上述问题，HarmonyOS应用框架提供了懒加载方式。</p>    </div>    <div class="tiledSection">     <h3 id="section69931513103314">LazyForEach<i class="anchor-icon anchor-icon-link" anchorid="section69931513103314" tips="复制节点链接"></i></h3>          <p>LazyForEach懒加载的原理及渲染过程如下：</p>     <ol>      <li><span>LazyForEach会根据屏幕可视区按需加载数据。</span></li>      <li><span>根据加载的数据量创建组件，挂载到组件树上，构建简短的组件树。屏幕展示多少列表项组件，就按需创建相应数量的ListItem组件节点，挂载在List组件树的根节点上。</span></li>      <li><span>屏幕可视区仅展示部分组件。当需要将可视区外的组件显示在屏幕上时，必须完成数据加载、组件创建和组件树挂载，直至渲染到屏幕上。</span></li>     </ol>     <p>其数据加载、组件树挂载、页面渲染的示意图如下所示：</p>     <div class="fignone">      <span class="figcap"><b>图4 </b>LazyForEach渲染过程示意图</span>     </div>     <p><span><img height="310.4486" originheight="440" originwidth="1131" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163431.26389444281446006580844089142022:50001231000000:2800:C7966E6DD335B6FB1979A70290C1F711A53A257B8C72217AA6D991E4232995FA.png" title="点击放大" width="798"></span></p>     <p>LazyForEach 实现了按需加载，适用于列表数据量大、列表组件复杂的场景。它减少了页面首次启动时一次性加载数据的时间消耗，降低了内存峰值。然而，在长列表滑动过程中，由于需要根据用户的滑动行为不断加载新内容，会增加滑动时的计算量，从而影响性能。通过在滑动停止或达到某个阈值时才进行加载，可以减少不必要的计算和请求，提高性能，提升用户体验。在实现按需加载时，需要综合考虑性能和用户体验的平衡，合理优化加载逻辑和渲染方式，以提升整体性能表现。</p>    </div>    <div class="tiledSection">     <h3 id="section612134033320">使用场景和规则<i class="anchor-icon anchor-icon-link" anchorid="section612134033320" tips="复制节点链接"></i></h3>          <p><strong>使用场景</strong></p>    </div>    <p>上文了解到ForEach是从列表数据源一次性加载全量数据，且一次性并全部挂载在组件树上；LazyForEach是按需加载部分数据，只构建出一棵短小的组件树。针对数据加载和组件树构建这两个显著差异，可以对ForEach/LazyForEach做出如下选型判断：</p>    <div class="tablenoborder">     <div class="tbBox"><table class="layoutFixed idpTab">      <caption>       <b>表1 </b>使用场景和选型原则      </caption>      <thead>       <tr>        <th align="left" class="cellrowborder" id="mcps1.3.10.2.3.1.1" valign="top" width="22.63%">         <p>渲染接口</p></th>        <th align="left" class="cellrowborder" id="mcps1.3.10.2.3.1.2" valign="top" width="77.37%">         <p>选型原则</p></th>       </tr>      </thead>             <tbody><tr>        <td class="cellrowborder" valign="top" width="22.63%">         <p>ForEach</p></td>        <td class="cellrowborder" valign="top" width="77.37%">         <p>列表数据较少，数据一次性全量加载不是性能瓶颈时。ForEach相对LazyForEach，代码简单很多。</p></td>       </tr>       <tr>        <td class="cellrowborder" valign="top" width="22.63%">         <p>LazyForEach</p></td>        <td class="cellrowborder" valign="top" width="77.37%">         <p>列表数据较长，一次性加载所有的列表数据创建、渲染页面产生性能瓶颈时。</p></td>       </tr>           </tbody></table></div>    </div>    <p><strong>使用规则</strong></p>    <p>详细的使用规则可以参考ForEach的<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-foreach#使用建议" target="_blank">使用建议</a>和LazyForEach的<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-lazyforeach#使用限制" target="_blank">使用限制</a>。</p>    <p></p>    <div class="tiledSection">     <h3 id="section1380125517340">场景案例<i class="anchor-icon anchor-icon-link" anchorid="section1380125517340" tips="复制节点链接"></i></h3>          <p>为了对比List组件在不同数据量下使用ForEach和LazyForEach的性能差异，可以对相关代码进行改造。首先，使用ForEach对列表进行循环；然后，使用LazyForEach对列表进行优化，得到如下两段关键代码：</p>     <ul>      <li>对比案例1：使用ForEach对List列表进行加载       <div class="screenLinkPre"><div _ngcontent-cql-c106="" class="highlight-div"><div _ngcontent-cql-c106="" class="highlight-div-header"><div _ngcontent-cql-c106="" class="highlight-div-header-left"><div _ngcontent-cql-c106="" class="handle-button expand-button"><div _ngcontent-cql-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-cql-c106="" class="highlight-div-header-right"><div _ngcontent-cql-c106="" class="handle-button ai-button"></div><div _ngcontent-cql-c106="" class="handle-button line-button"><div _ngcontent-cql-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-cql-c106="" class="handle-button theme-button"><div _ngcontent-cql-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-cql-c106="" class="handle-button copy-button"><div _ngcontent-cql-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-cql-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-cangjie" codehub="https://gitee.com/harmonyos_samples/list-optimization/blob/master/entry/src/main/ets/pages/ForEachListPage.ets#L34-L97" data-highlighted="yes"><ol class="linenums"><li>@<span class="hljs-title function_">Entry</span></li><li>@<span class="hljs-title function_">Component</span></li><li><span class="hljs-variable">export</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ForEachListPage</span> {</li><li>  <span class="hljs-variable">UIContext</span> = <span class="hljs-keyword">this</span>.<span class="hljs-title function_">getUIContext</span>()</li><li>  <span class="hljs-variable">context</span> = <span class="hljs-keyword">this</span>.<span class="hljs-variable">UIContext</span>.<span class="hljs-title function_">getHostContext</span>() <span class="hljs-keyword">as</span> <span class="hljs-variable">common</span>.<span class="hljs-variable">UIAbilityContext</span>;</li><li>
</li><li>  <span class="hljs-comment">// ...</span></li><li>
</li><li>  <span class="hljs-title function_">build</span>() {</li><li>    <span class="hljs-title function_">Column</span>() {</li><li>      <span class="hljs-title function_">Header</span>()</li><li>      <span class="hljs-title function_">List</span>({ <span class="hljs-variable">space</span>: <span class="hljs-title class_">Constants</span>.<span class="hljs-title class_">SPACE_16</span> }) {</li><li>        <span class="hljs-title function_">ForEach</span>(<span class="hljs-keyword">this</span>.<span class="hljs-variable">articleList</span>, (<span class="hljs-variable">item</span>: <span class="hljs-title class_">LearningResource</span>) =&gt; {</li><li>          <span class="hljs-title function_">ListItem</span>() {</li><li>            <span class="hljs-title function_">Column</span>({ <span class="hljs-variable">space</span>: <span class="hljs-title class_">Constants</span>.<span class="hljs-title class_">SPACE_12</span> }) {</li><li>              <span class="hljs-title function_">ArticleCardView</span>({</li><li>                <span class="hljs-variable">articleItem</span>: <span class="hljs-title class_">item</span>,</li><li>                <span class="hljs-variable">isLiked</span>: <span class="hljs-keyword">this</span>.<span class="hljs-title class_">isLiked</span>(<span class="hljs-title class_">item</span>.<span class="hljs-title class_">id</span>),</li><li>                <span class="hljs-variable">isCollected</span>: <span class="hljs-keyword">this</span>.<span class="hljs-title class_">isCollected</span>(<span class="hljs-title class_">item</span>.<span class="hljs-title class_">id</span>)</li><li>              })</li><li>            }</li><li>          }</li><li>        }, (<span class="hljs-variable">item</span>: <span class="hljs-title class_">LearningResource</span>) =&gt; <span class="hljs-variable">item</span>.<span class="hljs-variable">id</span>)</li><li>      }</li><li>      .<span class="hljs-title function_">width</span>(<span class="hljs-variable">Constants</span>.<span class="hljs-variable">FULL_SCREEN</span>)</li><li>      .<span class="hljs-title function_">height</span>(<span class="hljs-variable">Constants</span>.<span class="hljs-variable">FULL_SCREEN</span>)</li><li>      .<span class="hljs-title function_">padding</span>({ <span class="hljs-variable">left</span>: <span class="hljs-number">10</span>, <span class="hljs-variable">right</span>: <span class="hljs-number">10</span> })</li><li>      .<span class="hljs-title function_">layoutWeight</span>(<span class="hljs-number">1</span>)</li><li>    }</li><li>    .<span class="hljs-title function_">backgroundColor</span>($<span class="hljs-title function_">r</span>(<span class="hljs-string">'app.color.text_background'</span>))</li><li>  }</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/list-optimization/blob/master/entry/src/main/ets/pages/ForEachListPage.ets#L34-L97" target="_blank">ForEachListPage.ets</a></div></div></div></div></li>      <li>对比案例2：使用LazyForEach对List列表进行加载       <div class="screenLinkPre"><div _ngcontent-cql-c106="" class="highlight-div"><div _ngcontent-cql-c106="" class="highlight-div-header"><div _ngcontent-cql-c106="" class="highlight-div-header-left"><div _ngcontent-cql-c106="" class="handle-button expand-button"><div _ngcontent-cql-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-cql-c106="" class="highlight-div-header-right"><div _ngcontent-cql-c106="" class="handle-button ai-button"></div><div _ngcontent-cql-c106="" class="handle-button line-button"><div _ngcontent-cql-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-cql-c106="" class="handle-button theme-button"><div _ngcontent-cql-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-cql-c106="" class="handle-button copy-button"><div _ngcontent-cql-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-cql-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-cangjie" codehub="https://gitee.com/harmonyos_samples/list-optimization/blob/master/entry/src/main/ets/pages/LazyForEachListPage.ets#L36-L114" data-highlighted="yes"><ol class="linenums"><li>@<span class="hljs-title function_">Entry</span></li><li>@<span class="hljs-title function_">Component</span></li><li><span class="hljs-variable">export</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LazyForEachListPage</span> {</li><li>  <span class="hljs-variable">UIContext</span> = <span class="hljs-keyword">this</span>.<span class="hljs-title function_">getUIContext</span>()</li><li>  <span class="hljs-variable">context</span> = <span class="hljs-keyword">this</span>.<span class="hljs-variable">UIContext</span>.<span class="hljs-title function_">getHostContext</span>() <span class="hljs-keyword">as</span> <span class="hljs-variable">common</span>.<span class="hljs-variable">UIAbilityContext</span>;</li><li>
</li><li>  <span class="hljs-comment">// ...</span></li><li>
</li><li>  <span class="hljs-title function_">build</span>() {</li><li>    <span class="hljs-title function_">Column</span>() {</li><li>      <span class="hljs-title function_">Header</span>()</li><li>      <span class="hljs-title function_">List</span>({ <span class="hljs-variable">space</span>: <span class="hljs-title class_">Constants</span>.<span class="hljs-title class_">SPACE_16</span> }) {</li><li>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.<span class="hljs-variable">data</span> !== <span class="hljs-variable">null</span>) {</li><li>          <span class="hljs-comment">// Optimization method 1: Use LazyForEach.</span></li><li>          <span class="hljs-title function_">LazyForEach</span>(<span class="hljs-keyword">this</span>.<span class="hljs-variable">data</span>, (<span class="hljs-variable">item</span>: <span class="hljs-title class_">LearningResource</span>) =&gt; {</li><li>            <span class="hljs-title function_">ListItem</span>() {</li><li>              <span class="hljs-title function_">Column</span>({ <span class="hljs-variable">space</span>: <span class="hljs-title class_">Constants</span>.<span class="hljs-title class_">SPACE_12</span> }) {</li><li>                <span class="hljs-comment">// Optimization method 3：Reuse Component</span></li><li>                <span class="hljs-title function_">ReusableArticleCardView</span>({</li><li>                  <span class="hljs-variable">articleItem</span>: <span class="hljs-title class_">item</span>,</li><li>                  <span class="hljs-variable">isLiked</span>: <span class="hljs-keyword">this</span>.<span class="hljs-title class_">isLiked</span>(<span class="hljs-title class_">item</span>.<span class="hljs-title class_">id</span>),</li><li>                  <span class="hljs-variable">isCollected</span>: <span class="hljs-keyword">this</span>.<span class="hljs-title class_">isCollected</span>(<span class="hljs-title class_">item</span>.<span class="hljs-title class_">id</span>)</li><li>                })</li><li>              }</li><li>            }</li><li>            .<span class="hljs-title function_">reuseId</span>(<span class="hljs-string">'article'</span>)</li><li>          }, (<span class="hljs-variable">item</span>: <span class="hljs-title class_">LearningResource</span>) =&gt; <span class="hljs-variable">item</span>.<span class="hljs-variable">id</span>)</li><li>        }</li><li>      }</li><li>      .<span class="hljs-title function_">width</span>(<span class="hljs-variable">Constants</span>.<span class="hljs-variable">FULL_SCREEN</span>)</li><li>      .<span class="hljs-title function_">height</span>(<span class="hljs-variable">Constants</span>.<span class="hljs-variable">FULL_SCREEN</span>)</li><li>      .<span class="hljs-title function_">padding</span>({ <span class="hljs-variable">left</span>: <span class="hljs-number">10</span>, <span class="hljs-variable">right</span>: <span class="hljs-number">10</span> })</li><li>      .<span class="hljs-title function_">layoutWeight</span>(<span class="hljs-number">1</span>)</li><li>      <span class="hljs-comment">// ...</span></li><li>    }</li><li>    .<span class="hljs-title function_">backgroundColor</span>($<span class="hljs-title function_">r</span>(<span class="hljs-string">'app.color.text_background'</span>))</li><li>  }</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/list-optimization/blob/master/entry/src/main/ets/pages/LazyForEachListPage.ets#L36-L114" target="_blank">LazyForEachListPage.ets</a></div></div></div></div></li>     </ul>     <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content">       <p>LazyForEach的数据源需要实现IDataSource接口，具体实现可参考“HMOS世界”中的DiscoverView.ets代码。</p>      </div></div></div>    </div>    <div class="tiledSection">     <h3 id="section18112209355">性能分析<i class="anchor-icon anchor-icon-link" anchorid="section18112209355" tips="复制节点链接"></i></h3>          <p>针对长列表场景，本地模拟了10、100、1000、10000条数据，分别使用ForEach和LazyForEach测试关闭和开启懒加载情况下的完全显示时间、列表挂载时间、独占内存，并分析滑动过程中的丢帧率。列表挂载时间指创建组件和挂载数据的总时长。最终，使用DevEco Studio的Profiler工具检测上述指标，获得的数据如下所示：</p>     <div class="tablenoborder">      <div class="tbBox"><table class="layoutFixed idpTab">       <caption>        <b>表2 </b><strong>ForEach在不同数据量下的指标对比</strong>       </caption>       <thead>        <tr>         <th align="left" class="cellrowborder" id="mcps1.3.15.3.2.6.1.1" valign="top" width="20%">          <p>ForEach对比指标</p></th>         <th align="left" class="cellrowborder" id="mcps1.3.15.3.2.6.1.2" valign="top" width="20%">          <p>10条数据</p></th>         <th align="left" class="cellrowborder" id="mcps1.3.15.3.2.6.1.3" valign="top" width="20%">          <p>100条数据</p></th>         <th align="left" class="cellrowborder" id="mcps1.3.15.3.2.6.1.4" valign="top" width="20%">          <p>1000条数据</p></th>         <th align="left" class="cellrowborder" id="mcps1.3.15.3.2.6.1.5" valign="top" width="20%">          <p>10000条数据</p></th>        </tr>       </thead>               <tbody><tr>         <td class="cellrowborder" valign="top" width="20%">          <p>完全显示所用时间</p></td>         <td class="cellrowborder" valign="top" width="20%">          <p>1s741ms</p></td>         <td class="cellrowborder" valign="top" width="20%">          <p>1s786ms</p></td>         <td class="cellrowborder" valign="top" width="20%">          <p>1s942ms</p></td>         <td class="cellrowborder" valign="top" width="20%">          <p>5s841ms</p></td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="20%">          <p>列表挂载时间</p></td>         <td class="cellrowborder" valign="top" width="20%">          <p>87ms</p></td>         <td class="cellrowborder" valign="top" width="20%">          <p>88ms</p></td>         <td class="cellrowborder" valign="top" width="20%">          <p>135ms</p></td>         <td class="cellrowborder" valign="top" width="20%">          <p>3s 291ms</p></td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="20%">          <p>独占内存（滑动完成后）</p></td>         <td class="cellrowborder" valign="top" width="20%">          <p>38.2MB</p></td>         <td class="cellrowborder" valign="top" width="20%">          <p>48.7MB</p></td>         <td class="cellrowborder" valign="top" width="20%">          <p>83.7MB</p></td>         <td class="cellrowborder" valign="top" width="20%">          <p>560.1MB</p></td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="20%">          <p>丢帧率</p></td>         <td class="cellrowborder" valign="top" width="20%">          <p>0.0%</p></td>         <td class="cellrowborder" valign="top" width="20%">          <p>3.8%</p></td>         <td class="cellrowborder" valign="top" width="20%">          <p>4.5%</p></td>         <td class="cellrowborder" valign="top" width="20%">          <p>58.2%</p></td>        </tr>             </tbody></table></div>     </div>     <div class="tablenoborder">      <div class="tbBox"><table class="layoutFixed idpTab">       <caption>        <b>表3 </b><strong>LazyForEach在不同数据量下的指标对比</strong>       </caption>       <thead>        <tr>         <th align="left" class="cellrowborder" id="mcps1.3.15.4.2.6.1.1" valign="top" width="20%">          <p><strong>Lazy</strong>ForEach对比指标</p></th>         <th align="left" class="cellrowborder" id="mcps1.3.15.4.2.6.1.2" valign="top" width="20%">          <p>10条数据</p></th>         <th align="left" class="cellrowborder" id="mcps1.3.15.4.2.6.1.3" valign="top" width="20%">          <p>100条数据</p></th>         <th align="left" class="cellrowborder" id="mcps1.3.15.4.2.6.1.4" valign="top" width="19.97%">          <p>1000条数据</p></th>         <th align="left" class="cellrowborder" id="mcps1.3.15.4.2.6.1.5" valign="top" width="20.03%">          <p>10000条数据</p></th>        </tr>       </thead>               <tbody><tr>         <td class="cellrowborder" valign="top" width="20%">          <p>完全显示所用时间</p></td>         <td class="cellrowborder" valign="top" width="20%">          <p>1s544ms</p></td>         <td class="cellrowborder" valign="top" width="20%">          <p>1s572ms</p></td>         <td class="cellrowborder" valign="top" width="19.97%">          <p>1s652ms</p></td>         <td class="cellrowborder" valign="top" width="20.03%">          <p>1s707ms</p></td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="20%">          <p>列表挂载时间</p></td>         <td class="cellrowborder" valign="top" width="20%">          <p>88ms</p></td>         <td class="cellrowborder" valign="top" width="20%">          <p>89ms</p></td>         <td class="cellrowborder" valign="top" width="19.97%">          <p>94ms</p></td>         <td class="cellrowborder" valign="top" width="20.03%">          <p>97ms</p></td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="20%">          <p>独占内存（滑动完成后）</p></td>         <td class="cellrowborder" valign="top" width="20%">          <p>38.1MB</p></td>         <td class="cellrowborder" valign="top" width="20%">          <p>44.6MB</p></td>         <td class="cellrowborder" valign="top" width="19.97%">          <p>46.3MB</p></td>         <td class="cellrowborder" valign="top" width="20.03%">          <p>82.9MB</p></td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="20%">          <p>丢帧率</p></td>         <td class="cellrowborder" valign="top" width="20%">          <p>0.0%</p></td>         <td class="cellrowborder" valign="top" width="20%">          <p>2.3%</p></td>         <td class="cellrowborder" valign="top" width="19.97%">          <p>3.6%</p></td>         <td class="cellrowborder" valign="top" width="20.03%">          <p>6.6%</p></td>        </tr>             </tbody></table></div>     </div>     <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content">       <p>以上数据来源均为版本DevEco Studio 4.0.3.415、SDK 4.0.10.9条件下重复多次测试得到，不同设备类型数据可能存在差异，测试数据旨在体现性能优化趋势，仅供参考。</p>      </div></div></div>     <div class="fignone">      <span class="figcap"><b>图5 </b>ForEach和LazyForEach在不同数据量下的指标对比</span>      <p><span><img height="367.0667" originheight="908" originwidth="1974" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163431.07009555368773175025501597361182:50001231000000:2800:97E290C4908AE2F244BA438039C9AD5B67D3C80DFBD9D1A7FB9753B87C90289F.png" title="点击放大" width="798"></span></p>     </div>     <p>从测试数据可以看出：</p>     <ol>      <li>在100条数据范围内，ForEach和LazyForEach的性能差距不明显，两者各项性能指标均在可接受范围内。ForEach的代码逻辑比LazyForEach更简单，因此在此场景下建议使用ForEach。</li>      <li>当数据量超过1000条，特别是达到10000条时，ForEach在列表渲染、应用内存占用和丢帧率等方面会出现显著劣化，滑动时会出现明显的卡顿，甚至可能导致应用崩溃。</li>      <li>使用LazyForEach除了内存会略微增加外，列表渲染时间和丢帧率都不会有显著变化，性能表现良好。</li>     </ol>    </div>    <div class="tiledSection">     <h2 id="section11667144010222">缓存列表项<i class="anchor-icon anchor-icon-link" anchorid="section11667144010222" tips="复制节点链接"></i></h2>         </div>    <div class="tiledSection">     <h3 id="section177671253614" class="firsth2">原理介绍<i class="anchor-icon anchor-icon-link" anchorid="section177671253614" tips="复制节点链接"></i></h3>          <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content">       <p>建议开发者优先使用<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-code-linter" target="_blank">代码Code Linter检查</a>工具进行代码扫描，重点关注<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide_hp-arkui-set-cache-count-for-lazyforeach-grid" target="_blank">@performance/hp-arkui-set-cache-count-for-lazyforeach-grid</a>规则。若扫描结果中出现该规则相关问题，可参考本章节提供的优化建议进行调整。</p>      </div></div></div>     <p>从上文了解到，在进行列表加载时，应避免一次性加载所有列表数据项，推荐按需加载数据。例如，页面一次可以显示6条数据，若不提前缓存部分数据，快速下滑到列表底部时，可能会出现“滑动白块”的现象。这是因为上一次请求的数据仅限于屏幕上的6条，如果滑动速度过快，数据无法及时加载，导致白块出现。在追求高性能的同时，应避免此类影响用户体验的问题。</p>     <p>通过设置cachedCount，可以指定LazyForEach懒加载的缓存数量。设置cachedCount后，除了屏幕内显示的ListItem组件外，还会预先缓存屏幕可视区外指定数量的列表项数据。这样，当一个屏幕的数据加载完成后，再次向下滑动时，会先加载上一次请求的数据，加载完成后，再加载本次请求的数据。添加cachedCount缓存列表项后，LazyForEach的渲染过程如下：</p>     <ol>      <li><span>首先，请求n+cachedCount条数据，并在屏幕上显示n条数据。</span></li>      <li><span>当列表滑动，缓存列表项从屏幕可视区外进入可视区内时，只需渲染组件，从而提升显示效率。</span></li>      <li><span>当列表不断滑动，屏幕可视区外缓存的列表项数量少于cachedCount设置数量时，会触发列表项数据加载事件，继续预加载下一组缓存列表项（cachedCount个）。</span></li>      <li><span>当上滑和下滑交替进行时，列表会在两个方向上分别缓存cachedCount条数据。</span></li>      <li><span>如果不显式设置cachedCount，则cachedCount默认值为1。</span></li>     </ol>     <p>数据加载、组件树挂载、页面渲染的示意图如下所示：</p>     <div class="fignone">      <span class="figcap"><b>图6 </b>缓存作用区域与渲染过程示意图</span>      <br><span><img originheight="492" originwidth="1131" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163431.71438043927666038899574816160400:50001231000000:2800:E2C8176424B7B5B75C623AC903591553592A03163A8280556AFBA542E9CE783C.png" width="920" height="400.2122015915119"></span>     </div>    </div>    <div class="tiledSection">     <h3 id="section58753319362">使用场景和规则<i class="anchor-icon anchor-icon-link" anchorid="section58753319362" tips="复制节点链接"></i></h3>          <p><strong>使用场景</strong></p>    </div>    <p>缓存列表项适用于数据请求耗时的场景，如滑动列表中包含短视频、高清图片等大数据量资源。预先从网络加载并缓存相关数据，可以缩短渲染前的准备时间，提升列表响应速度。</p>    <p><strong>使用规则</strong></p>    <p>缓存列表项仅在使用LazyForEach懒加载时有效。ForEach循环渲染会一次性加载所有数据，因此无法也不需要设置缓存列表项。</p>    <div class="tiledSection">     <h3 id="section18672196153710">场景案例<i class="anchor-icon anchor-icon-link" anchorid="section18672196153710" tips="复制节点链接"></i></h3>          <p>在LazyForEach上添加缓存列表项后的关键代码如下所示：</p>     <div class="screenLinkPre"><div _ngcontent-cql-c106="" class="highlight-div"><div _ngcontent-cql-c106="" class="highlight-div-header"><div _ngcontent-cql-c106="" class="highlight-div-header-left"><div _ngcontent-cql-c106="" class="handle-button expand-button"><div _ngcontent-cql-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-cql-c106="" class="highlight-div-header-right"><div _ngcontent-cql-c106="" class="handle-button ai-button"></div><div _ngcontent-cql-c106="" class="handle-button line-button"><div _ngcontent-cql-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-cql-c106="" class="handle-button theme-button"><div _ngcontent-cql-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-cql-c106="" class="handle-button copy-button"><div _ngcontent-cql-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-cql-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-cangjie" codehub="https://gitee.com/harmonyos_samples/list-optimization/blob/master/entry/src/main/ets/pages/LazyForEachListPage.ets#L37-L115" data-highlighted="yes"><ol class="linenums"><li>@<span class="hljs-title function_">Entry</span></li><li>@<span class="hljs-title function_">Component</span></li><li><span class="hljs-variable">export</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LazyForEachListPage</span> {</li><li>  <span class="hljs-variable">UIContext</span> = <span class="hljs-keyword">this</span>.<span class="hljs-title function_">getUIContext</span>()</li><li>  <span class="hljs-variable">context</span> = <span class="hljs-keyword">this</span>.<span class="hljs-variable">UIContext</span>.<span class="hljs-title function_">getHostContext</span>() <span class="hljs-keyword">as</span> <span class="hljs-variable">common</span>.<span class="hljs-variable">UIAbilityContext</span>;</li><li>
</li><li>  <span class="hljs-comment">// ...</span></li><li>
</li><li>  <span class="hljs-title function_">build</span>() {</li><li>    <span class="hljs-title function_">Column</span>() {</li><li>      <span class="hljs-title function_">Header</span>()</li><li>      <span class="hljs-title function_">List</span>({ <span class="hljs-variable">space</span>: <span class="hljs-title class_">Constants</span>.<span class="hljs-title class_">SPACE_16</span> }) {</li><li>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.<span class="hljs-variable">data</span> !== <span class="hljs-variable">null</span>) {</li><li>          <span class="hljs-comment">// Optimization method 1: Use LazyForEach.</span></li><li>          <span class="hljs-title function_">LazyForEach</span>(<span class="hljs-keyword">this</span>.<span class="hljs-variable">data</span>, (<span class="hljs-variable">item</span>: <span class="hljs-title class_">LearningResource</span>) =&gt; {</li><li>            <span class="hljs-title function_">ListItem</span>() {</li><li>              <span class="hljs-title function_">Column</span>({ <span class="hljs-variable">space</span>: <span class="hljs-title class_">Constants</span>.<span class="hljs-title class_">SPACE_12</span> }) {</li><li>                <span class="hljs-comment">// Optimization method 3：Reuse Component</span></li><li>                <span class="hljs-title function_">ReusableArticleCardView</span>({</li><li>                  <span class="hljs-variable">articleItem</span>: <span class="hljs-title class_">item</span>,</li><li>                  <span class="hljs-variable">isLiked</span>: <span class="hljs-keyword">this</span>.<span class="hljs-title class_">isLiked</span>(<span class="hljs-title class_">item</span>.<span class="hljs-title class_">id</span>),</li><li>                  <span class="hljs-variable">isCollected</span>: <span class="hljs-keyword">this</span>.<span class="hljs-title class_">isCollected</span>(<span class="hljs-title class_">item</span>.<span class="hljs-title class_">id</span>)</li><li>                })</li><li>              }</li><li>            }</li><li>            .<span class="hljs-title function_">reuseId</span>(<span class="hljs-string">'article'</span>)</li><li>          }, (<span class="hljs-variable">item</span>: <span class="hljs-title class_">LearningResource</span>) =&gt; <span class="hljs-variable">item</span>.<span class="hljs-variable">id</span>)</li><li>        }</li><li>      }</li><li>      .<span class="hljs-title function_">width</span>(<span class="hljs-variable">Constants</span>.<span class="hljs-variable">FULL_SCREEN</span>)</li><li>      .<span class="hljs-title function_">height</span>(<span class="hljs-variable">Constants</span>.<span class="hljs-variable">FULL_SCREEN</span>)</li><li>      .<span class="hljs-title function_">padding</span>({ <span class="hljs-variable">left</span>: <span class="hljs-number">10</span>, <span class="hljs-variable">right</span>: <span class="hljs-number">10</span> })</li><li>      .<span class="hljs-title function_">layoutWeight</span>(<span class="hljs-number">1</span>)</li><li>      <span class="hljs-comment">// Optimization method 2：Use cachedCount</span></li><li>      .<span class="hljs-title function_">cachedCount</span>(<span class="hljs-number">3</span>);</li><li>    }</li><li>    .<span class="hljs-title function_">backgroundColor</span>($<span class="hljs-title function_">r</span>(<span class="hljs-string">'app.color.text_background'</span>))</li><li>  }</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/list-optimization/blob/master/entry/src/main/ets/pages/LazyForEachListPage.ets#L37-L115" target="_blank">LazyForEachListPage.ets</a></div></div></div></div>    </div>    <div class="tiledSection">     <h3 id="section8544153093714">性能分析<i class="anchor-icon anchor-icon-link" anchorid="section8544153093714" tips="复制节点链接"></i></h3>          <p>本文案例中的长列表每屏可以加载6条数据。为了测试不同缓存数量对丢帧率的影响，将cachedCount的值分别设为1、2、3、6、12、18和30。基于示例程序，测试结果显示，不设置缓存数量（默认cachedCount=1）时，丢帧率为6.6%。随着缓存数量的增加，丢帧率逐渐降低。当缓存数量设置为当前屏幕展示数量的一半，即缓存3个列表项时，丢帧率最低为3.7%。继续增加缓存数量，丢帧率不再显著下降，过多的缓存数量甚至可能影响丢帧率。</p>     <div class="fignone">      <span class="figcap"><b>图7 </b>10000条数据量下不同cachedCount对列表滑动帧率的影响</span>      <p><span><img height="341.39770000000004" originheight="403" originwidth="942" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163431.76957898349086618401900561565301:50001231000000:2800:B52462AE44E3EC156DE34BCCAFE8DC546F80CE91614CB2BD87BA9CC38BB06198.png" title="点击放大" width="798"></span></p>     </div>     <p>在缓存设置中，建议将cachedCount设置为n/2（n为一屏显示的列表数）。实际开发中，应根据具体场景合理调整缓存数量。例如，如果列表项需要显示网络数据，而网络数据加载较慢，为了提升列表信息的浏览效率和浏览体验，可以将cachedCount设置为大于n/2。如果列表中需要加载大图或视频等占用较大内存的数据，为了减少内存占用，可以将cachedCount设置为小于n/2。因此，实际场景中需要不断尝试和验证，以找到合适的缓存数量，平衡用户体验和内存占用。</p>     <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content">       <p>测试数据仅限于示例程序，不同的应用程序设置的合适缓存数量不一致，需要针对应用程序测试得出具体的缓存数量。</p>      </div></div></div>    </div>    <div class="tiledSection">     <h2 id="section45271003316">动态预加载<i class="anchor-icon anchor-icon-link" anchorid="section45271003316" tips="复制节点链接"></i></h2>         </div>    <div class="tiledSection">     <h3 id="section866417235319" class="firsth2">原理介绍<i class="anchor-icon anchor-icon-link" anchorid="section866417235319" tips="复制节点链接"></i></h3>          <p>从上文了解到，LazyForEach懒加载可以通过设置cachedCount来指定缓存数量，以解决下滑到列表最底端时，再快速下滑可能会引起“滑动白块”的现象。如果用户使用大量在线数据，在弱网和快速滑动的场景下，滑动过程中仍可能出现白块。将cachedCount设置为较大值可以减少滑动过程中白块的出现，但会增加首屏加载时间。在追求高性能的同时，应避免影响用户体验。</p>     <p>HarmonyOS提供内容预取能力Prefetcher，支持动态自适应网络状态。通过提前下载图片或资源，确保资源在需要时立即显示，减少白块出现。</p>     <p>LazyForEach懒加载可以通过使用Prefetcher来预取和预渲染数据。在使用Prefetcher后，除屏幕内显示的ListItem组件外，还会预先将屏幕可视区外的部分列表项数据进行预渲染和预取。这样当列表向下滑动时，会先显示预渲染组件，屏幕可视区外会动态调整预取范围。预取逻辑在Prefetcher的BasicPrefetcher类中实现，BasicPrefetcher支持预取和预渲染（图像解码、添加到组件树等）过程分离、自适应调整预获取范围、优先加载可视区域、以及取消不必要任务（快速滚动列表的场景下，智能取消不必要任务），其渲染过程如下：</p>     <ol>      <li><span>首先，请求n条数据，并在屏幕上显示m条数据。</span></li>      <li><span>当列表滑动，缓存列表项从屏幕可视区外进入可视区内时，显示预渲染组件。屏幕可视区外动态调整预取范围，相比仅设置cachedCount，显示效率更高。</span></li>      <li><span>当列表滑动时，屏幕外的列表项实时更新，预取数据和预渲染数据也同步更新。</span></li>     </ol>     <div class="fignone">      <span class="figcap"><b>图8 </b>动态预加载渲染过程示意图</span>     </div>     <p><span><img height="395.698275" originheight="1135" originwidth="2060" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163431.09538507176867209962005515045354:50001231000000:2800:492F9896B47C5656965345ED1F8E68B263BE4DF09D78BA19CD3F6C51D9A93504.png" title="点击放大" width="718.2"></span></p>    </div>    <div class="tiledSection">     <h3 id="section1753610153318">使用场景<i class="anchor-icon anchor-icon-link" anchorid="section1753610153318" tips="复制节点链接"></i></h3>          <p>动态预加载适用于数据请求耗时较长的场景，如滑动列表中包含大量图片资源。在LazyForEach的数据源中使用IDataSourcePrefetching的prefetch方法，提前从网络加载并缓存数据。BasicPrefetcher在滚动体验和CPU节省方面有显著提升，从而提高应用的响应速度。</p>    </div>    <div class="tiledSection">     <h3 id="section1536105332">场景案例<i class="anchor-icon anchor-icon-link" anchorid="section1536105332" tips="复制节点链接"></i></h3>          <p>实现DataSourcePrefetchingRCP类，继承IDataSourcePrefetching接口并实现prefetch和cancel方法，如下代码所示：</p>     <div class="screenLinkPre"><div _ngcontent-cql-c106="" class="highlight-div"><div _ngcontent-cql-c106="" class="highlight-div-header"><div _ngcontent-cql-c106="" class="highlight-div-header-left"><div _ngcontent-cql-c106="" class="handle-button expand-button"><div _ngcontent-cql-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-cql-c106="" class="highlight-div-header-right"><div _ngcontent-cql-c106="" class="handle-button ai-button"></div><div _ngcontent-cql-c106="" class="handle-button line-button"><div _ngcontent-cql-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-cql-c106="" class="handle-button theme-button"><div _ngcontent-cql-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-cql-c106="" class="handle-button copy-button"><div _ngcontent-cql-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-cql-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-typescript" codehub="https://gitee.com/harmonyos_samples/list-optimization/blob/master/entry/src/main/ets/pages/prefetching.ets#L2-L74" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">import</span> { <span class="hljs-title class_">SongInfoItem</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./song'</span>;</li><li><span class="hljs-keyword">import</span> { <span class="hljs-title class_">HashMap</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.ArkTS'</span>;</li><li><span class="hljs-keyword">import</span> { fileIo } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.CoreFileKit'</span>;</li><li><span class="hljs-keyword">import</span> { <span class="hljs-title class_">IDataSourcePrefetching</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.ArkUI'</span>;</li><li><span class="hljs-keyword">import</span> { rcp } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.RemoteCommunicationKit'</span>;</li><li><span class="hljs-keyword">let</span> <span class="hljs-attr">PREFETCH_ENABLED</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>;</li><li><span class="hljs-keyword">const</span> <span class="hljs-attr">CANCEL_CODE</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">1007900992</span>;</li><li><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">IMADE_UNAVAILABLE</span> = $r(<span class="hljs-string">'app.media.startIcon'</span>);</li><li><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataSourcePrefetching</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IDataSourcePrefetching</span> {</li><li>  <span class="hljs-keyword">private</span> <span class="hljs-attr">dataArray</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">SongInfoItem</span>&gt;;</li><li>  <span class="hljs-keyword">private</span> <span class="hljs-attr">listeners</span>: <span class="hljs-title class_">DataChangeListener</span>[] = [];</li><li>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> <span class="hljs-attr">requestsInFlight</span>: <span class="hljs-title class_">HashMap</span>&lt;<span class="hljs-built_in">number</span>, rcp.<span class="hljs-property">Request</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();</li><li>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> <span class="hljs-attr">session</span>: rcp.<span class="hljs-property">Session</span> = rcp.<span class="hljs-title function_">createSession</span>();</li><li>  <span class="hljs-title function_">cache</span>(<span class="hljs-params">ID:<span class="hljs-built_in">number</span>,body: ESObject</span>){}</li><li>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">dataArray: <span class="hljs-built_in">Array</span>&lt;SongInfoItem&gt;</span>) {</li><li>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dataArray</span> = dataArray;</li><li>  }</li><li>  <span class="hljs-title function_">totalCount</span>(): <span class="hljs-built_in">number</span> {</li><li>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Method not implemented.'</span>);</li><li>  }</li><li>  <span class="hljs-title function_">getData</span>(<span class="hljs-attr">index</span>: <span class="hljs-built_in">number</span>): <span class="hljs-title class_">ESObject</span> {</li><li>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Method not implemented.'</span>);</li><li>  }</li><li>  <span class="hljs-title function_">registerDataChangeListener</span>(<span class="hljs-attr">listener</span>: <span class="hljs-title class_">DataChangeListener</span>): <span class="hljs-built_in">void</span> {</li><li>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Method not implemented.'</span>);</li><li>  }</li><li>  <span class="hljs-title function_">unregisterDataChangeListener</span>(<span class="hljs-attr">listener</span>: <span class="hljs-title class_">DataChangeListener</span>): <span class="hljs-built_in">void</span> {</li><li>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Method not implemented.'</span>);</li><li>  }</li><li>  <span class="hljs-keyword">async</span> <span class="hljs-title function_">prefetch</span>(<span class="hljs-attr">index</span>: <span class="hljs-built_in">number</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {</li><li>    <span class="hljs-variable constant_">PREFETCH_ENABLED</span> = <span class="hljs-literal">true</span>;</li><li>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">requestsInFlight</span>.<span class="hljs-title function_">hasKey</span>(index)) {</li><li>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Already being prefetched'</span>)</li><li>    }</li><li>    <span class="hljs-keyword">const</span> item = <span class="hljs-variable language_">this</span>.<span class="hljs-property">dataArray</span>[index];</li><li>    <span class="hljs-keyword">if</span> (item.<span class="hljs-property">cachedImage</span>) {</li><li>      <span class="hljs-keyword">return</span>;</li><li>    }</li><li>    <span class="hljs-comment">// Data request</span></li><li>    <span class="hljs-keyword">const</span> request = <span class="hljs-keyword">new</span> rcp.<span class="hljs-title class_">Request</span>(item.<span class="hljs-property">albumUrl</span>, <span class="hljs-string">'GET'</span>);</li><li>    <span class="hljs-comment">// Cache the network request object, which is convenient for handling when the request needs to be cancelled.</span></li><li>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">requestsInFlight</span>.<span class="hljs-title function_">set</span>(index, request);</li><li>    <span class="hljs-keyword">try</span> {</li><li>      <span class="hljs-comment">// Send an http request to get a response.</span></li><li>      <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">session</span>.<span class="hljs-title function_">fetch</span>(request);</li><li>      <span class="hljs-keyword">if</span> (response.<span class="hljs-property">statusCode</span> !== <span class="hljs-number">200</span> || !response.<span class="hljs-property">body</span>) {</li><li>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Bad response'</span>);</li><li>      }</li><li>      <span class="hljs-comment">// Storing the loaded data information into a cache file.</span></li><li>      item.<span class="hljs-property">cachedImage</span> = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">cache</span>(item.<span class="hljs-property">songId</span>, response.<span class="hljs-property">body</span>);</li><li>      <span class="hljs-comment">// Delete the specified element</span></li><li>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">requestsInFlight</span>.<span class="hljs-title function_">remove</span>(index);</li><li>    } <span class="hljs-keyword">catch</span> (err) {</li><li>      <span class="hljs-keyword">if</span> (err.<span class="hljs-property">code</span> !== <span class="hljs-variable constant_">CANCEL_CODE</span>) {</li><li>        item.<span class="hljs-property">cachedImage</span> = <span class="hljs-variable constant_">IMADE_UNAVAILABLE</span>;</li><li>        <span class="hljs-comment">// Remove abnormal network request tasks.</span></li><li>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">requestsInFlight</span>.<span class="hljs-title function_">remove</span>(index);</li><li>      }</li><li>      <span class="hljs-keyword">throw</span> err <span class="hljs-keyword">as</span> <span class="hljs-title class_">Error</span>;</li><li>    }</li><li>  }</li><li>  <span class="hljs-title function_">cancel</span>(<span class="hljs-params">index: <span class="hljs-built_in">number</span></span>) {</li><li>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">requestsInFlight</span>.<span class="hljs-title function_">hasKey</span>(index)) {</li><li>      <span class="hljs-comment">// Returns the specified element of a MAP object.</span></li><li>      <span class="hljs-keyword">const</span> request = <span class="hljs-variable language_">this</span>.<span class="hljs-property">requestsInFlight</span>.<span class="hljs-title function_">get</span>(index);</li><li>      <span class="hljs-comment">// Cancel data request</span></li><li>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">session</span>.<span class="hljs-title function_">cancel</span>(request);</li><li>      <span class="hljs-comment">// Remove the canceled network request object</span></li><li>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">requestsInFlight</span>.<span class="hljs-title function_">remove</span>(index);</li><li>    }</li><li>  }</li><li>  <span class="hljs-comment">// ...</span></li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/list-optimization/blob/master/entry/src/main/ets/pages/prefetching.ets#L2-L74" target="_blank">prefetching.ets</a></div></div></div></div>     <p>在应用列表界面，创建DataSourcePrefetchingRCP和BasicPrefetcher对象。在List的onScrollIndex回调中，调用BasicPrefetcher的visibleAreaChanged()方法，传入List的可见区域起始坐标。这样可以优化代码。</p>     <div class="screenLinkPre"><div _ngcontent-cql-c106="" class="highlight-div"><div _ngcontent-cql-c106="" class="highlight-div-header"><div _ngcontent-cql-c106="" class="highlight-div-header-left"><div _ngcontent-cql-c106="" class="handle-button expand-button"><div _ngcontent-cql-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-cql-c106="" class="highlight-div-header-right"><div _ngcontent-cql-c106="" class="handle-button ai-button"></div><div _ngcontent-cql-c106="" class="handle-button line-button"><div _ngcontent-cql-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-cql-c106="" class="handle-button theme-button"><div _ngcontent-cql-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-cql-c106="" class="handle-button copy-button"><div _ngcontent-cql-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-cql-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-typescript" codehub="https://gitee.com/harmonyos_samples/list-optimization/blob/master/entry/src/main/ets/pages/basicPre.ets#L2-L44" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Header</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./header'</span></li><li><span class="hljs-keyword">import</span> { <span class="hljs-title class_">SongInfoItem</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./song'</span>;</li><li><span class="hljs-keyword">import</span> <span class="hljs-title class_">DataSourcePrefetching</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'../model/ArticleListData'</span>;</li><li><span class="hljs-keyword">import</span> { <span class="hljs-title class_">ObservedArray</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'../utils/ObservedArray'</span>;</li><li><span class="hljs-keyword">import</span> { <span class="hljs-title class_">ReusableArticleCardView</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'../components/ReusableArticleCardView'</span>;</li><li><span class="hljs-keyword">import</span> <span class="hljs-title class_">Constants</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'../constants/Constants'</span>;</li><li><span class="hljs-keyword">import</span> { <span class="hljs-title class_">PageViewModel</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./song'</span>;</li><li><span class="hljs-keyword">import</span> { <span class="hljs-title class_">BasicPrefetcher</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@kit.ArkUI'</span>;</li><li><span class="hljs-meta">@Entry</span></li><li><span class="hljs-meta">@Component</span></li><li><span class="hljs-keyword">export</span> struct <span class="hljs-title class_">LazyForEachListPage</span> {</li><li>  <span class="hljs-meta">@State</span> <span class="hljs-attr">collectedIds</span>: <span class="hljs-title class_">ObservedArray</span>&lt;<span class="hljs-built_in">string</span>&gt; = [<span class="hljs-string">'1'</span>, <span class="hljs-string">'2'</span>, <span class="hljs-string">'3'</span>, <span class="hljs-string">'4'</span>, <span class="hljs-string">'5'</span>, <span class="hljs-string">'6'</span>];</li><li>  <span class="hljs-meta">@State</span> <span class="hljs-attr">likedIds</span>: <span class="hljs-title class_">ObservedArray</span>&lt;<span class="hljs-built_in">string</span>&gt; = [<span class="hljs-string">'1'</span>, <span class="hljs-string">'2'</span>, <span class="hljs-string">'3'</span>, <span class="hljs-string">'4'</span>, <span class="hljs-string">'5'</span>, <span class="hljs-string">'6'</span>];</li><li>  <span class="hljs-meta">@State</span> <span class="hljs-attr">isListReachEnd</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>;</li><li>  <span class="hljs-comment">// Create a DataSourcePrefetching object, which is a data source with task prefetching and cancellation capabilities.</span></li><li>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> dataSource :<span class="hljs-title class_">ESObject</span>= <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataSourcePrefetching</span>(<span class="hljs-title class_">PageViewModel</span>.<span class="hljs-title function_">getItems</span>());</li><li>  <span class="hljs-comment">// Create a BasicPrefetcher object, which is realized by the default dynamic prefetching algorithm.</span></li><li>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> prefetcher = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BasicPrefetcher</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">dataSource</span>);</li><li>
</li><li>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) {</li><li>    <span class="hljs-title class_">Column</span>() {</li><li>      <span class="hljs-title class_">Header</span>()</li><li>      <span class="hljs-title class_">List</span>({ <span class="hljs-attr">space</span>: <span class="hljs-title class_">Constants</span>.<span class="hljs-property">SPACE_16</span> }) {</li><li>        <span class="hljs-title class_">LazyForEach</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">dataSource</span>, <span class="hljs-function">(<span class="hljs-params">item: SongInfoItem </span>) =&gt;</span> {</li><li>          <span class="hljs-title class_">ListItem</span>() {</li><li>            <span class="hljs-title class_">ReusableArticleCardView</span>({ <span class="hljs-attr">articleItem</span>: item })</li><li>          }</li><li>          .<span class="hljs-title function_">reuseId</span>(<span class="hljs-string">'article'</span>)</li><li>        })</li><li>      }</li><li>      .<span class="hljs-title function_">cachedCount</span>(<span class="hljs-number">5</span>)</li><li>      .<span class="hljs-title function_">onScrollIndex</span>(<span class="hljs-function">(<span class="hljs-params">start: <span class="hljs-built_in">number</span>, end: <span class="hljs-built_in">number</span></span>) =&gt;</span> {</li><li>        <span class="hljs-comment">// List scrolling triggers visibleareachan, updates the prefetch range in real time, and triggers calling prefetch and cancel interfaces.</span></li><li>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">prefetcher</span>.<span class="hljs-title function_">visibleAreaChanged</span>(start, end)</li><li>      })</li><li>      .<span class="hljs-title function_">width</span>(<span class="hljs-title class_">Constants</span>.<span class="hljs-property">FULL_SCREEN</span>)</li><li>      .<span class="hljs-title function_">height</span>(<span class="hljs-title class_">Constants</span>.<span class="hljs-property">FULL_SCREEN</span>)</li><li>      .<span class="hljs-title function_">padding</span>({ <span class="hljs-attr">left</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">right</span>: <span class="hljs-number">10</span> })</li><li>      .<span class="hljs-title function_">layoutWeight</span>(<span class="hljs-number">1</span>)</li><li>    }</li><li>    .<span class="hljs-title function_">backgroundColor</span>($r(<span class="hljs-string">'app.color.text_background'</span>))</li><li>  }</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/list-optimization/blob/master/entry/src/main/ets/pages/basicPre.ets#L2-L44" target="_blank">basicPre.ets</a></div></div></div></div>    </div>    <div class="tiledSection">     <h3 id="section1057101011338">性能分析<i class="anchor-icon anchor-icon-link" anchorid="section1057101011338" tips="复制节点链接"></i></h3>          <p>本文案例中的长列表每屏加载6条数据，测试不同cachedCount值对应用性能的影响，包括快速滑动场景下的白块数量、CPU开销占比和首屏加载时长。对比场景设置cachedCount=5和cachedCount=40。使用DevEco Studio的Profiler工具检测上述指标，得到的数据如下所示：</p>     <p><strong>1.场景滑动对比</strong></p>     <div class="tablenoborder">      <div class="tbBox"><table class="layoutFixed idpTab">       <thead>        <tr>         <th align="left" class="cellrowborder" id="mcps1.3.28.4.1.4.1.1" valign="top" width="33.33333333333333%">          <p><strong>cachedCount=5</strong></p></th>         <th align="left" class="cellrowborder" id="mcps1.3.28.4.1.4.1.2" valign="top" width="33.33333333333333%">          <p><strong>cachedCount=40</strong></p></th>         <th align="left" class="cellrowborder" id="mcps1.3.28.4.1.4.1.3" valign="top" width="33.33333333333333%">          <p><strong>动态预加载</strong></p></th>        </tr>       </thead>               <tbody><tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">          <p><span><img height="545.965" originheight="720" originwidth="348" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163431.84200930108887851216360442243632:50001231000000:2800:7919B7E379B7E9353C3950B889DF0D5E8231C1E17D75DA8C2F5355DB76897654.gif" title="点击放大" width="266"></span></p></td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">          <p><span><img height="545.965" originheight="720" originwidth="348" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163431.66186824341301534831760309618431:50001231000000:2800:C7E67428047B774682976EC28E68D11D9B267FB2A700410B683E8D5E5C15E898.gif" title="点击放大" width="266"></span></p></td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">          <p><span><img height="545.965" originheight="720" originwidth="348" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163432.93261600508125477575332110931366:50001231000000:2800:E361CF3E2879EB40A2F5F2D52389DC8E303937E3395EB99DCB1B3BFDBEC254B4.gif" title="点击放大" width="266"></span></p></td>        </tr>             </tbody></table></div>     </div>     <div class="tablenoborder">      <div class="tbBox"><table class="layoutFixed idpTab">       <thead>        <tr>         <th align="left" class="cellrowborder" id="mcps1.3.28.5.1.4.1.1" valign="top" width="33.33333333333333%">          <p>数据设置</p></th>         <th align="left" class="cellrowborder" id="mcps1.3.28.5.1.4.1.2" valign="top" width="33.33333333333333%">          <p>首屏加载</p></th>         <th align="left" class="cellrowborder" id="mcps1.3.28.5.1.4.1.3" valign="top" width="33.33333333333333%">          <p>滑动过程滑块数量</p></th>        </tr>       </thead>               <tbody><tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">          <p>cachedCount=5</p></td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">          <p>首屏加载快</p></td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">          <p>滑动过程中白块很多</p></td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">          <p>cachedCount=40</p></td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">          <p>首屏加载慢</p></td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">          <p>滑动过程中没有白块或很少</p></td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="33.33333333333333%">          <p>动态预加载</p></td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">          <p>首屏加载快</p></td>         <td class="cellrowborder" valign="top" width="33.33333333333333%">          <p>滑动过程中没有白块或很少</p></td>        </tr>             </tbody></table></div>     </div>     <p><strong>2. CPU开销对比</strong></p>     <p>利用Profiler工具分析得到相关trace图，追踪流程为应用侧的APP_LIST_FLING（列表从开始滚动到结束）的整个过程，从而观察应用的CPU占比。（注：不同设备特性和具体应用场景的多样性，所获得的性能数据存在差异，提供的数值仅供参考）</p>     <div class="fignone">      <span class="figcap"><b>图9 </b>cachedCount=5 CPU占比trace图</span>     </div>     <p><span><img height="288.84807" originheight="840" originwidth="1546" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163432.61406786973648001471871678713344:50001231000000:2800:6DCF9F31736E4FBDD6C710EBB2379C23D453109430A35C82BADAB09D52803004.png" title="点击放大" width="531.6675"></span></p>     <p>cachedCount=5 CPU占比为3.96%</p>     <div class="fignone">      <span class="figcap"><b>图10 </b>cachedCount=40 CPU占比trace图</span>     </div>     <p><span><img height="285.327959" originheight="842" originwidth="1557" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163432.66256120198425946522639309924334:50001231000000:2800:9AB1F1E1048BF9400C62A12110E994DE334CB81746E5753A2BF840883961E4A8.png" title="点击放大" width="527.6775"></span></p>     <p>cachedCount=40 CPU占比为5.04%</p>     <div class="fignone">      <span class="figcap"><b>图11 </b>动态预加载 CPU占比trace图</span>     </div>     <p><span><img height="287.18823000000003" originheight="848" originwidth="1558" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163432.55686150640737205852978513083935:50001231000000:2800:758265307A5D6BE87DD947E87656348DFB2AF09A422341F30371A43AAC481B8A.png" title="点击放大" width="527.6775"></span></p>     <p>动态预加载CPU占比为4.12%</p>     <div class="tablenoborder">      <div class="tbBox"><table class="layoutFixed idpTab">       <thead>        <tr>         <th align="left" class="cellrowborder" id="mcps1.3.28.17.1.3.1.1" valign="top" width="50%">          <p>数据设置</p></th>         <th align="left" class="cellrowborder" id="mcps1.3.28.17.1.3.1.2" valign="top" width="50%">          <p>CPU占比</p></th>        </tr>       </thead>               <tbody><tr>         <td class="cellrowborder" valign="top" width="50%">          <p>cachedCount=5</p></td>         <td class="cellrowborder" valign="top" width="50%">          <p>3.96%</p></td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="50%">          <p>cachedCount=40</p></td>         <td class="cellrowborder" valign="top" width="50%">          <p>5.04%</p></td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="50%">          <p>动态预加载</p></td>         <td class="cellrowborder" valign="top" width="50%">          <p>4.12%</p></td>        </tr>             </tbody></table></div>     </div>     <p><strong>3. 首屏加载时长对比</strong></p>     <p>使用Profiler工具分析相关trace图，追踪流程从“应用进程创建阶段”标签开始，到首屏所有图片加载完毕结束，以观察应用的首屏加载时间。请注意，不同设备和应用场景会导致性能数据有所差异，提供的数值仅作参考。</p>     <div class="fignone">      <span class="figcap"><b>图12 </b>cachedCount=5 首屏加载时长trace图</span>     </div>     <p><span><img height="190.48752100000002" originheight="509" originwidth="1556" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163432.74793201422236843131275005492881:50001231000000:2800:C6CE2F882EFF1F5A460D078A18E2C968DE5F8BFF127EF3B5A4785D94E4510607.png" title="点击放大" width="617.4525"></span></p>     <p>当cachedCount设置为5时，首屏加载时长为530.4ms。</p>     <div class="fignone">      <span class="figcap"><b>图13 </b>cachedCount=40 首屏加载时长trace图</span>     </div>     <p><span><img height="206.867535" originheight="507" originwidth="1553" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163432.30129328939687769413201120687502:50001231000000:2800:1FFAFDC484584CC578A1F26713A3E982930031B7D2E7F5DD561217CE4D2941EF.png" title="点击放大" width="619.4475"></span></p>     <p>当cachedCount设置为40时，首屏加载时长为1.8s。</p>     <div class="fignone">      <span class="figcap"><b>图14 </b>动态预加载 首屏加载时长trace图</span>     </div>     <p><span><img height="198.07557000000003" originheight="510" originwidth="1549" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163432.78384685046304276078540913417028:50001231000000:2800:FE1322A56713143F46E2DFD4E5565E81E87B137BA40889C49E179FB892840AFC.png" title="点击放大" width="627.4275"></span></p>     <p>动态预加载使首屏加载时长为545.5ms。</p>     <div class="tablenoborder">      <div class="tbBox"><table class="layoutFixed idpTab">       <thead>        <tr>         <th align="left" class="cellrowborder" id="mcps1.3.28.29.1.3.1.1" valign="top" width="50%">          <p>数据设置</p></th>         <th align="left" class="cellrowborder" id="mcps1.3.28.29.1.3.1.2" valign="top" width="50%">          <p>首屏加载时长</p></th>        </tr>       </thead>               <tbody><tr>         <td class="cellrowborder" valign="top" width="50%">          <p>cachedCount=5</p></td>         <td class="cellrowborder" valign="top" width="50%">          <p>530.4ms</p></td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="50%">          <p>cachedCount=40</p></td>         <td class="cellrowborder" valign="top" width="50%">          <p>1.8s</p></td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="50%">          <p>动态预加载</p></td>         <td class="cellrowborder" valign="top" width="50%">          <p>545.5ms</p></td>        </tr>             </tbody></table></div>     </div>     <p>从实验数据可以得出：</p>     <p>1）当cachedCount设置为 5 时，首屏加载时间较短，但在滑动过程中会出现较多白块，滑动时CPU占用率较低。</p>     <p>2）当cachedCount设置为 40 时，首屏加载时间为30秒，滑动过程中未出现白块，但滑动时CPU占用较高。</p>     <p>3）当在cachedCount=5的基础上设置动态预加载时，首屏加载时间较短，滑动过程中未出现白块，滑动时CPU占用率较低。</p>     <p><strong>当使用LazyForEach在线加载含有图片等大型资源时，建议采用动态预加载策略，以避免在弱网环境或快速滑动时出现空白块的问题。</strong></p>     <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content">       <p>测试数据仅限于示例程序，不同设备特性和具体应用场景的多样性，所获得的性能数据存在差异，提供的数值仅供参考。</p>      </div></div></div>    </div>    <div class="tiledSection">     <h2 id="section36781044162218">组件复用<i class="anchor-icon anchor-icon-link" anchorid="section36781044162218" tips="复制节点链接"></i></h2>         </div>    <div class="tiledSection">     <h3 id="section105871921192711" class="firsth2">原理介绍<i class="anchor-icon anchor-icon-link" anchorid="section105871921192711" tips="复制节点链接"></i></h3>          <p>HarmonyOS应用框架支持组件复用。当复用组件从组件树中移除时，会进入回收缓存区。创建新组件节点时，系统会优先使用缓存区中的节点，从而减少组件重新创建的时间。特别是在列表场景下，自定义子组件具有相同的布局结构，列表更新时只有状态变量等数据不同。组件复用可以提高列表页面的加载和响应速度。</p>     <p>组件复用机制如下：</p>     <ol>      <li><span>标记为@Reusable的组件从组件树移除时，组件及其对应的JSView对象都会存入复用缓存。</span></li>      <li><span>当列表滑动到新的ListItem将要显示，并且List组件树需要新建节点时，系统将从复用缓存中查找可复用的组件节点。</span></li>      <li><span>找到可复用节点并更新后，将其添加到组件树中，从而减少组件节点和JSView对象的创建时间。</span></li>     </ol>     <div class="fignone">      <span class="figcap"><b>图15 </b>组件复用原理图</span>      <p><span><img height="417.69980000000004" originheight="592" originwidth="1131" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163432.62640391677073334083882212014058:50001231000000:2800:88DF020C025FC13FB008B0B06B4067DE7544716230A9D98E2E7149BC4B21E827.png" title="点击放大" width="798"></span></p>     </div>     <p>组件复用生效的条件如下：</p>     <ul>      <li>自定义组件被@Reusable装饰器修饰，表示其具备组件复用的能力。</li>      <li>在一个自定义父组件下创建的具备组件复用能力的自定义子组件，从组件树上移除后，会被加入到其父组件的可复用节点缓存中。</li>      <li>在一个自定义父组件下创建可复用的子组件时，若其父组件的可复用节点缓存中有对应类型的可复用子组件，会通过更新可复用子组件的方式，快速创建子组件。</li>      <li>ForEach循环渲染会一次性加载所有数据，因此不支持组件复用。</li>     </ul>     <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content">       <p>名词介绍：</p>       <ol>        <li>@Reusable 表示组件可以复用，与 LazyForEach 懒加载结合使用，可解决列表滑动场景的瓶颈问题，提升滑动帧率。</li>        <li>CustomNode是一种自定义的虚拟节点，用于缓存列表中的某些内容，以提高性能和减少不必要的渲染。使用CustomNode可以实现仅渲染当前可见区域内的数据项，缓存未显示的数据项，从而减少渲染数量，提升性能。</li>        <li>RecycleManager是一种用于优化资源利用的回收管理器。当数据项滚出屏幕时，对应的视图对象不会立即销毁，而是放入复用池中。当新的数据项需要在屏幕上展示时，RecycleManager会从复用池中取出一个已存在的视图对象，并将新数据绑定到该视图上，从而避免频繁的创建和销毁过程。使用RecycleManager可以减少创建和销毁视图的次数，提高列表的滚动流畅度和性能。</li>        <li>CachedRecycleNodes是CustomNode的集合，用于存储被回收的CustomNode对象，以便复用。</li>       </ol>      </div></div></div>    </div>    <div class="tiledSection">     <h3 id="section12844195172813">使用场景和规则<i class="anchor-icon anchor-icon-link" anchorid="section12844195172813" tips="复制节点链接"></i></h3>          <p><strong>使用场景</strong></p>    </div>    <p>若业务实现中存在UI线程的帧率瓶颈，推荐使用组件复用：</p>    <ul>     <li>列表滚动（本例中的场景）：应用展示大量数据列表时，用户滚动操作可能导致频繁创建和销毁列表项视图，引起卡顿和性能问题。使用列表组件的复用机制可以重用已创建的列表项视图，提高滚动流畅度。</li>     <li>动态布局更新：如果应用界面需要根据用户操作或数据变化频繁更新布局，重复创建和销毁视图可能导致频繁的布局计算，影响帧率。使用组件复用可以避免不必要的视图创建和布局计算，提高性能。</li>     <li>地图渲染：在地图渲染中，频繁创建和销毁数据项的视图可能导致性能问题。使用组件复用可以重用已创建的视图，仅更新数据内容，减少视图的创建和销毁，从而提高性能。</li>    </ul>    <p>为了避免UI线程的帧率瓶颈，推荐使用组件复用来提升应用性能和用户体验。组件复用能够减少不必要的视图创建与销毁，降低布局计算和绘制操作，从而提高界面流畅度和响应速度。</p>    <p><strong>使用规则</strong></p>    <p>组件复用的使用规则如下：</p>    <ul>     <li>使用 @Reusable 标识：@Reusable 标识自定义组件具备可复用的能力。它可以被添加到任意的自定义组件上。开发者需要小心处理自定义组件的创建和更新流程，以确保自定义组件在复用后能展示出正确的行为。</li>     <li>缓存和复用范围：可复用自定义组件的缓存和复用只能发生在同一父组件下。无法在不同的父组件下复用同一自定义节点的实例。例如，A 组件是可复用组件，其也是 B 组件的子组件，并进入了 B 组件的可复用节点缓存中，但是在 C 组件中创建 A 组件时，无法使用 B 组件缓存的 A 组件。</li>     <li>组件结构保持不变：自定义组件复用带来的性能提升主要体现在减少JS对象的创建时间和复用组件树结构。如果开发者在复用前后使用渲染控制语法大幅改变了自定义组件的组件树结构，将无法获得组件复用的性能优势。</li>     <li>组件复用仅在特定场景下触发：当存在可复用的组件从组件树中移除并再次加入时，组件复用才会发生。如果不存在上述场景，则无法触发组件复用。例如，使用ForEach渲染控制语法创建的自定义组件，由于ForEach的全展开属性，不会触发组件复用。</li>    </ul>    <p>组件复用能节省创建时间，优化应用性能。需处理自定义组件的创建与更新流程，限制复用范围及特定触发场景，以实现复用效果。</p>    <div class="tiledSection">     <h3 id="section19482174122811">场景案例<i class="anchor-icon anchor-icon-link" anchorid="section19482174122811" tips="复制节点链接"></i></h3>          <p>下面的代码片段是在缓存列表项的基础上增加的组件复用的相关代码。组件复用需要首先在复用的组件上添加@Reusable注解，然后实现aboutToReuse方法。关键代码如下：</p>     <div class="screenLinkPre"><div _ngcontent-cql-c106="" class="highlight-div"><div _ngcontent-cql-c106="" class="highlight-div-header"><div _ngcontent-cql-c106="" class="highlight-div-header-left"><div _ngcontent-cql-c106="" class="handle-button expand-button"><div _ngcontent-cql-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-cql-c106="" class="highlight-div-header-right"><div _ngcontent-cql-c106="" class="handle-button ai-button"></div><div _ngcontent-cql-c106="" class="handle-button line-button"><div _ngcontent-cql-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-cql-c106="" class="handle-button theme-button"><div _ngcontent-cql-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-cql-c106="" class="handle-button copy-button"><div _ngcontent-cql-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-cql-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-typescript" codehub="https://gitee.com/harmonyos_samples/list-optimization/blob/master/entry/src/main/ets/components/ReusableArticleCardView.ets#L18-L98" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-meta">@Component</span></li><li><span class="hljs-meta">@Reusable</span></li><li><span class="hljs-keyword">export</span> struct <span class="hljs-title class_">ReusableArticleCardView</span> {</li><li>  <span class="hljs-meta">@Prop</span> <span class="hljs-attr">articleItem</span>: <span class="hljs-title class_">LearningResource</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LearningResource</span>();</li><li>  <span class="hljs-meta">@Prop</span> <span class="hljs-attr">isCollected</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>;</li><li>  <span class="hljs-meta">@Prop</span> <span class="hljs-attr">isLiked</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>;</li><li>  onCollected?: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>;</li><li>  onLiked?: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>;</li><li>
</li><li>  <span class="hljs-title function_">aboutToReuse</span>(<span class="hljs-attr">params</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Object</span>&gt;): <span class="hljs-built_in">void</span> {</li><li>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onCollected</span> = params.<span class="hljs-property">onCollected</span> <span class="hljs-keyword">as</span> () =&gt; <span class="hljs-built_in">void</span>;</li><li>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onLiked</span> = params.<span class="hljs-property">onLiked</span> <span class="hljs-keyword">as</span> () =&gt; <span class="hljs-built_in">void</span>;</li><li>  }</li><li>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) {</li><li>    <span class="hljs-comment">// ...</span></li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/list-optimization/blob/master/entry/src/main/ets/components/ReusableArticleCardView.ets#L18-L98" target="_blank">ReusableArticleCardView.ets</a></div></div></div></div>     <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content">       <p>无需对@Prop修饰的变量进行赋值，因为这些变量是由父组件传递给子组件的。如果在子组件中重新赋值这些变量，会导致重用的组件的内容重新触发状态刷新，从而降低组件的复用性能。相反，只需要在aboutToReuse方法中对onCollected和onLiked这两个函数进行重新赋值。</p>      </div></div></div>     <p>设置可复用组件的reuseId，关键代码如下：</p>     <div class="screenLinkPre"><div _ngcontent-cql-c106="" class="highlight-div"><div _ngcontent-cql-c106="" class="highlight-div-header"><div _ngcontent-cql-c106="" class="highlight-div-header-left"><div _ngcontent-cql-c106="" class="handle-button expand-button"><div _ngcontent-cql-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-cql-c106="" class="highlight-div-header-right"><div _ngcontent-cql-c106="" class="handle-button ai-button"></div><div _ngcontent-cql-c106="" class="handle-button line-button"><div _ngcontent-cql-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-cql-c106="" class="handle-button theme-button"><div _ngcontent-cql-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-cql-c106="" class="handle-button copy-button"><div _ngcontent-cql-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-cql-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-cangjie" codehub="https://gitee.com/harmonyos_samples/list-optimization/blob/master/entry/src/main/ets/pages/LazyForEachListPage.ets#L38-L116" data-highlighted="yes"><ol class="linenums"><li>@<span class="hljs-title function_">Entry</span></li><li>@<span class="hljs-title function_">Component</span></li><li><span class="hljs-variable">export</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LazyForEachListPage</span> {</li><li>  <span class="hljs-variable">UIContext</span> = <span class="hljs-keyword">this</span>.<span class="hljs-title function_">getUIContext</span>()</li><li>  <span class="hljs-variable">context</span> = <span class="hljs-keyword">this</span>.<span class="hljs-variable">UIContext</span>.<span class="hljs-title function_">getHostContext</span>() <span class="hljs-keyword">as</span> <span class="hljs-variable">common</span>.<span class="hljs-variable">UIAbilityContext</span>;</li><li>
</li><li>  <span class="hljs-comment">// ...</span></li><li>
</li><li>  <span class="hljs-title function_">build</span>() {</li><li>    <span class="hljs-title function_">Column</span>() {</li><li>      <span class="hljs-title function_">Header</span>()</li><li>      <span class="hljs-title function_">List</span>({ <span class="hljs-variable">space</span>: <span class="hljs-title class_">Constants</span>.<span class="hljs-title class_">SPACE_16</span> }) {</li><li>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.<span class="hljs-variable">data</span> !== <span class="hljs-variable">null</span>) {</li><li>          <span class="hljs-comment">// Optimization method 1: Use LazyForEach.</span></li><li>          <span class="hljs-title function_">LazyForEach</span>(<span class="hljs-keyword">this</span>.<span class="hljs-variable">data</span>, (<span class="hljs-variable">item</span>: <span class="hljs-title class_">LearningResource</span>) =&gt; {</li><li>            <span class="hljs-title function_">ListItem</span>() {</li><li>              <span class="hljs-title function_">Column</span>({ <span class="hljs-variable">space</span>: <span class="hljs-title class_">Constants</span>.<span class="hljs-title class_">SPACE_12</span> }) {</li><li>                <span class="hljs-comment">// Optimization method 3：Reuse Component</span></li><li>                <span class="hljs-title function_">ReusableArticleCardView</span>({</li><li>                  <span class="hljs-variable">articleItem</span>: <span class="hljs-title class_">item</span>,</li><li>                  <span class="hljs-variable">isLiked</span>: <span class="hljs-keyword">this</span>.<span class="hljs-title class_">isLiked</span>(<span class="hljs-title class_">item</span>.<span class="hljs-title class_">id</span>),</li><li>                  <span class="hljs-variable">isCollected</span>: <span class="hljs-keyword">this</span>.<span class="hljs-title class_">isCollected</span>(<span class="hljs-title class_">item</span>.<span class="hljs-title class_">id</span>)</li><li>                })</li><li>              }</li><li>            }</li><li>            .<span class="hljs-title function_">reuseId</span>(<span class="hljs-string">'article'</span>)</li><li>          }, (<span class="hljs-variable">item</span>: <span class="hljs-title class_">LearningResource</span>) =&gt; <span class="hljs-variable">item</span>.<span class="hljs-variable">id</span>)</li><li>        }</li><li>      }</li><li>      .<span class="hljs-title function_">width</span>(<span class="hljs-variable">Constants</span>.<span class="hljs-variable">FULL_SCREEN</span>)</li><li>      .<span class="hljs-title function_">height</span>(<span class="hljs-variable">Constants</span>.<span class="hljs-variable">FULL_SCREEN</span>)</li><li>      .<span class="hljs-title function_">padding</span>({ <span class="hljs-variable">left</span>: <span class="hljs-number">10</span>, <span class="hljs-variable">right</span>: <span class="hljs-number">10</span> })</li><li>      .<span class="hljs-title function_">layoutWeight</span>(<span class="hljs-number">1</span>)</li><li>      <span class="hljs-comment">// Optimization method 2：Use cachedCount</span></li><li>      .<span class="hljs-title function_">cachedCount</span>(<span class="hljs-number">3</span>);</li><li>    }</li><li>    .<span class="hljs-title function_">backgroundColor</span>($<span class="hljs-title function_">r</span>(<span class="hljs-string">'app.color.text_background'</span>))</li><li>  }</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/list-optimization/blob/master/entry/src/main/ets/pages/LazyForEachListPage.ets#L38-L116" target="_blank">LazyForEachListPage.ets</a></div></div></div></div>    </div>    <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content">      <p>需要注意的是复用组件中有@Builder自定义构建函数时，状态变量推荐使用<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-builder#按引用传递参数" target="_blank">按引用传递</a>。@Builder装饰的函数默认按值传递，当传递的参数为状态变量时，状态变量的改变不会引起@Builder方法内的UI刷新。</p>     </div></div></div>    <div class="tiledSection">     <h3 id="section1069111015296">性能分析<i class="anchor-icon anchor-icon-link" anchorid="section1069111015296" tips="复制节点链接"></i></h3>          <p><strong>组件未复用时</strong></p>    </div>    <p>上文已经将ForEach改造为了LazyForEach，并且添加了缓存项（cachedCount=3），当匀速滑动这个列表时，每隔5帧会稳定的丢帧，且会规律、重复的出现这个问题，如下图所示：</p>    <div class="fignone">     <span class="figcap"><b>图16 </b>未进行组件复用（均匀丢帧）</span>     <p><span><img height="109.7516" originheight="204" originwidth="1854" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163432.62743910740755592627369458277807:50001231000000:2800:86DA34EF015C37DD7F94A9DEF73D5401AC757C7BC2C77F528E5968BF124ABA4D.png" title="点击放大" width="798"></span></p>    </div>    <p>从图中可以看见，泳道中红色和绿色间隔出现，其中红色区域表示丢帧，绿色表示正常，对红色丢帧区域进行耗时分析：</p>    <div class="fignone">     <span class="figcap"><b>图17 </b>丢帧耗时分析</span>     <br><span><img height="374.6743" originheight="829" originwidth="2188" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163432.31628903904084471662128797979164:50001231000000:2800:0558FB56DC54CC4AC212E4B8505BA675DFE0F675E678EB8462299A75A365A0B1.png" title="点击放大" width="798"></span>    </div>    <div class="fignone">     <span class="figcap"><b>图18 </b>对丢帧部分的放大分析（整体耗时13.430ms）</span>     <p><span><img height="381.4174" originheight="837" originwidth="2189" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163433.08476114338362120617123135227625:50001231000000:2800:AE4CC780909A65EF6AA36F645C793634E003BE07A276E9FF0DB340A8893BEA2A.png" title="点击放大" width="798"></span></p>    </div>    <p>图中红色区域出现丢帧，缓存区中的最上面一个ListItem渲染时，BuildLazyItem操作耗时10.277ms，导致本帧总体耗时13.430ms，超过11.1ms而丢帧。</p>    <p><strong>组件复用后</strong></p>    <p>将代码进行改造，对复用组件ArticleCardView添加@Reusable注解，启用组件复用的相关代码后，以相同均匀速度滑动这个列表，得到的应用帧率检测情况如下：</p>    <div class="fignone">     <span class="figcap"><b>图19 </b>组件复用后（无丢帧）</span>     <p><span><img height="178.3131" originheight="340" originwidth="1902" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163433.09054110433329555130776291641090:50001231000000:2800:87A0BB8B23D4F25ADFB3E22031BAFA9B7080ABC10D62673ADE9D19E7ABD59542.png" title="点击放大" width="798"></span></p>    </div>    <p>上图显示列表快速滑动15.8秒，泳道全绿表示无丢帧，丢帧率为0%。放大分析某帧，如下图所示：</p>    <div class="fignone">     <span class="figcap"><b>图20 </b>组件复用后某帧耗时分析</span>     <p><span><img height="208.46420000000003" originheight="353" originwidth="1689" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163433.64148301335316343185928864824468:50001231000000:2800:D66A15663B6572A4153D1ED7D15F4C4E802BB4CF6DE45B4F74932F266504B966.png" title="点击放大" width="798"></span></p>    </div>    <p>BuildLazyItem的耗时为0.749ms，远低于未进行复用时的10.277ms。复用前后的耗时数据如下表所示：</p>    <div class="tablenoborder">     <div class="tbBox"><table class="layoutFixed idpTab">      <caption>       <b>表4 </b>组件复用前后丢帧率和耗时分析      </caption>      <thead>       <tr>        <th align="left" class="cellrowborder" id="mcps1.3.54.2.4.1.1" valign="top" width="33.33333333333333%">         <p>组件复用</p></th>        <th align="left" class="cellrowborder" id="mcps1.3.54.2.4.1.2" valign="top" width="33.33333333333333%">         <p>组件复用前</p></th>        <th align="left" class="cellrowborder" id="mcps1.3.54.2.4.1.3" valign="top" width="33.33333333333333%">         <p>组件复用后</p></th>       </tr>      </thead>             <tbody><tr>        <td class="cellrowborder" valign="top" width="33.33333333333333%">         <p>丢帧率</p></td>        <td class="cellrowborder" valign="top" width="33.33333333333333%">         <p>3.7%</p></td>        <td class="cellrowborder" valign="top" width="33.33333333333333%">         <p>0%</p></td>       </tr>       <tr>        <td class="cellrowborder" valign="top" width="33.33333333333333%">         <p>BuildLazyItem耗时</p></td>        <td class="cellrowborder" valign="top" width="33.33333333333333%">         <p>10.277ms</p></td>        <td class="cellrowborder" valign="top" width="33.33333333333333%">         <p>0.749ms</p></td>       </tr>       <tr>        <td class="cellrowborder" valign="top" width="33.33333333333333%">         <p>BuildRecycle耗时</p></td>        <td class="cellrowborder" valign="top" width="33.33333333333333%">         <p>不涉及</p></td>        <td class="cellrowborder" valign="top" width="33.33333333333333%">         <p>0.221ms</p></td>       </tr>       <tr>        <td class="cellrowborder" valign="top" width="33.33333333333333%">         <p>总耗时</p></td>        <td class="cellrowborder" valign="top" width="33.33333333333333%">         <p>13.430ms</p></td>        <td class="cellrowborder" valign="top" width="33.33333333333333%">         <p>7.310ms</p></td>       </tr>           </tbody></table></div>    </div>    <p>从图19可以看出，列表滑动时（15.8秒的区间段内）都是绿色，丢帧率为0%，没有出现图16中“规律且重复”的红色丢帧情况。这是因为List列表开启了组件复用功能，不会执行BuildLazyItem这个耗时操作（耗时10.277毫秒）。后续创建新组件节点时，会直接复用缓存区中的节点（耗时0.97毫秒），从而大幅减少了组件重新创建的时间。</p>    <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content">      <p>以上数据来源为版本DevEco Studio 4.0.3.415、SDK 4.0.10.9条件下测试得到，不同设备类型的数据会有所不同，测试数据用于体现性能优化趋势，仅供参考。</p>     </div></div></div>    <div class="tiledSection">     <h2 id="section155051250172217">布局优化<i class="anchor-icon anchor-icon-link" anchorid="section155051250172217" tips="复制节点链接"></i></h2>         </div>    <div class="tiledSection">     <h3 id="section8836561248" class="firsth2">原理介绍<i class="anchor-icon anchor-icon-link" anchorid="section8836561248" tips="复制节点链接"></i></h3>          <p>列表布局包含大量重复的ListItem，因此优化每个ListItem的布局尤为重要。错误的布局方式会导致组件树和嵌套层数过多，增加创建和布局绘制的性能开销，引起界面卡顿。合理减少嵌套层数，可以提高布局效率。</p>     <p>针对“HMOS世界”中的首屏长列表，可以将ListItem的线性布局修改为相对布局，从而将最大嵌套层级从5层减少到2层。在列表循环渲染时，特别是在数据量较大时，这种改动可以显著提升页面性能。虽然这个例子较为简单，优化空间有限，但当列表元素较为复杂时，减少布局嵌套层级和避免过度绘制可以带来显著的性能提升。</p>     <div class="fignone">      <span class="figcap"><b>图21 </b>布局优化前后的层级变化</span>      <br><span><img height="158.80200000000002" originheight="597" originwidth="3000" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163433.12126286979291692987046018423298:50001231000000:2800:BADB90F0DC0EFAB1A7BF30D6B9A5C718D92B73CBFC63A336246A6C4B1C2EDB91.png" title="点击放大" width="798"></span>     </div>    </div>    <div class="tiledSection">     <h3 id="section10676113419255">场景案例<i class="anchor-icon anchor-icon-link" anchorid="section10676113419255" tips="复制节点链接"></i></h3>          <p>为了对比布局嵌套层级对List列表滑动性能的影响，改造了相关代码。原始代码使用线性布局，最大嵌套层级为5层；通过相对布局优化代码，最大嵌套层级减少到2层；同时，刻意将布局过度嵌套，最大嵌套层级达到25层。示例代码如下所示：</p>     <ul>      <li>对比案例1：线性布局，最大嵌套层级为5层       <div _ngcontent-cql-c106="" class="highlight-div"><div _ngcontent-cql-c106="" class="highlight-div-header"><div _ngcontent-cql-c106="" class="highlight-div-header-left"><div _ngcontent-cql-c106="" class="handle-button expand-button"><div _ngcontent-cql-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-cql-c106="" class="highlight-div-header-right"><div _ngcontent-cql-c106="" class="handle-button ai-button"></div><div _ngcontent-cql-c106="" class="handle-button line-button"><div _ngcontent-cql-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-cql-c106="" class="handle-button theme-button"><div _ngcontent-cql-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-cql-c106="" class="handle-button copy-button"><div _ngcontent-cql-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-cql-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-scss" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">@Component</span></li><li>export struct ArticleCardView {</li><li>  <span class="hljs-built_in">build</span>() {</li><li>    <span class="hljs-built_in">Row</span>() {                  <span class="hljs-comment">// Linear layout, layer 1</span></li><li>      <span class="hljs-built_in">Column</span>() {             <span class="hljs-comment">// Linear layout, layer 2</span></li><li>        <span class="hljs-built_in">Column</span>() {</li><li>          Text()</li><li>          Text()</li><li>        }</li><li>        <span class="hljs-built_in">Row</span>() {              <span class="hljs-comment">// Linear layout, layer 3</span></li><li>          <span class="hljs-built_in">Row</span>(){             <span class="hljs-comment">// Linear layout, layer 4</span></li><li>            <span class="hljs-built_in">Image</span>('')          <span class="hljs-comment">// Linear layout, layer 5</span></li><li>            Text()</li><li>          }</li><li>          <span class="hljs-built_in">Row</span>(){</li><li>            <span class="hljs-built_in">Image</span>('')</li><li>            Text()</li><li>          }</li><li>          <span class="hljs-built_in">Row</span>(){</li><li>            <span class="hljs-built_in">Image</span>('')</li><li>            Text()</li><li>          }</li><li>        }</li><li>      }</li><li>      <span class="hljs-built_in">Image</span>('')</li><li>    }</li><li>  }</li><li>}</li></ol></pre></div></div></li>      <li>对比案例2：相对布局，最大嵌套层级为2层       <div _ngcontent-cql-c106="" class="highlight-div"><div _ngcontent-cql-c106="" class="highlight-div-header"><div _ngcontent-cql-c106="" class="highlight-div-header-left"><div _ngcontent-cql-c106="" class="handle-button expand-button"><div _ngcontent-cql-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-cql-c106="" class="highlight-div-header-right"><div _ngcontent-cql-c106="" class="handle-button ai-button"></div><div _ngcontent-cql-c106="" class="handle-button line-button"><div _ngcontent-cql-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-cql-c106="" class="handle-button theme-button"><div _ngcontent-cql-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-cql-c106="" class="handle-button copy-button"><div _ngcontent-cql-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-cql-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-scss" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">@Component</span></li><li>struct ArticleCardView {</li><li>  <span class="hljs-built_in">build</span>() {</li><li>    <span class="hljs-built_in">RelativeContainer</span>() {     <span class="hljs-comment">// Relative layout, level 1</span></li><li>      Text()<span class="hljs-comment">// ...</span></li><li>      Text()<span class="hljs-comment">// ...</span></li><li>      <span class="hljs-built_in">Image</span>('')<span class="hljs-comment">// ...</span></li><li>      Text()<span class="hljs-comment">// ...               // Relative layout, level 2</span></li><li>      <span class="hljs-built_in">Image</span>('')<span class="hljs-comment">// ...</span></li><li>      Text()<span class="hljs-comment">// ...</span></li><li>      <span class="hljs-built_in">Image</span>('')<span class="hljs-comment">// ...</span></li><li>      Text()<span class="hljs-comment">// ...</span></li><li>      <span class="hljs-built_in">Image</span>('')<span class="hljs-comment">// ...</span></li><li>    }</li><li>  }</li><li>}</li></ol></pre></div></div></li>      <li>对比案例3：刻意嵌套20层，最大嵌套层级为25层       <div _ngcontent-cql-c106="" class="highlight-div"><div _ngcontent-cql-c106="" class="highlight-div-header"><div _ngcontent-cql-c106="" class="highlight-div-header-left"><div _ngcontent-cql-c106="" class="handle-button expand-button"><div _ngcontent-cql-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-cql-c106="" class="highlight-div-header-right"><div _ngcontent-cql-c106="" class="handle-button ai-button"></div><div _ngcontent-cql-c106="" class="handle-button line-button"><div _ngcontent-cql-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-cql-c106="" class="handle-button theme-button"><div _ngcontent-cql-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-cql-c106="" class="handle-button copy-button"><div _ngcontent-cql-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-cql-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-scss" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">@Component</span></li><li>struct ArticleCardView {</li><li>  <span class="hljs-built_in">build</span>() {</li><li>    <span class="hljs-built_in">Column</span>() {</li><li>      <span class="hljs-built_in">Column</span>() {</li><li>        <span class="hljs-built_in">Column</span>() {</li><li>          <span class="hljs-comment">// ...                  // Deliberate nesting with a maximum nesting level of 25 layers</span></li><li>        }<span class="hljs-selector-class">.width</span>('<span class="hljs-number">100%</span>')</li><li>      }<span class="hljs-selector-class">.width</span>('<span class="hljs-number">100%</span>')</li><li>    }<span class="hljs-selector-class">.width</span>('<span class="hljs-number">100%</span>')</li><li>  }</li><li>}</li></ol></pre></div></div></li>     </ul>    </div>    <div class="tiledSection">     <h3 id="section5999101192615">性能分析<i class="anchor-icon anchor-icon-link" anchorid="section5999101192615" tips="复制节点链接"></i></h3>          <p>本文案例分析了正常情况和过度嵌套情况下应用独占内存、页面滑动帧率、丢帧率的对比。使用DevEco Studio中的ArkUI Inspector查看页面嵌套层级，如下所示：</p>     <div class="fignone">      <span class="figcap"><b>图22 </b>额外嵌套后的布局层级</span>      <br><span><img height="396.0075" originheight="905" originwidth="1196" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163433.23334273613529506985621725445107:50001231000000:2800:AC24272A1CB18684EBC9DB63AF126D400A0E4E76FCFCE4F4456D96D16B7FABBA.png" title="点击放大" width="523.6875"></span>     </div>     <p>快速滑动10000条数据后，得到布局嵌套层级对列表性能的影响对比，如下所示：</p>     <div class="tablenoborder">      <div class="tbBox"><table class="layoutFixed idpTab">       <caption>        <b>表5 </b>布局嵌套对应用性能的影响分析       </caption>       <thead>        <tr>         <th align="left" class="cellrowborder" id="mcps1.3.60.5.2.5.1.1" valign="top" width="25%">          <p>布局</p></th>         <th align="left" class="cellrowborder" id="mcps1.3.60.5.2.5.1.2" valign="top" width="25%">          <p>相对布局（2层）</p></th>         <th align="left" class="cellrowborder" id="mcps1.3.60.5.2.5.1.3" valign="top" width="24.740000000000002%">          <p>线性布局（5层）</p></th>         <th align="left" class="cellrowborder" id="mcps1.3.60.5.2.5.1.4" valign="top" width="25.259999999999998%">          <p>额外嵌套的线性布局（25层）</p></th>        </tr>       </thead>               <tbody><tr>         <td class="cellrowborder" valign="top" width="25%">          <p>独占内存</p></td>         <td class="cellrowborder" valign="top" width="25%">          <p>78.4MB</p></td>         <td class="cellrowborder" valign="top" width="24.740000000000002%">          <p>80.1MB</p></td>         <td class="cellrowborder" valign="top" width="25.259999999999998%">          <p>153.7MB</p></td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="25%">          <p>丢帧率</p></td>         <td class="cellrowborder" valign="top" width="25%">          <p>0%</p></td>         <td class="cellrowborder" valign="top" width="24.740000000000002%">          <p>0%</p></td>         <td class="cellrowborder" valign="top" width="25.259999999999998%">          <p>2.3%</p></td>        </tr>             </tbody></table></div>     </div>     <p>布局过度嵌套会导致应用内存增加，并影响应用的帧率，增加丢帧。因此，开发者在编写列表等循环组件的代码时，需要优化布局。通常，布局的最大嵌套层级应控制在5到8层。过度优化布局会增加代码开发难度，降低代码可读性，增加维护成本，不利于多设备适配，且性能提升不明显。</p>    </div>    <div class="tiledSection">     <h2 id="section1468625418223">总结与回顾<i class="anchor-icon anchor-icon-link" anchorid="section1468625418223" tips="复制节点链接"></i></h2>          <p>针对长列表这一场景，在本地模拟了10、100、1000、10000条数据，分别使用ForEach和LazyForEach，测试关闭和开启懒加载的完全显示所用时间、丢帧率、应用独占内存等各项指标。测试结果表明，使用LazyForEach懒加载技术后，与ForEach这种加载方式相比，在列表数据量较小（100条内）且数据一次性全量加载不是性能瓶颈时，两者各项性能指标差异不大。但当列表数据量较长，特别是达到10000条数据时，ForEach的上述4项性能指标显著劣化，滑动会出现明显的卡顿，甚至会出现应用崩溃等现象；而LazyForEach因为采用了懒加载技术，能明显减少首屏完全显示所用时间，降低应用的独占内存，提高页面滑动帧率，带来更好的性能。在10000条数据量下，其各项对比指标数据如下所示：</p>     <div class="tablenoborder">      <div class="tbBox"><table class="layoutFixed idpTab">       <caption>        <b>表6 </b>10000条数据量性能优化对比（因动态预加载使用的是网络数据，所以不参与该表格的比较）       </caption>       <thead>        <tr>         <th align="left" class="cellrowborder" id="mcps1.3.61.3.2.7.1.1" valign="top" width="16.666666666666664%">          <p>性能指标</p></th>         <th align="left" class="cellrowborder" id="mcps1.3.61.3.2.7.1.2" valign="top" width="16.666666666666664%">          <p>ForEach</p></th>         <th align="left" class="cellrowborder" id="mcps1.3.61.3.2.7.1.3" valign="top" width="16.666666666666664%">          <p>LazyForEach</p></th>         <th align="left" class="cellrowborder" id="mcps1.3.61.3.2.7.1.4" valign="top" width="16.666666666666664%">          <p>缓存列表项</p></th>         <th align="left" class="cellrowborder" id="mcps1.3.61.3.2.7.1.5" valign="top" width="16.666666666666664%">          <p>组件复用后</p></th>         <th align="left" class="cellrowborder" id="mcps1.3.61.3.2.7.1.6" valign="top" width="16.666666666666664%">          <p>布局优化后</p></th>        </tr>       </thead>               <tbody><tr>         <td class="cellrowborder" valign="top" width="16.666666666666664%">          <p>完全显示所用时间</p></td>         <td class="cellrowborder" valign="top" width="16.666666666666664%">          <p>5s841ms</p></td>         <td class="cellrowborder" valign="top" width="16.666666666666664%">          <p>1s707ms</p></td>         <td class="cellrowborder" valign="top" width="16.666666666666664%">          <p>1s658ms</p></td>         <td class="cellrowborder" valign="top" width="16.666666666666664%">          <p>1s564ms</p></td>         <td class="cellrowborder" valign="top" width="16.666666666666664%">          <p>1s339ms</p></td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="16.666666666666664%">          <p>丢帧率</p></td>         <td class="cellrowborder" valign="top" width="16.666666666666664%">          <p>58.2%</p></td>         <td class="cellrowborder" valign="top" width="16.666666666666664%">          <p>6.6%</p></td>         <td class="cellrowborder" valign="top" width="16.666666666666664%">          <p>3.7%</p></td>         <td class="cellrowborder" valign="top" width="16.666666666666664%">          <p>0.0%</p></td>         <td class="cellrowborder" valign="top" width="16.666666666666664%">          <p>0.0%</p></td>        </tr>        <tr>         <td class="cellrowborder" valign="top" width="16.666666666666664%">          <p>独占内存</p></td>         <td class="cellrowborder" valign="top" width="16.666666666666664%">          <p>560.1MB</p></td>         <td class="cellrowborder" valign="top" width="16.666666666666664%">          <p>82.9MB</p></td>         <td class="cellrowborder" valign="top" width="16.666666666666664%">          <p>81.7MB</p></td>         <td class="cellrowborder" valign="top" width="16.666666666666664%">          <p>80.1MB</p></td>         <td class="cellrowborder" valign="top" width="16.666666666666664%">          <p>78.4MB</p></td>        </tr>             </tbody></table></div>     </div>     <p>测试结果表明，使用 LazyForEach 时，合理添加缓存列表项，可以提升列表滑动帧率 2.9%，减少“滑动白块”的出现。使用组件复用技术后，由于省去了组件频繁创建的耗时操作，可以显著减少“有规律且重复”的丢帧现象，提高列表页面的加载速度和响应速度，丢帧率降低 3.7%。测试还证明，对页面进行布局优化在大数据量下可以显著提升页面性能。</p>     <p>需要指出的是，ForEach、LazyForEach、缓存列表项、组件复用和布局优化是在本地模拟10000条数据，通过控制变量的方法对ForEach和LazyForEach进行压力测试得出的数据结论。动态预加载则是在弱网和快速滑动状态下加载数据测试得出的结论。当使用网络数据探讨LazyForEach如何进行网络数据加载和优化时，可以采用动态预加载技术。动态预加载通过将预取和预渲染分离，并在滑动过程中实时更新列表项、预取数据和预渲染数据，从而在弱网和快速滑动场景中显著减少滑动过程中出现的白块现象。</p>     <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content">       <p>以上数据来源为DevEco Studio 4.0.3.415、SDK 4.0.10.9测试得到。不同设备类型数据可能有差异，测试数据仅体现性能优化趋势，仅供参考。</p>      </div></div></div>    </div>    <div class="tiledSection">     <h2 id="section893964713405">示例代码<i class="anchor-icon anchor-icon-link" anchorid="section893964713405" tips="复制节点链接"></i></h2>          <ul>      <li><a href="https://gitee.com/harmonyos_samples/list-optimization" target="_blank">长列表性能对比</a></li>     </ul>    </div>   </div>   <div></div></div>