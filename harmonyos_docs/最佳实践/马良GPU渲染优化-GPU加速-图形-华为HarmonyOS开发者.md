<h1 _ngcontent-rcd-c119="" class="doc-title ng-star-inserted" title="马良GPU渲染优化"> 马良GPU渲染优化 </h1>

<div _ngcontent-rcd-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;"> <div><div class="tiledSection"><h2 id="section198425281116">概述<i class="anchor-icon anchor-icon-link" anchorid="section198425281116" tips="复制节点链接"></i></h2><p>本文档主要指导开发者如何在马良（Maleoon）GPU上达到最佳的性能表现，只针对Maleoon GPU的优化实践，帮助开发者高效完成渲染任务，如果想要达成该目标，首先需要通过<a href="https://developer.huawei.com/consumer/cn/doc/Tools-Guides/overview-0000001050741459" target="_blank">Graphics Profiler</a>等GPU分析工具，找到当前的能效瓶颈点，并遵循以下两个基本优化原则进行性能调优。本文所有优化建议，都将围绕这两个基本优化原则展开。</p> <ol><li>结合Maleoon GPU的软硬件架构，让驱动和硬件各模块并发执行，使芯片能力充分释放出来。</li><li>利用硬件能力高效执行任务，从而降低芯片负载。</li></ol> <p>图形渲染的基本流程如下图所示。</p> <p><span><img height="364.08750000000003" originheight="5200" originwidth="7475" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163049.31187235347025536125130405578710:50001231000000:2800:99598A6B7328029DA9D18F182DA0CBA9E5E541642A0A83A8147450CACDF00156.jpg" title="点击放大" width="523.6875"></span></p> <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"><p>本文档主要适用于以下开发者：</p> <p>熟悉图形标准API（<a href="https://registry.khronos.org/vulkan/#apispecs" target="_blank">Vulkan</a>或<a href="https://www.khronos.org/opengles/" target="_blank">OpenGL ES</a>）、了解shader编码，有一定GPU性能优化基础。</p> </div></div></div> </div> <div class="tiledSection"><h2 id="section490303414120">CPU优化<i class="anchor-icon anchor-icon-link" anchorid="section490303414120" tips="复制节点链接"></i></h2></div> <div class="tiledSection"><h3 id="section16472125816127" class="firsth2">Memory<i class="anchor-icon anchor-icon-link" anchorid="section16472125816127" tips="复制节点链接"></i></h3><div class="p"><strong>1. Device Memory分配与释放</strong><div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"><p>仅适用于<a href="https://registry.khronos.org/vulkan/#apispecs" target="_blank">Vulkan</a>。</p> </div></div></div> </div> <p>vkAllocateMemory为了避免分配的内存没有真正被渲染线程使用，造成内存浪费，采用了延迟分配（protected memory除外）的处理。在调用vkBindImageMemory || vkBindBufferMemory || vkMapMemory（如果内存支持VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT属性）时会真正分配内存，但是需要在此之前调用vkAllocateMemory分配device memory对象。</p> <p><strong>【推荐】</strong></p> <p>根据资源需求，选择最为匹配的内存类型进行内存分配，相同类型的memory按照用户实际需求一次分配大块size用于不同类型的资源（比如index buffer、vertex buffer及uniform buffer），可以提升内存申请的效率。</p> <p><span><img height="197.5981" originheight="1356" originwidth="2731" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163050.15158662784630282422469458286208:50001231000000:2800:13CFCFC39FA07E4E2D0C3A3EC35BABC04DEFA9436A80A47702DBC1F2C551354D.jpg" title="点击放大" width="399"></span></p> <ul><li>vkFreeMemory一定要与vkAllocateMemory成对使用，避免内存泄漏。</li><li>绑定的memory资源尽量分时复用。</li><li>如果存在CPU访问内存，建议使用VK_MEMORY_PROPERTY_HOST_CACHED_BIT进行申请。</li></ul> <p><strong>【不推荐】</strong></p> <p>频繁使用vkAllocateMemory。设备内存申请次数支持的最大数量可以通过maxMemoryAllocationCount limits属性获取。</p> <p><strong>2. D</strong><strong>evice Memory访问</strong></p> </div> <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"><p>仅适用于<a href="https://registry.khronos.org/vulkan/#apispecs" target="_blank">Vulkan</a>。</p> </div></div></div> <p>按照spec描述的内存类型范围支持4种类型：</p> <ul><li>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</li></ul> <ul><li>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_CACHED_BIT</li></ul> <ul><li>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT</li></ul> <ul><li>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | VK_MEMORY_PROPERTY_PROTECTED_BIT</li></ul> <p>对于不同类型的memory资源，有不同的使用方法：</p> <ul><li>DEVICE_LOCAL | HOST_VISIBLE | HOST_COHERENT类型：属于CPU non-cache的内存，最好是用于CPU只写的资源。</li><li>DEVICE_LOCAL | HOST_VISIBLE | HOST_CACHED类型：HOST_CACHED内存的访问要考虑一致性问题，该类型内存写操作后要使用如下接口进行cache同步操作：<ul><li>vkFlushMappedMemoryRanges：CPU修改对GPU可见，CPU到GPU的同步。</li><li>vkInvalidateMappedMemoryRanges：GPU对memory的更新对CPU可见，GPU到CPU的同步。</li></ul> <p>以上这两个操作对性能都有一定的消耗。</p> </li><li>DEVICE_LOCAL | LAZILY_ALLOCATED类型：此种类型的内存允许只分配虚拟地址空间而不分配物理页，如果存在内存访问，则按需分配更多的物理页，支持内存增长。</li><li>DEVICE_LOCAL | PROTECTED类型：Protected Flag将内存分成了Protected device memory和Unprotected device memory两种。<ul><li>Protected device memory只对device（即GPU）可见，对host（即CPU）不可见。</li><li>Unprotected device memory对device可见，也可以对host可见，取决于host visible属性。</li></ul> </li></ul> <p><strong>【推荐】</strong></p> <ul><li>DEVICE_LOCAL | HOST_VISIBLE | HOST_COHERENT类型的内存用于CPU只写的资源。</li><li>DEVICE_LOCAL | HOST_VISIBLE | HOST_CACHED类型的内存用于CPU回读的资源。</li><li>DEVICE_LOCAL | LAZILY_ALLOCATED类型的内存只能用于TRANSIENT_ATTACHMENT用途的image。</li></ul> <p><strong>【不推荐】</strong></p> <p>从CPU non-cache的内存中频繁回读数据，会影响性能。</p> <div class="tiledSection"><h3 id="section10631102319132">Pipeline<i class="anchor-icon anchor-icon-link" anchorid="section10631102319132" tips="复制节点链接"></i></h3><div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"><p>仅适用于<a href="https://registry.khronos.org/vulkan/#apispecs" target="_blank">Vulkan</a>。</p> </div></div></div> <p>Pipeline是整个渲染过程的状态集合，包括可编程的shader和不可编程的fixed function state，其参数配置影响整个渲染过程的执行效率。</p> <p><strong>1. Shader Stage</strong></p> <p><strong>【推荐】</strong></p> <ul><li>在shader中如果需要用同一个sampler对同一个纹理多次采样的结果进行加权处理（比如模糊处理）并且权值和坐标是都mediump，建议可以使用base采样坐标加多组偏移的方式进行采样，并且用一层for循环进行多次采样加权操作。base采样坐标、偏移值和加权值需要是uniform，例如编译时常量或者来自uniform buffer（循环次数为编译时常量，最大为64）。<div class="screenLinkPre"><div _ngcontent-rcd-c106="" class="highlight-div"><div _ngcontent-rcd-c106="" class="highlight-div-header"><div _ngcontent-rcd-c106="" class="highlight-div-header-left"><div _ngcontent-rcd-c106="" class="handle-button expand-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-rcd-c106="" class="highlight-div-header-right"><div _ngcontent-rcd-c106="" class="handle-button ai-button"></div><div _ngcontent-rcd-c106="" class="handle-button line-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-rcd-c106="" class="handle-button theme-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-rcd-c106="" class="handle-button copy-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-rcd-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-java" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/MaliangGPU/entry/src/main/ets/pages/shader.frag#L20-L26" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-type">vec2</span> <span class="hljs-variable">baseCoord</span> <span class="hljs-operator">=</span> ve2(<span class="hljs-number">0.0</span>);</li><li>vec2 offset[<span class="hljs-number">4</span>] = {...};</li><li><span class="hljs-type">float</span> weight[<span class="hljs-number">4</span>] = {...};</li><li><span class="hljs-type">vec4</span> <span class="hljs-variable">color</span> <span class="hljs-operator">=</span> vec4(<span class="hljs-number">0.0</span>);</li><li><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) {</li><li>    color += weight[i] * texture(texSampler, baseCoord + offset[i]);</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/MaliangGPU/entry/src/main/ets/pages/shader.frag#L20-L26" target="_blank">shader.frag</a></div></div></div></div> </li><li>shader中如果访问小批量的常量数据，推荐使用push constant。</li><li>shader中访问uniform buffer array时，索引下标使用编译时常量。</li><li>shader中访问uniform buffer时，访问的位置使用编译时常量。</li><li>compute shader的一个workgroup size的三个维度的乘积为32的整数倍。</li><li>fragment shader中，使用input attribute作为采样坐标去采样的次数小于等于8次，且所有采样用的texture和sampler都放到同一个descriptor set中。</li></ul> <p><strong>【不推荐】</strong></p> <ul><li>使用tessellation shader和geometry shader。</li><li>create VkDevice时使能VkPhysicalDeviceProtectedMemoryFeatures::protectedMemory(或者VkPhysicalDeviceVulkan11Features::protectedMemory)。</li><li>需要使能depth test时，fragment shader中使用discard指令。</li><li>需要使能depth test时，fragment shader中写gl_FragDepth。</li><li>需要使能depth test时，fragment shader中写了storage image或者storage buffer。</li><li>需要使能depth test时，fragment shader中写了gl_SampleMask。</li><li>fragment shader中使用highp。</li><li>需要使能blend时，fragment shader的输出color值与color attachment format的精度不匹配。例如color format是VK_FORMAT_B10G11R11_UFLOAT_PACK32，针对R通道，预期颜色在0.0~1.0f精度范围内时11bit的float可以表示较为精准，但是数值越大能够表示的精度越差。两个相邻像素本来预期的颜色假如是1024.0f和1024.1f，但是11bit可以精确表示1024.0f，但是无法精确表示1024.1f，所以1024.1f被存储成1040.0f，导致视觉效果上产生突变。</li></ul> </div> <p><strong>2. Fixed State</strong></p> <p><strong>【推荐】</strong></p> <ul><li>不同的vertex attribute在vertex buffer内连续排布。</li><li>不同的vertex attribute其所属的vertex buffer的binding号从0开始连续编排。比如有2个vertex buffer，其binding号配置为0和1性能较友好，配置为1和3性能不友好。</li><li>App如果需要提前使用vkCreateGraphicsPipelines进行场景预热，建议create info中（主要是renderpass、pipeline layout、blend state、multisample count、alpha to coverage）要填充真实场景所使用的create info，因为这些info会影响shader的编译，如果预热时填充的create info与真实场景不一致，pipeline cache起不到作用，达不到预热的目的。</li></ul> <p><strong>【不推荐】</strong></p> <p>使能depth test时，开启alpha to coverage。</p> <p><strong>【影响】</strong></p> <p>使能multisample，消耗多倍GPU运行资源，降低执行效率。</p> <div class="tiledSection"><h3 id="section1694104371318">Shader编译<i class="anchor-icon anchor-icon-link" anchorid="section1694104371318" tips="复制节点链接"></i></h3><div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"><p>仅适用于<a href="https://www.khronos.org/opengles/" target="_blank">OpenGL ES</a>。</p> </div></div></div> <p>Shader的首次编译（glCompileShader，glLinkProgram）耗时长，若在应用运行时进行实时编译，容易引起卡顿和丢帧，影响用户体验。</p> <p><strong>【推荐】</strong></p> <p>建议将Shader编译提前至应用启动时进行。</p> <p><strong>【不推荐】</strong></p> <p>在应用运行时实时编译Shader。</p> </div> <div class="tiledSection"><h3 id="section46063597130">Command Buffer<i class="anchor-icon anchor-icon-link" anchorid="section46063597130" tips="复制节点链接"></i></h3><p>Command buffer usage flags会影响command buffer的执行性能。当使用了SIMULTANEOUS_USE_BIT时，会降低command buffer的执行性能。如果在renderpass内使用secondary command buffer，flags不会有影响。</p> <p><strong>【推荐】</strong></p> <p>使用ONE_TIME_SUBMIT_BIT flag创建Command Buffer。</p> <p><strong>【不推荐】</strong></p> <p>除了用在renderpass内的secondary command buffer，其他类型的command buffer使用SIMULTANEOUS_USE_BIT。</p> </div> <div class="tiledSection"><h3 id="section29189147140">Draw Call Batching<i class="anchor-icon anchor-icon-link" anchorid="section29189147140" tips="复制节点链接"></i></h3><p>游戏下发的draw call数量越多，带来的CPU开销越多，整体的性能越差，建议合并draw call来降低CPU侧的开销。</p> <p><strong>【推荐】</strong></p> <p>一些典型的Draw call Batching场景：</p> <ul><li>使用shader相同，资源不同<p>所使用的vertex buffers或者texture等资源变化，这些draw可以通过合并vertex buffer或使用texture arrays等方式来合并。</p> </li></ul> <ul><li>使用shader和Mesh相同<p>通常绘制石头、树、灌木丛等情况，游戏会使用多个相同几何形状的instance去绘制，这种情况建议使用instance draw来完成。</p> </li></ul> <ul><li>使用Multi-Draw indirect功能</li></ul> <p><strong>【不推荐】</strong></p> <ul><li>使用大量顶点数少的draw call。</li><li>频繁切换管线状态，例如program、uniform等，对应相同管线状态的draw call尽量集中处理。</li></ul> </div> <div class="tiledSection"><h2 id="section744412673315">GPU优化<i class="anchor-icon anchor-icon-link" anchorid="section744412673315" tips="复制节点链接"></i></h2></div> <div class="tiledSection"><h3 id="section1568394383311" class="firsth2">Vertex shading<i class="anchor-icon anchor-icon-link" anchorid="section1568394383311" tips="复制节点链接"></i></h3><p><strong>1. 精度</strong></p> <p>为了规避Vertex shader计算位置信息的偏差导致后续shader stage误差放大，Maleoon GPU上vertex shader精度统一按照highp实现。</p> <p><strong>【推荐】</strong></p> <p>建议使用highp设置。</p> <p><strong>2. InstanceID</strong></p> <p>InstanceID经常会参与uniform buffer索引值的计算，此种情况下，Maleoon GPU会根据是否能有效减小load mem的次数从而开启Single InstanceID优化。此优化可以保证每组任务运行时InstanceID一致，从而每组任务load mem只用执行first thread一次load即可拿到整组对应数据。进一步，如果此shader所有uniform不超过1024 bytes大小，此uniform buffer可以完全放在constant register里面，即可通过Maleoon GPU特有的relative constant register代替此load mem操作，性能最优。</p> <p><strong>【推荐】</strong></p> <ul><li>InstanceID参与uniform buffer索引值计算时，uniform buffer中尽量精简只保留有效数据。</li><li>条件允许下，InstanceID每个实例可以多画一些点，性能收益更大。</li><li>InstanceID参与uniform buffer索引值计算时，尽量不要在复杂的嵌套之内。</li></ul> <p><strong>【示例】</strong></p> <p>原始shader：</p> <div class="screenLinkPre"><div _ngcontent-rcd-c106="" class="highlight-div"><div _ngcontent-rcd-c106="" class="highlight-div-header"><div _ngcontent-rcd-c106="" class="highlight-div-header-left"><div _ngcontent-rcd-c106="" class="handle-button expand-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-rcd-c106="" class="highlight-div-header-right"><div _ngcontent-rcd-c106="" class="handle-button ai-button"></div><div _ngcontent-rcd-c106="" class="handle-button line-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-rcd-c106="" class="handle-button theme-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-rcd-c106="" class="handle-button copy-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-rcd-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-csharp" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/MaliangGPU/entry/src/main/ets/pages/shader.frag#L29-L40" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">struct</span> unity_ Type {</li><li>  vec4 vecArrA[<span class="hljs-number">4</span>];</li><li>  vec4 vecArrB[<span class="hljs-number">4</span>];</li><li>};</li><li>layout(std140) uniform UnityInstancing_PerDraw0 {</li><li>  unity_Type unity_Array[<span class="hljs-number">32</span>];</li><li>};</li><li><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span>()</span> {</li><li>  u_xlati0 = gl_InstanceID + unity_BaseInstanceID;</li><li>  u_xlati0 = u_xlati0 &lt;&lt; <span class="hljs-number">2</span>;</li><li>  u_xlat1.yw = (-_mhyWorldOffset.zx) + unity_Array[u_xlati0 / <span class="hljs-number">4</span>].vecArrA[<span class="hljs-number">3</span>].zx;</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/MaliangGPU/entry/src/main/ets/pages/shader.frag#L29-L40" target="_blank">shader.frag</a></div></div></div></div> <p>推荐shader：</p> <div class="screenLinkPre"><div _ngcontent-rcd-c106="" class="highlight-div"><div _ngcontent-rcd-c106="" class="highlight-div-header"><div _ngcontent-rcd-c106="" class="highlight-div-header-left"><div _ngcontent-rcd-c106="" class="handle-button expand-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-rcd-c106="" class="highlight-div-header-right"><div _ngcontent-rcd-c106="" class="handle-button ai-button"></div><div _ngcontent-rcd-c106="" class="handle-button line-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-rcd-c106="" class="handle-button theme-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-rcd-c106="" class="handle-button copy-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-rcd-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-csharp" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/MaliangGPU/entry/src/main/ets/pages/shader.frag#L43-L53" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">struct</span> unity_ Type {</li><li>    vec4 vecArrA[<span class="hljs-number">4</span>];</li><li>};</li><li>layout(std140) uniform UnityInstancing_PerDraw0 {</li><li>    unity_Type unity_Array[<span class="hljs-number">32</span>];</li><li>};</li><li><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span>()</span> {</li><li>    u_xlati0 = gl_InstanceID + unity_BaseInstanceID;</li><li>    u_xlati0 = u_xlati0 &lt;&lt; <span class="hljs-number">2</span>;</li><li>    u_xlat1.yw = (-_mhyWorldOffset.zx) + unity_Array[u_xlati0 / <span class="hljs-number">4</span>].vecArrA[<span class="hljs-number">3</span>].zx;</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/MaliangGPU/entry/src/main/ets/pages/shader.frag#L43-L53" target="_blank">shader.frag</a></div></div></div></div> </div> <p><strong>3. 顶点排布</strong></p> <p>Maleoon GPU是Tile-Based架构的GPU，对于Tile-Based架构的GPU，有一个单独的pass（binning pass）仅用于计算顶点着色器的顶点位置。因此，如果输入的顶点位置相关属性与所有其他属性存储在同一个buffer中，则binning pass获取vertex shader输入时，由于memory的连续读取粒度较大，将会导致实际读取到较多对该shader无效的输入数据，内存带宽将会增加很多。</p> <p><strong>【推荐】</strong></p> <p>将顶点相关的属性存储在独立buffer中。</p> <div class="tiledSection"><h3 id="section16841037349">Per-Fragment Test<i class="anchor-icon anchor-icon-link" anchorid="section16841037349" tips="复制节点链接"></i></h3><p><strong>Overdraw</strong></p> <p>Overdraw作为影响GPU性能的核心问题之一，开发者可以对于不透明的primitive进行排序，让后面的primitive可以被剔除，GPU也在硬件层次上支持不依赖primitive排序的剔除方案。</p> <p>Maleoon GPU内部有一套针对Depth Test的硬件优化，主要功能是对传统图形管线Depth Test的补充优化，目的是在更早期阶段，以较粗的粒度区块，提前剔除掉一些无效的绘制，从而更好的减少后级管线的开销。</p> <p>Renderpass整体的CompareOp是以第一次满足“可进行深度剔除”时的Op为主要方向，例如，一段Renderpass有3个draw，它们的Depth Test通过条件分别为less (不满足剔除条件) 、 greater (满足剔除约束) 、 greater (不满足剔除约束)，则该段Renderpass以greater为主要方向进行深度剃除。</p> <p><strong>【推荐】</strong></p> <ul><li>尽可能开启depth write enable。不开启会导致当下draw无法更新深度剔除值，从而产生overdraw。</li><li>renderpass内各个draw的compareOp保持一致。当renderpass中，某个draw的compareOp与该renderpass的主要方向的compareOp相反。此时，当下draw无法进行深度剔除及深度更新，从而产生overdraw。</li><li>Clear attachment尽可能放在renderpass的最开始或者是renderpass尚未赋予主要方向。若出现主要方向后，某draw有clear attachment操作，则从此draw开始无法进行深度剔除及深度值更新。</li></ul> <p><strong>【不推荐】</strong></p> <ul><li>当Draw的compareOp为equal、not_equal、always、never这些状态时，当下draw无法进行深度更新。</li><li>当renderpass已确定主要方向后，若之后的过程中出现compareOp为always或者是not_equal，从此always或not_equal的draw开始，包含之后所有的draw，无法进行深度剔除及更新深度剔除值。</li><li>Draw同时使能depth bound enable和depth write enable。若出现此种情况，从此draw开始，无法进行深度剔除及深度值更新。</li><li>Draw同时使能blend和depth write enable。若出现此种情况，从此draw开始，无法再更新深度剔除值，从而降低剔除率。</li><li>shader使用discard、gl_SampleMask、gl_FragDepth、alpha2coverage等配置。若出现此种情况，当下draw的深度剔除值将无法更新。</li><li>renderpass中绑定不同组pipeline，其PipelineColorBlendAttachmentState -&gt; colorWriteMask会出现不一致的情况，当下的draw无法进行深度更新。若满足该条件且depth write enable，从此draw开始，无法进行深度剔除及深度值更新。</li></ul> </div> <div class="tiledSection"><h3 id="section3216157346">Fragment Shading<i class="anchor-icon anchor-icon-link" anchorid="section3216157346" tips="复制节点链接"></i></h3><p><strong>1. Renderpass</strong></p> <p><strong>1.1 基本配置</strong></p> <p><strong>Vulkan</strong></p> <p>Vulkan API明确定义了每个attachment在渲染开始和结束时行为，比如API接口中的loadOp定义了GPU如何在渲染开始时初始化片上内存，storeOp定义了渲染结束时是否需要写回主内存。</p> <p><strong>【推荐】</strong></p> <ul><li>在不依赖于attachment初始内容的情况下，attachment的loadOp设置为LOAD_OP_NONE来初始化。</li><li>Attachment的loadOp设置为LOAD_OP_CLEAR来清除内存。</li><li>不依赖的attachment，其storeOp设置为STORE_OP_NONE节省带宽。</li></ul> <p><strong>【不推荐】</strong></p> <ul><li>使用vkCmdClearColorImage或者vkCmdClearDepthStencilImage接口来清除作为attachment的image。</li><li>使用vkCmdClearAttachments接口来清除attachment。</li><li>使用shader写固定颜色来清除attachment。</li><li>在不依赖于attachment初始内容的情况下，attachment的loadOp设置为LOAD_OP_LOAD。</li><li>配置不需要的attachment。</li><li>不依赖的attachment，storeOp设置为STORE_OP_STORE。</li></ul> <p><strong>OpenGL ES</strong></p> <p>OpenGL ES并没有明确的API来定义render pass的开始和结束，而是由GPU驱动根据framebuffer的绑定调用来推断的。</p> <p>一个framebuffer的render pass通常开始于该framebuffer的target被绑定为GL_DRAW_FRAMEBUFFER，结束于换绑另一个framebuffer为GL_DRAW_FRAMEBUFFER。</p> <p><strong>【推荐】</strong></p> <ul><li>全屏绘制的render pass，在render pass开头增加一个glClear操作。如果一个render pass前没有glClear操作，GPU将会在render pass的开始插入一个回读的操作从内存中读取attachment初始内容到GPU片上，带来不必要的带宽开销。</li><li>如果attachments的内容在接下来的渲染操作中将是不再需要的，调用glInvalidateFramebuffer通知GPU，GPU会做相应的优化处理。</li></ul> <p><strong>【不推荐】</strong></p> <ul><li>来回切换FBO。<p>每次FBO切换GPU都需要完成上下文切换从而带来开销。通常开发者都注意不会频繁做不必要的FBO切换，然而有一些特殊场景比较容易忽略。</p> <p>例如，用户先clear FBO A，然后在另一个FBO B上开始一个新的render pass，最后再回到FBO A上开始渲染。这样第一个clear操作将开始一个单独包含clear操作的render pass，最终实际上有3个render pass被执行，且第3个渲染过程将有额外的回读操作。如果将第一个clear操作往后移动到真正相关的FBO渲染之前，将仅生成2个render pass，并且不会出现额外的回读操作。</p> </li><li>在一个render pass内部调用glFlush和glFinish，有性能开销。</li><li>使用glReadPixels，CPU会等GPU job执行完成，在这之前都是阻塞状态，破坏CPU和GPU的并行。</li></ul> <p><strong>1.2 Multisample</strong></p> <p>对于MSAA的大多数场景，multisample attachment一般只需要保留在GPU内部的片上内存中，无需写回到主内存中，只需要解析为singlesample attachment，然后将singlesample attachment写回到主内存，即multisample attachment的额外带宽永远不会写回到主内存，可以提高效率。</p> <p><strong>Vulkan</strong></p> <p><strong>【推荐】</strong></p> <ul><li>multisample attachment的loadOp设置为LOAD_OP_NONE或者LOAD_OP_CLEAR。</li><li>multisample attachment的storeOp设置为STORE_OP_NONE。</li><li>通过在subpass中设置pResolveAttachments来将multisample解析为singlesample。</li></ul> <p><strong>【不推荐】</strong></p> <ul><li>multisample attachment的loadOp设置为LOAD_OP_LOAD。</li><li>multisample attachment的storeOp设置为STORE_OP_STORE。</li><li>使用vkCmdResolveImage接口将multisample image解析为singlesample image。</li><li>针对depth attachment进行resolve操作。</li></ul> <p><strong>OpenGL ES</strong></p> <p><strong>【推荐】</strong></p> <p>使用GL_EXT_multisampled_render_to_texture扩展，实现将GPU片上multisampled数据resolve后直接写回到一个非multisampled纹理中。</p> <p><strong>【不推荐】</strong></p> <p>先将multisampled数据写回内存中的multisampled纹理中，然后再通过调用glBlitFramebuffer来实现resolve。</p> <p><strong>2. Texture Prefetch</strong></p> <p>Texture Prefetch是Maleoon GPU上一种资源预读取的加速技术。通过在shader执行前，对采样操作进行预读取，可以加速shader执行。</p> <p><strong>【推荐】</strong></p> <p>shader中texture prefetch需要满足以下条件：</p> <ul><li>采样坐标为输入变量。如果在fragment shader中包含采样操作，其采样坐标是输入变量与立即数或输入变量与uniform线性运算的结果，可以尝试将线性运算放到vertex shader中执行，详见以下【示例】。</li><li>以下采样函数支持texture prefetch。 <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><tbody><tr><td class="cellrowborder" valign="top" width="100%"><p>gvec4 texture(gsampler2D sampler, vec2 P, [float bias]);</p> <p>bias is imm value or some other uniform variable</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="100%"><p>gvec4 textureLod(gsampler2D sampler, vec2 P, float lod);</p> <p>lod is imm value or some other uniform variable</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="100%"><p>gvec4 textureProj(gsampler2D sampler, vec4(or vec3) P, [float bias]);</p> <p>bias = 0.0 (or no bias parameter)</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="100%"><p>gvec4 textureLodOffset(gsampler2D sampler, vec2 P, float lod, ivec2 offset);</p> <p>lod is imm value or some other uniform variable</p> </td> </tr>  </tbody></table></div> </div> </li></ul> <p><strong>【不推荐】</strong></p> <p>在fragment shader中的if条件语句中直接使用来自vertex shader的坐标进行prefetch，以免带来不必要的带宽开销。</p> <p><strong>【示例】</strong></p> <div class="p">原始shader：<div class="screenLinkPre"><div _ngcontent-rcd-c106="" class="highlight-div"><div _ngcontent-rcd-c106="" class="highlight-div-header"><div _ngcontent-rcd-c106="" class="highlight-div-header-left"><div _ngcontent-rcd-c106="" class="handle-button expand-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-rcd-c106="" class="highlight-div-header-right"><div _ngcontent-rcd-c106="" class="handle-button ai-button"></div><div _ngcontent-rcd-c106="" class="handle-button line-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-rcd-c106="" class="handle-button theme-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-rcd-c106="" class="handle-button copy-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-rcd-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-csharp" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/MaliangGPU/entry/src/main/ets/pages/shader.frag#L57-L79" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// Vertex shader</span></li><li><span class="hljs-meta">#version 300 es</span></li><li><span class="hljs-keyword">in</span> vec4 in_position;</li><li><span class="hljs-keyword">in</span> vec2 in_coord;</li><li><span class="hljs-keyword">out</span> vec2 texCoord;</li><li><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span>()</span> {</li><li>    gl_Position = in_position;</li><li>    texCoord = in_coord;</li><li>}</li><li>
</li><li>
</li><li><span class="hljs-comment">// Fragment shader</span></li><li><span class="hljs-meta">#version 300 es</span></li><li>precision highp <span class="hljs-built_in">int</span>;</li><li>precision highp <span class="hljs-built_in">float</span>;</li><li><span class="hljs-keyword">in</span> vec2 texCoord;</li><li>uniform vec2 texOffset;</li><li>layout(location = <span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> highp vec4 fragColor0;</li><li>layout(location = <span class="hljs-number">0</span>) uniform highp sampler2D sampler0;</li><li><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span>()</span> {</li><li>    vec2 coord = texCoord + texOffset;</li><li>    fragColor0 = texture(sampler0, coord);</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/MaliangGPU/entry/src/main/ets/pages/shader.frag#L57-L79" target="_blank">shader.frag</a></div></div></div></div> </div> <p>推荐shader：</p> <div class="screenLinkPre"><div _ngcontent-rcd-c106="" class="highlight-div"><div _ngcontent-rcd-c106="" class="highlight-div-header"><div _ngcontent-rcd-c106="" class="highlight-div-header-left"><div _ngcontent-rcd-c106="" class="handle-button expand-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-rcd-c106="" class="highlight-div-header-right"><div _ngcontent-rcd-c106="" class="handle-button ai-button"></div><div _ngcontent-rcd-c106="" class="handle-button line-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-rcd-c106="" class="handle-button theme-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-rcd-c106="" class="handle-button copy-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-rcd-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-csharp" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/MaliangGPU/entry/src/main/ets/pages/shader.frag#L83-L106" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-comment">// Vertex shader</span></li><li><span class="hljs-meta">#version 300 es</span></li><li><span class="hljs-keyword">in</span> vec4 in_position;</li><li><span class="hljs-keyword">in</span> vec2 in_coord;</li><li><span class="hljs-keyword">out</span> vec2 texCoord;</li><li>uniform vec2 texOffset;</li><li><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span>()</span> {</li><li>    gl_Position = in_position;</li><li>    texCoord = in_coord + texOffset;</li><li>}</li><li>
</li><li>
</li><li><span class="hljs-comment">// Fragment shader</span></li><li><span class="hljs-meta">#version 300 es</span></li><li>precision highp <span class="hljs-built_in">int</span>;</li><li>precision highp <span class="hljs-built_in">float</span>;</li><li><span class="hljs-keyword">in</span> vec2 texCoord;</li><li>uniform vec2 texOffset;</li><li>layout(location = <span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> highp vec4 fragColor0;</li><li>layout(location = <span class="hljs-number">0</span>) uniform highp sampler2D sampler0;</li><li><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span>()</span> {</li><li>    fragColor0 = texture(sampler0, texCoord);</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/MaliangGPU/entry/src/main/ets/pages/shader.frag#L83-L106" target="_blank">shader.frag</a></div></div></div></div> <p><strong>3. Texture Reuse</strong></p> <p>Texture Reuse是一种指令的合并方法，因为在Fragment Shader中texture使用频率较高，且消耗的资源较大，所以Maleoon GPU使用了Texture Reuse来优化符合条件的2D Texture。</p> <p><strong>【推荐】</strong></p> <p>Texture Reuse可以分为三种模式：TSLOOP、POLOOP和OFFSETLOOP。</p> <ul><li>TSLOOP：不同的sampler，相同的texcoord。<p>推荐shader：</p> <div class="screenLinkPre"><div _ngcontent-rcd-c106="" class="highlight-div"><div _ngcontent-rcd-c106="" class="highlight-div-header"><div _ngcontent-rcd-c106="" class="highlight-div-header-left"><div _ngcontent-rcd-c106="" class="handle-button expand-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-rcd-c106="" class="highlight-div-header-right"><div _ngcontent-rcd-c106="" class="handle-button ai-button"></div><div _ngcontent-rcd-c106="" class="handle-button line-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-rcd-c106="" class="handle-button theme-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-rcd-c106="" class="handle-button copy-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-rcd-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-java" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/MaliangGPU/entry/src/main/ets/pages/shader.frag#L110-L113" data-highlighted="yes"><ol class="linenums"><li>highp <span class="hljs-type">vec4</span> <span class="hljs-variable">t0</span> <span class="hljs-operator">=</span> texture(texture_unit0, texcoord, bias);</li><li>highp <span class="hljs-type">vec4</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> texture(texture_unit1, texcoord, bias);</li><li>highp <span class="hljs-type">vec4</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> texture(texture_unit2, texcoord, bias);</li><li>highp <span class="hljs-type">vec4</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> texture(texture_unit3, texcoord, bias);</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/MaliangGPU/entry/src/main/ets/pages/shader.frag#L110-L113" target="_blank">shader.frag</a></div></div></div></div> </li><li>POLOOP：相同的sampler，相同的texcoord，不同的offset。<p>offset支持immediate。</p> <p>推荐shader：</p> <div class="screenLinkPre"><div _ngcontent-rcd-c106="" class="highlight-div"><div _ngcontent-rcd-c106="" class="highlight-div-header"><div _ngcontent-rcd-c106="" class="highlight-div-header-left"><div _ngcontent-rcd-c106="" class="handle-button expand-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-rcd-c106="" class="highlight-div-header-right"><div _ngcontent-rcd-c106="" class="handle-button ai-button"></div><div _ngcontent-rcd-c106="" class="handle-button line-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-rcd-c106="" class="handle-button theme-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-rcd-c106="" class="handle-button copy-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-rcd-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-java" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/MaliangGPU/entry/src/main/ets/pages/shader.frag#L117-L120" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-type">vec4</span> <span class="hljs-variable">t0</span> <span class="hljs-operator">=</span> texelFetchOffset(texture_unit0, texcoord0, lod, offset0);</li><li><span class="hljs-type">vec4</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> texelFetchOffset(texture_unit0, texcoord0, lod, offset1);</li><li><span class="hljs-type">vec4</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> texelFetchOffset(texture_unit0, texcoord0, lod, offset2);</li><li><span class="hljs-type">vec4</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> texelFetchOffset(texture_unit0, texcoord0, lod, offset3);</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/MaliangGPU/entry/src/main/ets/pages/shader.frag#L117-L120" target="_blank">shader.frag</a></div></div></div></div> </li><li>OFFSETLOOP：相同的sampler，texcoord相同的base（texcoord0），不同的offset。<p>offset支持immediate和uniform。</p> <p>推荐shader：</p> <div class="screenLinkPre"><div _ngcontent-rcd-c106="" class="highlight-div"><div _ngcontent-rcd-c106="" class="highlight-div-header"><div _ngcontent-rcd-c106="" class="highlight-div-header-left"><div _ngcontent-rcd-c106="" class="handle-button expand-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-rcd-c106="" class="highlight-div-header-right"><div _ngcontent-rcd-c106="" class="handle-button ai-button"></div><div _ngcontent-rcd-c106="" class="handle-button line-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-rcd-c106="" class="handle-button theme-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-rcd-c106="" class="handle-button copy-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-rcd-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-java" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/MaliangGPU/entry/src/main/ets/pages/shader.frag#L123-L126" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-type">vec4</span> <span class="hljs-variable">t0</span> <span class="hljs-operator">=</span> texture(texture_unit0, texcoord0 + vec2(-<span class="hljs-number">0.25</span>, <span class="hljs-number">0</span>), bias0);</li><li><span class="hljs-type">vec4</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> texture(texture_unit0, texcoord0 + vec2(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.25</span>), bias1);</li><li><span class="hljs-type">vec4</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> texture(texture_unit0, texcoord0 + vec2(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>), bias2);</li><li><span class="hljs-type">vec4</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> texture(texture_unit0, texcoord0 + vec2(-<span class="hljs-number">0.25</span>, <span class="hljs-number">0.25</span>), bias3);</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/MaliangGPU/entry/src/main/ets/pages/shader.frag#L123-L126" target="_blank">shader.frag</a></div></div></div></div> </li></ul> <p>对于这三类texture，Maleoon GPU会对其进行reuse，减少传输的次数，降低功耗。</p> <p><strong>4. 高阶采样</strong></p> <p>基于Texture Reuse做进一步优化，可以在采样单元直接计算出运算结果，支持POLOOP和OFFSETLOOP。</p> <p><strong>【推荐】</strong></p> <p>根据texture reuse的不同使用场景加入了三种高阶采样优化：Convolution、Max和Min。</p> <ul><li>Convolution：卷积操作<p>sampler支持lowp/mediump，weight支持mediump，可以为immediate或者uniform</p> <p>推荐shader：</p> <div class="screenLinkPre"><div _ngcontent-rcd-c106="" class="highlight-div"><div _ngcontent-rcd-c106="" class="highlight-div-header"><div _ngcontent-rcd-c106="" class="highlight-div-header-left"><div _ngcontent-rcd-c106="" class="handle-button expand-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-rcd-c106="" class="highlight-div-header-right"><div _ngcontent-rcd-c106="" class="handle-button ai-button"></div><div _ngcontent-rcd-c106="" class="handle-button line-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-rcd-c106="" class="handle-button theme-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-rcd-c106="" class="handle-button copy-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-rcd-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-java" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/MaliangGPU/entry/src/main/ets/pages/shader.frag#L130-L136" data-highlighted="yes"><ol class="linenums"><li>uniform lowp/mediump sampler2D texture_unit0;</li><li>uniform highp <span class="hljs-type">float</span> w[<span class="hljs-number">4</span>];</li><li><span class="hljs-type">vec4</span> <span class="hljs-variable">t0</span> <span class="hljs-operator">=</span> texelFetchOffset(texture_unit0, texcoord0, lod, offset0);</li><li><span class="hljs-type">vec4</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> texelFetchOffset(texture_unit0, texcoord0, lod, offset1);</li><li><span class="hljs-type">vec4</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> texelFetchOffset(texture_unit0, texcoord0, lod, offset2);</li><li><span class="hljs-type">vec4</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> texelFetchOffset(texture_unit0, texcoord0, lod, offset3);</li><li><span class="hljs-type">vec4</span> <span class="hljs-variable">conv_enable</span> <span class="hljs-operator">=</span> w[<span class="hljs-number">0</span>] * t0 + w[<span class="hljs-number">1</span>] * t1 + w[<span class="hljs-number">2</span>] * t2 + w[<span class="hljs-number">3</span>] * t3;</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/MaliangGPU/entry/src/main/ets/pages/shader.frag#L130-L136" target="_blank">shader.frag</a></div></div></div></div> </li><li>Max：取最大值操作<p>sampler支持lowp/mediump</p> <p>推荐shader：</p> <div class="screenLinkPre"><div _ngcontent-rcd-c106="" class="highlight-div"><div _ngcontent-rcd-c106="" class="highlight-div-header"><div _ngcontent-rcd-c106="" class="highlight-div-header-left"><div _ngcontent-rcd-c106="" class="handle-button expand-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-rcd-c106="" class="highlight-div-header-right"><div _ngcontent-rcd-c106="" class="handle-button ai-button"></div><div _ngcontent-rcd-c106="" class="handle-button line-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-rcd-c106="" class="handle-button theme-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-rcd-c106="" class="handle-button copy-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-rcd-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-java" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/MaliangGPU/entry/src/main/ets/pages/shader.frag#L140-L145" data-highlighted="yes"><ol class="linenums"><li>uniform lowp/mediump sampler2D texture_unit0;</li><li><span class="hljs-type">vec4</span> <span class="hljs-variable">t0</span> <span class="hljs-operator">=</span> texelFetchOffset(texture_unit0, texcoord0, lod, offset0);</li><li><span class="hljs-type">vec4</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> texelFetchOffset(texture_unit0, texcoord0, lod, offset1);</li><li><span class="hljs-type">vec4</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> texelFetchOffset(texture_unit0, texcoord0, lod, offset2);</li><li><span class="hljs-type">vec4</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> texelFetchOffset(texture_unit0, texcoord0, lod, offset3);</li><li><span class="hljs-type">vec4</span> <span class="hljs-variable">max_enable</span> <span class="hljs-operator">=</span> max(max(max(t0, t1), t2), t3);</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/MaliangGPU/entry/src/main/ets/pages/shader.frag#L140-L145" target="_blank">shader.frag</a></div></div></div></div> </li><li>Min：取最小值操作<p>sampler支持lowp/mediump</p> <p>推荐shader：</p> <div class="screenLinkPre"><div _ngcontent-rcd-c106="" class="highlight-div"><div _ngcontent-rcd-c106="" class="highlight-div-header"><div _ngcontent-rcd-c106="" class="highlight-div-header-left"><div _ngcontent-rcd-c106="" class="handle-button expand-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-rcd-c106="" class="highlight-div-header-right"><div _ngcontent-rcd-c106="" class="handle-button ai-button"></div><div _ngcontent-rcd-c106="" class="handle-button line-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-rcd-c106="" class="handle-button theme-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-rcd-c106="" class="handle-button copy-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-rcd-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-java" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/MaliangGPU/entry/src/main/ets/pages/shader.frag#L149-L154" data-highlighted="yes"><ol class="linenums"><li>uniform lowp/mediump sampler2D texture_unit0;</li><li><span class="hljs-type">vec4</span> <span class="hljs-variable">t0</span> <span class="hljs-operator">=</span> texelFetchOffset(texture_unit0, texcoord0, lod, offset0);</li><li><span class="hljs-type">vec4</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> texelFetchOffset(texture_unit0, texcoord0, lod, offset1);</li><li><span class="hljs-type">vec4</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> texelFetchOffset(texture_unit0, texcoord0, lod, offset2);</li><li><span class="hljs-type">vec4</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> texelFetchOffset(texture_unit0, texcoord0, lod, offset3);</li><li><span class="hljs-type">vec4</span> <span class="hljs-variable">min_enable</span> <span class="hljs-operator">=</span> min(min(min(t0, t1), t2), t3);</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/MaliangGPU/entry/src/main/ets/pages/shader.frag#L149-L154" target="_blank">shader.frag</a></div></div></div></div> </li></ul> <p>对于这三类texture，Maleoon GPU在reuse基础上进一步减少传输的信息，降低功耗。</p> </div> <div class="tiledSection"><h3 id="section13490143013349">Blend<i class="anchor-icon anchor-icon-link" anchorid="section13490143013349" tips="复制节点链接"></i></h3><p>Maleoon GPU上，Blend可以通过Fixed Funcion（硬件加速）的方式，或者软件shader的方式实现，具体的影响因素包括采用的blend mode和进行blend的color attachment的format。</p> <p><strong>【推荐】</strong></p> <ul><li>Blend mode为add、sub。<div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"><p>仅适用于Maleoon 910 GPU。</p> </div></div></div> </li><li>App本身不需要使能blend时，如果color attachment为以下format时，建议VkPipelineColorBlendAttachmentState::colorWriteMask配置成0xf，并且fragment shader中对应attachment输出color的四个通道都有赋值。<ul><li>A2R10G10B10_UINT_PACK32</li><li>A2R10G10B10_SINT_PACK32</li><li>A2B10G10R10_UINT_PACK32</li><li>A2B10G10R10_SINT_PACK32</li><li>A2R10G10B10_UNORM_PACK32</li><li>A2R10G10B10_SNORM_PACK32</li><li>A2B10G10R10_UNORM_PACK32</li><li>A2B10G10R10_SNORM_PACK32</li><li>R5G6B5_UNORM_PACK16</li><li>B5G6R5_UNORM_PACK16</li><li>R5G5B5A1_UNORM_PACK16</li><li>B5G5R5A1_UNORM_PACK16</li><li>A1R5G5B5_UNORM_PACK16</li></ul> </li><li>App本身不需要使能blend时，如果color attachment的format是B10G11R11_UFLOAT_PACK32，建议VkPipelineColorBlendAttachmentState::colorWriteMask配置成0x7，并且fragment shader中对应attachment的输出color 3个通道都有赋值。</li></ul> <p><strong>【不推荐】</strong></p> <ul><li>Blend mode为min、max。<div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"><p>仅适用于Maleoon 910 GPU。</p> </div></div></div> </li></ul> <ul><li>App本身需要开启blend时，color attachment为以下format：<ul><li>R32_SFLOAT</li><li>R32G32_SFLOAT</li><li>R32G32B32_SFLOAT</li><li>R32G32B32A32_SFLOAT</li><li>R16_UNORM</li><li>R16G16_UNORM</li><li>R16G16B16_SNORM</li><li>R16G16B16A16_UNORM</li></ul> </li><li>对于不透明的primitive，使能blend。</li></ul> <ul><li>Shader中大量使用EXT_shader_framebuffer_fetch，会影响GPU的执行效率。建议开发者识别如果是Maleoon GPU时，请关闭framebuffer fetch功能。<div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"><ul><li>仅适用于<a href="https://www.khronos.org/opengles/" target="_blank">OpenGL ES</a>。</li><li>Maleoon 920及以上的GPU，在单个三角形覆盖全屏区域的场景下，推荐使用EXT_shader_framebuffer_fetch。</li></ul> </div></div></div> </li></ul> </div> <div class="tiledSection"><h3 id="section1872274473419">Transfer<i class="anchor-icon anchor-icon-link" anchorid="section1872274473419" tips="复制节点链接"></i></h3><div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"><p>仅适用于<a href="https://registry.khronos.org/vulkan/#apispecs" target="_blank">Vulkan</a>。</p> </div></div></div> <p>通过transfer命令，用户可以执行GPU上数据的拷贝。在拷贝时，将数据对齐到合适的alignment以及适当合并拷贝的区域将有助于性能提升。</p> <p><strong>【推荐】</strong></p> <ul><li>使用vkCmdCopyImageToBuffer/vkCmdCopyImageToBuffer2时，buffer的offset对应的地址建议对齐到optimalBufferCopyOffsetAlignment，单位为Byte。</li><li>使用vkCmdCopyImageToBuffer/vkCmdCopyImageToBuffer2时，buffer的rowStride建议对齐到optimalBufferCopyRowPitchAlignment，单位为Byte。</li><li>使用vkCmdCopyImage/vkCmdCopyImage2/vkCmdBlitImage/vkCmdBlitImage2时，如果image的format是FORMAT_D24_UNORM_S8_UINT，并且需要copy/blit depth和stencil两个aspect，那么建议使用一个region，aspectMask指定为VK_IMAGE_ASPECT_DEPTH_BIT | VK_IMAGE_ASPECT_STENCIL_BIT。</li></ul> </div> <div class="tiledSection"><h3 id="section138179820358">Compute<i class="anchor-icon anchor-icon-link" anchorid="section138179820358" tips="复制节点链接"></i></h3><p><strong>1. Compute Shading</strong></p> <p><strong>1.1 Workgroup size</strong></p> <p>Workgroup size大小调优是一种简单有效的优化方法。</p> <p><strong>【推荐】</strong></p> <ul><li>应用中的compute shader建议重新适配Maleoon GPU。</li><li>Workgroup size为32/64，Maleoon GPU运行效率更佳。</li></ul> </div> <p><strong>1.2 Barrier</strong></p> <p>不管是数据并行和任务并行有时候不可避免存在相关性，需要等待其他任务或者数据才能进行下一步计算，这时要用到同步机制，OpenCL同步机制称为Barrier。</p> <p><strong>【推荐】</strong></p> <p>如果Workgroup size小于32(simd32)，硬件可以保证workgroup中的所有线程在一个warp中。因此开发者可以省略workgroup级别的Barrier，从而提升性能。</p> <p><strong>1.3 Loop Reduction</strong></p> <p>Loop Reduction是用OpenCL有效实现数组求和，Maleoon GPU支持Vulkan与OpenCL的subgroup特性。</p> <p><strong>【推荐】</strong></p> <p>尽量使用subgroup特性各类extension实现Loop reduction。</p> <p><strong>2. OpenCL</strong></p> <p><strong>2.1 API使用</strong></p> <p><a href="https://registry.khronos.org/OpenCL/" target="_blank">OpenCL</a>作为一个支持多种计算设备的框架，提供了多个标准API以应对不同场景，使用具有很大的灵活性。为了引导OpenCL API使用者在Maleoon GPU上获取更好性能，给出以下OpenCL API的使用推荐。</p> <p><strong>【推荐】</strong></p> <ul><li>对于相同的Kernel算子，需要在应用开始阶段编译一次<p>OpenCL的算子在应用开始阶段，只编译一次，然后把binary保存下来，后面在应用中直接使用，减少多次编译引起的耗时。</p> </li><li>clEnqueueNDRangeKernel的work-items数量尽可能大<p>GPU的shader优点是多核多线程操作，clEnqueueNDRangeKernel的work-items数量应该尽可能的大，充分发挥多warps的优势。</p> </li><li>使用异步操作，避开任务提交和任务执行导致CPU侧阻塞<p>在调用一个或者多个clEnqueueNDRange()后，再执行clFlush()，最后调用clWaitForEvent()。同步操作需要在任务下发后在CPU侧进行等待，阻塞CPU任务执行。</p> </li><li>为了获取最优的性能，使用的workgroup size为32/64或者是32的倍数关系。</li><li>如果global size的值不能被workgroup size整除，需要补齐到workgroup size，或者使用non-uniform workgroup。</li><li>如果需要获得最优的OpenCL性能，需要去轮询workgroup size，使得并行度等最优，从而获取最优的性能。</li><li>使用cl_arm_import_memory_dma_buf的扩展特性。<div class="screenLinkPre"><div _ngcontent-rcd-c106="" class="highlight-div"><div _ngcontent-rcd-c106="" class="highlight-div-header"><div _ngcontent-rcd-c106="" class="highlight-div-header-left"><div _ngcontent-rcd-c106="" class="handle-button expand-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-rcd-c106="" class="highlight-div-header-right"><div _ngcontent-rcd-c106="" class="handle-button ai-button"></div><div _ngcontent-rcd-c106="" class="handle-button line-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-rcd-c106="" class="handle-button theme-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-rcd-c106="" class="handle-button copy-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-rcd-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-cpp" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/MaliangGPU/entry/src/main/ets/pages/shader.frag#L158-L163" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-function">cl_mem <span class="hljs-title">clImportMemoryARM</span><span class="hljs-params">(cl_context context,</span></span></li><li><span class="hljs-function">    cl_mem_flags flags,</span></li><li><span class="hljs-function">    <span class="hljs-type">const</span> cl_import_properties_arm *properties,</span></li><li><span class="hljs-function">    <span class="hljs-type">void</span> *memory,</span></li><li><span class="hljs-function">    <span class="hljs-type">size_t</span> size,</span></li><li><span class="hljs-function">    cl_int *errorcode_ret)</span>;</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/MaliangGPU/entry/src/main/ets/pages/shader.frag#L158-L163" target="_blank">shader.frag</a></div></div></div></div> </li></ul> <p><strong>2.2 Kernel算子</strong></p> <p>Kernel算子是OpenCL的核心模块，算子的写法会影响OpenCL程序的性能，体现在主机和设备间的数据传输、算子执行的并行度、内存的访问模式等。为了使OpenCL Kernel算子在Maleoon GPU上获取更好性能，给出以下Kernel算子的用法推荐。</p> <p><strong>【推荐】</strong></p> <ul><li>使用合理的内建函数<p>通常在精度允许的情况下，可以使用half_or native_等内建函数版本，这样可以获取比数学函数更好的性能。</p> <div class="screenLinkPre"><div _ngcontent-rcd-c106="" class="highlight-div"><div _ngcontent-rcd-c106="" class="highlight-div-header"><div _ngcontent-rcd-c106="" class="highlight-div-header-left"><div _ngcontent-rcd-c106="" class="handle-button expand-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-rcd-c106="" class="highlight-div-header-right"><div _ngcontent-rcd-c106="" class="handle-button ai-button"></div><div _ngcontent-rcd-c106="" class="handle-button line-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-rcd-c106="" class="handle-button theme-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-rcd-c106="" class="handle-button copy-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-rcd-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-scss" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/MaliangGPU/entry/src/main/ets/pages/shader.frag#L167-L173" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-built_in">native_sin</span>();</li><li><span class="hljs-built_in">native_cos</span>();</li><li><span class="hljs-built_in">native_tan</span>();</li><li><span class="hljs-built_in">native_divide</span>();</li><li><span class="hljs-built_in">native_exp</span>();</li><li><span class="hljs-built_in">native_sqrt</span>();</li><li><span class="hljs-built_in">half_sqrt</span>();</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/MaliangGPU/entry/src/main/ets/pages/shader.frag#L167-L173" target="_blank">shader.frag</a></div></div></div></div> </li></ul> <ul><li>编译优化选项<p>对于精度不高，计算单元负载大的场景，可以使用-cl-fast-relaxed-math。</p> </li><li>合并一些小的，并且数据复合度很大的kernel。<p>如果在流程中有一系列算子，算子的数据复合度很高，并且算子的逻辑很简单，考虑将小kernel进行适当的合并，但是如果数据没有依赖性的算子就尽可能不要合并。</p> </li><li>拆分一些复杂算子<p>如果一些算子逻辑中有大量的barrier，或者寄存器使用量太大，可以考虑对这类算子进行拆分，降低单个算子使用寄存器的数目，以提升warp的并行度。</p> </li><li>在算子中使用向量化操作，避免标量化处理加载数据<p>使用向量化的逻辑提升数据加载的效率和EU的指令数目，可以考虑vload16()等操作。</p> </li><li>使用正确的数据类型<ul><li>使用尽可能小的数据类型，使得加载的数据量小。</li><li>如果精度允许，可以使用ushort或者uchar等替换int等类型。</li></ul> </li><li>OpenCL算子中临时变量尽可能集中，防止寄存器的溢出<p>需要避免在OpenCL算子中使用大量的临时变量，而且使用尽可能集中，减少寄存器的使用，汇编指令中寄存器的使用量超过64时，会大大降低warp的并行度。</p> </li><li>在算子中使用常量寄存器（可以对输入buffer使用restrict和const的关键字）<p>算子中使用const关键字等，方便编译时优化为常量寄存器。</p> </li><li>使用离线编译binary的方式替换在线编译<p>使用hv_clcc离线编译binary的方式替换在线编译的方式，减少编译器编译binary的时间，提升整体性能。</p> </li><li>Vload3的数据操作需要进行vector4对齐<p>通过vload3加载global memory时，内存需要按照vector4的格式进行数据对齐。</p> </li><li>使用constant和__attribute__((max_constant_size(字节数)))，使用FAU常量寄存器<p>针对uniform的buffer，使用constant和max_constant_size关键字，把相关参数存入到FAU常量寄存器中，节省多个线程加载数据的执行时间。</p> </li></ul> <p><strong>【不推荐】</strong></p> <ul><li>算子中进行不必要的类型转换<p>在算子中对数据进行类型转换，可能会导致数据的对齐格式发生变化，那么在加载数据时需要额外的操作，会拉低执行效率。</p> </li><li>算子中对数据进行类型转化，无法使用只读buffer的优化<p>对于global内存，不要在算法内部进行数据的转换。例如，输入的全局内存是int*或者short *，不要让它转换为char*再作一个偏移，然后又转换为int*或者short*的类型，这样只读buffer优化就无法使用，无法将只读buffer带宽大的优势体现出来。</p> </li><li>算子中使用大量分支逻辑<p>Warp中的多个线程尽可能走同一跳转分支，如果算法中包含的分支数太多，例如switch，if，while等操作，使得warp中各个线程会走不同的分支逻辑。这样会导致ALU把所有的分支逻辑都走一遍，降低算子的性能。</p> </li><li>算子中使用大量atomic操作<p>在算子中使用大量global memory的atomic操作，会拉低warp的并行度，建议使用shared memory的atomic。</p> </li></ul> <div class="tiledSection"><h3 id="section289982113351">Window System Integration<i class="anchor-icon anchor-icon-link" anchorid="section289982113351" tips="复制节点链接"></i></h3><div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"><p>仅适用于<a href="https://registry.khronos.org/vulkan/#apispecs" target="_blank">Vulkan</a>。</p> </div></div></div> <p>通过vkCreateSwapchainKHR创建交换链，用于呈现绘制结果。用户可以通过VkSwapchainCreateInfoKHR-&gt; minImageCount自定义交换链中可供使用的image的数量。App会通过vkAcquireNextImageKHR从交换链中申请出一个可用的image资源，执行绘制任务，然后通过vkQueuePresentKHR将完成绘制的image送回交换链并呈现绘制结果。</p> <p>用户可以定义一个非常大的minImageCount来保证每次都能申请到可用的image资源，但若GPU能在远低于Vsync的时间内完成绘制，则该行为可能会导致画面存在撕裂感，并显著增加内存开销。若绘制任务负载很重，GPU无法在一个Vsync周期内完成绘制，则一个很小的minImageCount（例如2）会导致帧率的显著降低。</p> <p><strong>【推荐】</strong></p> <ul><li>低负载模式下，将minImageCount配置为2。</li><li>重负载模式下，将minImageCount配置为3或4。</li><li>尽量把调用image的时机，延迟到本帧最后一个renderpass（该pass一般即是送显的renderpass）之前执行。</li><li>请确保交换链的preTransform与vkGetPhysicalDeviceSurfaceCapabilityKHR返回的currentTransform值匹配。</li><li>如果vkAcquireNextImageKHR或vkQueuePresentKHR返回VK_SUBOPTIMAL_KHR或VK_ERROR_OUT_OF_DATE_KHR，建议此时根据surface属性变化重建交换链。</li></ul> </div> <div class="tiledSection"><h3 id="section13896257355">Resource<i class="anchor-icon anchor-icon-link" anchorid="section13896257355" tips="复制节点链接"></i></h3><p><strong>1. Texture</strong></p> <p><strong>1.1 HEBC</strong></p> <p>HEBC是Maleoon GPU独有的硬件压缩算法，纹理的数据以无损的压缩格式存储，降低了数据传输的功耗和带宽，需要参考以下条件来使能HEBC。</p> <p><strong>Vulkan</strong></p> <p><strong>【推荐】</strong></p> <ul><li>Image tiling必须为optimal。</li><li>Image type必须为IMAGE_TYPE_2D。</li><li>Image usage只能包含以下取值：<ul><li>IMAGE_USAGE_COLOR_ATTACHMENT_BIT</li><li>IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</li><li>IMAGE_USAGE_SAMPLED_BIT</li><li>IMAGE_USAGE_TRANSFER_SRC_BIT</li><li>IMAGE_USAGE_INPUT_ATTACHMENT_BIT</li><li>IMAGE_USAGE_TRANSFER_DST_BIT</li></ul> </li><li>image可支持的format列表如下： <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.59.7.4.1.1.3.1.1" valign="top" width="7.5200000000000005%"><p>序号</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.59.7.4.1.1.3.1.2" valign="top" width="92.47999999999999%"><p>可支持的format</p> </th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>1</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_A4B4G4R4_UNORM=2</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>2</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_A4R4G4B4_UNORM=3</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>3</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_B5G6R5_UNORM=4</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>4</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_R5G6B5_UNORM=5</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>5</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_A1B5G5R5_UNORM=6</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>6</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_A1R5G5B5_UNORM=7</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>7</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_B5G5R5A1_UNORM=8</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>8</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_R8_UNORM=9</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>9</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_R8_UINT=13</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>10</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_R8_SINT=14</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>11</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_R8G8_UNORM=16</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>12</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_R8G8_UINT=20</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>13</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_R8G8_SINT=21</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>14</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_R8G8B8_UNORM=23</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>15</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_R8G8B8_UINT=27</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>16</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_R8G8B8_SINT=28</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>17</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_R8G8B8_SRGB=29</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>18</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_B8G8R8_UNORM=30</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>19</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_B8G8R8_UINT=34</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>20</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_B8G8R8_SINT=35</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>21</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_B8G8R8_SRGB=36</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>22</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_R8G8B8A8_UNORM=37</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>23</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_R8G8B8A8_UINT=41</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>24</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_R8G8B8A8_SINT=42</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>25</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_R8G8B8A8_SRGB=43</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>26</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_B8G8R8A8_UNORM=44</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>27</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_B8G8R8A8_UINT=48</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>28</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_B8G8R8A8_SINT=49</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>29</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_B8G8R8A8_SRGB=50</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>30</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_B10G10R10A2_UNORM=58</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>31</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_B10G10R10A2_UINT=62</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>32</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_R10G10B10A2_UNORM=64</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>33</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_R10G10B10A2_UINT=68</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>34</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_R16_UINT=74</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>35</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_R16_SINT=75</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>36</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_R16_SFLOAT=76</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>37</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_R16G16_UINT=81</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>38</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_R16G16_SINT=82</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>39</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_R16G16_SFLOAT=83</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>40</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_R16G16B16_UINT=88</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>41</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_R16G16B16_SINT=89</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>42</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_R16G16B16_SFLOAT=90</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>43</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_R16G16B16A16_UINT=95</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>44</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_R16G16B16A16_SINT=96</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>45</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_R16G16B16A16_SFLOAT=97</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>46</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_R32_UINT=98</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>47</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_R32_SINT=99</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>48</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_R32_SFLOAT=100</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>49</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_R11G11B10_UFLOAT=122</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>50</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_D16_UNORM=124</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>51</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_D24_X8_UNORM=125</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>52</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_D32_SFLOAT=126</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>53</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_D24_UNORM_S8_UINT=129</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>54</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>FORMAT_D32_SFLOAT_S8_UINT=130</p> </td> </tr>  </tbody></table></div> </div> </li></ul> <p><strong>OpenGL ES</strong></p> <p><strong>【推荐】</strong></p> <ul><li>纹理尺寸大于32，小于等于8192。</li><li>支持压缩的纹理internal format如下： <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.59.10.2.1.1.3.1.1" valign="top" width="7.5200000000000005%"><p>序号</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.59.10.2.1.1.3.1.2" valign="top" width="92.47999999999999%"><p>可支持的format</p> </th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>1</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>GL_RGB8_OES</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>2</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>GL_RGBA8_OES</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>3</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>GL_BGRA8_EXT</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>4</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>GL_RGBA4</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>5</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>GL_RGB565</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>6</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>GL_RGB5_A1</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>7</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>GL_DEPTH_COMPONENT16</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>8</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>GL_DEPTH_COMPONENT24_OES</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>9</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>GL_DEPTH24_STENCIL8_OES</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>10</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>GL_DEPTH_COMPONENT32F</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>11</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>GL_DEPTH32F_STENCIL8</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>12</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>GL_RGB10_EXT</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>13</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>GL_RGB10_A2_EXT</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>14</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>GL_R8_EXT</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>15</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>GL_RG8_EXT</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>16</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>GL_R16F</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>17</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>GL_RG16F</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>18</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>GL_RGBA16F</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>19</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>GL_R11F_G11F_B10F</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>20</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>GL_SRGB8_ALPHA8</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>21</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>GL_RGB10_A2UI</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>22</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>GL_RGBA16UI</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>23</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>GL_RGBA8UI</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="7.5200000000000005%"><p>24</p> </td> <td class="cellrowborder" valign="top" width="92.47999999999999%"><p>GL_RGBA16IGL_RGBA8I</p> </td> </tr>  </tbody></table></div> </div> </li></ul> <p><strong>【不推荐】</strong></p> <p>通过glBindImageTexture绑定到image unit的已经被压缩的纹理，在被imageLoad/imageStore访问时，驱动侧会触发解压缩流程。</p> <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"><p>解压缩后的纹理在之后的渲染过程中不会被重新压缩，都是以非压缩的状态存在。</p> </div></div></div> </div> <p><strong>1.2 Filtering</strong></p> <p>各向异性滤波（Anisotropic Filtering）被用来避免mip-map的过度模糊效应，然而各向异性滤波和三线性滤波会降低纹理采样的性能。Maleoon GPU上，YUV纹理暂不支持各向异性滤波。</p> <p><strong>【推荐】</strong></p> <p>为了在Maleoon GPU上获得更好的性能，我们建议：</p> <ul><li>仅在必要的情况下使用AF和三线性滤波。使用AF时，检查性能尽量达成性能和效果的平衡。</li><li>尽量避免将各向异性滤波和三线性滤波的结果应用于阶跃函数或控制代码端（if-else代码结构等）。</li><li>检查图像质量是否需要各向异性滤波或三线性滤波。</li></ul> <p><strong>1.3 三通道Texture Buffer</strong></p> <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"><p>仅适用于<a href="https://www.khronos.org/opengles/" target="_blank">OpenGL ES</a>。</p> </div></div></div> <p>使用GLSL texelFetch指令采样三通道的Texture Buffer，对性能有一定的影响，开发者尽量避免。</p> <p><strong>【不推荐】</strong></p> <p>使用GLSL texelFetch指令采样三通道的Texture Buffer。</p> <p><strong>1.4 Feedback Loops</strong></p> <p>一张纹理同时被采样和写出，spec定义该同读同写场景为feedback loops，feedback loops的结果未定义。</p> <p><strong>【不推荐】</strong></p> <p>使用feedback loops。</p> <p><strong>2. Buffer</strong></p> <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"><p>仅适用于<a href="https://www.khronos.org/opengles/" target="_blank">OpenGL ES</a>。</p> </div></div></div> <p>如果glMapBufferRange包含MAP_UNSYNCHRONIZED_BIT 标记位，GPU驱动无需关注buffer内存状态，直接将该buffer地址返回给用户。即使buffer内存正在被使用，也不会报错，后续该buffer内存读写操作所导致的结果都是未定义的。这个标志允许开发者在不等待之前操作完成的情况下映射buffer，可能会提高性能，但同时也带来了数据错误的风险。</p> <p><strong>【推荐】</strong></p> <p>如果可以保证buffer没有任何的读写依赖，调用glMapBufferRange时包含MAP_UNSYNCHRONIZED_BIT标记位，有助于提升性能。</p> <p><strong>【不推荐】</strong></p> <p>不能保证buffer没有任何的读写依赖，调用glMapBufferRange时不要包含MAP_UNSYNCHRONIZED_BIT标记位，否则会有数据错误的风险。</p> <div class="tiledSection"><h3 id="section784336143517">Synchronization<i class="anchor-icon anchor-icon-link" anchorid="section784336143517" tips="复制节点链接"></i></h3><div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"><p>仅适用于<a href="https://registry.khronos.org/vulkan/#apispecs" target="_blank">Vulkan</a>。</p> </div></div></div> <p>Vulkan提供了多种不同的同步原语供App使用，用户可以用这些同步原语来保证GPU任务的执行时序，从而保证执行结果符合预期。其中Barrier、Event、Semaphore等同步原语都可以作为GPU任务间同步的工具，用户可以下发srcStageMask和dstStageMask来指定被等待的pipelineStages和等待的pipelineStages。</p> <p>由于一般游戏应用中，graphics jobs是用来绘制游戏画面的，负载比较大且直接影响帧率。所以尽量不要让其他类型的Jobs（如Transfer、Compute）阻塞graphics jobs。如果有这类需要，应该尽量考虑消除或减少阻塞的时间。</p> <p><strong>【推荐】</strong></p> <ul><li>尽量减少不必要的同步操作，同步操作中的srcStageMask应当包含尽量少的pipelineStages。</li><li>graphics等待的transfer/compute jobs尽早提交、尽早解除对graphics的阻塞，且vkCmdPipelineBarrier()应当尽早下发。</li><li>等待transfer/compute jobs的graphics jobs尽量晚执行，避免graphics jobs被阻塞而导致GPU绘制性能下降。</li><li>如果compute/transfer jobs与某个graphics存在依赖，尽量使之与其他graphics jobs并发执行，从而提升graphics这类重载job的并发度。</li></ul> <p>例如以下序列，compute执行时graphics是闲置的，导致graphics并发度低。</p> <div class="screenLinkPre"><div _ngcontent-rcd-c106="" class="highlight-div"><div _ngcontent-rcd-c106="" class="highlight-div-header"><div _ngcontent-rcd-c106="" class="highlight-div-header-left"><div _ngcontent-rcd-c106="" class="handle-button expand-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-rcd-c106="" class="highlight-div-header-right"><div _ngcontent-rcd-c106="" class="handle-button ai-button"></div><div _ngcontent-rcd-c106="" class="handle-button line-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-rcd-c106="" class="handle-button theme-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-rcd-c106="" class="handle-button copy-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-rcd-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-scss" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/MaliangGPU/entry/src/main/ets/pages/shader.frag#L177-L185" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-built_in">vkCmdBeginRenderPass</span>(renderpass1)；</li><li><span class="hljs-built_in">vkCmdDraw</span>()；</li><li><span class="hljs-built_in">vkCmdEndRenderPass</span>()；</li><li><span class="hljs-built_in">vkCmdPipelineBarrier</span>(src: rendering, dst:compute)；</li><li><span class="hljs-built_in">vkCmdDispatch</span>()；</li><li><span class="hljs-built_in">vkCmdPipelineBarrier</span>(src: compute, dst:rendering)；</li><li><span class="hljs-built_in">vkCmdBeginRenderPass</span>(renderpass2)；</li><li><span class="hljs-built_in">vkCmdDraw</span>()；</li><li><span class="hljs-built_in">vkCmdEndRenderPass</span>()；</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/MaliangGPU/entry/src/main/ets/pages/shader.frag#L177-L185" target="_blank">shader.frag</a></div></div></div></div> <p>Job的执行顺序如下图所示，可见graphics jobs之间存在较大空隙，compute和graphics jobs为串行执行。</p> <p><span><img height="103.74000000000001" originheight="838" originwidth="4194" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163050.36350666357665951054728064405800:50001231000000:2800:8428CD2CF0ABA9887A812CCF9F015BE4EC9C3BC38461347C41CAFD4428AD89F9.jpg" title="点击放大" width="523.6875"></span></p> <p>为了避免以上情况出现，compute执行时，尽量让可以并行的graphics任务与compute同时执行。API序列如下所示：</p> <div class="screenLinkPre"><div _ngcontent-rcd-c106="" class="highlight-div"><div _ngcontent-rcd-c106="" class="highlight-div-header"><div _ngcontent-rcd-c106="" class="highlight-div-header-left"><div _ngcontent-rcd-c106="" class="handle-button expand-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-rcd-c106="" class="highlight-div-header-right"><div _ngcontent-rcd-c106="" class="handle-button ai-button"></div><div _ngcontent-rcd-c106="" class="handle-button line-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-rcd-c106="" class="handle-button theme-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-rcd-c106="" class="handle-button copy-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-rcd-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-scss" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/MaliangGPU/entry/src/main/ets/pages/shader.frag#L189-L200" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-built_in">vkCmdBeginRenderPass</span>(renderpass1);</li><li><span class="hljs-built_in">vkCmdDraw</span>();</li><li><span class="hljs-built_in">vkCmdEndRenderPass</span>();</li><li><span class="hljs-built_in">vkCmdPipelineBarrier</span>(src:rendering, dst:compute);</li><li><span class="hljs-built_in">vkCmdDispatch</span>();</li><li><span class="hljs-built_in">vkCmdBeginRenderPass</span>(renderpass3);</li><li><span class="hljs-built_in">vkCmdDraw</span>();</li><li><span class="hljs-built_in">vkCmdEndRenderPass</span>();</li><li><span class="hljs-built_in">vkCmdPipelineBarrier</span>(src:compute, dst:rendering);</li><li><span class="hljs-built_in">vkCmdBeginRenderPass</span>(renderpass2);</li><li><span class="hljs-built_in">vkCmdDraw</span>();</li><li><span class="hljs-built_in">vkCmdEndRenderPass</span>();</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/MaliangGPU/entry/src/main/ets/pages/shader.frag#L189-L200" target="_blank">shader.frag</a></div></div></div></div>  <p>Job的执行顺序如下图所示，此时compute和graphics jobs可以并发执行。</p> <p><span><img height="103.74000000000001" originheight="838" originwidth="4194" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163050.36342011484381719169377357292472:50001231000000:2800:DB93D9E14E8C8417D4FAE925E992FCDED350139105E5784DD0BE12639BB1958A.jpg" title="点击放大" width="523.6875"></span></p> <p><strong>【不推荐】</strong></p> <ul><li>DstStageMask中包含VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT、VK_PIPELINE_STAGE_VERTEX_*、VK_PIPELINE_STAGE_TESSELLATION_*或者VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT这些Bit。</li><li>SrcStageMask中包含VK_PIPELINE_STAGE_VERTEX_* Bit。如果必须使用它们，需要尽早下发vkCmdPipelineBarrier()。</li></ul> <p>影响</p> <p>不恰当的同步操作可能会使Maleoon GPU不同类型的Jobs并行度变差，从而导致GPU性能受损。</p> </div> <div class="tiledSection"><h3 id="section147703471353">Subpass Merge<i class="anchor-icon anchor-icon-link" anchorid="section147703471353" tips="复制节点链接"></i></h3><div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"><p>仅适用于<a href="https://registry.khronos.org/vulkan/#apispecs" target="_blank">Vulkan</a>。</p> </div></div></div> <p>Vulkan支持多subpass渲染，该功能使得GPU能够从一个subpass获取color attachment和depthstencil attachment，无需写回到主内存，直接在片上将它们用作后续subpass中的input attachment，这个优化叫做subpass merge。</p> <p>在一些应用场景下（例如延迟着色场景），通过多subpass配置，成功merge-subpass，则会大大提高效率。</p> <p>Maleoon GPU硬件支持在满足以下条件时，允许后面的subpass按照合适的tiler粒度和执行顺序直接从tile buffer上读取前面的subpass的输出结果来使用，从而避免出现“写出到DDR”和“从DDR读回”这样一个来回高耗带宽的数据存取过程。</p> <p><strong>【推荐】</strong></p> <p>当merge-subpass满足以下条件，能够实现merge-subpass方案。</p> <ul><li>Subpass总数大于1。</li><li>所有的attachment必须是singlesample。</li><li>第一个subpass最多有8个color attachment，其他subpass最多4个color attachment，所有subpass的color attachment总数不能超过8个。</li><li>所有subpass的depthstencil attachment如果存在，则必须是同一个。</li><li>depthstencil attachment只能有一次写操作。</li><li>必须存在前面subpass的输出被后面subpass作为input attachment的情况。</li><li>Input attachment的format不能是srgb格式。<div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"><p>仅适用于Maleoon 910 GPU。</p> </div></div></div> </li><li>非multiview和multilayer场景。</li><li>SrcAccessMask和dstAccessMask只包含以下BIT:<ul><li>INPUT_ATTACHMENT_READ_BIT</li><li>COLOR_ATTACHMENT_READ_BIT</li><li>COLOR_ATTACHMENT_WRITE_BIT</li><li>DEPTH_STENCIL_ATTACHMENT_READ_BIT</li><li>DEPTH_STENCIL_ATTACHMENT_WRITE_BIT</li></ul> </li></ul> <p><strong>【不推荐】</strong></p> <ul><li>Input attachment的storeOp配置为STORE_OP_STORE。</li><li>在一个subpass内针对同一个attachment进行读写操作。</li></ul> </div> <div class="tiledSection"><h2 id="section11831972016">Shader编码优化<i class="anchor-icon anchor-icon-link" anchorid="section11831972016" tips="复制节点链接"></i></h2></div> <div class="tiledSection"><h3 id="section34442418017" class="firsth2">不要使用较复杂shader<i class="anchor-icon anchor-icon-link" anchorid="section34442418017" tips="复制节点链接"></i></h3><p>相比于CPU优化，在做GPU优化时，需要特别关注shader并发执行的情况，发挥GPU并行计算的能力，这个比做好单个shader的优化更加重要。这种并发分两个层面，一方面是不同的shader之间，如果无依赖，要尽量并发的执行，另一方面是同一个shader，不同的线程（vertex/pixel…）要尽可能的并发执行。</p> <p>Shader执行所需的资源，在GPC/EU等层级上可能会有独占的情况，即如果一个shader申请了过多的资源，那其它shader可能无法并发执行，例如如果一个shader使用了过多GPR资源，那么在一个EU里并发一个warp任务，导致GPU算力发挥不了。移动端GPU资源更加紧凑，需要更加注意。</p> <p><strong>【推荐】</strong></p> <p>建议不要使用超过800行的shader，如果确实需要如此复杂的计算量，可以尝试拆分为多个shader来执行。虽然相同计算量下拆分draw会有额外开销，但是可以提升EU并发度，避免GPU卡在个别的几个shader上，阻塞了其它shader的执行。总体而言性能更佳。</p> </div> <div class="tiledSection"><h3 id="section892433810014">内存访问向量化<i class="anchor-icon anchor-icon-link" anchorid="section892433810014" tips="复制节点链接"></i></h3><p>Maleoon GPU在内存访问操作上使用向量化是更加高效的行为，向量化的内存访问可以减少访问cycle和带宽。</p> <p><strong>【推荐】</strong></p> <p>推荐shader写法：</p> <div class="screenLinkPre"><div _ngcontent-rcd-c106="" class="highlight-div"><div _ngcontent-rcd-c106="" class="highlight-div-header"><div _ngcontent-rcd-c106="" class="highlight-div-header-left"><div _ngcontent-rcd-c106="" class="handle-button expand-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-rcd-c106="" class="highlight-div-header-right"><div _ngcontent-rcd-c106="" class="handle-button ai-button"></div><div _ngcontent-rcd-c106="" class="handle-button line-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-rcd-c106="" class="handle-button theme-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-rcd-c106="" class="handle-button copy-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-rcd-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-csharp" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/MaliangGPU/entry/src/main/ets/pages/shader.frag#L204-L214" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">struct</span> FCocTileSample {</li><li>    vec4 Fgd;</li><li>};</li><li><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span>()</span> {</li><li>    <span class="hljs-built_in">uint</span> u12 = <span class="hljs-number">0u</span>;</li><li>    FCocTileSample t10[<span class="hljs-number">3</span>];</li><li>    <span class="hljs-keyword">while</span> (u12 &lt; <span class="hljs-number">3u</span>) {</li><li>        t10[<span class="hljs-built_in">int</span>(u12)].Fgd = a;</li><li>        u12++;</li><li>    }</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/MaliangGPU/entry/src/main/ets/pages/shader.frag#L204-L214" target="_blank">shader.frag</a></div></div></div></div> <p><strong>【不推荐】</strong></p> <p>原始shader写法：</p> <div class="screenLinkPre"><div _ngcontent-rcd-c106="" class="highlight-div"><div _ngcontent-rcd-c106="" class="highlight-div-header"><div _ngcontent-rcd-c106="" class="highlight-div-header-left"><div _ngcontent-rcd-c106="" class="handle-button expand-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-rcd-c106="" class="highlight-div-header-right"><div _ngcontent-rcd-c106="" class="handle-button ai-button"></div><div _ngcontent-rcd-c106="" class="handle-button line-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-rcd-c106="" class="handle-button theme-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-rcd-c106="" class="handle-button copy-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-rcd-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-csharp" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/MaliangGPU/entry/src/main/ets/pages/field.glsl#L20-L36" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">struct</span> FCocTileSample {</li><li>    <span class="hljs-built_in">float</span> FgdMinCoc;</li><li>    <span class="hljs-built_in">float</span> FgdMaxCoc;</li><li>    <span class="hljs-built_in">float</span> BgdMinCoc;</li><li>    <span class="hljs-built_in">float</span> BgdMaxCoc;</li><li>};</li><li><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span>()</span> {</li><li>    <span class="hljs-built_in">uint</span> u12 = <span class="hljs-number">0u</span>;</li><li>    FCocTileSample t10[<span class="hljs-number">3</span>];</li><li>    <span class="hljs-keyword">while</span> (u12 &lt; <span class="hljs-number">3u</span>) {</li><li>        t10[<span class="hljs-built_in">int</span>(u12)].FgdMinCoc = a;</li><li>        t10[<span class="hljs-built_in">int</span>(u12)].FgdMaxCoc = b;</li><li>        t10[<span class="hljs-built_in">int</span>(u12)].BgdMinCoc = c;</li><li>        t10[<span class="hljs-built_in">int</span>(u12)].BgdMaxCoc = d;</li><li>        u12++;</li><li>    }</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/MaliangGPU/entry/src/main/ets/pages/field.glsl#L20-L36" target="_blank">field.glsl</a></div></div></div></div> </div> <div class="tiledSection"><h3 id="section2915429516">尽量使用低精度<i class="anchor-icon anchor-icon-link" anchorid="section2915429516" tips="复制节点链接"></i></h3><p>Maleoon GPU同时支持高精度和低精度，并且在软硬件上对低精度运算进行了深度优化。</p> <p><strong>【推荐】</strong></p> <ul><li>shader内部使用低精度可以加快shader的执行速度，在input/output上使用低精度可以有效减少带宽。因此推荐开发者在不影响视觉效果的情况下，尽可能在fragment shader和compute shader中使用低精度。</li><li>在OpenGL ES和Vulkan GLSL上，可以通过将全局变量或者临时变量的精度修改为mediump使用低精度运算，在SPIR-V上，可以通过对变量或者result使用relaxed-precision decoration使用低精度运算。需要注意的是，Maleoon GPU上lowp会按照mediump实现。</li></ul> <p>推荐shader写法：</p> <div class="screenLinkPre"><div _ngcontent-rcd-c106="" class="highlight-div"><div _ngcontent-rcd-c106="" class="highlight-div-header"><div _ngcontent-rcd-c106="" class="highlight-div-header-left"><div _ngcontent-rcd-c106="" class="handle-button expand-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-rcd-c106="" class="highlight-div-header-right"><div _ngcontent-rcd-c106="" class="handle-button ai-button"></div><div _ngcontent-rcd-c106="" class="handle-button line-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-rcd-c106="" class="handle-button theme-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-rcd-c106="" class="handle-button copy-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-rcd-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-java" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/MaliangGPU/entry/src/main/ets/pages/field.glsl#L40-L44" data-highlighted="yes"><ol class="linenums"><li>precision highp <span class="hljs-type">float</span>;</li><li>varying mediump vec4 in0;</li><li>mediump <span class="hljs-type">vec2</span> <span class="hljs-variable">var0</span> <span class="hljs-operator">=</span> in0.xw;</li><li>mediump <span class="hljs-type">vec2</span> <span class="hljs-variable">var1</span> <span class="hljs-operator">=</span> in0.zy;</li><li>mediump <span class="hljs-type">vec2</span> <span class="hljs-variable">var2</span> <span class="hljs-operator">=</span> (var0 + var1) / <span class="hljs-number">2.0f</span>;</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/MaliangGPU/entry/src/main/ets/pages/field.glsl#L40-L44" target="_blank">field.glsl</a></div></div></div></div> <p><strong>【不推荐】</strong></p> <p>以下场景不建议使用低精度运算：</p> <ul><li>Position计算</li><li>Coordinate计算，尤其是采样坐标</li></ul> <p>原始shader写法：</p> <div class="screenLinkPre"><div _ngcontent-rcd-c106="" class="highlight-div"><div _ngcontent-rcd-c106="" class="highlight-div-header"><div _ngcontent-rcd-c106="" class="highlight-div-header-left"><div _ngcontent-rcd-c106="" class="handle-button expand-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-rcd-c106="" class="highlight-div-header-right"><div _ngcontent-rcd-c106="" class="handle-button ai-button"></div><div _ngcontent-rcd-c106="" class="handle-button line-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-rcd-c106="" class="handle-button theme-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-rcd-c106="" class="handle-button copy-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-rcd-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-java" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/MaliangGPU/entry/src/main/ets/pages/field.glsl#L48-L53" data-highlighted="yes"><ol class="linenums"><li>precision highp <span class="hljs-type">float</span>;</li><li>varying vec4 in0;</li><li><span class="hljs-type">vec2</span> <span class="hljs-variable">var0</span> <span class="hljs-operator">=</span> in0.xw;</li><li><span class="hljs-type">vec2</span> <span class="hljs-variable">var1</span> <span class="hljs-operator">=</span> in0.zy;</li><li><span class="hljs-type">vec2</span> <span class="hljs-variable">var2</span> <span class="hljs-operator">=</span> (var0 + var1) / <span class="hljs-number">2.0f</span>;</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/MaliangGPU/entry/src/main/ets/pages/field.glsl#L48-L53" target="_blank">field.glsl</a></div></div></div></div> </div> <div class="tiledSection"><h3 id="section484313521112">生成优化的SPIR-V<i class="anchor-icon anchor-icon-link" anchorid="section484313521112" tips="复制节点链接"></i></h3><p>如果使用HLSL/GLSL开发vulkan应用，一般需要通过工具转换生成SPIR-V格式的shader，但是转换过程中可能与原本HLSL/GLSL有差异。</p> <p><strong>【推荐】</strong></p> <p>建议使用glslang 11.0及以上版本，并确认生成的SPIR-V包含了足够的优化信息，例如relaxed-precision描述等。</p> </div> <div class="tiledSection"><h3 id="section154671110225">Uniforms<i class="anchor-icon anchor-icon-link" anchorid="section154671110225" tips="复制节点链接"></i></h3><p>Maleoon GPU可以将部分uniform data转换成shader core的register，从而减少频繁的uniform data load。</p> <p><strong>【推荐】</strong></p> <ul><li>一个shader内，使用不超过1024 bytes uniform data。</li><li>避免非必要的uniform dynamic indexing写法。</li><li>不相关的dynamic data请不要merge到uniform vector或者uniform matrix中。</li></ul> <p><strong>【不推荐】</strong></p> <p>以下uniform data无法转换成register：</p> <ul><li>Uniform data过多，导致shader core内部constant register用尽。</li><li>通过dynamic indexing的uniform data，且编译器无法通过loop unroll/动态索引寄存器等技术优化。</li></ul> </div> <div class="tiledSection"><h3 id="section181881820323">Uniform Expressions<i class="anchor-icon anchor-icon-link" anchorid="section181881820323" tips="复制节点链接"></i></h3><p>Maleoon GPU通过协处理器，可以在draw call执行前，在协处理器上完成一部分标量运算，主要包括了uniform和立即数相关表达式的计算，计算结果提供给整个draw call使用。因此，在Maleoon GPU上uniform expressions不会占用GPU运行的时间。</p> <p><strong>【推荐】</strong></p> <p>通过调整计算顺序，合并uniform和立即数的计算过程，减少uniform计算和普通计算频繁交替。</p> </div> <div class="tiledSection"><h3 id="section1025117311226">Uniform Relative Indexing<i class="anchor-icon anchor-icon-link" anchorid="section1025117311226" tips="复制节点链接"></i></h3><p>Maleoon GPU对于Uniform relative indexing的一般做法为将动态索引的完整uniform buffer放在mem中，再通过运行时计算出来的index从mem中load出对应的uniform value。</p> <p><strong>【推荐】</strong></p> <ul><li>从mem中load数据开销较大，因此避免非必要的uniform dynamic indexing写法。</li><li>如果有必要，可以通过向量化操作拉长整个变量的生命周期，减少load mem的次数。</li></ul> <p><strong>【示例】</strong></p> <p>原始shader写法：</p> <div class="screenLinkPre"><div _ngcontent-rcd-c106="" class="highlight-div"><div _ngcontent-rcd-c106="" class="highlight-div-header"><div _ngcontent-rcd-c106="" class="highlight-div-header-left"><div _ngcontent-rcd-c106="" class="handle-button expand-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-rcd-c106="" class="highlight-div-header-right"><div _ngcontent-rcd-c106="" class="handle-button ai-button"></div><div _ngcontent-rcd-c106="" class="handle-button line-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-rcd-c106="" class="handle-button theme-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-rcd-c106="" class="handle-button copy-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-rcd-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-java" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/MaliangGPU/entry/src/main/ets/pages/field.glsl#L57-L64" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">if</span> (_61.x) {</li><li>    <span class="hljs-type">vec3</span> <span class="hljs-variable">_513</span> <span class="hljs-operator">=</span> (-_37.xyz) * _462._m0[_440 / <span class="hljs-number">8</span>]._m0.www + _462._m0[_440 / <span class="hljs-number">8</span>]._m0.xyz;</li><li>    _179.x = _516 + _462._m0[_440 / <span class="hljs-number">8</span>]._m3.w;</li><li>    _516 *= _462._m0[_440 / <span class="hljs-number">8</span>]._m2.x;</li><li>    _516 *= _462._m0[_440 / <span class="hljs-number">8</span>]._m3.w;</li><li>    _559 = dot(_462._m0[_440 / <span class="hljs-number">8</span>]._m3.xyz, _71.xyz);</li><li>    _559 = (_559 * _462._m0[_440 / <span class="hljs-number">8</span>]._m2.z) + _462._m0[_440 / <span class="hljs-number">8</span>]._m2.w;</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/MaliangGPU/entry/src/main/ets/pages/field.glsl#L57-L64" target="_blank">field.glsl</a></div></div></div></div> <p>推荐shader写法：</p> <div class="screenLinkPre"><div _ngcontent-rcd-c106="" class="highlight-div"><div _ngcontent-rcd-c106="" class="highlight-div-header"><div _ngcontent-rcd-c106="" class="highlight-div-header-left"><div _ngcontent-rcd-c106="" class="handle-button expand-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-rcd-c106="" class="highlight-div-header-right"><div _ngcontent-rcd-c106="" class="handle-button ai-button"></div><div _ngcontent-rcd-c106="" class="handle-button line-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-rcd-c106="" class="handle-button theme-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-rcd-c106="" class="handle-button copy-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-rcd-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-java" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/MaliangGPU/entry/src/main/ets/pages/field.glsl#L68-L78" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">if</span> (_61.x) {</li><li>    <span class="hljs-type">vec4</span> <span class="hljs-variable">ldubo_mo</span> <span class="hljs-operator">=</span> _462._m0[_440 / <span class="hljs-number">8</span>]._m0.xyzw;</li><li>    <span class="hljs-type">vec4</span> <span class="hljs-variable">ldubo_m2</span> <span class="hljs-operator">=</span> _462._m0[_440 / <span class="hljs-number">8</span>]._m2.xyzw;</li><li>    <span class="hljs-type">vec4</span> <span class="hljs-variable">ldubo_m3</span> <span class="hljs-operator">=</span> _462._m0[_440 / <span class="hljs-number">8</span>]._m3.xyzw;</li><li>    <span class="hljs-type">vec3</span> <span class="hljs-variable">_513</span> <span class="hljs-operator">=</span> (-_37.xyz) * ldubo_mo.www + ldubo_mo.xyz;</li><li>    _179.x = _516 + ldubo_m3.w;</li><li>    _516 *= ldubo_m2.x;</li><li>    _516 *= ldubo_m3.w;</li><li>    _559 = dot(ldubo_m3.xyz, _71.xyz);</li><li>    _559 = (_559 * ldubo_m2.z) + ldubo_m2.w;</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/MaliangGPU/entry/src/main/ets/pages/field.glsl#L68-L78" target="_blank">field.glsl</a></div></div></div></div> </div> <div class="tiledSection"><h3 id="section4771204420210">Branch<i class="anchor-icon anchor-icon-link" anchorid="section4771204420210" tips="复制节点链接"></i></h3><p>分支（branching）在GPU上代价较大，原因如下：</p> <ul><li>分支使得一个warp内的线程会出现分叉，同一时刻可能只有一部分线程是active的，线程利用率降低。Maleoon GPU是大核结构（SIMD32/SIMD64），分支越多性能，利用率会越低。</li><li>GPU硬件上需要额外的硬件单元记录branch和branch合并时的信息，这些资源是有限的，过多的branch可能导致warp并发度降低。</li><li>分支给编译器优化带来更多可变因子，而图形渲染大部分是在线编译，需要平衡优化效果和编译时间。</li><li>uniform branch相比普通的branch，可以避免分叉的产生，但还是会有其它的影响。开发过程中还是要尽可能避免使用branch。</li></ul> <p><strong>【推荐】</strong></p> <ul><li>尽量减少复杂的分支结构，减少嵌套深度， 嵌套深度尽量控制在8层以内。</li><li>可以使用min()、max()、clamp()、mix()，三目运算符等方式减少简单的分支跳转。</li><li>如果冗余计算的代价不大，可以去掉分支结构保留冗余计算。</li><li>使用宏常量代替uniform变量。</li><li>Vulkan使用push constant代替uniform变量。</li></ul> <p><strong>【不推荐】</strong></p> <p>有些shader为了兼容性，会把memory的relative indexing改成if-else或者switch-case，这种太多分支操作写法对GPU不友好，导致性能很差。Maleoon GPU是支持所有memory类型的relative indexing，并且有些场景编译器还能优化，所以请保留relative indexing。</p> <p><strong>【示例】</strong></p> <p>原始shader写法：</p> <div class="screenLinkPre"><div _ngcontent-rcd-c106="" class="highlight-div"><div _ngcontent-rcd-c106="" class="highlight-div-header"><div _ngcontent-rcd-c106="" class="highlight-div-header-left"><div _ngcontent-rcd-c106="" class="handle-button expand-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-rcd-c106="" class="highlight-div-header-right"><div _ngcontent-rcd-c106="" class="handle-button ai-button"></div><div _ngcontent-rcd-c106="" class="handle-button line-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-rcd-c106="" class="handle-button theme-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-rcd-c106="" class="handle-button copy-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-rcd-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-kotlin" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/MaliangGPU/entry/src/main/ets/pages/field.glsl#L82-L116" data-highlighted="yes"><ol class="linenums"><li>vec4 UniformArrayDynamicIndex(int i) {</li><li>    <span class="hljs-keyword">if</span> (i &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> UArray[<span class="hljs-number">0</span>];</li><li>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> UArray[<span class="hljs-number">1</span>];</li><li>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> UArray[<span class="hljs-number">2</span>];</li><li>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> UArray[<span class="hljs-number">3</span>];</li><li>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> UArray[<span class="hljs-number">4</span>];</li><li>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">5</span>) <span class="hljs-keyword">return</span> UArray[<span class="hljs-number">5</span>];</li><li>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">6</span>) <span class="hljs-keyword">return</span> UArray[<span class="hljs-number">6</span>];</li><li>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">7</span>) <span class="hljs-keyword">return</span> UArray[<span class="hljs-number">7</span>];</li><li>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">8</span>) <span class="hljs-keyword">return</span> UArray[<span class="hljs-number">8</span>];</li><li>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">9</span>) <span class="hljs-keyword">return</span> UArray[<span class="hljs-number">9</span>];</li><li>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">10</span>) <span class="hljs-keyword">return</span> UArray[<span class="hljs-number">10</span>];</li><li>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">11</span>) <span class="hljs-keyword">return</span> UArray[<span class="hljs-number">11</span>];</li><li>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">12</span>) <span class="hljs-keyword">return</span> UArray[<span class="hljs-number">12</span>];</li><li>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">13</span>) <span class="hljs-keyword">return</span> UArray[<span class="hljs-number">13</span>];</li><li>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">14</span>) <span class="hljs-keyword">return</span> UArray[<span class="hljs-number">14</span>];</li><li>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">15</span>) <span class="hljs-keyword">return</span> UArray[<span class="hljs-number">15</span>];</li><li>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">16</span>) <span class="hljs-keyword">return</span> UArray[<span class="hljs-number">16</span>];</li><li>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">17</span>) <span class="hljs-keyword">return</span> UArray[<span class="hljs-number">17</span>];</li><li>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">18</span>) <span class="hljs-keyword">return</span> UArray[<span class="hljs-number">18</span>];</li><li>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">19</span>) <span class="hljs-keyword">return</span> UArray[<span class="hljs-number">19</span>];</li><li>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">20</span>) <span class="hljs-keyword">return</span> UArray[<span class="hljs-number">20</span>];</li><li>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">21</span>) <span class="hljs-keyword">return</span> UArray[<span class="hljs-number">21</span>];</li><li>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">22</span>) <span class="hljs-keyword">return</span> UArray[<span class="hljs-number">22</span>];</li><li>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">23</span>) <span class="hljs-keyword">return</span> UArray[<span class="hljs-number">23</span>];</li><li>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">24</span>) <span class="hljs-keyword">return</span> UArray[<span class="hljs-number">24</span>];</li><li>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">25</span>) <span class="hljs-keyword">return</span> UArray[<span class="hljs-number">25</span>];</li><li>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">26</span>) <span class="hljs-keyword">return</span> UArray[<span class="hljs-number">26</span>];</li><li>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">27</span>) <span class="hljs-keyword">return</span> UArray[<span class="hljs-number">27</span>];</li><li>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">28</span>) <span class="hljs-keyword">return</span> UArray[<span class="hljs-number">28</span>];</li><li>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">29</span>) <span class="hljs-keyword">return</span> UArray[<span class="hljs-number">29</span>];</li><li>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">30</span>) <span class="hljs-keyword">return</span> UArray[<span class="hljs-number">30</span>];</li><li>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">31</span>) <span class="hljs-keyword">return</span> UArray[<span class="hljs-number">31</span>];</li><li>    <span class="hljs-keyword">return</span> UArray[<span class="hljs-number">0</span>];</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/MaliangGPU/entry/src/main/ets/pages/field.glsl#L82-L116" target="_blank">field.glsl</a></div></div></div></div> <p>推荐shader写法：</p> <div class="screenLinkPre"><div _ngcontent-rcd-c106="" class="highlight-div"><div _ngcontent-rcd-c106="" class="highlight-div-header"><div _ngcontent-rcd-c106="" class="highlight-div-header-left"><div _ngcontent-rcd-c106="" class="handle-button expand-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-rcd-c106="" class="highlight-div-header-right"><div _ngcontent-rcd-c106="" class="handle-button ai-button"></div><div _ngcontent-rcd-c106="" class="handle-button line-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-rcd-c106="" class="handle-button theme-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-rcd-c106="" class="handle-button copy-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-rcd-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-cpp" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/MaliangGPU/entry/src/main/ets/pages/field.glsl#L120-L124" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-function">vec4 <span class="hljs-title">UniformArrayDynamicIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>{</li><li>    <span class="hljs-keyword">if</span> (i &lt;<span class="hljs-number">0</span> || i &gt; <span class="hljs-number">31</span>)</li><li>        i = <span class="hljs-number">0</span>;</li><li>    <span class="hljs-keyword">return</span> UArray[i];</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/MaliangGPU/entry/src/main/ets/pages/field.glsl#L120-L124" target="_blank">field.glsl</a></div></div></div></div> </div> <div class="tiledSection"><h3 id="section862734835">Loop<i class="anchor-icon anchor-icon-link" anchorid="section862734835" tips="复制节点链接"></i></h3><p>Loop运行过程中，会产生较多的分叉，且会有大量的分支指令，性能在GPU上较差。</p> <p><strong>【推荐】</strong></p> <p>如果一定要使用loop，建议使用如下的for循环：</p> <ul><li>for循环的循环次数优先使用常量，uniform变量次之。</li><li>简化for循环的条件，使得for循环的起始值、step值都是常量或者常量表达式。</li></ul> <p>推荐shader：</p> <div class="screenLinkPre"><div _ngcontent-rcd-c106="" class="highlight-div"><div _ngcontent-rcd-c106="" class="highlight-div-header"><div _ngcontent-rcd-c106="" class="highlight-div-header-left"><div _ngcontent-rcd-c106="" class="handle-button expand-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-rcd-c106="" class="highlight-div-header-right"><div _ngcontent-rcd-c106="" class="handle-button ai-button"></div><div _ngcontent-rcd-c106="" class="handle-button line-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-rcd-c106="" class="handle-button theme-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-rcd-c106="" class="handle-button copy-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-rcd-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-scss" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/MaliangGPU/entry/src/main/ets/pages/field.glsl#L128-L128" data-highlighted="yes"><ol class="linenums"><li>for (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span> ; i++) {}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/MaliangGPU/entry/src/main/ets/pages/field.glsl#L128-L128" target="_blank">field.glsl</a></div></div></div></div> <p><strong>【不推荐】</strong></p> <p>原始shader：</p> <div class="screenLinkPre"><div _ngcontent-rcd-c106="" class="highlight-div"><div _ngcontent-rcd-c106="" class="highlight-div-header"><div _ngcontent-rcd-c106="" class="highlight-div-header-left"><div _ngcontent-rcd-c106="" class="handle-button expand-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-rcd-c106="" class="highlight-div-header-right"><div _ngcontent-rcd-c106="" class="handle-button ai-button"></div><div _ngcontent-rcd-c106="" class="handle-button line-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-rcd-c106="" class="handle-button theme-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-rcd-c106="" class="handle-button copy-button"><div _ngcontent-rcd-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-rcd-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-bash" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/MaliangGPU/entry/src/main/ets/pages/field.glsl#L132-L138" data-highlighted="yes"><ol class="linenums"><li>i = 0;</li><li><span class="hljs-keyword">for</span> (;;) {</li><li>    <span class="hljs-keyword">if</span> (((i * <span class="hljs-number">2</span> ) + <span class="hljs-number">1</span> &gt;=<span class="hljs-number">4</span>)) {</li><li>        <span class="hljs-built_in">break</span>;</li><li>    }</li><li>    i++;</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/MaliangGPU/entry/src/main/ets/pages/field.glsl#L132-L138" target="_blank">field.glsl</a></div></div></div></div> </div> </div> <div></div></div>