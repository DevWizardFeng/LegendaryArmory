<h1 _ngcontent-inh-c119="" class="doc-title ng-star-inserted" title="高负载场景分帧渲染"> 高负载场景分帧渲染 </h1>

<div _ngcontent-inh-c106="" auitextselectionexpansion="" class="markdown-body ng-star-inserted" style="position: relative;"> <div><div class="tiledSection"><h2 id="section151121758154016">概述<i class="anchor-icon anchor-icon-link" anchorid="section151121758154016" tips="复制节点链接"></i></h2><p>在应用开发中，页面内列表结构复杂，每个列表项包含的组件较多，就会导致嵌套层级较深，从而引起组件负载加重，绘制耗时增长。</p> <p>在这种情况下，转场或者列表滑动的时候列表项就会一次性加载大量的数据，此时可以采用分帧渲染，将本来一帧内加载的数据分成多帧加载，但是分帧渲染需要开发者计算每帧中加载多少数据，操作复杂，因此在必要的情况下才推荐使用。</p> </div> <div class="tiledSection"><h2 id="section109141235119">实现原理<i class="anchor-icon anchor-icon-link" anchorid="section109141235119" tips="复制节点链接"></i></h2></div> <div class="tiledSection"><h3 id="section2097310103317" class="firsth2">原理说明<i class="anchor-icon anchor-icon-link" anchorid="section2097310103317" tips="复制节点链接"></i></h3><p>单帧内绘制多个特点各不相同的组件时，会同时创建数量较多的Graphics Pipelines，引发后续整个Flush阶段的耗时延长，从而导致单帧耗时超长。对于这种单帧内组件负载重、加载数据多和绘制耗时长的问题场景，开发者可以根据实际的业务逻辑、应用页面布局和数据量，提前计算规划出需要通过多少帧完成加载以及每帧具体加载的数据。应用页面实际加载绘制的时候，结合页面的布局，使用帧回调监听修改状态变量或补充数据到数据结构等方式，对每一帧需要处理的渲染数据进行计算和设置，保证每一帧内只处理提前设置好的数据。通过预先设置的帧回调监听，组件加载时可直接基于状态变量或数据结构实现分帧加载。这样就达到了原本在一帧中加载的数据分到多帧加载的目的，有效减少了首帧的耗时，避免首帧卡顿现象的出现。如下图所示，将一帧数据拆分到三帧示例：</p> <p><span><img originheight="680" originwidth="959" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163429.14158171600997278771141102796909:50001231000000:2800:303850BC8372181EB46BAE4260A4469FFE93DC98824B2549CFA8024603F35643.png" width="920" height="652.3461939520334"></span></p> </div> <div class="tiledSection"><h3 id="section191119109414">具体实现<i class="anchor-icon anchor-icon-link" anchorid="section191119109414" tips="复制节点链接"></i></h3><p>在高负载场景下使用分帧渲染的关键操作是把数据拆分到每一帧中加载，但这个过程中加载新的数据时可能会将已有数据再次绘制，因此需要搭配合理的页面布局来避免重绘。可以通过if或ForEach两种方法来实现布局，两种方法的更新机制如下：</p> <ul><li><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-ifelse#更新机制" target="_blank">if更新机制</a>是根据状态判断条件，如果分支没有变化，不会对条件渲染语句进行更新。</li><li><a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-foreach#非首次渲染" target="_blank">ForEach非首次渲染</a>会检查新生成的键值是否在上次渲染中已经存在。如果键值不存在，则会创建一个新的组件；如果键值存在，则不会创建新的组件，而是直接渲染该键值所对应的组件。</li></ul> <p>因此在分帧逐步加载数据时使用上述两种方法不会引起重绘。并且在页面布局时可以给分帧渲染的外部容器组件设置宽高，这样组件本身不会触发重新进行Measure的过程，对组件的宽高不会重新测算，避免因外部容器大小改变引起重绘，详情可参考<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-improve-layout-performance" target="_blank">合理使用布局</a>。</p> <p>保证页面不会重绘后，在实际开发过程中为了逐步增加页面数据，可以使用ArkTS中提供的<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-graphics-displaysync" target="_blank">displaySync（可变帧率）</a>API接口，通过Vsync信号控制数据刷新的时机，来实现绘制内容帧率的控制。先通过页面UI中aboutToAppear()添加帧回调监听并开启监听，Vsync信号变化时触发帧回调执行应用逻辑，计算每帧加载的数据，改变ViewModel数据。ViewModel数据改变后驱动页面或组件执行build()，使用if或ForEach分帧迭代渲染绘制UI并控制刷新范围。最后可以在aboutToDisappear()里停止帧回调监听。</p> <p>具体操作流程如下图：</p> <p><span><img originheight="652" originwidth="958" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163429.16091629011666205041093904307940:50001231000000:2800:DB7CC66C18478BD124A5526E520AB00E630777964B2647578B38F4457A6B70EC.png" width="920" height="626.1377870563674"></span></p> </div> <div class="tiledSection"><h2 id="section5987133112411">转场场景<i class="anchor-icon anchor-icon-link" anchorid="section5987133112411" tips="复制节点链接"></i></h2><p>由于业务需求，从当前页面进入一个新页面时，会有转场动画播放，并且在动画首帧中加载新页面所需要的数据。如果数据量较多，那么动画首帧的响应时延就会变长，导致后面动画帧延迟播放的情况。从一个页面到新页面转场流程图如下：</p> <p><span><img height="92" originheight="146" originwidth="1359" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163429.38733543254961806547246971979468:50001231000000:2800:042947C2B2BB196FE066EDE61A3621AF326DB6795457CBEFAAA93EAEA7050864.png" title="点击放大" width="920"></span></p> </div> <div class="tiledSection"><h3 id="section5732184419461" class="firsth2">解决思路<i class="anchor-icon anchor-icon-link" anchorid="section5732184419461" tips="复制节点链接"></i></h3><p>既然转场时一次性加载大量的数据会导致卡顿情况，那么采用分帧渲染将数据拆分成多份并分批次进行加载就是一种解决思路。</p> <p>转场场景分帧：转场时会在动画首帧加载新页面的数据，采用分帧策略就是将首帧加载的数据拆分，将数据拆分到后面的帧加载，新页面打开后List列表只展示两个列表项，因此在首帧加载显示两条数据，其余缓存数据可以在第二帧加载。该方法的优点是减少动画首帧的响应时间，缺点是转场动画完成时延变长。</p> <p>转场场景效果图如下：</p> <p><span><img height="650.0641" originheight="720" originwidth="337" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163429.40173879766907478826086897932387:50001231000000:2800:6C880E03D5407E25A9BAEA8E8DAB2DFD72A5F895963AF3FA401C84F8B2EEC41C.gif" title="点击放大" width="325.75690000000003"></span></p> <p>在分帧前会在转场动画的首帧将层叠组件和列表可见区域与缓存区域的数据全部加载，而分帧后在首帧加载层叠组件和列表前两项的数据，在第二帧加载缓存区域的列表数据。分帧前后示意图如下：</p> <p><span><img originheight="624" originwidth="911" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163430.34525723059743025251369199407050:50001231000000:2800:BE79381669C99B0E400ED236ADBC16ED1644C6F02878DC16823C5080CF688C0C.png" width="911" height="624"></span></p> </div> <div class="tiledSection"><h3 id="section275354112319">常规代码<i class="anchor-icon anchor-icon-link" anchorid="section275354112319" tips="复制节点链接"></i></h3><p>通常情况下，在自定义列表组件中一次性加载全部数据，更新所有的列表项。</p> <div class="screenLinkPre"><div _ngcontent-inh-c106="" class="highlight-div"><div _ngcontent-inh-c106="" class="highlight-div-header"><div _ngcontent-inh-c106="" class="highlight-div-header-left"><div _ngcontent-inh-c106="" class="handle-button expand-button"><div _ngcontent-inh-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-inh-c106="" class="highlight-div-header-right"><div _ngcontent-inh-c106="" class="handle-button ai-button"></div><div _ngcontent-inh-c106="" class="handle-button line-button"><div _ngcontent-inh-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-inh-c106="" class="handle-button theme-button"><div _ngcontent-inh-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-inh-c106="" class="handle-button copy-button"><div _ngcontent-inh-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-inh-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-typescript" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/FramedRendering/entry/src/main/ets/view/TestCode.ets#L5-L23" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-meta">@Component</span></li><li><span class="hljs-keyword">export</span> struct <span class="hljs-title class_">TransitionScene</span> {</li><li>  <span class="hljs-keyword">private</span> <span class="hljs-attr">productData</span>: <span class="hljs-title class_">ProductDetailSource</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProductDetailSource</span>();</li><li>
</li><li>  <span class="hljs-title function_">aboutToAppear</span>(<span class="hljs-params"></span>) {</li><li>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">productData</span>.<span class="hljs-title function_">getProductData</span>();</li><li>  }</li><li>
</li><li>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) {</li><li>    <span class="hljs-title class_">WaterFlow</span>() {</li><li>      <span class="hljs-title class_">LazyForEach</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">productData</span>, <span class="hljs-function">(<span class="hljs-params">item: ProductDetailModel</span>) =&gt;</span> {</li><li>        <span class="hljs-title class_">FlowItem</span>() {</li><li>          <span class="hljs-comment">// ...</span></li><li>        }</li><li>      }, <span class="hljs-function">(<span class="hljs-params">item: ProductDetailModel</span>) =&gt;</span> item.<span class="hljs-property">id</span>.<span class="hljs-title function_">toString</span>())</li><li>    }</li><li>    <span class="hljs-comment">// ...</span></li><li>  }</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/FramedRendering/entry/src/main/ets/view/TestCode.ets#L5-L23" target="_blank">TestCode.ets</a></div></div></div></div> </div> <p>这段代码里，在组件即将出现时回调aboutToAppear()接口，将数据放入productData中，并通过瀑布流加载。编译运行后，可以通过Trace图看到，转场动画的首帧耗时21ms左右，这是因为在点击进入页面时将数据全部放入瀑布流，在235970帧中需要计算每个子组件的尺寸，导致了响应时间增长。</p> <p><span><img height="367.60668000000004" originheight="697" originwidth="1601" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163430.35180965888413718824121275022163:50001231000000:2800:97AC69B662416693238168529CEBB345A34952DB699A14D8770224D579A39E9C.png" title="点击放大" width="862.8375000000001"></span></p> <div><div class="hw-editor-tip info"><div class="title">说明</div><div class="content"><ul><li>上图是运行DevEco Studio中的Profiler工具结果Trace图，针对Frame运行的性能分析泳道。</li><li>Actual TimeLane：橙色块235970为页面渲染第一帧的过程，橙色块235972为渲染第二帧的过程。</li><li>Slice Details：应用渲染每帧的情况，Duration代表渲染此帧的耗时。如上图所示，第一帧耗时21ms，第二帧耗时4ms。</li><li>Trace图帧分析详情请参考：<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-insight-session-frame" target="_blank">Frame分析</a>。</li></ul> </div></div></div> <div class="tiledSection"><h3 id="section91425781510">优化代码<i class="anchor-icon anchor-icon-link" anchorid="section91425781510" tips="复制节点链接"></i></h3><p>在aboutToAppear()接口中添加displaySync的帧回调，并将数据拆分进行加载。</p> <div class="screenLinkPre"><div _ngcontent-inh-c106="" class="highlight-div"><div _ngcontent-inh-c106="" class="highlight-div-header"><div _ngcontent-inh-c106="" class="highlight-div-header-left"><div _ngcontent-inh-c106="" class="handle-button expand-button"><div _ngcontent-inh-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-inh-c106="" class="highlight-div-header-right"><div _ngcontent-inh-c106="" class="handle-button ai-button"></div><div _ngcontent-inh-c106="" class="handle-button line-button"><div _ngcontent-inh-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-inh-c106="" class="handle-button theme-button"><div _ngcontent-inh-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-inh-c106="" class="handle-button copy-button"><div _ngcontent-inh-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-inh-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-kotlin" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/FramedRendering/entry/src/main/ets/view/TransitionScene.ets#L24-L89" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-meta">@Entry</span></li><li><span class="hljs-meta">@Component</span></li><li>struct TransitionScene {</li><li>  <span class="hljs-meta">@State</span> currentIndex: number = <span class="hljs-number">0</span>;</li><li>  <span class="hljs-keyword">private</span> readonly LIST_SPACE: number = <span class="hljs-number">10</span>;</li><li>  <span class="hljs-keyword">private</span> readonly FRAME_60: number = <span class="hljs-number">60</span>;</li><li>  <span class="hljs-keyword">private</span> readonly FRAME_120: number = <span class="hljs-number">120</span>;</li><li>  <span class="hljs-keyword">private</span> readonly SWIPER_CACHE: number = <span class="hljs-number">2</span>;</li><li>  <span class="hljs-keyword">private</span> readonly HORIZONTAL_LIST_CACHE: number = <span class="hljs-number">2</span>;</li><li>  <span class="hljs-keyword">private</span> swiperDataSource: SwiperDataSource = new SwiperDataSource();</li><li>  <span class="hljs-keyword">private</span> midListDataSource: MidListDataSource = new MidListDataSource();</li><li>  <span class="hljs-keyword">private</span> productDetailSource: ProductDetailSource = new ProductDetailSource();</li><li>  <span class="hljs-keyword">private</span> displaySync: displaySync.DisplaySync | undefined = undefined;</li><li>  <span class="hljs-keyword">private</span> frame: number = <span class="hljs-number">1</span>;</li><li>
</li><li>  aboutToAppear(): void {</li><li>    <span class="hljs-keyword">this</span>.swiperDataSource.getProductData();</li><li>    <span class="hljs-keyword">this</span>.midListDataSource.getProductData();</li><li>
</li><li>    <span class="hljs-comment">// Creating a DisplaySync Object</span></li><li>    <span class="hljs-keyword">this</span>.displaySync = displaySync.create();</li><li>
</li><li>    <span class="hljs-comment">// Set the expected frame rate</span></li><li>    let range: ExpectedFrameRateRange = {</li><li>      expected: <span class="hljs-keyword">this</span>.FRAME_120,</li><li>      min: <span class="hljs-keyword">this</span>.FRAME_60,</li><li>      max: <span class="hljs-keyword">this</span>.FRAME_120</li><li>    };</li><li>    <span class="hljs-keyword">this</span>.displaySync.setExpectedFrameRateRange(range);</li><li>
</li><li>    <span class="hljs-comment">// Add Frame Callback</span></li><li>    <span class="hljs-keyword">this</span>.displaySync.on(<span class="hljs-string">'frame'</span>, () =&gt; {</li><li>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.frame === <span class="hljs-number">1</span>) {</li><li>        hiTraceMeter.startTrace(<span class="hljs-string">'firstFrame'</span>, <span class="hljs-number">1</span>);</li><li>        <span class="hljs-keyword">this</span>.productDetailSource.getProductData(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>);</li><li>        <span class="hljs-keyword">this</span>.frame += <span class="hljs-number">1</span>;</li><li>        hiTraceMeter.finishTrace(<span class="hljs-string">'firstFrame'</span>, <span class="hljs-number">1</span>);</li><li>      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.frame === <span class="hljs-number">2</span>) {</li><li>        hiTraceMeter.startTrace(<span class="hljs-string">'secondFrame'</span>, <span class="hljs-number">2</span>);</li><li>        <span class="hljs-keyword">this</span>.productDetailSource.getProductData(<span class="hljs-number">2</span>, <span class="hljs-number">10</span>);</li><li>        hiTraceMeter.finishTrace(<span class="hljs-string">'secondFrame'</span>, <span class="hljs-number">2</span>);</li><li>        <span class="hljs-keyword">this</span>.frame += <span class="hljs-number">1</span>;</li><li>        <span class="hljs-keyword">this</span>.displaySync?.stop();</li><li>      }</li><li>    });</li><li>
</li><li>    <span class="hljs-comment">// Enable frame callback listening</span></li><li>    <span class="hljs-keyword">this</span>.displaySync.start();</li><li>  }</li><li>
</li><li>  aboutToDisappear(): void {</li><li>    <span class="hljs-keyword">this</span>.displaySync?.stop();</li><li>  }</li><li>
</li><li>  build() {</li><li>    Column() {</li><li>      Search({ placeholder: $r(<span class="hljs-string">'app.string.search_title'</span>) })</li><li>      <span class="hljs-keyword">this</span>.typeSwiper();</li><li>      <span class="hljs-keyword">this</span>.typeList();</li><li>      <span class="hljs-keyword">this</span>.typeWaterFlow();</li><li>    }</li><li>    .padding({</li><li>      left: <span class="hljs-number">16</span>,</li><li>      right: <span class="hljs-number">16</span></li><li>    })</li><li>  }</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/FramedRendering/entry/src/main/ets/view/TransitionScene.ets#L24-L89" target="_blank">TransitionScene.ets</a></div></div></div></div> </div> <p>在这段代码中，aboutToAppear()接口中并没有一次性加载全部数据，而是将数据拆分，在帧回调中分成2次进行加载，编译运行后，通过Trace图可以看到，动画首帧的耗时是12ms。相较于优化前的代码，不再是首帧占据大量的时间，而是将耗时分摊到了后面的动画帧中。当数据量更大时，可以将数据进行更多次拆分，将不会直接出现在屏幕上的数据放到第二帧或者第三帧中进行加载，降低首帧的响应时延。</p> <p><span><img height="434.647724" originheight="775" originwidth="1606" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163430.23504533501258807288936716290705:50001231000000:2800:14F17FAE03910B67AA03CB848347C6BE453DC62B14C26BE03325E14B33E340AA.png" title="点击放大" width="900.7425000000001"></span></p> <p>对使用分帧前后进行分析，得到的数据如下表所示：</p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><caption><b>表1 </b>使用分帧前后耗时对比</caption><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.15.2.4.1.1" valign="top" width="33.33333333333333%"><p>使用分帧</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.15.2.4.1.2" valign="top" width="33.33333333333333%"><p>使用分帧前</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.15.2.4.1.3" valign="top" width="33.33333333333333%"><p>使用分帧后</p> </th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="33.33333333333333%"><p>首帧耗时</p> </td> <td class="cellrowborder" valign="top" width="33.33333333333333%"><p>21ms</p> </td> <td class="cellrowborder" valign="top" width="33.33333333333333%"><p>12ms</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="33.33333333333333%"><p>第二帧耗时</p> </td> <td class="cellrowborder" valign="top" width="33.33333333333333%"><p>4ms</p> </td> <td class="cellrowborder" valign="top" width="33.33333333333333%"><p>13ms</p> </td> </tr>  </tbody></table></div> </div> <p>在使用分帧后动画首帧与第二帧分别是12ms和13ms，如果依然没有达到期望的帧率，可以继续将数据拆分。</p> <div class="tiledSection"><h2 id="section15195122915243">滑动场景<i class="anchor-icon anchor-icon-link" anchorid="section15195122915243" tips="复制节点链接"></i></h2><p>在日历应用中，需要在一个List里面加载每个月的全部天数，包括公历和农历日期，这样在一个ItemView复用组件中就会有很多数据加载，当列表滑动的时候，通过组件复用的aboutToReuse()接口设置新的数据，就会导致ItemView内所有组件一起刷新，可能会引起掉帧卡顿现象。</p> </div> <div class="tiledSection"><h3 id="section15107125083418" class="firsth2">解决思路<i class="anchor-icon anchor-icon-link" anchorid="section15107125083418" tips="复制节点链接"></i></h3><p>由于一次性加载大量数据、刷新大量组件会导致卡顿丢帧，那么减少一次性加载的数据量就是一种解决方法。但是由于业务需求，需要加载的数据总量和绘制的组件数量是不能减少的，那么就可以考虑采用分帧渲染。</p> <p>滑动场景分帧：滑动日历列表，复用ItemView组件，更新每月天数包含阴历和阳历，一次更新所有天数，数据量大，可以使用分帧策略，将每月日期数据进行拆分，一帧只更新5天数据，在使用ForEach循环每月的天数时，因为一次只更新5天数据，ForEach会根据key值更新对应的天数，从而避免在一帧中更新所有数据。该方法优点是可以将数据拆分在多帧中加载；缺点是操作比较麻烦，需要开发者根据实际情况计算一帧中加载的数据量，维护较为复杂。</p> <p>滑动场景效果图如下：</p> <p><span><img height="540.6184000000001" originheight="720" originwidth="337" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163430.53018774137312604875019233299218:50001231000000:2800:956B4858B6D2B12CC6483CD90675DAE9514679CD9E15DF72437B69A8C58C0907.gif" title="点击放大" width="266"></span></p> <p>分帧前后示意图如下：</p> <p><span><img height="412.3532000000001" originheight="633" originwidth="1225" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163430.03709416265094860286961895469055:50001231000000:2800:76C538E9A4487CF6E9BE71B10650DC7F958993D331B1EE03F0E892DD4DFAEE73.png" title="点击放大" width="798"></span></p> </div> <div class="tiledSection"><h3 id="section14704163352">常规代码<i class="anchor-icon anchor-icon-link" anchorid="section14704163352" tips="复制节点链接"></i></h3><p>通常情况下，会在aboutToReuse()中设置新的数据，并一次性绘制所有的组件。</p> <div class="screenLinkPre"><div _ngcontent-inh-c106="" class="highlight-div"><div _ngcontent-inh-c106="" class="highlight-div-header"><div _ngcontent-inh-c106="" class="highlight-div-header-left"><div _ngcontent-inh-c106="" class="handle-button expand-button"><div _ngcontent-inh-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-inh-c106="" class="highlight-div-header-right"><div _ngcontent-inh-c106="" class="handle-button ai-button"></div><div _ngcontent-inh-c106="" class="handle-button line-button"><div _ngcontent-inh-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-inh-c106="" class="handle-button theme-button"><div _ngcontent-inh-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-inh-c106="" class="handle-button copy-button"><div _ngcontent-inh-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-inh-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-kotlin" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/FramedRendering/entry/src/main/ets/view/DateItemView.ets#L29-L178" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-meta">@Reusable</span></li><li><span class="hljs-meta">@Component</span></li><li>export struct DateItemView {</li><li>  <span class="hljs-comment">// ...</span></li><li>  aboutToAppear(): void {</li><li>    hiTraceMeter.startTrace(<span class="hljs-string">'appear_'</span>, <span class="hljs-number">1</span>);</li><li>    <span class="hljs-keyword">this</span>.displaySync = displaySync.create();</li><li>    <span class="hljs-keyword">const</span> range: ExpectedFrameRateRange = {</li><li>      expected: <span class="hljs-number">120</span>,</li><li>      min: <span class="hljs-number">60</span>,</li><li>      max: <span class="hljs-number">120</span></li><li>    };</li><li>    <span class="hljs-keyword">this</span>.displaySync.setExpectedFrameRateRange(range);</li><li>    <span class="hljs-keyword">this</span>.displaySync.on(<span class="hljs-string">'frame'</span>, () =&gt; {</li><li>      <span class="hljs-comment">// ...</span></li><li>    });</li><li>    <span class="hljs-keyword">this</span>.displaySync.start();</li><li>    allDisplaySyncArray.push(<span class="hljs-keyword">this</span>.displaySync);</li><li>    <span class="hljs-keyword">this</span>.temp.push(<span class="hljs-keyword">this</span>.monthItem);</li><li>    hiTraceMeter.finishTrace(<span class="hljs-string">'appear_'</span>, <span class="hljs-number">1</span>);</li><li>  }</li><li>  <span class="hljs-comment">// ...</span></li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/FramedRendering/entry/src/main/ets/view/DateItemView.ets#L29-L178" target="_blank">DateItemView.ets</a></div></div></div></div> </div> <p>在上面的代码中，通过组件复用，在ItemView的aboutToReuse()接口中，将一个月的数据直接设置到状态变量monthItem中，这样下面的Flex就会收到状态变量变更的消息通知，从而刷新组件中的数据。编译运行后，进入日历页面，然后滑动列表到最底端，分析下图。</p> <p><span><img height="378.7648970747562" originheight="789" originwidth="1744" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163430.29132873743826137613599812562109:50001231000000:2800:928107CB4E9BA9B987C366D045CF0475CB4F3D0D4FA0615068B93B47411FCFCB.png" title="点击放大" width="920"></span></p> <ul><li>选中Actual Timeline（render_service）标签中的146272后，可以通过箭头看到它所关联到的位置是Actual Timeline（example.display）标签中的209136和209137，即RenderService层出现的异常情况是由应用层中前面两帧里面的操作引起的。</li><li>通过箭头2的标签可以看到，在209135中调用了aboutToReuse接口，此时系统开始了组件复用的绘制操作，在aboutToReuse接口将一个月的所有数据全部放入了当前被复用的组件中，并更新了所有用于显示日期的Text组件中的数据（箭头3，diffIndexArray.length：35，表示有35个不同的元素），这就导致209136需要计算35个子组件的尺寸（箭头1），从而引起146272的绘制时间延长。</li><li>在列表数据量较少时，其实并不会引起掉帧现象，因为每次延长帧的时间都很短，对帧率的影响较小，但是在列表数据较多时，就会因为延长帧过多，发生掉帧现象。</li></ul> <div class="tiledSection"><h3 id="section1782816111574">优化代码<i class="anchor-icon anchor-icon-link" anchorid="section1782816111574" tips="复制节点链接"></i></h3><p>通过displaySync中的帧回调方法，将数据拆分到每一帧中进行加载和绘制，只需要在帧回调中修改自定义子组件ItemView中加载数据的方式。</p> </div> <p>首先，需要在ItemView中第一次使用时创建displaySync对象，设置期望帧率，添加帧回调的监听，然后进行启动。</p> <div class="screenLinkPre"><div _ngcontent-inh-c106="" class="highlight-div"><div _ngcontent-inh-c106="" class="highlight-div-header"><div _ngcontent-inh-c106="" class="highlight-div-header-left"><div _ngcontent-inh-c106="" class="handle-button expand-button"><div _ngcontent-inh-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-inh-c106="" class="highlight-div-header-right"><div _ngcontent-inh-c106="" class="handle-button ai-button"></div><div _ngcontent-inh-c106="" class="handle-button line-button"><div _ngcontent-inh-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-inh-c106="" class="handle-button theme-button"><div _ngcontent-inh-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-inh-c106="" class="handle-button copy-button"><div _ngcontent-inh-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-inh-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-kotlin" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/FramedRendering/entry/src/main/ets/view/DateItemView.ets#L29-L178" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-meta">@Reusable</span></li><li><span class="hljs-meta">@Component</span></li><li>export struct DateItemView {</li><li>  <span class="hljs-comment">// ...</span></li><li>  aboutToAppear(): void {</li><li>    hiTraceMeter.startTrace(<span class="hljs-string">'appear_'</span>, <span class="hljs-number">1</span>);</li><li>    <span class="hljs-keyword">this</span>.displaySync = displaySync.create();</li><li>    <span class="hljs-keyword">const</span> range: ExpectedFrameRateRange = {</li><li>      expected: <span class="hljs-number">120</span>,</li><li>      min: <span class="hljs-number">60</span>,</li><li>      max: <span class="hljs-number">120</span></li><li>    };</li><li>    <span class="hljs-keyword">this</span>.displaySync.setExpectedFrameRateRange(range);</li><li>    <span class="hljs-keyword">this</span>.displaySync.on(<span class="hljs-string">'frame'</span>, () =&gt; {</li><li>      <span class="hljs-comment">// ...</span></li><li>    });</li><li>    <span class="hljs-keyword">this</span>.displaySync.start();</li><li>    allDisplaySyncArray.push(<span class="hljs-keyword">this</span>.displaySync);</li><li>    <span class="hljs-keyword">this</span>.temp.push(<span class="hljs-keyword">this</span>.monthItem);</li><li>    hiTraceMeter.finishTrace(<span class="hljs-string">'appear_'</span>, <span class="hljs-number">1</span>);</li><li>  }</li><li>  <span class="hljs-comment">// ...</span></li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/FramedRendering/entry/src/main/ets/view/DateItemView.ets#L29-L178" target="_blank">DateItemView.ets</a></div></div></div></div> <p>然后，在监听中添加更新数据的代码。这里将每个月的数据更新拆分开来，第一步用来更新月份数据和计算总的执行步骤，最后一步将计数数据清空， 方便下一次数据的写入，其余需要执行步骤的多少根据每次加载数据量会有所改变。</p> <div class="screenLinkPre"><div _ngcontent-inh-c106="" class="highlight-div"><div _ngcontent-inh-c106="" class="highlight-div-header"><div _ngcontent-inh-c106="" class="highlight-div-header-left"><div _ngcontent-inh-c106="" class="handle-button expand-button"><div _ngcontent-inh-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-inh-c106="" class="highlight-div-header-right"><div _ngcontent-inh-c106="" class="handle-button ai-button"></div><div _ngcontent-inh-c106="" class="handle-button line-button"><div _ngcontent-inh-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-inh-c106="" class="handle-button theme-button"><div _ngcontent-inh-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-inh-c106="" class="handle-button copy-button"><div _ngcontent-inh-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-inh-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-kotlin" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/FramedRendering/entry/src/main/ets/view/DateItemView.ets#L79-L105" data-highlighted="yes"><ol class="linenums"><li><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.temp.length &gt; <span class="hljs-number">0</span>) {</li><li>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.step === <span class="hljs-number">0</span>) {</li><li>    <span class="hljs-comment">// Step 1: Add the monthly data and calculate the maximum number of frames required to complete the data operation.</span></li><li>    hiTraceMeter.startTrace(<span class="hljs-string">'reuse_'</span> + <span class="hljs-keyword">this</span>.step, <span class="hljs-number">1</span>);</li><li>    <span class="hljs-keyword">this</span>.month = <span class="hljs-keyword">this</span>.temp[<span class="hljs-number">0</span>].month;</li><li>    <span class="hljs-keyword">this</span>.monthNumber = <span class="hljs-keyword">this</span>.temp[<span class="hljs-number">0</span>].num;</li><li>    <span class="hljs-keyword">this</span>.maxStep = <span class="hljs-keyword">this</span>.maxStep + Math.ceil(<span class="hljs-keyword">this</span>.temp[<span class="hljs-number">0</span>].days.length / <span class="hljs-keyword">this</span>.MAX_EVERY_FRAME);</li><li>    hiTraceMeter.finishTrace(<span class="hljs-string">'reuse_'</span> + <span class="hljs-keyword">this</span>.step, <span class="hljs-number">1</span>);</li><li>    <span class="hljs-keyword">this</span>.step += <span class="hljs-number">1</span>;</li><li>  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.step === <span class="hljs-keyword">this</span>.maxStep - <span class="hljs-number">1</span>) {</li><li>    <span class="hljs-comment">// Final step: Initialize partial count data.</span></li><li>    <span class="hljs-keyword">this</span>.temp = [];</li><li>    <span class="hljs-keyword">this</span>.step = <span class="hljs-number">0</span>;</li><li>    <span class="hljs-keyword">this</span>.maxStep = <span class="hljs-number">2</span>;</li><li>  } <span class="hljs-keyword">else</span> {</li><li>    hiTraceMeter.startTrace(<span class="hljs-string">'reuse_'</span> + <span class="hljs-keyword">this</span>.step, <span class="hljs-number">1</span>);</li><li>    <span class="hljs-keyword">const</span> start: number = <span class="hljs-keyword">this</span>.MAX_EVERY_FRAME * (<span class="hljs-keyword">this</span>.step - <span class="hljs-number">1</span>);</li><li>    <span class="hljs-keyword">const</span> end: number = (<span class="hljs-keyword">this</span>.MAX_EVERY_FRAME * <span class="hljs-keyword">this</span>.step) &gt; <span class="hljs-keyword">this</span>.temp[<span class="hljs-number">0</span>].days.length ?</li><li>    <span class="hljs-keyword">this</span>.temp[<span class="hljs-number">0</span>].days.length : <span class="hljs-keyword">this</span>.MAX_EVERY_FRAME * <span class="hljs-keyword">this</span>.step;</li><li>    <span class="hljs-keyword">for</span> (let i = start; i &lt; end; i++) {</li><li>      <span class="hljs-keyword">this</span>.days[i] = <span class="hljs-keyword">this</span>.temp[<span class="hljs-number">0</span>].days[i];</li><li>      <span class="hljs-keyword">this</span>.lunarDays[i] = <span class="hljs-keyword">this</span>.temp[<span class="hljs-number">0</span>].lunarDays[i];</li><li>    }</li><li>    hiTraceMeter.finishTrace(<span class="hljs-string">'reuse_'</span> + <span class="hljs-keyword">this</span>.step, <span class="hljs-number">1</span>);</li><li>    <span class="hljs-keyword">this</span>.step += <span class="hljs-number">1</span>;</li><li>  }</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/FramedRendering/entry/src/main/ets/view/DateItemView.ets#L79-L105" target="_blank">DateItemView.ets</a></div></div></div></div> <p>最后，在aboutToReuse接口中将数据放入数组中，用于帧回调中开始执行数据更新。</p> <div class="screenLinkPre"><div _ngcontent-inh-c106="" class="highlight-div"><div _ngcontent-inh-c106="" class="highlight-div-header"><div _ngcontent-inh-c106="" class="highlight-div-header-left"><div _ngcontent-inh-c106="" class="handle-button expand-button"><div _ngcontent-inh-c106="" class="handle-hover-tips">收起</div></div></div><div _ngcontent-inh-c106="" class="highlight-div-header-right"><div _ngcontent-inh-c106="" class="handle-button ai-button"></div><div _ngcontent-inh-c106="" class="handle-button line-button"><div _ngcontent-inh-c106="" class="handle-hover-tips">自动换行</div></div><div _ngcontent-inh-c106="" class="handle-button theme-button"><div _ngcontent-inh-c106="" class="handle-hover-tips">深色代码主题</div></div><div _ngcontent-inh-c106="" class="handle-button copy-button"><div _ngcontent-inh-c106="" class="handle-hover-tips">复制</div></div></div></div><div _ngcontent-inh-c106="" class="highlight-scroll-div"><pre class="screen prettyprint linenums hljs language-csharp" codehub="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/FramedRendering/entry/src/main/ets/view/DateItemView.ets#L52-L56" data-highlighted="yes"><ol class="linenums"><li>aboutToReuse(<span class="hljs-keyword">params</span>: Record&lt;<span class="hljs-built_in">string</span>, Object&gt;): <span class="hljs-keyword">void</span> {</li><li>  hiTraceMeter.startTrace(<span class="hljs-string">'reuse_'</span> + (<span class="hljs-keyword">params</span>.monthItem <span class="hljs-keyword">as</span> Month).month, <span class="hljs-number">1</span>);</li><li>  <span class="hljs-keyword">this</span>.temp.push(<span class="hljs-keyword">params</span>.monthItem <span class="hljs-keyword">as</span> Month);</li><li>  hiTraceMeter.finishTrace(<span class="hljs-string">'reuse_'</span> + (<span class="hljs-keyword">params</span>.monthItem <span class="hljs-keyword">as</span> Month).month, <span class="hljs-number">1</span>);</li><li>}</li></ol></pre><div class="screen-link-div"><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/blob/master/FramedRendering/entry/src/main/ets/view/DateItemView.ets#L52-L56" target="_blank">DateItemView.ets</a></div></div></div></div> <p>分析下面trace图，在211618中，开始调用aboutToReuse接口，由于只是将数据放入一个temp数组中，并没有更新复用组件中的数据，所以这一帧并没有发生延长现象。</p> <p>在211619中开始逐步更新复用组件中的数据，在第一帧中更新月份和周的数据，但是由于前一帧（211618）中并没有更新当前复用组件中的数据，所以在211619中并不需要绘制组件，所以此帧耗时依旧很短。</p> <p>结合代码可以看到，在211620中放入了5天的日期数据，由于前一帧（211619）只是设置了2条数据，并且只有1条会更新，所以这一帧的绘制时间也不会超时。</p> <p><span><img height="452.926845" originheight="785" originwidth="1447" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163430.64803000175656890324857316377464:50001231000000:2800:36083771AB30ECE73C3B3717A159BC865B4C6C95ED3C36B651A1E782A5C1988B.png" title="点击放大" width="882.7875"></span></p> <p>和前一帧（211620）一样，此帧（211621）中更新了5天的日期数据，并且会重新测量上一帧中更新数据的5个Text组件尺寸（箭头1），而其余的组件由于数据并没有变动，所以测量被略过了（箭头2）。</p> <p>后面的帧是类似的，每次只会放入5天的数据，并且更新上一帧中设置的数据所关联的Text组件。由于每次更新的组件数量较少，每帧基本上都能在规定的时间内（1秒120帧，即8ms一帧）绘制完成，所以延长帧就会较少。这样不论列表中数据多还是少，都不会引起掉帧现象的发生。</p> <p><span><img height="397.005" originheight="812" originwidth="1605" src="https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20251211163430.98090352457447414838264262769634:50001231000000:2800:418BC2070BE8C29D20BD7E1A1D4E64042A9A5BFCF76AA20F438E9DC72BC4D977.png" title="点击放大" width="885.7800000000001"></span></p>  <div class="tablenoborder"><div class="tbBox"><table class="layoutFixed idpTab"><caption><b>表2 </b>使用分帧前后对比</caption><thead><tr><th align="left" class="cellrowborder" id="mcps1.3.37.2.4.1.1" valign="top" width="33.33333333333333%"><p>使用分帧</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.37.2.4.1.2" valign="top" width="33.33333333333333%"><p>使用分帧前</p> </th> <th align="left" class="cellrowborder" id="mcps1.3.37.2.4.1.3" valign="top" width="33.33333333333333%"><p>使用分帧后</p> </th> </tr> </thead> <tbody><tr><td class="cellrowborder" valign="top" width="33.33333333333333%"><p>渲染帧率</p> </td> <td class="cellrowborder" valign="top" width="33.33333333333333%"><p>113fps</p> </td> <td class="cellrowborder" valign="top" width="33.33333333333333%"><p>120fps</p> </td> </tr> <tr><td class="cellrowborder" valign="top" width="33.33333333333333%"><p>丢帧率</p> </td> <td class="cellrowborder" valign="top" width="33.33333333333333%"><p>5.8%</p> </td> <td class="cellrowborder" valign="top" width="33.33333333333333%"><p>0%</p> </td> </tr>  </tbody></table></div> </div> <p>在使用displaySync时不建议将ExpectedFrameRateRange中的expected、min、max都设置为120，否则会干扰系统的可变帧率机制运行，产生不必要的负载，进而影响到整机的性能和功耗，详情请参考<a href="https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-ltpo-description#section12516101118180" target="_blank">场景策略建议</a>。</p> <div class="tiledSection"><h2 id="section53201446145711">总结<i class="anchor-icon anchor-icon-link" anchorid="section53201446145711" tips="复制节点链接"></i></h2><p>通过上面的示例代码和优化过程，可以看到在列表中使用组件复用时，一次性全部加载时可能会引起掉帧。虽然在数据量较少时，单帧绘制的延长并不会引起掉帧，但是数据量变多后，这种延长帧的影响就会比较明显。根据自己实际业务需求合理使用分帧策略进行数据拆分后，可以有效减少延长帧的发生，从而减少掉帧引起的性能问题。</p> </div> <div class="tiledSection"><h2 id="section893964713405">示例代码<i class="anchor-icon anchor-icon-link" anchorid="section893964713405" tips="复制节点链接"></i></h2><ul><li><a href="https://gitee.com/harmonyos_samples/BestPracticeSnippets/tree/master/FramedRendering" target="_blank">基于分帧渲染实现应用界面优化</a></li></ul> </div> </div> <div></div></div>